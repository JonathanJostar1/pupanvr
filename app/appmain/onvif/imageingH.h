/* imageingH.h
   Generated by gSOAP 2.8.117 for out/onvif_imaging.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#ifndef imageingH_H
#define imageingH_H
#include "imageingStub.h"
#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap*, const void*, int);

#ifdef __cplusplus
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap*);
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap*);
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap*, const char*, int*);
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap*, const void*, const char*, int, int);
SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap*, const void*, int);
SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void*, int);

#ifdef __cplusplus
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap*);
SOAP_FMAC3 void * SOAP_FMAC4 imageing_instantiate(struct soap*, int, const char*, const char*, size_t*);
SOAP_FMAC3 int SOAP_FMAC4 imageing_fdelete(struct soap *soap, struct soap_clist*);
SOAP_FMAC3 int SOAP_FMAC4 imageing_fbase(int, int);
SOAP_FMAC3 void SOAP_FMAC4 imageing_finsert(struct soap*, int, int, void*, size_t, const void*, void**);

#ifndef SOAP_TYPE_byte_DEFINED
#define SOAP_TYPE_byte_DEFINED

inline void soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap*, const char*, int, const char *, const char*);
SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap*, const char*, char *, const char*);

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap*, const char *, const char*, const char*);

inline int soap_write_byte(struct soap *soap, char const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_byte(soap, p, "byte", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_byte(struct soap *soap, const char *URL, char const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_byte(soap, p, "byte", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_byte(struct soap *soap, const char *URL, char const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_byte(soap, p, "byte", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_byte(struct soap *soap, const char *URL, char const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_byte(soap, p, "byte", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap*, char *, const char*, const char*);

inline int soap_read_byte(struct soap *soap, char *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_byte(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_byte(struct soap *soap, const char *URL, char *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_byte(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_byte(struct soap *soap, char *p)
{
	if (::soap_read_byte(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_int_DEFINED
#define SOAP_TYPE_int_DEFINED

inline void soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap*, const char*, int, const int *, const char*);
SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap*, const char*, int *, const char*);

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap*, const int *, const char*, const char*);

inline int soap_write_int(struct soap *soap, int const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_int(soap, p, "int", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_int(struct soap *soap, const char *URL, int const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_int(soap, p, "int", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_int(struct soap *soap, const char *URL, int const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_int(soap, p, "int", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_int(struct soap *soap, const char *URL, int const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_int(soap, p, "int", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap*, int *, const char*, const char*);

inline int soap_read_int(struct soap *soap, int *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_int(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_int(struct soap *soap, const char *URL, int *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_int(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_int(struct soap *soap, int *p)
{
	if (::soap_read_int(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_float_DEFINED
#define SOAP_TYPE_float_DEFINED

inline void soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap*, const char*, int, const float *, const char*);
SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap*, const char*, float *, const char*);

SOAP_FMAC3 float * SOAP_FMAC4 soap_new_float(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap*, const float *, const char*, const char*);

inline int soap_write_float(struct soap *soap, float const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_float(soap, p, "float", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_float(struct soap *soap, const char *URL, float const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_float(soap, p, "float", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_float(struct soap *soap, const char *URL, float const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_float(soap, p, "float", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_float(struct soap *soap, const char *URL, float const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_float(soap, p, "float", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap*, float *, const char*, const char*);

inline int soap_read_float(struct soap *soap, float *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_float(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_float(struct soap *soap, const char *URL, float *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_float(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_float(struct soap *soap, float *p)
{
	if (::soap_read_float(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_double_DEFINED
#define SOAP_TYPE_double_DEFINED

inline void soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap*, const char*, int, const double *, const char*);
SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap*, const char*, double *, const char*);

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap*, const double *, const char*, const char*);

inline int soap_write_double(struct soap *soap, double const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_double(soap, p, "double", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_double(struct soap *soap, const char *URL, double const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_double(soap, p, "double", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_double(struct soap *soap, const char *URL, double const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_double(soap, p, "double", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_double(struct soap *soap, const char *URL, double const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_double(soap, p, "double", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap*, double *, const char*, const char*);

inline int soap_read_double(struct soap *soap, double *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_double(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_double(struct soap *soap, const char *URL, double *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_double(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_double(struct soap *soap, double *p)
{
	if (::soap_read_double(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_unsignedByte_DEFINED
#define SOAP_TYPE_unsignedByte_DEFINED

inline void soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap*, const char*, int, const unsigned char *, const char*);
SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap*, const char*, unsigned char *, const char*);

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap*, const unsigned char *, const char*, const char*);

inline int soap_write_unsignedByte(struct soap *soap, unsigned char const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_unsignedByte(soap, p, "unsignedByte", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_unsignedByte(struct soap *soap, const char *URL, unsigned char const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_unsignedByte(soap, p, "unsignedByte", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_unsignedByte(struct soap *soap, const char *URL, unsigned char const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_unsignedByte(soap, p, "unsignedByte", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_unsignedByte(struct soap *soap, const char *URL, unsigned char const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_unsignedByte(soap, p, "unsignedByte", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap*, unsigned char *, const char*, const char*);

inline int soap_read_unsignedByte(struct soap *soap, unsigned char *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_unsignedByte(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_unsignedByte(struct soap *soap, const char *URL, unsigned char *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_unsignedByte(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_unsignedByte(struct soap *soap, unsigned char *p)
{
	if (::soap_read_unsignedByte(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_unsignedInt_DEFINED
#define SOAP_TYPE_unsignedInt_DEFINED

inline void soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap*, const char*, int, const unsigned int *, const char*);
SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap*, const char*, unsigned int *, const char*);

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap*, const unsigned int *, const char*, const char*);

inline int soap_write_unsignedInt(struct soap *soap, unsigned int const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_unsignedInt(soap, p, "unsignedInt", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_unsignedInt(struct soap *soap, const char *URL, unsigned int const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_unsignedInt(soap, p, "unsignedInt", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_unsignedInt(struct soap *soap, const char *URL, unsigned int const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_unsignedInt(soap, p, "unsignedInt", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_unsignedInt(struct soap *soap, const char *URL, unsigned int const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_unsignedInt(soap, p, "unsignedInt", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap*, unsigned int *, const char*, const char*);

inline int soap_read_unsignedInt(struct soap *soap, unsigned int *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_unsignedInt(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_unsignedInt(struct soap *soap, const char *URL, unsigned int *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_unsignedInt(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_unsignedInt(struct soap *soap, unsigned int *p)
{
	if (::soap_read_unsignedInt(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif
/* _wsa5__RetryAfter is a typedef synonym of ULONG64 */

#ifndef SOAP_TYPE__wsa5__RetryAfter_DEFINED
#define SOAP_TYPE__wsa5__RetryAfter_DEFINED

#define soap_default__wsa5__RetryAfter soap_default_ULONG64


#define soap__wsa5__RetryAfter2s soap_ULONG642s


#define soap_out__wsa5__RetryAfter soap_out_ULONG64


#define soap_s2_wsa5__RetryAfter soap_s2ULONG64


#define soap_in__wsa5__RetryAfter soap_in_ULONG64


#define imageing_instantiate__wsa5__RetryAfter imageing_instantiate_ULONG64


#define soap_new__wsa5__RetryAfter soap_new_ULONG64

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RetryAfter(struct soap*, const ULONG64 *, const char*, const char*);

inline int soap_write__wsa5__RetryAfter(struct soap *soap, ULONG64 const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put__wsa5__RetryAfter(soap, p, "wsa5:RetryAfter", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT__wsa5__RetryAfter(struct soap *soap, const char *URL, ULONG64 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__RetryAfter(soap, p, "wsa5:RetryAfter", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__RetryAfter(struct soap *soap, const char *URL, ULONG64 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__RetryAfter(soap, p, "wsa5:RetryAfter", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__RetryAfter(struct soap *soap, const char *URL, ULONG64 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__RetryAfter(soap, p, "wsa5:RetryAfter", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__wsa5__RetryAfter soap_get_ULONG64


#define soap_read__wsa5__RetryAfter soap_read_ULONG64


#define soap_GET__wsa5__RetryAfter soap_GET_ULONG64


#define soap_POST_recv__wsa5__RetryAfter soap_POST_recv_ULONG64

#endif

#ifndef SOAP_TYPE_ULONG64_DEFINED
#define SOAP_TYPE_ULONG64_DEFINED

inline void soap_default_ULONG64(struct soap *soap, ULONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ULONG64
	*a = SOAP_DEFAULT_ULONG64;
#else
	*a = (ULONG64)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap*, const char*, int, const ULONG64 *, const char*);
SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap*, const char*, ULONG64 *, const char*);

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_new_ULONG64(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap*, const ULONG64 *, const char*, const char*);

inline int soap_write_ULONG64(struct soap *soap, ULONG64 const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_ULONG64(soap, p, "unsignedLong", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_ULONG64(struct soap *soap, const char *URL, ULONG64 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_ULONG64(soap, p, "unsignedLong", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_ULONG64(struct soap *soap, const char *URL, ULONG64 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_ULONG64(soap, p, "unsignedLong", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_ULONG64(struct soap *soap, const char *URL, ULONG64 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_ULONG64(soap, p, "unsignedLong", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap*, ULONG64 *, const char*, const char*);

inline int soap_read_ULONG64(struct soap *soap, ULONG64 *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_ULONG64(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_ULONG64(struct soap *soap, const char *URL, ULONG64 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_ULONG64(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_ULONG64(struct soap *soap, ULONG64 *p)
{
	if (::soap_read_ULONG64(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_dateTime_DEFINED
#define SOAP_TYPE_dateTime_DEFINED

inline void soap_default_dateTime(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dateTime
	*a = SOAP_DEFAULT_dateTime;
#else
	*a = (time_t)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap*, const char*, int, const time_t *, const char*);
SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap*, const char*, time_t *, const char*);

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap*, const time_t *, const char*, const char*);

inline int soap_write_dateTime(struct soap *soap, time_t const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_dateTime(soap, p, "dateTime", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_dateTime(struct soap *soap, const char *URL, time_t const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_dateTime(soap, p, "dateTime", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_dateTime(struct soap *soap, const char *URL, time_t const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_dateTime(soap, p, "dateTime", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_dateTime(struct soap *soap, const char *URL, time_t const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_dateTime(soap, p, "dateTime", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap*, time_t *, const char*, const char*);

inline int soap_read_dateTime(struct soap *soap, time_t *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_dateTime(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_dateTime(struct soap *soap, const char *URL, time_t *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_dateTime(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_dateTime(struct soap *soap, time_t *p)
{
	if (::soap_read_dateTime(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__MoveStatus_DEFINED
#define SOAP_TYPE_tt__MoveStatus_DEFINED

inline void soap_default_tt__MoveStatus(struct soap *soap, enum tt__MoveStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__MoveStatus
	*a = SOAP_DEFAULT_tt__MoveStatus;
#else
	*a = (enum tt__MoveStatus)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveStatus(struct soap*, const char*, int, const enum tt__MoveStatus *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__MoveStatus2s(struct soap*, enum tt__MoveStatus);
SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_in_tt__MoveStatus(struct soap*, const char*, enum tt__MoveStatus *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__MoveStatus(struct soap*, const char*, enum tt__MoveStatus *);

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_new_tt__MoveStatus(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MoveStatus(struct soap*, const enum tt__MoveStatus *, const char*, const char*);

inline int soap_write_tt__MoveStatus(struct soap *soap, enum tt__MoveStatus const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__MoveStatus(soap, p, "tt:MoveStatus", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__MoveStatus(struct soap *soap, const char *URL, enum tt__MoveStatus const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__MoveStatus(soap, p, "tt:MoveStatus", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__MoveStatus(struct soap *soap, const char *URL, enum tt__MoveStatus const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__MoveStatus(soap, p, "tt:MoveStatus", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__MoveStatus(struct soap *soap, const char *URL, enum tt__MoveStatus const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__MoveStatus(soap, p, "tt:MoveStatus", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_get_tt__MoveStatus(struct soap*, enum tt__MoveStatus *, const char*, const char*);

inline int soap_read_tt__MoveStatus(struct soap *soap, enum tt__MoveStatus *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__MoveStatus(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__MoveStatus(struct soap *soap, const char *URL, enum tt__MoveStatus *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__MoveStatus(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__MoveStatus(struct soap *soap, enum tt__MoveStatus *p)
{
	if (::soap_read_tt__MoveStatus(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__PropertyOperation_DEFINED
#define SOAP_TYPE_tt__PropertyOperation_DEFINED

inline void soap_default_tt__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__PropertyOperation
	*a = SOAP_DEFAULT_tt__PropertyOperation;
#else
	*a = (enum tt__PropertyOperation)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PropertyOperation(struct soap*, const char*, int, const enum tt__PropertyOperation *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__PropertyOperation2s(struct soap*, enum tt__PropertyOperation);
SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_in_tt__PropertyOperation(struct soap*, const char*, enum tt__PropertyOperation *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__PropertyOperation(struct soap*, const char*, enum tt__PropertyOperation *);

SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_new_tt__PropertyOperation(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PropertyOperation(struct soap*, const enum tt__PropertyOperation *, const char*, const char*);

inline int soap_write_tt__PropertyOperation(struct soap *soap, enum tt__PropertyOperation const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__PropertyOperation(soap, p, "tt:PropertyOperation", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__PropertyOperation(struct soap *soap, const char *URL, enum tt__PropertyOperation const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__PropertyOperation(soap, p, "tt:PropertyOperation", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__PropertyOperation(struct soap *soap, const char *URL, enum tt__PropertyOperation const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__PropertyOperation(soap, p, "tt:PropertyOperation", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__PropertyOperation(struct soap *soap, const char *URL, enum tt__PropertyOperation const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__PropertyOperation(soap, p, "tt:PropertyOperation", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_get_tt__PropertyOperation(struct soap*, enum tt__PropertyOperation *, const char*, const char*);

inline int soap_read_tt__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__PropertyOperation(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__PropertyOperation(struct soap *soap, const char *URL, enum tt__PropertyOperation *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__PropertyOperation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *p)
{
	if (::soap_read_tt__PropertyOperation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationMode_DEFINED
#define SOAP_TYPE_tt__ImageStabilizationMode_DEFINED

inline void soap_default_tt__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__ImageStabilizationMode
	*a = SOAP_DEFAULT_tt__ImageStabilizationMode;
#else
	*a = (enum tt__ImageStabilizationMode)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationMode(struct soap*, const char*, int, const enum tt__ImageStabilizationMode *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ImageStabilizationMode2s(struct soap*, enum tt__ImageStabilizationMode);
SOAP_FMAC3 enum tt__ImageStabilizationMode * SOAP_FMAC4 soap_in_tt__ImageStabilizationMode(struct soap*, const char*, enum tt__ImageStabilizationMode *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ImageStabilizationMode(struct soap*, const char*, enum tt__ImageStabilizationMode *);

SOAP_FMAC3 enum tt__ImageStabilizationMode * SOAP_FMAC4 soap_new_tt__ImageStabilizationMode(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImageStabilizationMode(struct soap*, const enum tt__ImageStabilizationMode *, const char*, const char*);

inline int soap_write_tt__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__ImageStabilizationMode(soap, p, "tt:ImageStabilizationMode", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__ImageStabilizationMode(struct soap *soap, const char *URL, enum tt__ImageStabilizationMode const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ImageStabilizationMode(soap, p, "tt:ImageStabilizationMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImageStabilizationMode(struct soap *soap, const char *URL, enum tt__ImageStabilizationMode const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ImageStabilizationMode(soap, p, "tt:ImageStabilizationMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImageStabilizationMode(struct soap *soap, const char *URL, enum tt__ImageStabilizationMode const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ImageStabilizationMode(soap, p, "tt:ImageStabilizationMode", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__ImageStabilizationMode * SOAP_FMAC4 soap_get_tt__ImageStabilizationMode(struct soap*, enum tt__ImageStabilizationMode *, const char*, const char*);

inline int soap_read_tt__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__ImageStabilizationMode(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImageStabilizationMode(struct soap *soap, const char *URL, enum tt__ImageStabilizationMode *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImageStabilizationMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode *p)
{
	if (::soap_read_tt__ImageStabilizationMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterMode_DEFINED
#define SOAP_TYPE_tt__IrCutFilterMode_DEFINED

inline void soap_default_tt__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__IrCutFilterMode
	*a = SOAP_DEFAULT_tt__IrCutFilterMode;
#else
	*a = (enum tt__IrCutFilterMode)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterMode(struct soap*, const char*, int, const enum tt__IrCutFilterMode *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IrCutFilterMode2s(struct soap*, enum tt__IrCutFilterMode);
SOAP_FMAC3 enum tt__IrCutFilterMode * SOAP_FMAC4 soap_in_tt__IrCutFilterMode(struct soap*, const char*, enum tt__IrCutFilterMode *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IrCutFilterMode(struct soap*, const char*, enum tt__IrCutFilterMode *);

SOAP_FMAC3 enum tt__IrCutFilterMode * SOAP_FMAC4 soap_new_tt__IrCutFilterMode(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IrCutFilterMode(struct soap*, const enum tt__IrCutFilterMode *, const char*, const char*);

inline int soap_write_tt__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__IrCutFilterMode(soap, p, "tt:IrCutFilterMode", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__IrCutFilterMode(struct soap *soap, const char *URL, enum tt__IrCutFilterMode const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__IrCutFilterMode(soap, p, "tt:IrCutFilterMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IrCutFilterMode(struct soap *soap, const char *URL, enum tt__IrCutFilterMode const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__IrCutFilterMode(soap, p, "tt:IrCutFilterMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IrCutFilterMode(struct soap *soap, const char *URL, enum tt__IrCutFilterMode const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__IrCutFilterMode(soap, p, "tt:IrCutFilterMode", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__IrCutFilterMode * SOAP_FMAC4 soap_get_tt__IrCutFilterMode(struct soap*, enum tt__IrCutFilterMode *, const char*, const char*);

inline int soap_read_tt__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__IrCutFilterMode(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IrCutFilterMode(struct soap *soap, const char *URL, enum tt__IrCutFilterMode *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IrCutFilterMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *p)
{
	if (::soap_read_tt__IrCutFilterMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceMode_DEFINED
#define SOAP_TYPE_tt__WhiteBalanceMode_DEFINED

inline void soap_default_tt__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__WhiteBalanceMode
	*a = SOAP_DEFAULT_tt__WhiteBalanceMode;
#else
	*a = (enum tt__WhiteBalanceMode)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceMode(struct soap*, const char*, int, const enum tt__WhiteBalanceMode *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__WhiteBalanceMode2s(struct soap*, enum tt__WhiteBalanceMode);
SOAP_FMAC3 enum tt__WhiteBalanceMode * SOAP_FMAC4 soap_in_tt__WhiteBalanceMode(struct soap*, const char*, enum tt__WhiteBalanceMode *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__WhiteBalanceMode(struct soap*, const char*, enum tt__WhiteBalanceMode *);

SOAP_FMAC3 enum tt__WhiteBalanceMode * SOAP_FMAC4 soap_new_tt__WhiteBalanceMode(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalanceMode(struct soap*, const enum tt__WhiteBalanceMode *, const char*, const char*);

inline int soap_write_tt__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__WhiteBalanceMode(soap, p, "tt:WhiteBalanceMode", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__WhiteBalanceMode(struct soap *soap, const char *URL, enum tt__WhiteBalanceMode const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__WhiteBalanceMode(soap, p, "tt:WhiteBalanceMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__WhiteBalanceMode(struct soap *soap, const char *URL, enum tt__WhiteBalanceMode const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__WhiteBalanceMode(soap, p, "tt:WhiteBalanceMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__WhiteBalanceMode(struct soap *soap, const char *URL, enum tt__WhiteBalanceMode const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__WhiteBalanceMode(soap, p, "tt:WhiteBalanceMode", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__WhiteBalanceMode * SOAP_FMAC4 soap_get_tt__WhiteBalanceMode(struct soap*, enum tt__WhiteBalanceMode *, const char*, const char*);

inline int soap_read_tt__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__WhiteBalanceMode(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__WhiteBalanceMode(struct soap *soap, const char *URL, enum tt__WhiteBalanceMode *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__WhiteBalanceMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode *p)
{
	if (::soap_read_tt__WhiteBalanceMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ExposureMode_DEFINED
#define SOAP_TYPE_tt__ExposureMode_DEFINED

inline void soap_default_tt__ExposureMode(struct soap *soap, enum tt__ExposureMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__ExposureMode
	*a = SOAP_DEFAULT_tt__ExposureMode;
#else
	*a = (enum tt__ExposureMode)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureMode(struct soap*, const char*, int, const enum tt__ExposureMode *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ExposureMode2s(struct soap*, enum tt__ExposureMode);
SOAP_FMAC3 enum tt__ExposureMode * SOAP_FMAC4 soap_in_tt__ExposureMode(struct soap*, const char*, enum tt__ExposureMode *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ExposureMode(struct soap*, const char*, enum tt__ExposureMode *);

SOAP_FMAC3 enum tt__ExposureMode * SOAP_FMAC4 soap_new_tt__ExposureMode(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposureMode(struct soap*, const enum tt__ExposureMode *, const char*, const char*);

inline int soap_write_tt__ExposureMode(struct soap *soap, enum tt__ExposureMode const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__ExposureMode(soap, p, "tt:ExposureMode", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__ExposureMode(struct soap *soap, const char *URL, enum tt__ExposureMode const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ExposureMode(soap, p, "tt:ExposureMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ExposureMode(struct soap *soap, const char *URL, enum tt__ExposureMode const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ExposureMode(soap, p, "tt:ExposureMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ExposureMode(struct soap *soap, const char *URL, enum tt__ExposureMode const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ExposureMode(soap, p, "tt:ExposureMode", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__ExposureMode * SOAP_FMAC4 soap_get_tt__ExposureMode(struct soap*, enum tt__ExposureMode *, const char*, const char*);

inline int soap_read_tt__ExposureMode(struct soap *soap, enum tt__ExposureMode *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__ExposureMode(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ExposureMode(struct soap *soap, const char *URL, enum tt__ExposureMode *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ExposureMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ExposureMode(struct soap *soap, enum tt__ExposureMode *p)
{
	if (::soap_read_tt__ExposureMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ExposurePriority_DEFINED
#define SOAP_TYPE_tt__ExposurePriority_DEFINED

inline void soap_default_tt__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__ExposurePriority
	*a = SOAP_DEFAULT_tt__ExposurePriority;
#else
	*a = (enum tt__ExposurePriority)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposurePriority(struct soap*, const char*, int, const enum tt__ExposurePriority *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ExposurePriority2s(struct soap*, enum tt__ExposurePriority);
SOAP_FMAC3 enum tt__ExposurePriority * SOAP_FMAC4 soap_in_tt__ExposurePriority(struct soap*, const char*, enum tt__ExposurePriority *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ExposurePriority(struct soap*, const char*, enum tt__ExposurePriority *);

SOAP_FMAC3 enum tt__ExposurePriority * SOAP_FMAC4 soap_new_tt__ExposurePriority(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposurePriority(struct soap*, const enum tt__ExposurePriority *, const char*, const char*);

inline int soap_write_tt__ExposurePriority(struct soap *soap, enum tt__ExposurePriority const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__ExposurePriority(soap, p, "tt:ExposurePriority", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__ExposurePriority(struct soap *soap, const char *URL, enum tt__ExposurePriority const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ExposurePriority(soap, p, "tt:ExposurePriority", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ExposurePriority(struct soap *soap, const char *URL, enum tt__ExposurePriority const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ExposurePriority(soap, p, "tt:ExposurePriority", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ExposurePriority(struct soap *soap, const char *URL, enum tt__ExposurePriority const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ExposurePriority(soap, p, "tt:ExposurePriority", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__ExposurePriority * SOAP_FMAC4 soap_get_tt__ExposurePriority(struct soap*, enum tt__ExposurePriority *, const char*, const char*);

inline int soap_read_tt__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__ExposurePriority(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ExposurePriority(struct soap *soap, const char *URL, enum tt__ExposurePriority *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ExposurePriority(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *p)
{
	if (::soap_read_tt__ExposurePriority(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationMode_DEFINED
#define SOAP_TYPE_tt__BacklightCompensationMode_DEFINED

inline void soap_default_tt__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__BacklightCompensationMode
	*a = SOAP_DEFAULT_tt__BacklightCompensationMode;
#else
	*a = (enum tt__BacklightCompensationMode)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationMode(struct soap*, const char*, int, const enum tt__BacklightCompensationMode *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__BacklightCompensationMode2s(struct soap*, enum tt__BacklightCompensationMode);
SOAP_FMAC3 enum tt__BacklightCompensationMode * SOAP_FMAC4 soap_in_tt__BacklightCompensationMode(struct soap*, const char*, enum tt__BacklightCompensationMode *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__BacklightCompensationMode(struct soap*, const char*, enum tt__BacklightCompensationMode *);

SOAP_FMAC3 enum tt__BacklightCompensationMode * SOAP_FMAC4 soap_new_tt__BacklightCompensationMode(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensationMode(struct soap*, const enum tt__BacklightCompensationMode *, const char*, const char*);

inline int soap_write_tt__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__BacklightCompensationMode(soap, p, "tt:BacklightCompensationMode", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__BacklightCompensationMode(struct soap *soap, const char *URL, enum tt__BacklightCompensationMode const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__BacklightCompensationMode(soap, p, "tt:BacklightCompensationMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__BacklightCompensationMode(struct soap *soap, const char *URL, enum tt__BacklightCompensationMode const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__BacklightCompensationMode(soap, p, "tt:BacklightCompensationMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__BacklightCompensationMode(struct soap *soap, const char *URL, enum tt__BacklightCompensationMode const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__BacklightCompensationMode(soap, p, "tt:BacklightCompensationMode", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__BacklightCompensationMode * SOAP_FMAC4 soap_get_tt__BacklightCompensationMode(struct soap*, enum tt__BacklightCompensationMode *, const char*, const char*);

inline int soap_read_tt__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__BacklightCompensationMode(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__BacklightCompensationMode(struct soap *soap, const char *URL, enum tt__BacklightCompensationMode *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__BacklightCompensationMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *p)
{
	if (::soap_read_tt__BacklightCompensationMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__WideDynamicMode_DEFINED
#define SOAP_TYPE_tt__WideDynamicMode_DEFINED

inline void soap_default_tt__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__WideDynamicMode
	*a = SOAP_DEFAULT_tt__WideDynamicMode;
#else
	*a = (enum tt__WideDynamicMode)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicMode(struct soap*, const char*, int, const enum tt__WideDynamicMode *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__WideDynamicMode2s(struct soap*, enum tt__WideDynamicMode);
SOAP_FMAC3 enum tt__WideDynamicMode * SOAP_FMAC4 soap_in_tt__WideDynamicMode(struct soap*, const char*, enum tt__WideDynamicMode *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__WideDynamicMode(struct soap*, const char*, enum tt__WideDynamicMode *);

SOAP_FMAC3 enum tt__WideDynamicMode * SOAP_FMAC4 soap_new_tt__WideDynamicMode(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicMode(struct soap*, const enum tt__WideDynamicMode *, const char*, const char*);

inline int soap_write_tt__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__WideDynamicMode(soap, p, "tt:WideDynamicMode", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__WideDynamicMode(struct soap *soap, const char *URL, enum tt__WideDynamicMode const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__WideDynamicMode(soap, p, "tt:WideDynamicMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__WideDynamicMode(struct soap *soap, const char *URL, enum tt__WideDynamicMode const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__WideDynamicMode(soap, p, "tt:WideDynamicMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__WideDynamicMode(struct soap *soap, const char *URL, enum tt__WideDynamicMode const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__WideDynamicMode(soap, p, "tt:WideDynamicMode", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__WideDynamicMode * SOAP_FMAC4 soap_get_tt__WideDynamicMode(struct soap*, enum tt__WideDynamicMode *, const char*, const char*);

inline int soap_read_tt__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__WideDynamicMode(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__WideDynamicMode(struct soap *soap, const char *URL, enum tt__WideDynamicMode *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__WideDynamicMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode *p)
{
	if (::soap_read_tt__WideDynamicMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__AutoFocusMode_DEFINED
#define SOAP_TYPE_tt__AutoFocusMode_DEFINED

inline void soap_default_tt__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__AutoFocusMode
	*a = SOAP_DEFAULT_tt__AutoFocusMode;
#else
	*a = (enum tt__AutoFocusMode)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AutoFocusMode(struct soap*, const char*, int, const enum tt__AutoFocusMode *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AutoFocusMode2s(struct soap*, enum tt__AutoFocusMode);
SOAP_FMAC3 enum tt__AutoFocusMode * SOAP_FMAC4 soap_in_tt__AutoFocusMode(struct soap*, const char*, enum tt__AutoFocusMode *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AutoFocusMode(struct soap*, const char*, enum tt__AutoFocusMode *);

SOAP_FMAC3 enum tt__AutoFocusMode * SOAP_FMAC4 soap_new_tt__AutoFocusMode(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AutoFocusMode(struct soap*, const enum tt__AutoFocusMode *, const char*, const char*);

inline int soap_write_tt__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__AutoFocusMode(soap, p, "tt:AutoFocusMode", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__AutoFocusMode(struct soap *soap, const char *URL, enum tt__AutoFocusMode const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__AutoFocusMode(soap, p, "tt:AutoFocusMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__AutoFocusMode(struct soap *soap, const char *URL, enum tt__AutoFocusMode const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__AutoFocusMode(soap, p, "tt:AutoFocusMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__AutoFocusMode(struct soap *soap, const char *URL, enum tt__AutoFocusMode const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__AutoFocusMode(soap, p, "tt:AutoFocusMode", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__AutoFocusMode * SOAP_FMAC4 soap_get_tt__AutoFocusMode(struct soap*, enum tt__AutoFocusMode *, const char*, const char*);

inline int soap_read_tt__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__AutoFocusMode(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__AutoFocusMode(struct soap *soap, const char *URL, enum tt__AutoFocusMode *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__AutoFocusMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode *p)
{
	if (::soap_read_tt__AutoFocusMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ReverseMode_DEFINED
#define SOAP_TYPE_tt__ReverseMode_DEFINED

inline void soap_default_tt__ReverseMode(struct soap *soap, enum tt__ReverseMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__ReverseMode
	*a = SOAP_DEFAULT_tt__ReverseMode;
#else
	*a = (enum tt__ReverseMode)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseMode(struct soap*, const char*, int, const enum tt__ReverseMode *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ReverseMode2s(struct soap*, enum tt__ReverseMode);
SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_in_tt__ReverseMode(struct soap*, const char*, enum tt__ReverseMode *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ReverseMode(struct soap*, const char*, enum tt__ReverseMode *);

SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_new_tt__ReverseMode(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReverseMode(struct soap*, const enum tt__ReverseMode *, const char*, const char*);

inline int soap_write_tt__ReverseMode(struct soap *soap, enum tt__ReverseMode const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__ReverseMode(soap, p, "tt:ReverseMode", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__ReverseMode(struct soap *soap, const char *URL, enum tt__ReverseMode const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ReverseMode(soap, p, "tt:ReverseMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ReverseMode(struct soap *soap, const char *URL, enum tt__ReverseMode const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ReverseMode(soap, p, "tt:ReverseMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ReverseMode(struct soap *soap, const char *URL, enum tt__ReverseMode const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ReverseMode(soap, p, "tt:ReverseMode", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_get_tt__ReverseMode(struct soap*, enum tt__ReverseMode *, const char*, const char*);

inline int soap_read_tt__ReverseMode(struct soap *soap, enum tt__ReverseMode *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__ReverseMode(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ReverseMode(struct soap *soap, const char *URL, enum tt__ReverseMode *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ReverseMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ReverseMode(struct soap *soap, enum tt__ReverseMode *p)
{
	if (::soap_read_tt__ReverseMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__EFlipMode_DEFINED
#define SOAP_TYPE_tt__EFlipMode_DEFINED

inline void soap_default_tt__EFlipMode(struct soap *soap, enum tt__EFlipMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__EFlipMode
	*a = SOAP_DEFAULT_tt__EFlipMode;
#else
	*a = (enum tt__EFlipMode)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipMode(struct soap*, const char*, int, const enum tt__EFlipMode *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__EFlipMode2s(struct soap*, enum tt__EFlipMode);
SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_in_tt__EFlipMode(struct soap*, const char*, enum tt__EFlipMode *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__EFlipMode(struct soap*, const char*, enum tt__EFlipMode *);

SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_new_tt__EFlipMode(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EFlipMode(struct soap*, const enum tt__EFlipMode *, const char*, const char*);

inline int soap_write_tt__EFlipMode(struct soap *soap, enum tt__EFlipMode const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__EFlipMode(soap, p, "tt:EFlipMode", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__EFlipMode(struct soap *soap, const char *URL, enum tt__EFlipMode const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__EFlipMode(soap, p, "tt:EFlipMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__EFlipMode(struct soap *soap, const char *URL, enum tt__EFlipMode const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__EFlipMode(soap, p, "tt:EFlipMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__EFlipMode(struct soap *soap, const char *URL, enum tt__EFlipMode const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__EFlipMode(soap, p, "tt:EFlipMode", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_get_tt__EFlipMode(struct soap*, enum tt__EFlipMode *, const char*, const char*);

inline int soap_read_tt__EFlipMode(struct soap *soap, enum tt__EFlipMode *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__EFlipMode(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__EFlipMode(struct soap *soap, const char *URL, enum tt__EFlipMode *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__EFlipMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__EFlipMode(struct soap *soap, enum tt__EFlipMode *p)
{
	if (::soap_read_tt__EFlipMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IPType_DEFINED
#define SOAP_TYPE_tt__IPType_DEFINED

inline void soap_default_tt__IPType(struct soap *soap, enum tt__IPType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__IPType
	*a = SOAP_DEFAULT_tt__IPType;
#else
	*a = (enum tt__IPType)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPType(struct soap*, const char*, int, const enum tt__IPType *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPType2s(struct soap*, enum tt__IPType);
SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_in_tt__IPType(struct soap*, const char*, enum tt__IPType *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPType(struct soap*, const char*, enum tt__IPType *);

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_new_tt__IPType(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPType(struct soap*, const enum tt__IPType *, const char*, const char*);

inline int soap_write_tt__IPType(struct soap *soap, enum tt__IPType const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__IPType(soap, p, "tt:IPType", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__IPType(struct soap *soap, const char *URL, enum tt__IPType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__IPType(soap, p, "tt:IPType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IPType(struct soap *soap, const char *URL, enum tt__IPType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__IPType(soap, p, "tt:IPType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IPType(struct soap *soap, const char *URL, enum tt__IPType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__IPType(soap, p, "tt:IPType", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_get_tt__IPType(struct soap*, enum tt__IPType *, const char*, const char*);

inline int soap_read_tt__IPType(struct soap *soap, enum tt__IPType *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__IPType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IPType(struct soap *soap, const char *URL, enum tt__IPType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IPType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IPType(struct soap *soap, enum tt__IPType *p)
{
	if (::soap_read_tt__IPType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__AudioEncoding_DEFINED
#define SOAP_TYPE_tt__AudioEncoding_DEFINED

inline void soap_default_tt__AudioEncoding(struct soap *soap, enum tt__AudioEncoding *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__AudioEncoding
	*a = SOAP_DEFAULT_tt__AudioEncoding;
#else
	*a = (enum tt__AudioEncoding)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoding(struct soap*, const char*, int, const enum tt__AudioEncoding *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AudioEncoding2s(struct soap*, enum tt__AudioEncoding);
SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_in_tt__AudioEncoding(struct soap*, const char*, enum tt__AudioEncoding *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AudioEncoding(struct soap*, const char*, enum tt__AudioEncoding *);

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_new_tt__AudioEncoding(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoding(struct soap*, const enum tt__AudioEncoding *, const char*, const char*);

inline int soap_write_tt__AudioEncoding(struct soap *soap, enum tt__AudioEncoding const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__AudioEncoding(soap, p, "tt:AudioEncoding", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__AudioEncoding(struct soap *soap, const char *URL, enum tt__AudioEncoding const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__AudioEncoding(soap, p, "tt:AudioEncoding", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__AudioEncoding(struct soap *soap, const char *URL, enum tt__AudioEncoding const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__AudioEncoding(soap, p, "tt:AudioEncoding", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__AudioEncoding(struct soap *soap, const char *URL, enum tt__AudioEncoding const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__AudioEncoding(soap, p, "tt:AudioEncoding", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_get_tt__AudioEncoding(struct soap*, enum tt__AudioEncoding *, const char*, const char*);

inline int soap_read_tt__AudioEncoding(struct soap *soap, enum tt__AudioEncoding *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__AudioEncoding(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__AudioEncoding(struct soap *soap, const char *URL, enum tt__AudioEncoding *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__AudioEncoding(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__AudioEncoding(struct soap *soap, enum tt__AudioEncoding *p)
{
	if (::soap_read_tt__AudioEncoding(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__H264Profile_DEFINED
#define SOAP_TYPE_tt__H264Profile_DEFINED

inline void soap_default_tt__H264Profile(struct soap *soap, enum tt__H264Profile *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__H264Profile
	*a = SOAP_DEFAULT_tt__H264Profile;
#else
	*a = (enum tt__H264Profile)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Profile(struct soap*, const char*, int, const enum tt__H264Profile *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__H264Profile2s(struct soap*, enum tt__H264Profile);
SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_in_tt__H264Profile(struct soap*, const char*, enum tt__H264Profile *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__H264Profile(struct soap*, const char*, enum tt__H264Profile *);

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_new_tt__H264Profile(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Profile(struct soap*, const enum tt__H264Profile *, const char*, const char*);

inline int soap_write_tt__H264Profile(struct soap *soap, enum tt__H264Profile const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__H264Profile(soap, p, "tt:H264Profile", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__H264Profile(struct soap *soap, const char *URL, enum tt__H264Profile const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__H264Profile(soap, p, "tt:H264Profile", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__H264Profile(struct soap *soap, const char *URL, enum tt__H264Profile const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__H264Profile(soap, p, "tt:H264Profile", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__H264Profile(struct soap *soap, const char *URL, enum tt__H264Profile const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__H264Profile(soap, p, "tt:H264Profile", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_get_tt__H264Profile(struct soap*, enum tt__H264Profile *, const char*, const char*);

inline int soap_read_tt__H264Profile(struct soap *soap, enum tt__H264Profile *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__H264Profile(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__H264Profile(struct soap *soap, const char *URL, enum tt__H264Profile *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__H264Profile(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__H264Profile(struct soap *soap, enum tt__H264Profile *p)
{
	if (::soap_read_tt__H264Profile(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Profile_DEFINED
#define SOAP_TYPE_tt__Mpeg4Profile_DEFINED

inline void soap_default_tt__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__Mpeg4Profile
	*a = SOAP_DEFAULT_tt__Mpeg4Profile;
#else
	*a = (enum tt__Mpeg4Profile)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Profile(struct soap*, const char*, int, const enum tt__Mpeg4Profile *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Mpeg4Profile2s(struct soap*, enum tt__Mpeg4Profile);
SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_in_tt__Mpeg4Profile(struct soap*, const char*, enum tt__Mpeg4Profile *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Mpeg4Profile(struct soap*, const char*, enum tt__Mpeg4Profile *);

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_new_tt__Mpeg4Profile(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Profile(struct soap*, const enum tt__Mpeg4Profile *, const char*, const char*);

inline int soap_write_tt__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__Mpeg4Profile(soap, p, "tt:Mpeg4Profile", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__Mpeg4Profile(struct soap *soap, const char *URL, enum tt__Mpeg4Profile const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__Mpeg4Profile(soap, p, "tt:Mpeg4Profile", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Mpeg4Profile(struct soap *soap, const char *URL, enum tt__Mpeg4Profile const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__Mpeg4Profile(soap, p, "tt:Mpeg4Profile", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Mpeg4Profile(struct soap *soap, const char *URL, enum tt__Mpeg4Profile const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__Mpeg4Profile(soap, p, "tt:Mpeg4Profile", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_get_tt__Mpeg4Profile(struct soap*, enum tt__Mpeg4Profile *, const char*, const char*);

inline int soap_read_tt__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__Mpeg4Profile(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Mpeg4Profile(struct soap *soap, const char *URL, enum tt__Mpeg4Profile *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Mpeg4Profile(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *p)
{
	if (::soap_read_tt__Mpeg4Profile(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__VideoEncoding_DEFINED
#define SOAP_TYPE_tt__VideoEncoding_DEFINED

inline void soap_default_tt__VideoEncoding(struct soap *soap, enum tt__VideoEncoding *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__VideoEncoding
	*a = SOAP_DEFAULT_tt__VideoEncoding;
#else
	*a = (enum tt__VideoEncoding)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoding(struct soap*, const char*, int, const enum tt__VideoEncoding *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncoding2s(struct soap*, enum tt__VideoEncoding);
SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_in_tt__VideoEncoding(struct soap*, const char*, enum tt__VideoEncoding *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncoding(struct soap*, const char*, enum tt__VideoEncoding *);

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_new_tt__VideoEncoding(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoding(struct soap*, const enum tt__VideoEncoding *, const char*, const char*);

inline int soap_write_tt__VideoEncoding(struct soap *soap, enum tt__VideoEncoding const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__VideoEncoding(soap, p, "tt:VideoEncoding", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__VideoEncoding(struct soap *soap, const char *URL, enum tt__VideoEncoding const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__VideoEncoding(soap, p, "tt:VideoEncoding", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__VideoEncoding(struct soap *soap, const char *URL, enum tt__VideoEncoding const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__VideoEncoding(soap, p, "tt:VideoEncoding", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__VideoEncoding(struct soap *soap, const char *URL, enum tt__VideoEncoding const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__VideoEncoding(soap, p, "tt:VideoEncoding", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_get_tt__VideoEncoding(struct soap*, enum tt__VideoEncoding *, const char*, const char*);

inline int soap_read_tt__VideoEncoding(struct soap *soap, enum tt__VideoEncoding *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__VideoEncoding(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__VideoEncoding(struct soap *soap, const char *URL, enum tt__VideoEncoding *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__VideoEncoding(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__VideoEncoding(struct soap *soap, enum tt__VideoEncoding *p)
{
	if (::soap_read_tt__VideoEncoding(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__SceneOrientationMode_DEFINED
#define SOAP_TYPE_tt__SceneOrientationMode_DEFINED

inline void soap_default_tt__SceneOrientationMode(struct soap *soap, enum tt__SceneOrientationMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__SceneOrientationMode
	*a = SOAP_DEFAULT_tt__SceneOrientationMode;
#else
	*a = (enum tt__SceneOrientationMode)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientationMode(struct soap*, const char*, int, const enum tt__SceneOrientationMode *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SceneOrientationMode2s(struct soap*, enum tt__SceneOrientationMode);
SOAP_FMAC3 enum tt__SceneOrientationMode * SOAP_FMAC4 soap_in_tt__SceneOrientationMode(struct soap*, const char*, enum tt__SceneOrientationMode *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SceneOrientationMode(struct soap*, const char*, enum tt__SceneOrientationMode *);

SOAP_FMAC3 enum tt__SceneOrientationMode * SOAP_FMAC4 soap_new_tt__SceneOrientationMode(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SceneOrientationMode(struct soap*, const enum tt__SceneOrientationMode *, const char*, const char*);

inline int soap_write_tt__SceneOrientationMode(struct soap *soap, enum tt__SceneOrientationMode const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__SceneOrientationMode(soap, p, "tt:SceneOrientationMode", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__SceneOrientationMode(struct soap *soap, const char *URL, enum tt__SceneOrientationMode const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__SceneOrientationMode(soap, p, "tt:SceneOrientationMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__SceneOrientationMode(struct soap *soap, const char *URL, enum tt__SceneOrientationMode const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__SceneOrientationMode(soap, p, "tt:SceneOrientationMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__SceneOrientationMode(struct soap *soap, const char *URL, enum tt__SceneOrientationMode const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__SceneOrientationMode(soap, p, "tt:SceneOrientationMode", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__SceneOrientationMode * SOAP_FMAC4 soap_get_tt__SceneOrientationMode(struct soap*, enum tt__SceneOrientationMode *, const char*, const char*);

inline int soap_read_tt__SceneOrientationMode(struct soap *soap, enum tt__SceneOrientationMode *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__SceneOrientationMode(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__SceneOrientationMode(struct soap *soap, const char *URL, enum tt__SceneOrientationMode *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__SceneOrientationMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__SceneOrientationMode(struct soap *soap, enum tt__SceneOrientationMode *p)
{
	if (::soap_read_tt__SceneOrientationMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__RotateMode_DEFINED
#define SOAP_TYPE_tt__RotateMode_DEFINED

inline void soap_default_tt__RotateMode(struct soap *soap, enum tt__RotateMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__RotateMode
	*a = SOAP_DEFAULT_tt__RotateMode;
#else
	*a = (enum tt__RotateMode)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateMode(struct soap*, const char*, int, const enum tt__RotateMode *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RotateMode2s(struct soap*, enum tt__RotateMode);
SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_in_tt__RotateMode(struct soap*, const char*, enum tt__RotateMode *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RotateMode(struct soap*, const char*, enum tt__RotateMode *);

SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_new_tt__RotateMode(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RotateMode(struct soap*, const enum tt__RotateMode *, const char*, const char*);

inline int soap_write_tt__RotateMode(struct soap *soap, enum tt__RotateMode const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__RotateMode(soap, p, "tt:RotateMode", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__RotateMode(struct soap *soap, const char *URL, enum tt__RotateMode const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__RotateMode(soap, p, "tt:RotateMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__RotateMode(struct soap *soap, const char *URL, enum tt__RotateMode const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__RotateMode(soap, p, "tt:RotateMode", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__RotateMode(struct soap *soap, const char *URL, enum tt__RotateMode const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__RotateMode(soap, p, "tt:RotateMode", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_get_tt__RotateMode(struct soap*, enum tt__RotateMode *, const char*, const char*);

inline int soap_read_tt__RotateMode(struct soap *soap, enum tt__RotateMode *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__RotateMode(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__RotateMode(struct soap *soap, const char *URL, enum tt__RotateMode *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__RotateMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__RotateMode(struct soap *soap, enum tt__RotateMode *p)
{
	if (::soap_read_tt__RotateMode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_bool_DEFINED
#define SOAP_TYPE_bool_DEFINED

inline void soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap*, const char*, int, const bool *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap*, bool);
SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap*, const char*, bool *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap*, const char*, bool *);

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap*, const bool *, const char*, const char*);

inline int soap_write_bool(struct soap *soap, bool const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_bool(soap, p, "boolean", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_bool(struct soap *soap, const char *URL, bool const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_bool(soap, p, "boolean", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_bool(struct soap *soap, const char *URL, bool const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_bool(soap, p, "boolean", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_bool(struct soap *soap, const char *URL, bool const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_bool(soap, p, "boolean", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap*, bool *, const char*, const char*);

inline int soap_read_bool(struct soap *soap, bool *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_bool(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_bool(struct soap *soap, const char *URL, bool *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_bool(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_bool(struct soap *soap, bool *p)
{
	if (::soap_read_bool(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsa5__IsReferenceParameter_DEFINED
#define SOAP_TYPE__wsa5__IsReferenceParameter_DEFINED

inline void soap_default__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__wsa5__IsReferenceParameter
	*a = SOAP_DEFAULT__wsa5__IsReferenceParameter;
#else
	*a = (enum _wsa5__IsReferenceParameter)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap*, const char*, int, const enum _wsa5__IsReferenceParameter *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap*, enum _wsa5__IsReferenceParameter);
SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap*, const char*, enum _wsa5__IsReferenceParameter *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap*, const char*, enum _wsa5__IsReferenceParameter *);

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_new__wsa5__IsReferenceParameter(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap*, const enum _wsa5__IsReferenceParameter *, const char*, const char*);

inline int soap_write__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put__wsa5__IsReferenceParameter(soap, p, "wsa5:IsReferenceParameter", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT__wsa5__IsReferenceParameter(struct soap *soap, const char *URL, enum _wsa5__IsReferenceParameter const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__IsReferenceParameter(soap, p, "wsa5:IsReferenceParameter", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__IsReferenceParameter(struct soap *soap, const char *URL, enum _wsa5__IsReferenceParameter const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__IsReferenceParameter(soap, p, "wsa5:IsReferenceParameter", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__IsReferenceParameter(struct soap *soap, const char *URL, enum _wsa5__IsReferenceParameter const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__IsReferenceParameter(soap, p, "wsa5:IsReferenceParameter", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap*, enum _wsa5__IsReferenceParameter *, const char*, const char*);

inline int soap_read__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get__wsa5__IsReferenceParameter(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsa5__IsReferenceParameter(struct soap *soap, const char *URL, enum _wsa5__IsReferenceParameter *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsa5__IsReferenceParameter(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p)
{
	if (::soap_read__wsa5__IsReferenceParameter(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsa5__FaultCodesType_DEFINED
#define SOAP_TYPE_wsa5__FaultCodesType_DEFINED

inline void soap_default_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__FaultCodesType
	*a = SOAP_DEFAULT_wsa5__FaultCodesType;
#else
	*a = (enum wsa5__FaultCodesType)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap*, const char*, int, const enum wsa5__FaultCodesType *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap*, enum wsa5__FaultCodesType);
SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap*, const char*, enum wsa5__FaultCodesType *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap*, const char*, enum wsa5__FaultCodesType *);

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_new_wsa5__FaultCodesType(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap*, const enum wsa5__FaultCodesType *, const char*, const char*);

inline int soap_write_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_wsa5__FaultCodesType(soap, p, "wsa5:FaultCodesType", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_wsa5__FaultCodesType(struct soap *soap, const char *URL, enum wsa5__FaultCodesType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsa5__FaultCodesType(soap, p, "wsa5:FaultCodesType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsa5__FaultCodesType(struct soap *soap, const char *URL, enum wsa5__FaultCodesType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsa5__FaultCodesType(soap, p, "wsa5:FaultCodesType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsa5__FaultCodesType(struct soap *soap, const char *URL, enum wsa5__FaultCodesType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsa5__FaultCodesType(soap, p, "wsa5:FaultCodesType", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap*, enum wsa5__FaultCodesType *, const char*, const char*);

inline int soap_read_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_wsa5__FaultCodesType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsa5__FaultCodesType(struct soap *soap, const char *URL, enum wsa5__FaultCodesType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsa5__FaultCodesType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p)
{
	if (::soap_read_wsa5__FaultCodesType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsa5__RelationshipType_DEFINED
#define SOAP_TYPE_wsa5__RelationshipType_DEFINED

inline void soap_default_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__RelationshipType
	*a = SOAP_DEFAULT_wsa5__RelationshipType;
#else
	*a = (enum wsa5__RelationshipType)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap*, const char*, int, const enum wsa5__RelationshipType *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap*, enum wsa5__RelationshipType);
SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap*, const char*, enum wsa5__RelationshipType *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap*, const char*, enum wsa5__RelationshipType *);

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_new_wsa5__RelationshipType(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap*, const enum wsa5__RelationshipType *, const char*, const char*);

inline int soap_write_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_wsa5__RelationshipType(soap, p, "wsa5:RelationshipType", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_wsa5__RelationshipType(struct soap *soap, const char *URL, enum wsa5__RelationshipType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsa5__RelationshipType(soap, p, "wsa5:RelationshipType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsa5__RelationshipType(struct soap *soap, const char *URL, enum wsa5__RelationshipType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsa5__RelationshipType(soap, p, "wsa5:RelationshipType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsa5__RelationshipType(struct soap *soap, const char *URL, enum wsa5__RelationshipType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsa5__RelationshipType(soap, p, "wsa5:RelationshipType", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap*, enum wsa5__RelationshipType *, const char*, const char*);

inline int soap_read_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_wsa5__RelationshipType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsa5__RelationshipType(struct soap *soap, const char *URL, enum wsa5__RelationshipType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsa5__RelationshipType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p)
{
	if (::soap_read_wsa5__RelationshipType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic_DEFINED
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wstop__TopicNamespaceType_Topic(struct soap*, const char*, int, const _wstop__TopicNamespaceType_Topic *, const char*);
SOAP_FMAC3 _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_in__wstop__TopicNamespaceType_Topic(struct soap*, const char*, _wstop__TopicNamespaceType_Topic *, const char*);
SOAP_FMAC1 _wstop__TopicNamespaceType_Topic * SOAP_FMAC2 imageing_instantiate__wstop__TopicNamespaceType_Topic(struct soap*, int, const char*, const char*, size_t*);

inline _wstop__TopicNamespaceType_Topic * soap_new__wstop__TopicNamespaceType_Topic(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wstop__TopicNamespaceType_Topic(soap, n, NULL, NULL, NULL);
}

inline _wstop__TopicNamespaceType_Topic * soap_new_req__wstop__TopicNamespaceType_Topic(
	struct soap *soap,
	const std::string& name)
{
	_wstop__TopicNamespaceType_Topic *_p = ::soap_new__wstop__TopicNamespaceType_Topic(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wstop__TopicNamespaceType_Topic::name = name;
	}
	return _p;
}

inline _wstop__TopicNamespaceType_Topic * soap_new_set__wstop__TopicNamespaceType_Topic(
	struct soap *soap,
	wstop__Documentation *documentation,
	char *__anyAttribute,
	wstop__QueryExpressionType *MessagePattern,
	const std::vector<wstop__TopicType *> & Topic,
	const std::vector<char *> & __any,
	const std::string& name,
	std::string *messageTypes,
	bool final_,
	std::string *parent)
{
	_wstop__TopicNamespaceType_Topic *_p = ::soap_new__wstop__TopicNamespaceType_Topic(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wstop__TopicNamespaceType_Topic::documentation = documentation;
		_p->_wstop__TopicNamespaceType_Topic::__anyAttribute = __anyAttribute;
		_p->_wstop__TopicNamespaceType_Topic::MessagePattern = MessagePattern;
		_p->_wstop__TopicNamespaceType_Topic::Topic = Topic;
		_p->_wstop__TopicNamespaceType_Topic::__any = __any;
		_p->_wstop__TopicNamespaceType_Topic::name = name;
		_p->_wstop__TopicNamespaceType_Topic::messageTypes = messageTypes;
		_p->_wstop__TopicNamespaceType_Topic::final_ = final_;
		_p->_wstop__TopicNamespaceType_Topic::parent = parent;
	}
	return _p;
}

inline int soap_write__wstop__TopicNamespaceType_Topic(struct soap *soap, _wstop__TopicNamespaceType_Topic const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicNamespaceType-Topic", p->soap_type() == SOAP_TYPE__wstop__TopicNamespaceType_Topic ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *URL, _wstop__TopicNamespaceType_Topic const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicNamespaceType-Topic", p->soap_type() == SOAP_TYPE__wstop__TopicNamespaceType_Topic ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *URL, _wstop__TopicNamespaceType_Topic const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicNamespaceType-Topic", p->soap_type() == SOAP_TYPE__wstop__TopicNamespaceType_Topic ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *URL, _wstop__TopicNamespaceType_Topic const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicNamespaceType-Topic", p->soap_type() == SOAP_TYPE__wstop__TopicNamespaceType_Topic ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_get__wstop__TopicNamespaceType_Topic(struct soap*, _wstop__TopicNamespaceType_Topic *, const char*, const char*);

inline int soap_read__wstop__TopicNamespaceType_Topic(struct soap *soap, _wstop__TopicNamespaceType_Topic *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wstop__TopicNamespaceType_Topic(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *URL, _wstop__TopicNamespaceType_Topic *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wstop__TopicNamespaceType_Topic(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wstop__TopicNamespaceType_Topic(struct soap *soap, _wstop__TopicNamespaceType_Topic *p)
{
	if (::soap_read__wstop__TopicNamespaceType_Topic(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause_DEFINED
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_FaultCause(struct soap*, const char*, int, const _wsrfbf__BaseFaultType_FaultCause *, const char*);
SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_FaultCause(struct soap*, const char*, _wsrfbf__BaseFaultType_FaultCause *, const char*);
SOAP_FMAC1 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC2 imageing_instantiate__wsrfbf__BaseFaultType_FaultCause(struct soap*, int, const char*, const char*, size_t*);

inline _wsrfbf__BaseFaultType_FaultCause * soap_new__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsrfbf__BaseFaultType_FaultCause(soap, n, NULL, NULL, NULL);
}

inline _wsrfbf__BaseFaultType_FaultCause * soap_new_req__wsrfbf__BaseFaultType_FaultCause(
	struct soap *soap)
{
	_wsrfbf__BaseFaultType_FaultCause *_p = ::soap_new__wsrfbf__BaseFaultType_FaultCause(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsrfbf__BaseFaultType_FaultCause * soap_new_set__wsrfbf__BaseFaultType_FaultCause(
	struct soap *soap,
	char *__any)
{
	_wsrfbf__BaseFaultType_FaultCause *_p = ::soap_new__wsrfbf__BaseFaultType_FaultCause(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsrfbf__BaseFaultType_FaultCause::__any = __any;
	}
	return _p;
}

inline int soap_write__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType-FaultCause", p->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *URL, _wsrfbf__BaseFaultType_FaultCause const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType-FaultCause", p->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *URL, _wsrfbf__BaseFaultType_FaultCause const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType-FaultCause", p->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *URL, _wsrfbf__BaseFaultType_FaultCause const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType-FaultCause", p->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_FaultCause(struct soap*, _wsrfbf__BaseFaultType_FaultCause *, const char*, const char*);

inline int soap_read__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsrfbf__BaseFaultType_FaultCause(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *URL, _wsrfbf__BaseFaultType_FaultCause *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsrfbf__BaseFaultType_FaultCause(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *p)
{
	if (::soap_read__wsrfbf__BaseFaultType_FaultCause(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description_DEFINED
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_Description(struct soap*, const char*, int, const _wsrfbf__BaseFaultType_Description *, const char*);
SOAP_FMAC3 _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_Description(struct soap*, const char*, _wsrfbf__BaseFaultType_Description *, const char*);
SOAP_FMAC1 _wsrfbf__BaseFaultType_Description * SOAP_FMAC2 imageing_instantiate__wsrfbf__BaseFaultType_Description(struct soap*, int, const char*, const char*, size_t*);

inline _wsrfbf__BaseFaultType_Description * soap_new__wsrfbf__BaseFaultType_Description(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsrfbf__BaseFaultType_Description(soap, n, NULL, NULL, NULL);
}

inline _wsrfbf__BaseFaultType_Description * soap_new_req__wsrfbf__BaseFaultType_Description(
	struct soap *soap,
	const std::string& __item)
{
	_wsrfbf__BaseFaultType_Description *_p = ::soap_new__wsrfbf__BaseFaultType_Description(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsrfbf__BaseFaultType_Description::__item = __item;
	}
	return _p;
}

inline _wsrfbf__BaseFaultType_Description * soap_new_set__wsrfbf__BaseFaultType_Description(
	struct soap *soap,
	const std::string& __item,
	std::string *xml__lang)
{
	_wsrfbf__BaseFaultType_Description *_p = ::soap_new__wsrfbf__BaseFaultType_Description(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsrfbf__BaseFaultType_Description::__item = __item;
		_p->_wsrfbf__BaseFaultType_Description::xml__lang = xml__lang;
	}
	return _p;
}

inline int soap_write__wsrfbf__BaseFaultType_Description(struct soap *soap, _wsrfbf__BaseFaultType_Description const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType-Description", p->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_Description ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *URL, _wsrfbf__BaseFaultType_Description const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType-Description", p->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_Description ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *URL, _wsrfbf__BaseFaultType_Description const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType-Description", p->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_Description ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *URL, _wsrfbf__BaseFaultType_Description const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType-Description", p->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_Description ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_Description(struct soap*, _wsrfbf__BaseFaultType_Description *, const char*, const char*);

inline int soap_read__wsrfbf__BaseFaultType_Description(struct soap *soap, _wsrfbf__BaseFaultType_Description *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsrfbf__BaseFaultType_Description(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *URL, _wsrfbf__BaseFaultType_Description *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsrfbf__BaseFaultType_Description(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsrfbf__BaseFaultType_Description(struct soap *soap, _wsrfbf__BaseFaultType_Description *p)
{
	if (::soap_read__wsrfbf__BaseFaultType_Description(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode_DEFINED
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_ErrorCode(struct soap*, const char*, int, const _wsrfbf__BaseFaultType_ErrorCode *, const char*);
SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_ErrorCode(struct soap*, const char*, _wsrfbf__BaseFaultType_ErrorCode *, const char*);
SOAP_FMAC1 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC2 imageing_instantiate__wsrfbf__BaseFaultType_ErrorCode(struct soap*, int, const char*, const char*, size_t*);

inline _wsrfbf__BaseFaultType_ErrorCode * soap_new__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsrfbf__BaseFaultType_ErrorCode(soap, n, NULL, NULL, NULL);
}

inline _wsrfbf__BaseFaultType_ErrorCode * soap_new_req__wsrfbf__BaseFaultType_ErrorCode(
	struct soap *soap,
	const std::string& dialect)
{
	_wsrfbf__BaseFaultType_ErrorCode *_p = ::soap_new__wsrfbf__BaseFaultType_ErrorCode(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsrfbf__BaseFaultType_ErrorCode::dialect = dialect;
	}
	return _p;
}

inline _wsrfbf__BaseFaultType_ErrorCode * soap_new_set__wsrfbf__BaseFaultType_ErrorCode(
	struct soap *soap,
	const std::string& dialect,
	char *__mixed)
{
	_wsrfbf__BaseFaultType_ErrorCode *_p = ::soap_new__wsrfbf__BaseFaultType_ErrorCode(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsrfbf__BaseFaultType_ErrorCode::dialect = dialect;
		_p->_wsrfbf__BaseFaultType_ErrorCode::__mixed = __mixed;
	}
	return _p;
}

inline int soap_write__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType-ErrorCode", p->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *URL, _wsrfbf__BaseFaultType_ErrorCode const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType-ErrorCode", p->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *URL, _wsrfbf__BaseFaultType_ErrorCode const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType-ErrorCode", p->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *URL, _wsrfbf__BaseFaultType_ErrorCode const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType-ErrorCode", p->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_ErrorCode(struct soap*, _wsrfbf__BaseFaultType_ErrorCode *, const char*, const char*);

inline int soap_read__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsrfbf__BaseFaultType_ErrorCode(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *URL, _wsrfbf__BaseFaultType_ErrorCode *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsrfbf__BaseFaultType_ErrorCode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *p)
{
	if (::soap_read__wsrfbf__BaseFaultType_ErrorCode(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy_DEFINED
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe_SubscriptionPolicy(struct soap*, const char*, int, const _wsnt__Subscribe_SubscriptionPolicy *, const char*);
SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_in__wsnt__Subscribe_SubscriptionPolicy(struct soap*, const char*, _wsnt__Subscribe_SubscriptionPolicy *, const char*);
SOAP_FMAC1 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC2 imageing_instantiate__wsnt__Subscribe_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__Subscribe_SubscriptionPolicy * soap_new__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__Subscribe_SubscriptionPolicy(soap, n, NULL, NULL, NULL);
}

inline _wsnt__Subscribe_SubscriptionPolicy * soap_new_req__wsnt__Subscribe_SubscriptionPolicy(
	struct soap *soap)
{
	_wsnt__Subscribe_SubscriptionPolicy *_p = ::soap_new__wsnt__Subscribe_SubscriptionPolicy(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__Subscribe_SubscriptionPolicy * soap_new_set__wsnt__Subscribe_SubscriptionPolicy(
	struct soap *soap,
	const std::vector<char *> & __any)
{
	_wsnt__Subscribe_SubscriptionPolicy *_p = ::soap_new__wsnt__Subscribe_SubscriptionPolicy(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__Subscribe_SubscriptionPolicy::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Subscribe-SubscriptionPolicy", p->soap_type() == SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *URL, _wsnt__Subscribe_SubscriptionPolicy const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Subscribe-SubscriptionPolicy", p->soap_type() == SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *URL, _wsnt__Subscribe_SubscriptionPolicy const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Subscribe-SubscriptionPolicy", p->soap_type() == SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *URL, _wsnt__Subscribe_SubscriptionPolicy const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Subscribe-SubscriptionPolicy", p->soap_type() == SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_get__wsnt__Subscribe_SubscriptionPolicy(struct soap*, _wsnt__Subscribe_SubscriptionPolicy *, const char*, const char*);

inline int soap_read__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__Subscribe_SubscriptionPolicy(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *URL, _wsnt__Subscribe_SubscriptionPolicy *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__Subscribe_SubscriptionPolicy(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *p)
{
	if (::soap_read__wsnt__Subscribe_SubscriptionPolicy(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message_DEFINED
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationMessageHolderType_Message(struct soap*, const char*, int, const _wsnt__NotificationMessageHolderType_Message *, const char*);
SOAP_FMAC3 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_in__wsnt__NotificationMessageHolderType_Message(struct soap*, const char*, _wsnt__NotificationMessageHolderType_Message *, const char*);
SOAP_FMAC1 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC2 imageing_instantiate__wsnt__NotificationMessageHolderType_Message(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__NotificationMessageHolderType_Message * soap_new__wsnt__NotificationMessageHolderType_Message(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__NotificationMessageHolderType_Message(soap, n, NULL, NULL, NULL);
}

inline _wsnt__NotificationMessageHolderType_Message * soap_new_req__wsnt__NotificationMessageHolderType_Message(
	struct soap *soap)
{
	_wsnt__NotificationMessageHolderType_Message *_p = ::soap_new__wsnt__NotificationMessageHolderType_Message(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__NotificationMessageHolderType_Message * soap_new_set__wsnt__NotificationMessageHolderType_Message(
	struct soap *soap,
	char *__any)
{
	_wsnt__NotificationMessageHolderType_Message *_p = ::soap_new__wsnt__NotificationMessageHolderType_Message(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__NotificationMessageHolderType_Message::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__NotificationMessageHolderType_Message(struct soap *soap, _wsnt__NotificationMessageHolderType_Message const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotificationMessageHolderType-Message", p->soap_type() == SOAP_TYPE__wsnt__NotificationMessageHolderType_Message ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *URL, _wsnt__NotificationMessageHolderType_Message const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotificationMessageHolderType-Message", p->soap_type() == SOAP_TYPE__wsnt__NotificationMessageHolderType_Message ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *URL, _wsnt__NotificationMessageHolderType_Message const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotificationMessageHolderType-Message", p->soap_type() == SOAP_TYPE__wsnt__NotificationMessageHolderType_Message ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *URL, _wsnt__NotificationMessageHolderType_Message const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotificationMessageHolderType-Message", p->soap_type() == SOAP_TYPE__wsnt__NotificationMessageHolderType_Message ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_get__wsnt__NotificationMessageHolderType_Message(struct soap*, _wsnt__NotificationMessageHolderType_Message *, const char*, const char*);

inline int soap_read__wsnt__NotificationMessageHolderType_Message(struct soap *soap, _wsnt__NotificationMessageHolderType_Message *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__NotificationMessageHolderType_Message(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *URL, _wsnt__NotificationMessageHolderType_Message *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__NotificationMessageHolderType_Message(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__NotificationMessageHolderType_Message(struct soap *soap, _wsnt__NotificationMessageHolderType_Message *p)
{
	if (::soap_read__wsnt__NotificationMessageHolderType_Message(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__tt__ItemList_ElementItem_DEFINED
#define SOAP_TYPE__tt__ItemList_ElementItem_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_ElementItem(struct soap*, const char*, int, const _tt__ItemList_ElementItem *, const char*);
SOAP_FMAC3 _tt__ItemList_ElementItem * SOAP_FMAC4 soap_in__tt__ItemList_ElementItem(struct soap*, const char*, _tt__ItemList_ElementItem *, const char*);
SOAP_FMAC1 _tt__ItemList_ElementItem * SOAP_FMAC2 imageing_instantiate__tt__ItemList_ElementItem(struct soap*, int, const char*, const char*, size_t*);

inline _tt__ItemList_ElementItem * soap_new__tt__ItemList_ElementItem(struct soap *soap, int n = -1)
{
	return imageing_instantiate__tt__ItemList_ElementItem(soap, n, NULL, NULL, NULL);
}

inline _tt__ItemList_ElementItem * soap_new_req__tt__ItemList_ElementItem(
	struct soap *soap,
	const std::string& Name)
{
	_tt__ItemList_ElementItem *_p = ::soap_new__tt__ItemList_ElementItem(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_tt__ItemList_ElementItem::Name = Name;
	}
	return _p;
}

inline _tt__ItemList_ElementItem * soap_new_set__tt__ItemList_ElementItem(
	struct soap *soap,
	char *__any,
	const std::string& Name)
{
	_tt__ItemList_ElementItem *_p = ::soap_new__tt__ItemList_ElementItem(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_tt__ItemList_ElementItem::__any = __any;
		_p->_tt__ItemList_ElementItem::Name = Name;
	}
	return _p;
}

inline int soap_write__tt__ItemList_ElementItem(struct soap *soap, _tt__ItemList_ElementItem const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemList-ElementItem", p->soap_type() == SOAP_TYPE__tt__ItemList_ElementItem ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__tt__ItemList_ElementItem(struct soap *soap, const char *URL, _tt__ItemList_ElementItem const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemList-ElementItem", p->soap_type() == SOAP_TYPE__tt__ItemList_ElementItem ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__tt__ItemList_ElementItem(struct soap *soap, const char *URL, _tt__ItemList_ElementItem const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemList-ElementItem", p->soap_type() == SOAP_TYPE__tt__ItemList_ElementItem ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__tt__ItemList_ElementItem(struct soap *soap, const char *URL, _tt__ItemList_ElementItem const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemList-ElementItem", p->soap_type() == SOAP_TYPE__tt__ItemList_ElementItem ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _tt__ItemList_ElementItem * SOAP_FMAC4 soap_get__tt__ItemList_ElementItem(struct soap*, _tt__ItemList_ElementItem *, const char*, const char*);

inline int soap_read__tt__ItemList_ElementItem(struct soap *soap, _tt__ItemList_ElementItem *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__tt__ItemList_ElementItem(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__tt__ItemList_ElementItem(struct soap *soap, const char *URL, _tt__ItemList_ElementItem *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__tt__ItemList_ElementItem(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__tt__ItemList_ElementItem(struct soap *soap, _tt__ItemList_ElementItem *p)
{
	if (::soap_read__tt__ItemList_ElementItem(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__tt__ItemList_SimpleItem_DEFINED
#define SOAP_TYPE__tt__ItemList_SimpleItem_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_SimpleItem(struct soap*, const char*, int, const _tt__ItemList_SimpleItem *, const char*);
SOAP_FMAC3 _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_in__tt__ItemList_SimpleItem(struct soap*, const char*, _tt__ItemList_SimpleItem *, const char*);
SOAP_FMAC1 _tt__ItemList_SimpleItem * SOAP_FMAC2 imageing_instantiate__tt__ItemList_SimpleItem(struct soap*, int, const char*, const char*, size_t*);

inline _tt__ItemList_SimpleItem * soap_new__tt__ItemList_SimpleItem(struct soap *soap, int n = -1)
{
	return imageing_instantiate__tt__ItemList_SimpleItem(soap, n, NULL, NULL, NULL);
}

inline _tt__ItemList_SimpleItem * soap_new_req__tt__ItemList_SimpleItem(
	struct soap *soap,
	const std::string& Name,
	const std::string& Value)
{
	_tt__ItemList_SimpleItem *_p = ::soap_new__tt__ItemList_SimpleItem(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_tt__ItemList_SimpleItem::Name = Name;
		_p->_tt__ItemList_SimpleItem::Value = Value;
	}
	return _p;
}

inline _tt__ItemList_SimpleItem * soap_new_set__tt__ItemList_SimpleItem(
	struct soap *soap,
	const std::string& Name,
	const std::string& Value)
{
	_tt__ItemList_SimpleItem *_p = ::soap_new__tt__ItemList_SimpleItem(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_tt__ItemList_SimpleItem::Name = Name;
		_p->_tt__ItemList_SimpleItem::Value = Value;
	}
	return _p;
}

inline int soap_write__tt__ItemList_SimpleItem(struct soap *soap, _tt__ItemList_SimpleItem const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemList-SimpleItem", p->soap_type() == SOAP_TYPE__tt__ItemList_SimpleItem ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__tt__ItemList_SimpleItem(struct soap *soap, const char *URL, _tt__ItemList_SimpleItem const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemList-SimpleItem", p->soap_type() == SOAP_TYPE__tt__ItemList_SimpleItem ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__tt__ItemList_SimpleItem(struct soap *soap, const char *URL, _tt__ItemList_SimpleItem const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemList-SimpleItem", p->soap_type() == SOAP_TYPE__tt__ItemList_SimpleItem ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__tt__ItemList_SimpleItem(struct soap *soap, const char *URL, _tt__ItemList_SimpleItem const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemList-SimpleItem", p->soap_type() == SOAP_TYPE__tt__ItemList_SimpleItem ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_get__tt__ItemList_SimpleItem(struct soap*, _tt__ItemList_SimpleItem *, const char*, const char*);

inline int soap_read__tt__ItemList_SimpleItem(struct soap *soap, _tt__ItemList_SimpleItem *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__tt__ItemList_SimpleItem(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__tt__ItemList_SimpleItem(struct soap *soap, const char *URL, _tt__ItemList_SimpleItem *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__tt__ItemList_SimpleItem(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__tt__ItemList_SimpleItem(struct soap *soap, _tt__ItemList_SimpleItem *p)
{
	if (::soap_read__tt__ItemList_SimpleItem(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy_DEFINED
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__EventSubscription_SubscriptionPolicy(struct soap*, const char*, int, const _tt__EventSubscription_SubscriptionPolicy *, const char*);
SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_in__tt__EventSubscription_SubscriptionPolicy(struct soap*, const char*, _tt__EventSubscription_SubscriptionPolicy *, const char*);
SOAP_FMAC1 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC2 imageing_instantiate__tt__EventSubscription_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);

inline _tt__EventSubscription_SubscriptionPolicy * soap_new__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, int n = -1)
{
	return imageing_instantiate__tt__EventSubscription_SubscriptionPolicy(soap, n, NULL, NULL, NULL);
}

inline _tt__EventSubscription_SubscriptionPolicy * soap_new_req__tt__EventSubscription_SubscriptionPolicy(
	struct soap *soap)
{
	_tt__EventSubscription_SubscriptionPolicy *_p = ::soap_new__tt__EventSubscription_SubscriptionPolicy(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _tt__EventSubscription_SubscriptionPolicy * soap_new_set__tt__EventSubscription_SubscriptionPolicy(
	struct soap *soap,
	const std::vector<char *> & __any)
{
	_tt__EventSubscription_SubscriptionPolicy *_p = ::soap_new__tt__EventSubscription_SubscriptionPolicy(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_tt__EventSubscription_SubscriptionPolicy::__any = __any;
	}
	return _p;
}

inline int soap_write__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EventSubscription-SubscriptionPolicy", p->soap_type() == SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *URL, _tt__EventSubscription_SubscriptionPolicy const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EventSubscription-SubscriptionPolicy", p->soap_type() == SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *URL, _tt__EventSubscription_SubscriptionPolicy const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EventSubscription-SubscriptionPolicy", p->soap_type() == SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *URL, _tt__EventSubscription_SubscriptionPolicy const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EventSubscription-SubscriptionPolicy", p->soap_type() == SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_get__tt__EventSubscription_SubscriptionPolicy(struct soap*, _tt__EventSubscription_SubscriptionPolicy *, const char*, const char*);

inline int soap_read__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__tt__EventSubscription_SubscriptionPolicy(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *URL, _tt__EventSubscription_SubscriptionPolicy *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__tt__EventSubscription_SubscriptionPolicy(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy *p)
{
	if (::soap_read__tt__EventSubscription_SubscriptionPolicy(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression___DEFINED
#define SOAP_TYPE_wstop__ConcreteTopicExpression___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ConcreteTopicExpression__(struct soap*, const char*, int, const wstop__ConcreteTopicExpression__ *, const char*);
SOAP_FMAC3 wstop__ConcreteTopicExpression__ * SOAP_FMAC4 soap_in_wstop__ConcreteTopicExpression__(struct soap*, const char*, wstop__ConcreteTopicExpression__ *, const char*);
SOAP_FMAC1 wstop__ConcreteTopicExpression__ * SOAP_FMAC2 imageing_instantiate_wstop__ConcreteTopicExpression__(struct soap*, int, const char*, const char*, size_t*);

inline wstop__ConcreteTopicExpression__ * soap_new_wstop__ConcreteTopicExpression__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wstop__ConcreteTopicExpression__(soap, n, NULL, NULL, NULL);
}

inline wstop__ConcreteTopicExpression__ * soap_new_req_wstop__ConcreteTopicExpression__(
	struct soap *soap,
	const std::string& __item)
{
	wstop__ConcreteTopicExpression__ *_p = ::soap_new_wstop__ConcreteTopicExpression__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wstop__ConcreteTopicExpression__::__item = __item;
	}
	return _p;
}

inline wstop__ConcreteTopicExpression__ * soap_new_set_wstop__ConcreteTopicExpression__(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	wstop__ConcreteTopicExpression__ *_p = ::soap_new_wstop__ConcreteTopicExpression__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wstop__ConcreteTopicExpression__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_wstop__ConcreteTopicExpression__(struct soap *soap, wstop__ConcreteTopicExpression__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:ConcreteTopicExpression", p->soap_type() == SOAP_TYPE_wstop__ConcreteTopicExpression__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wstop__ConcreteTopicExpression__(struct soap *soap, const char *URL, wstop__ConcreteTopicExpression__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:ConcreteTopicExpression", p->soap_type() == SOAP_TYPE_wstop__ConcreteTopicExpression__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wstop__ConcreteTopicExpression__(struct soap *soap, const char *URL, wstop__ConcreteTopicExpression__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:ConcreteTopicExpression", p->soap_type() == SOAP_TYPE_wstop__ConcreteTopicExpression__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wstop__ConcreteTopicExpression__(struct soap *soap, const char *URL, wstop__ConcreteTopicExpression__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:ConcreteTopicExpression", p->soap_type() == SOAP_TYPE_wstop__ConcreteTopicExpression__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wstop__ConcreteTopicExpression__ * SOAP_FMAC4 soap_get_wstop__ConcreteTopicExpression__(struct soap*, wstop__ConcreteTopicExpression__ *, const char*, const char*);

inline int soap_read_wstop__ConcreteTopicExpression__(struct soap *soap, wstop__ConcreteTopicExpression__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wstop__ConcreteTopicExpression__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wstop__ConcreteTopicExpression__(struct soap *soap, const char *URL, wstop__ConcreteTopicExpression__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wstop__ConcreteTopicExpression__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wstop__ConcreteTopicExpression__(struct soap *soap, wstop__ConcreteTopicExpression__ *p)
{
	if (::soap_read_wstop__ConcreteTopicExpression__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif
/* wstop__ConcreteTopicExpression is a typedef restriction of xsd__token */

#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression_DEFINED
#define SOAP_TYPE_wstop__ConcreteTopicExpression_DEFINED

#define soap_default_wstop__ConcreteTopicExpression soap_default_xsd__token


#define soap_serialize_wstop__ConcreteTopicExpression soap_serialize_xsd__token


#define soap_wstop__ConcreteTopicExpression2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ConcreteTopicExpression(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2wstop__ConcreteTopicExpression(soap, s, a) soap_s2stdchar((soap), (s), (a), 5, 0, -1, "(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)(/([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)*")
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wstop__ConcreteTopicExpression(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_wstop__ConcreteTopicExpression imageing_instantiate_xsd__token


#define soap_new_wstop__ConcreteTopicExpression soap_new_xsd__token

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ConcreteTopicExpression(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_wstop__ConcreteTopicExpression(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_wstop__ConcreteTopicExpression(soap, p, "wstop:ConcreteTopicExpression", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_wstop__ConcreteTopicExpression(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wstop__ConcreteTopicExpression(soap, p, "wstop:ConcreteTopicExpression", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wstop__ConcreteTopicExpression(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wstop__ConcreteTopicExpression(soap, p, "wstop:ConcreteTopicExpression", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wstop__ConcreteTopicExpression(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wstop__ConcreteTopicExpression(soap, p, "wstop:ConcreteTopicExpression", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wstop__ConcreteTopicExpression(struct soap*, std::string *, const char*, const char*);

inline int soap_read_wstop__ConcreteTopicExpression(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_wstop__ConcreteTopicExpression(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wstop__ConcreteTopicExpression(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wstop__ConcreteTopicExpression(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wstop__ConcreteTopicExpression(struct soap *soap, std::string *p)
{
	if (::soap_read_wstop__ConcreteTopicExpression(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__MoveStatus__DEFINED
#define SOAP_TYPE_tt__MoveStatus__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveStatus_(struct soap*, const char*, int, const tt__MoveStatus_ *, const char*);
SOAP_FMAC3 tt__MoveStatus_ * SOAP_FMAC4 soap_in_tt__MoveStatus_(struct soap*, const char*, tt__MoveStatus_ *, const char*);
SOAP_FMAC1 tt__MoveStatus_ * SOAP_FMAC2 imageing_instantiate_tt__MoveStatus_(struct soap*, int, const char*, const char*, size_t*);

inline tt__MoveStatus_ * soap_new_tt__MoveStatus_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__MoveStatus_(soap, n, NULL, NULL, NULL);
}

inline tt__MoveStatus_ * soap_new_req_tt__MoveStatus_(
	struct soap *soap,
	enum tt__MoveStatus __item)
{
	tt__MoveStatus_ *_p = ::soap_new_tt__MoveStatus_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__MoveStatus_::__item = __item;
	}
	return _p;
}

inline tt__MoveStatus_ * soap_new_set_tt__MoveStatus_(
	struct soap *soap,
	enum tt__MoveStatus __item,
	char *__item__1)
{
	tt__MoveStatus_ *_p = ::soap_new_tt__MoveStatus_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__MoveStatus_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__MoveStatus_(struct soap *soap, tt__MoveStatus_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MoveStatus", p->soap_type() == SOAP_TYPE_tt__MoveStatus_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__MoveStatus_(struct soap *soap, const char *URL, tt__MoveStatus_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MoveStatus", p->soap_type() == SOAP_TYPE_tt__MoveStatus_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__MoveStatus_(struct soap *soap, const char *URL, tt__MoveStatus_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MoveStatus", p->soap_type() == SOAP_TYPE_tt__MoveStatus_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__MoveStatus_(struct soap *soap, const char *URL, tt__MoveStatus_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MoveStatus", p->soap_type() == SOAP_TYPE_tt__MoveStatus_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__MoveStatus_ * SOAP_FMAC4 soap_get_tt__MoveStatus_(struct soap*, tt__MoveStatus_ *, const char*, const char*);

inline int soap_read_tt__MoveStatus_(struct soap *soap, tt__MoveStatus_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__MoveStatus_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__MoveStatus_(struct soap *soap, const char *URL, tt__MoveStatus_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__MoveStatus_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__MoveStatus_(struct soap *soap, tt__MoveStatus_ *p)
{
	if (::soap_read_tt__MoveStatus_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ReferenceToken___DEFINED
#define SOAP_TYPE_tt__ReferenceToken___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken__(struct soap*, const char*, int, const tt__ReferenceToken__ *, const char*);
SOAP_FMAC3 tt__ReferenceToken__ * SOAP_FMAC4 soap_in_tt__ReferenceToken__(struct soap*, const char*, tt__ReferenceToken__ *, const char*);
SOAP_FMAC1 tt__ReferenceToken__ * SOAP_FMAC2 imageing_instantiate_tt__ReferenceToken__(struct soap*, int, const char*, const char*, size_t*);

inline tt__ReferenceToken__ * soap_new_tt__ReferenceToken__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ReferenceToken__(soap, n, NULL, NULL, NULL);
}

inline tt__ReferenceToken__ * soap_new_req_tt__ReferenceToken__(
	struct soap *soap,
	const std::string& __item)
{
	tt__ReferenceToken__ *_p = ::soap_new_tt__ReferenceToken__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ReferenceToken__::__item = __item;
	}
	return _p;
}

inline tt__ReferenceToken__ * soap_new_set_tt__ReferenceToken__(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	tt__ReferenceToken__ *_p = ::soap_new_tt__ReferenceToken__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ReferenceToken__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ReferenceToken__(struct soap *soap, tt__ReferenceToken__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ReferenceToken", p->soap_type() == SOAP_TYPE_tt__ReferenceToken__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ReferenceToken__(struct soap *soap, const char *URL, tt__ReferenceToken__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ReferenceToken", p->soap_type() == SOAP_TYPE_tt__ReferenceToken__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ReferenceToken__(struct soap *soap, const char *URL, tt__ReferenceToken__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ReferenceToken", p->soap_type() == SOAP_TYPE_tt__ReferenceToken__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ReferenceToken__(struct soap *soap, const char *URL, tt__ReferenceToken__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ReferenceToken", p->soap_type() == SOAP_TYPE_tt__ReferenceToken__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ReferenceToken__ * SOAP_FMAC4 soap_get_tt__ReferenceToken__(struct soap*, tt__ReferenceToken__ *, const char*, const char*);

inline int soap_read_tt__ReferenceToken__(struct soap *soap, tt__ReferenceToken__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ReferenceToken__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ReferenceToken__(struct soap *soap, const char *URL, tt__ReferenceToken__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ReferenceToken__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ReferenceToken__(struct soap *soap, tt__ReferenceToken__ *p)
{
	if (::soap_read_tt__ReferenceToken__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ReferenceToken_DEFINED
#define SOAP_TYPE_tt__ReferenceToken_DEFINED

inline void soap_default_tt__ReferenceToken(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceToken(struct soap*, const std::string *);

#define soap_tt__ReferenceToken2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2tt__ReferenceToken(soap, s, a) soap_s2stdchar((soap), (s), (a), 1, 0, 64, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__ReferenceToken(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_tt__ReferenceToken imageing_instantiate_std__string


#define soap_new_tt__ReferenceToken soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceToken(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_tt__ReferenceToken(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__ReferenceToken(soap, p, "tt:ReferenceToken", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__ReferenceToken(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ReferenceToken(soap, p, "tt:ReferenceToken", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ReferenceToken(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ReferenceToken(soap, p, "tt:ReferenceToken", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ReferenceToken(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__ReferenceToken(soap, p, "tt:ReferenceToken", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__ReferenceToken(struct soap*, std::string *, const char*, const char*);

inline int soap_read_tt__ReferenceToken(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__ReferenceToken(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ReferenceToken(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ReferenceToken(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ReferenceToken(struct soap *soap, std::string *p)
{
	if (::soap_read_tt__ReferenceToken(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__PropertyOperation__DEFINED
#define SOAP_TYPE_tt__PropertyOperation__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PropertyOperation_(struct soap*, const char*, int, const tt__PropertyOperation_ *, const char*);
SOAP_FMAC3 tt__PropertyOperation_ * SOAP_FMAC4 soap_in_tt__PropertyOperation_(struct soap*, const char*, tt__PropertyOperation_ *, const char*);
SOAP_FMAC1 tt__PropertyOperation_ * SOAP_FMAC2 imageing_instantiate_tt__PropertyOperation_(struct soap*, int, const char*, const char*, size_t*);

inline tt__PropertyOperation_ * soap_new_tt__PropertyOperation_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__PropertyOperation_(soap, n, NULL, NULL, NULL);
}

inline tt__PropertyOperation_ * soap_new_req_tt__PropertyOperation_(
	struct soap *soap,
	enum tt__PropertyOperation __item)
{
	tt__PropertyOperation_ *_p = ::soap_new_tt__PropertyOperation_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PropertyOperation_::__item = __item;
	}
	return _p;
}

inline tt__PropertyOperation_ * soap_new_set_tt__PropertyOperation_(
	struct soap *soap,
	enum tt__PropertyOperation __item,
	char *__item__1)
{
	tt__PropertyOperation_ *_p = ::soap_new_tt__PropertyOperation_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PropertyOperation_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__PropertyOperation_(struct soap *soap, tt__PropertyOperation_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PropertyOperation", p->soap_type() == SOAP_TYPE_tt__PropertyOperation_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__PropertyOperation_(struct soap *soap, const char *URL, tt__PropertyOperation_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PropertyOperation", p->soap_type() == SOAP_TYPE_tt__PropertyOperation_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__PropertyOperation_(struct soap *soap, const char *URL, tt__PropertyOperation_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PropertyOperation", p->soap_type() == SOAP_TYPE_tt__PropertyOperation_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__PropertyOperation_(struct soap *soap, const char *URL, tt__PropertyOperation_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PropertyOperation", p->soap_type() == SOAP_TYPE_tt__PropertyOperation_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__PropertyOperation_ * SOAP_FMAC4 soap_get_tt__PropertyOperation_(struct soap*, tt__PropertyOperation_ *, const char*, const char*);

inline int soap_read_tt__PropertyOperation_(struct soap *soap, tt__PropertyOperation_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__PropertyOperation_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__PropertyOperation_(struct soap *soap, const char *URL, tt__PropertyOperation_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__PropertyOperation_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__PropertyOperation_(struct soap *soap, tt__PropertyOperation_ *p)
{
	if (::soap_read_tt__PropertyOperation_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationMode__DEFINED
#define SOAP_TYPE_tt__ImageStabilizationMode__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationMode_(struct soap*, const char*, int, const tt__ImageStabilizationMode_ *, const char*);
SOAP_FMAC3 tt__ImageStabilizationMode_ * SOAP_FMAC4 soap_in_tt__ImageStabilizationMode_(struct soap*, const char*, tt__ImageStabilizationMode_ *, const char*);
SOAP_FMAC1 tt__ImageStabilizationMode_ * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilizationMode_(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImageStabilizationMode_ * soap_new_tt__ImageStabilizationMode_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImageStabilizationMode_(soap, n, NULL, NULL, NULL);
}

inline tt__ImageStabilizationMode_ * soap_new_req_tt__ImageStabilizationMode_(
	struct soap *soap,
	enum tt__ImageStabilizationMode __item)
{
	tt__ImageStabilizationMode_ *_p = ::soap_new_tt__ImageStabilizationMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImageStabilizationMode_::__item = __item;
	}
	return _p;
}

inline tt__ImageStabilizationMode_ * soap_new_set_tt__ImageStabilizationMode_(
	struct soap *soap,
	enum tt__ImageStabilizationMode __item,
	char *__item__1)
{
	tt__ImageStabilizationMode_ *_p = ::soap_new_tt__ImageStabilizationMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImageStabilizationMode_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImageStabilizationMode_(struct soap *soap, tt__ImageStabilizationMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationMode", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationMode_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImageStabilizationMode_(struct soap *soap, const char *URL, tt__ImageStabilizationMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationMode", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImageStabilizationMode_(struct soap *soap, const char *URL, tt__ImageStabilizationMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationMode", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImageStabilizationMode_(struct soap *soap, const char *URL, tt__ImageStabilizationMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationMode", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationMode_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImageStabilizationMode_ * SOAP_FMAC4 soap_get_tt__ImageStabilizationMode_(struct soap*, tt__ImageStabilizationMode_ *, const char*, const char*);

inline int soap_read_tt__ImageStabilizationMode_(struct soap *soap, tt__ImageStabilizationMode_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImageStabilizationMode_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImageStabilizationMode_(struct soap *soap, const char *URL, tt__ImageStabilizationMode_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImageStabilizationMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImageStabilizationMode_(struct soap *soap, tt__ImageStabilizationMode_ *p)
{
	if (::soap_read_tt__ImageStabilizationMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterMode__DEFINED
#define SOAP_TYPE_tt__IrCutFilterMode__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterMode_(struct soap*, const char*, int, const tt__IrCutFilterMode_ *, const char*);
SOAP_FMAC3 tt__IrCutFilterMode_ * SOAP_FMAC4 soap_in_tt__IrCutFilterMode_(struct soap*, const char*, tt__IrCutFilterMode_ *, const char*);
SOAP_FMAC1 tt__IrCutFilterMode_ * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterMode_(struct soap*, int, const char*, const char*, size_t*);

inline tt__IrCutFilterMode_ * soap_new_tt__IrCutFilterMode_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__IrCutFilterMode_(soap, n, NULL, NULL, NULL);
}

inline tt__IrCutFilterMode_ * soap_new_req_tt__IrCutFilterMode_(
	struct soap *soap,
	enum tt__IrCutFilterMode __item)
{
	tt__IrCutFilterMode_ *_p = ::soap_new_tt__IrCutFilterMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IrCutFilterMode_::__item = __item;
	}
	return _p;
}

inline tt__IrCutFilterMode_ * soap_new_set_tt__IrCutFilterMode_(
	struct soap *soap,
	enum tt__IrCutFilterMode __item,
	char *__item__1)
{
	tt__IrCutFilterMode_ *_p = ::soap_new_tt__IrCutFilterMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IrCutFilterMode_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__IrCutFilterMode_(struct soap *soap, tt__IrCutFilterMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterMode", p->soap_type() == SOAP_TYPE_tt__IrCutFilterMode_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__IrCutFilterMode_(struct soap *soap, const char *URL, tt__IrCutFilterMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterMode", p->soap_type() == SOAP_TYPE_tt__IrCutFilterMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IrCutFilterMode_(struct soap *soap, const char *URL, tt__IrCutFilterMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterMode", p->soap_type() == SOAP_TYPE_tt__IrCutFilterMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IrCutFilterMode_(struct soap *soap, const char *URL, tt__IrCutFilterMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterMode", p->soap_type() == SOAP_TYPE_tt__IrCutFilterMode_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__IrCutFilterMode_ * SOAP_FMAC4 soap_get_tt__IrCutFilterMode_(struct soap*, tt__IrCutFilterMode_ *, const char*, const char*);

inline int soap_read_tt__IrCutFilterMode_(struct soap *soap, tt__IrCutFilterMode_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__IrCutFilterMode_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IrCutFilterMode_(struct soap *soap, const char *URL, tt__IrCutFilterMode_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IrCutFilterMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IrCutFilterMode_(struct soap *soap, tt__IrCutFilterMode_ *p)
{
	if (::soap_read_tt__IrCutFilterMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceMode__DEFINED
#define SOAP_TYPE_tt__WhiteBalanceMode__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceMode_(struct soap*, const char*, int, const tt__WhiteBalanceMode_ *, const char*);
SOAP_FMAC3 tt__WhiteBalanceMode_ * SOAP_FMAC4 soap_in_tt__WhiteBalanceMode_(struct soap*, const char*, tt__WhiteBalanceMode_ *, const char*);
SOAP_FMAC1 tt__WhiteBalanceMode_ * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalanceMode_(struct soap*, int, const char*, const char*, size_t*);

inline tt__WhiteBalanceMode_ * soap_new_tt__WhiteBalanceMode_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__WhiteBalanceMode_(soap, n, NULL, NULL, NULL);
}

inline tt__WhiteBalanceMode_ * soap_new_req_tt__WhiteBalanceMode_(
	struct soap *soap,
	enum tt__WhiteBalanceMode __item)
{
	tt__WhiteBalanceMode_ *_p = ::soap_new_tt__WhiteBalanceMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WhiteBalanceMode_::__item = __item;
	}
	return _p;
}

inline tt__WhiteBalanceMode_ * soap_new_set_tt__WhiteBalanceMode_(
	struct soap *soap,
	enum tt__WhiteBalanceMode __item,
	char *__item__1)
{
	tt__WhiteBalanceMode_ *_p = ::soap_new_tt__WhiteBalanceMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WhiteBalanceMode_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__WhiteBalanceMode_(struct soap *soap, tt__WhiteBalanceMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalanceMode", p->soap_type() == SOAP_TYPE_tt__WhiteBalanceMode_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__WhiteBalanceMode_(struct soap *soap, const char *URL, tt__WhiteBalanceMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalanceMode", p->soap_type() == SOAP_TYPE_tt__WhiteBalanceMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__WhiteBalanceMode_(struct soap *soap, const char *URL, tt__WhiteBalanceMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalanceMode", p->soap_type() == SOAP_TYPE_tt__WhiteBalanceMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__WhiteBalanceMode_(struct soap *soap, const char *URL, tt__WhiteBalanceMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalanceMode", p->soap_type() == SOAP_TYPE_tt__WhiteBalanceMode_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__WhiteBalanceMode_ * SOAP_FMAC4 soap_get_tt__WhiteBalanceMode_(struct soap*, tt__WhiteBalanceMode_ *, const char*, const char*);

inline int soap_read_tt__WhiteBalanceMode_(struct soap *soap, tt__WhiteBalanceMode_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__WhiteBalanceMode_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__WhiteBalanceMode_(struct soap *soap, const char *URL, tt__WhiteBalanceMode_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__WhiteBalanceMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__WhiteBalanceMode_(struct soap *soap, tt__WhiteBalanceMode_ *p)
{
	if (::soap_read_tt__WhiteBalanceMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ExposureMode__DEFINED
#define SOAP_TYPE_tt__ExposureMode__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureMode_(struct soap*, const char*, int, const tt__ExposureMode_ *, const char*);
SOAP_FMAC3 tt__ExposureMode_ * SOAP_FMAC4 soap_in_tt__ExposureMode_(struct soap*, const char*, tt__ExposureMode_ *, const char*);
SOAP_FMAC1 tt__ExposureMode_ * SOAP_FMAC2 imageing_instantiate_tt__ExposureMode_(struct soap*, int, const char*, const char*, size_t*);

inline tt__ExposureMode_ * soap_new_tt__ExposureMode_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ExposureMode_(soap, n, NULL, NULL, NULL);
}

inline tt__ExposureMode_ * soap_new_req_tt__ExposureMode_(
	struct soap *soap,
	enum tt__ExposureMode __item)
{
	tt__ExposureMode_ *_p = ::soap_new_tt__ExposureMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ExposureMode_::__item = __item;
	}
	return _p;
}

inline tt__ExposureMode_ * soap_new_set_tt__ExposureMode_(
	struct soap *soap,
	enum tt__ExposureMode __item,
	char *__item__1)
{
	tt__ExposureMode_ *_p = ::soap_new_tt__ExposureMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ExposureMode_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ExposureMode_(struct soap *soap, tt__ExposureMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ExposureMode", p->soap_type() == SOAP_TYPE_tt__ExposureMode_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ExposureMode_(struct soap *soap, const char *URL, tt__ExposureMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ExposureMode", p->soap_type() == SOAP_TYPE_tt__ExposureMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ExposureMode_(struct soap *soap, const char *URL, tt__ExposureMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ExposureMode", p->soap_type() == SOAP_TYPE_tt__ExposureMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ExposureMode_(struct soap *soap, const char *URL, tt__ExposureMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ExposureMode", p->soap_type() == SOAP_TYPE_tt__ExposureMode_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ExposureMode_ * SOAP_FMAC4 soap_get_tt__ExposureMode_(struct soap*, tt__ExposureMode_ *, const char*, const char*);

inline int soap_read_tt__ExposureMode_(struct soap *soap, tt__ExposureMode_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ExposureMode_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ExposureMode_(struct soap *soap, const char *URL, tt__ExposureMode_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ExposureMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ExposureMode_(struct soap *soap, tt__ExposureMode_ *p)
{
	if (::soap_read_tt__ExposureMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ExposurePriority__DEFINED
#define SOAP_TYPE_tt__ExposurePriority__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposurePriority_(struct soap*, const char*, int, const tt__ExposurePriority_ *, const char*);
SOAP_FMAC3 tt__ExposurePriority_ * SOAP_FMAC4 soap_in_tt__ExposurePriority_(struct soap*, const char*, tt__ExposurePriority_ *, const char*);
SOAP_FMAC1 tt__ExposurePriority_ * SOAP_FMAC2 imageing_instantiate_tt__ExposurePriority_(struct soap*, int, const char*, const char*, size_t*);

inline tt__ExposurePriority_ * soap_new_tt__ExposurePriority_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ExposurePriority_(soap, n, NULL, NULL, NULL);
}

inline tt__ExposurePriority_ * soap_new_req_tt__ExposurePriority_(
	struct soap *soap,
	enum tt__ExposurePriority __item)
{
	tt__ExposurePriority_ *_p = ::soap_new_tt__ExposurePriority_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ExposurePriority_::__item = __item;
	}
	return _p;
}

inline tt__ExposurePriority_ * soap_new_set_tt__ExposurePriority_(
	struct soap *soap,
	enum tt__ExposurePriority __item,
	char *__item__1)
{
	tt__ExposurePriority_ *_p = ::soap_new_tt__ExposurePriority_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ExposurePriority_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ExposurePriority_(struct soap *soap, tt__ExposurePriority_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ExposurePriority", p->soap_type() == SOAP_TYPE_tt__ExposurePriority_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ExposurePriority_(struct soap *soap, const char *URL, tt__ExposurePriority_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ExposurePriority", p->soap_type() == SOAP_TYPE_tt__ExposurePriority_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ExposurePriority_(struct soap *soap, const char *URL, tt__ExposurePriority_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ExposurePriority", p->soap_type() == SOAP_TYPE_tt__ExposurePriority_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ExposurePriority_(struct soap *soap, const char *URL, tt__ExposurePriority_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ExposurePriority", p->soap_type() == SOAP_TYPE_tt__ExposurePriority_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ExposurePriority_ * SOAP_FMAC4 soap_get_tt__ExposurePriority_(struct soap*, tt__ExposurePriority_ *, const char*, const char*);

inline int soap_read_tt__ExposurePriority_(struct soap *soap, tt__ExposurePriority_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ExposurePriority_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ExposurePriority_(struct soap *soap, const char *URL, tt__ExposurePriority_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ExposurePriority_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ExposurePriority_(struct soap *soap, tt__ExposurePriority_ *p)
{
	if (::soap_read_tt__ExposurePriority_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationMode__DEFINED
#define SOAP_TYPE_tt__BacklightCompensationMode__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationMode_(struct soap*, const char*, int, const tt__BacklightCompensationMode_ *, const char*);
SOAP_FMAC3 tt__BacklightCompensationMode_ * SOAP_FMAC4 soap_in_tt__BacklightCompensationMode_(struct soap*, const char*, tt__BacklightCompensationMode_ *, const char*);
SOAP_FMAC1 tt__BacklightCompensationMode_ * SOAP_FMAC2 imageing_instantiate_tt__BacklightCompensationMode_(struct soap*, int, const char*, const char*, size_t*);

inline tt__BacklightCompensationMode_ * soap_new_tt__BacklightCompensationMode_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__BacklightCompensationMode_(soap, n, NULL, NULL, NULL);
}

inline tt__BacklightCompensationMode_ * soap_new_req_tt__BacklightCompensationMode_(
	struct soap *soap,
	enum tt__BacklightCompensationMode __item)
{
	tt__BacklightCompensationMode_ *_p = ::soap_new_tt__BacklightCompensationMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__BacklightCompensationMode_::__item = __item;
	}
	return _p;
}

inline tt__BacklightCompensationMode_ * soap_new_set_tt__BacklightCompensationMode_(
	struct soap *soap,
	enum tt__BacklightCompensationMode __item,
	char *__item__1)
{
	tt__BacklightCompensationMode_ *_p = ::soap_new_tt__BacklightCompensationMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__BacklightCompensationMode_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__BacklightCompensationMode_(struct soap *soap, tt__BacklightCompensationMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:BacklightCompensationMode", p->soap_type() == SOAP_TYPE_tt__BacklightCompensationMode_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__BacklightCompensationMode_(struct soap *soap, const char *URL, tt__BacklightCompensationMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:BacklightCompensationMode", p->soap_type() == SOAP_TYPE_tt__BacklightCompensationMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__BacklightCompensationMode_(struct soap *soap, const char *URL, tt__BacklightCompensationMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:BacklightCompensationMode", p->soap_type() == SOAP_TYPE_tt__BacklightCompensationMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__BacklightCompensationMode_(struct soap *soap, const char *URL, tt__BacklightCompensationMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:BacklightCompensationMode", p->soap_type() == SOAP_TYPE_tt__BacklightCompensationMode_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__BacklightCompensationMode_ * SOAP_FMAC4 soap_get_tt__BacklightCompensationMode_(struct soap*, tt__BacklightCompensationMode_ *, const char*, const char*);

inline int soap_read_tt__BacklightCompensationMode_(struct soap *soap, tt__BacklightCompensationMode_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__BacklightCompensationMode_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__BacklightCompensationMode_(struct soap *soap, const char *URL, tt__BacklightCompensationMode_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__BacklightCompensationMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__BacklightCompensationMode_(struct soap *soap, tt__BacklightCompensationMode_ *p)
{
	if (::soap_read_tt__BacklightCompensationMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__WideDynamicMode__DEFINED
#define SOAP_TYPE_tt__WideDynamicMode__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicMode_(struct soap*, const char*, int, const tt__WideDynamicMode_ *, const char*);
SOAP_FMAC3 tt__WideDynamicMode_ * SOAP_FMAC4 soap_in_tt__WideDynamicMode_(struct soap*, const char*, tt__WideDynamicMode_ *, const char*);
SOAP_FMAC1 tt__WideDynamicMode_ * SOAP_FMAC2 imageing_instantiate_tt__WideDynamicMode_(struct soap*, int, const char*, const char*, size_t*);

inline tt__WideDynamicMode_ * soap_new_tt__WideDynamicMode_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__WideDynamicMode_(soap, n, NULL, NULL, NULL);
}

inline tt__WideDynamicMode_ * soap_new_req_tt__WideDynamicMode_(
	struct soap *soap,
	enum tt__WideDynamicMode __item)
{
	tt__WideDynamicMode_ *_p = ::soap_new_tt__WideDynamicMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WideDynamicMode_::__item = __item;
	}
	return _p;
}

inline tt__WideDynamicMode_ * soap_new_set_tt__WideDynamicMode_(
	struct soap *soap,
	enum tt__WideDynamicMode __item,
	char *__item__1)
{
	tt__WideDynamicMode_ *_p = ::soap_new_tt__WideDynamicMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WideDynamicMode_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__WideDynamicMode_(struct soap *soap, tt__WideDynamicMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WideDynamicMode", p->soap_type() == SOAP_TYPE_tt__WideDynamicMode_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__WideDynamicMode_(struct soap *soap, const char *URL, tt__WideDynamicMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WideDynamicMode", p->soap_type() == SOAP_TYPE_tt__WideDynamicMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__WideDynamicMode_(struct soap *soap, const char *URL, tt__WideDynamicMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WideDynamicMode", p->soap_type() == SOAP_TYPE_tt__WideDynamicMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__WideDynamicMode_(struct soap *soap, const char *URL, tt__WideDynamicMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WideDynamicMode", p->soap_type() == SOAP_TYPE_tt__WideDynamicMode_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__WideDynamicMode_ * SOAP_FMAC4 soap_get_tt__WideDynamicMode_(struct soap*, tt__WideDynamicMode_ *, const char*, const char*);

inline int soap_read_tt__WideDynamicMode_(struct soap *soap, tt__WideDynamicMode_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__WideDynamicMode_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__WideDynamicMode_(struct soap *soap, const char *URL, tt__WideDynamicMode_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__WideDynamicMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__WideDynamicMode_(struct soap *soap, tt__WideDynamicMode_ *p)
{
	if (::soap_read_tt__WideDynamicMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__AutoFocusMode__DEFINED
#define SOAP_TYPE_tt__AutoFocusMode__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AutoFocusMode_(struct soap*, const char*, int, const tt__AutoFocusMode_ *, const char*);
SOAP_FMAC3 tt__AutoFocusMode_ * SOAP_FMAC4 soap_in_tt__AutoFocusMode_(struct soap*, const char*, tt__AutoFocusMode_ *, const char*);
SOAP_FMAC1 tt__AutoFocusMode_ * SOAP_FMAC2 imageing_instantiate_tt__AutoFocusMode_(struct soap*, int, const char*, const char*, size_t*);

inline tt__AutoFocusMode_ * soap_new_tt__AutoFocusMode_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__AutoFocusMode_(soap, n, NULL, NULL, NULL);
}

inline tt__AutoFocusMode_ * soap_new_req_tt__AutoFocusMode_(
	struct soap *soap,
	enum tt__AutoFocusMode __item)
{
	tt__AutoFocusMode_ *_p = ::soap_new_tt__AutoFocusMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AutoFocusMode_::__item = __item;
	}
	return _p;
}

inline tt__AutoFocusMode_ * soap_new_set_tt__AutoFocusMode_(
	struct soap *soap,
	enum tt__AutoFocusMode __item,
	char *__item__1)
{
	tt__AutoFocusMode_ *_p = ::soap_new_tt__AutoFocusMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AutoFocusMode_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__AutoFocusMode_(struct soap *soap, tt__AutoFocusMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AutoFocusMode", p->soap_type() == SOAP_TYPE_tt__AutoFocusMode_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__AutoFocusMode_(struct soap *soap, const char *URL, tt__AutoFocusMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AutoFocusMode", p->soap_type() == SOAP_TYPE_tt__AutoFocusMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__AutoFocusMode_(struct soap *soap, const char *URL, tt__AutoFocusMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AutoFocusMode", p->soap_type() == SOAP_TYPE_tt__AutoFocusMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__AutoFocusMode_(struct soap *soap, const char *URL, tt__AutoFocusMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AutoFocusMode", p->soap_type() == SOAP_TYPE_tt__AutoFocusMode_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__AutoFocusMode_ * SOAP_FMAC4 soap_get_tt__AutoFocusMode_(struct soap*, tt__AutoFocusMode_ *, const char*, const char*);

inline int soap_read_tt__AutoFocusMode_(struct soap *soap, tt__AutoFocusMode_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__AutoFocusMode_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__AutoFocusMode_(struct soap *soap, const char *URL, tt__AutoFocusMode_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__AutoFocusMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__AutoFocusMode_(struct soap *soap, tt__AutoFocusMode_ *p)
{
	if (::soap_read_tt__AutoFocusMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ReverseMode__DEFINED
#define SOAP_TYPE_tt__ReverseMode__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseMode_(struct soap*, const char*, int, const tt__ReverseMode_ *, const char*);
SOAP_FMAC3 tt__ReverseMode_ * SOAP_FMAC4 soap_in_tt__ReverseMode_(struct soap*, const char*, tt__ReverseMode_ *, const char*);
SOAP_FMAC1 tt__ReverseMode_ * SOAP_FMAC2 imageing_instantiate_tt__ReverseMode_(struct soap*, int, const char*, const char*, size_t*);

inline tt__ReverseMode_ * soap_new_tt__ReverseMode_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ReverseMode_(soap, n, NULL, NULL, NULL);
}

inline tt__ReverseMode_ * soap_new_req_tt__ReverseMode_(
	struct soap *soap,
	enum tt__ReverseMode __item)
{
	tt__ReverseMode_ *_p = ::soap_new_tt__ReverseMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ReverseMode_::__item = __item;
	}
	return _p;
}

inline tt__ReverseMode_ * soap_new_set_tt__ReverseMode_(
	struct soap *soap,
	enum tt__ReverseMode __item,
	char *__item__1)
{
	tt__ReverseMode_ *_p = ::soap_new_tt__ReverseMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ReverseMode_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ReverseMode_(struct soap *soap, tt__ReverseMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ReverseMode", p->soap_type() == SOAP_TYPE_tt__ReverseMode_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ReverseMode_(struct soap *soap, const char *URL, tt__ReverseMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ReverseMode", p->soap_type() == SOAP_TYPE_tt__ReverseMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ReverseMode_(struct soap *soap, const char *URL, tt__ReverseMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ReverseMode", p->soap_type() == SOAP_TYPE_tt__ReverseMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ReverseMode_(struct soap *soap, const char *URL, tt__ReverseMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ReverseMode", p->soap_type() == SOAP_TYPE_tt__ReverseMode_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ReverseMode_ * SOAP_FMAC4 soap_get_tt__ReverseMode_(struct soap*, tt__ReverseMode_ *, const char*, const char*);

inline int soap_read_tt__ReverseMode_(struct soap *soap, tt__ReverseMode_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ReverseMode_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ReverseMode_(struct soap *soap, const char *URL, tt__ReverseMode_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ReverseMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ReverseMode_(struct soap *soap, tt__ReverseMode_ *p)
{
	if (::soap_read_tt__ReverseMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__EFlipMode__DEFINED
#define SOAP_TYPE_tt__EFlipMode__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipMode_(struct soap*, const char*, int, const tt__EFlipMode_ *, const char*);
SOAP_FMAC3 tt__EFlipMode_ * SOAP_FMAC4 soap_in_tt__EFlipMode_(struct soap*, const char*, tt__EFlipMode_ *, const char*);
SOAP_FMAC1 tt__EFlipMode_ * SOAP_FMAC2 imageing_instantiate_tt__EFlipMode_(struct soap*, int, const char*, const char*, size_t*);

inline tt__EFlipMode_ * soap_new_tt__EFlipMode_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__EFlipMode_(soap, n, NULL, NULL, NULL);
}

inline tt__EFlipMode_ * soap_new_req_tt__EFlipMode_(
	struct soap *soap,
	enum tt__EFlipMode __item)
{
	tt__EFlipMode_ *_p = ::soap_new_tt__EFlipMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__EFlipMode_::__item = __item;
	}
	return _p;
}

inline tt__EFlipMode_ * soap_new_set_tt__EFlipMode_(
	struct soap *soap,
	enum tt__EFlipMode __item,
	char *__item__1)
{
	tt__EFlipMode_ *_p = ::soap_new_tt__EFlipMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__EFlipMode_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__EFlipMode_(struct soap *soap, tt__EFlipMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EFlipMode", p->soap_type() == SOAP_TYPE_tt__EFlipMode_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__EFlipMode_(struct soap *soap, const char *URL, tt__EFlipMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EFlipMode", p->soap_type() == SOAP_TYPE_tt__EFlipMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__EFlipMode_(struct soap *soap, const char *URL, tt__EFlipMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EFlipMode", p->soap_type() == SOAP_TYPE_tt__EFlipMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__EFlipMode_(struct soap *soap, const char *URL, tt__EFlipMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EFlipMode", p->soap_type() == SOAP_TYPE_tt__EFlipMode_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__EFlipMode_ * SOAP_FMAC4 soap_get_tt__EFlipMode_(struct soap*, tt__EFlipMode_ *, const char*, const char*);

inline int soap_read_tt__EFlipMode_(struct soap *soap, tt__EFlipMode_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__EFlipMode_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__EFlipMode_(struct soap *soap, const char *URL, tt__EFlipMode_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__EFlipMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__EFlipMode_(struct soap *soap, tt__EFlipMode_ *p)
{
	if (::soap_read_tt__EFlipMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IPType__DEFINED
#define SOAP_TYPE_tt__IPType__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPType_(struct soap*, const char*, int, const tt__IPType_ *, const char*);
SOAP_FMAC3 tt__IPType_ * SOAP_FMAC4 soap_in_tt__IPType_(struct soap*, const char*, tt__IPType_ *, const char*);
SOAP_FMAC1 tt__IPType_ * SOAP_FMAC2 imageing_instantiate_tt__IPType_(struct soap*, int, const char*, const char*, size_t*);

inline tt__IPType_ * soap_new_tt__IPType_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__IPType_(soap, n, NULL, NULL, NULL);
}

inline tt__IPType_ * soap_new_req_tt__IPType_(
	struct soap *soap,
	enum tt__IPType __item)
{
	tt__IPType_ *_p = ::soap_new_tt__IPType_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IPType_::__item = __item;
	}
	return _p;
}

inline tt__IPType_ * soap_new_set_tt__IPType_(
	struct soap *soap,
	enum tt__IPType __item,
	char *__item__1)
{
	tt__IPType_ *_p = ::soap_new_tt__IPType_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IPType_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__IPType_(struct soap *soap, tt__IPType_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPType", p->soap_type() == SOAP_TYPE_tt__IPType_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__IPType_(struct soap *soap, const char *URL, tt__IPType_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPType", p->soap_type() == SOAP_TYPE_tt__IPType_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IPType_(struct soap *soap, const char *URL, tt__IPType_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPType", p->soap_type() == SOAP_TYPE_tt__IPType_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IPType_(struct soap *soap, const char *URL, tt__IPType_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPType", p->soap_type() == SOAP_TYPE_tt__IPType_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__IPType_ * SOAP_FMAC4 soap_get_tt__IPType_(struct soap*, tt__IPType_ *, const char*, const char*);

inline int soap_read_tt__IPType_(struct soap *soap, tt__IPType_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__IPType_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IPType_(struct soap *soap, const char *URL, tt__IPType_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IPType_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IPType_(struct soap *soap, tt__IPType_ *p)
{
	if (::soap_read_tt__IPType_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IPv6Address___DEFINED
#define SOAP_TYPE_tt__IPv6Address___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6Address__(struct soap*, const char*, int, const tt__IPv6Address__ *, const char*);
SOAP_FMAC3 tt__IPv6Address__ * SOAP_FMAC4 soap_in_tt__IPv6Address__(struct soap*, const char*, tt__IPv6Address__ *, const char*);
SOAP_FMAC1 tt__IPv6Address__ * SOAP_FMAC2 imageing_instantiate_tt__IPv6Address__(struct soap*, int, const char*, const char*, size_t*);

inline tt__IPv6Address__ * soap_new_tt__IPv6Address__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__IPv6Address__(soap, n, NULL, NULL, NULL);
}

inline tt__IPv6Address__ * soap_new_req_tt__IPv6Address__(
	struct soap *soap,
	const std::string& __item)
{
	tt__IPv6Address__ *_p = ::soap_new_tt__IPv6Address__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IPv6Address__::__item = __item;
	}
	return _p;
}

inline tt__IPv6Address__ * soap_new_set_tt__IPv6Address__(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	tt__IPv6Address__ *_p = ::soap_new_tt__IPv6Address__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IPv6Address__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__IPv6Address__(struct soap *soap, tt__IPv6Address__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPv6Address", p->soap_type() == SOAP_TYPE_tt__IPv6Address__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__IPv6Address__(struct soap *soap, const char *URL, tt__IPv6Address__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPv6Address", p->soap_type() == SOAP_TYPE_tt__IPv6Address__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IPv6Address__(struct soap *soap, const char *URL, tt__IPv6Address__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPv6Address", p->soap_type() == SOAP_TYPE_tt__IPv6Address__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IPv6Address__(struct soap *soap, const char *URL, tt__IPv6Address__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPv6Address", p->soap_type() == SOAP_TYPE_tt__IPv6Address__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__IPv6Address__ * SOAP_FMAC4 soap_get_tt__IPv6Address__(struct soap*, tt__IPv6Address__ *, const char*, const char*);

inline int soap_read_tt__IPv6Address__(struct soap *soap, tt__IPv6Address__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__IPv6Address__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IPv6Address__(struct soap *soap, const char *URL, tt__IPv6Address__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IPv6Address__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IPv6Address__(struct soap *soap, tt__IPv6Address__ *p)
{
	if (::soap_read_tt__IPv6Address__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif
/* tt__IPv6Address is a typedef synonym of xsd__token */

#ifndef SOAP_TYPE_tt__IPv6Address_DEFINED
#define SOAP_TYPE_tt__IPv6Address_DEFINED

#define soap_default_tt__IPv6Address soap_default_xsd__token


#define soap_serialize_tt__IPv6Address soap_serialize_xsd__token


#define soap_tt__IPv6Address2s(soap, a) ((a).c_str())

#define soap_out_tt__IPv6Address soap_out_xsd__token


#define soap_s2tt__IPv6Address(soap, s, a) soap_s2stdchar((soap), (s), (a), 5, 0, -1, NULL)

#define soap_in_tt__IPv6Address soap_in_xsd__token


#define imageing_instantiate_tt__IPv6Address imageing_instantiate_xsd__token


#define soap_new_tt__IPv6Address soap_new_xsd__token


#define soap_put_tt__IPv6Address soap_put_xsd__token


#define soap_write_tt__IPv6Address soap_write_xsd__token


#define soap_PUT_tt__IPv6Address soap_PUT_xsd__token


#define soap_PATCH_tt__IPv6Address soap_PATCH_xsd__token


#define soap_POST_send_tt__IPv6Address soap_POST_send_xsd__token


#define soap_get_tt__IPv6Address soap_get_xsd__token


#define soap_read_tt__IPv6Address soap_read_xsd__token


#define soap_GET_tt__IPv6Address soap_GET_xsd__token


#define soap_POST_recv_tt__IPv6Address soap_POST_recv_xsd__token

#endif

#ifndef SOAP_TYPE_tt__IPv4Address___DEFINED
#define SOAP_TYPE_tt__IPv4Address___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4Address__(struct soap*, const char*, int, const tt__IPv4Address__ *, const char*);
SOAP_FMAC3 tt__IPv4Address__ * SOAP_FMAC4 soap_in_tt__IPv4Address__(struct soap*, const char*, tt__IPv4Address__ *, const char*);
SOAP_FMAC1 tt__IPv4Address__ * SOAP_FMAC2 imageing_instantiate_tt__IPv4Address__(struct soap*, int, const char*, const char*, size_t*);

inline tt__IPv4Address__ * soap_new_tt__IPv4Address__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__IPv4Address__(soap, n, NULL, NULL, NULL);
}

inline tt__IPv4Address__ * soap_new_req_tt__IPv4Address__(
	struct soap *soap,
	const std::string& __item)
{
	tt__IPv4Address__ *_p = ::soap_new_tt__IPv4Address__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IPv4Address__::__item = __item;
	}
	return _p;
}

inline tt__IPv4Address__ * soap_new_set_tt__IPv4Address__(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	tt__IPv4Address__ *_p = ::soap_new_tt__IPv4Address__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IPv4Address__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__IPv4Address__(struct soap *soap, tt__IPv4Address__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPv4Address", p->soap_type() == SOAP_TYPE_tt__IPv4Address__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__IPv4Address__(struct soap *soap, const char *URL, tt__IPv4Address__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPv4Address", p->soap_type() == SOAP_TYPE_tt__IPv4Address__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IPv4Address__(struct soap *soap, const char *URL, tt__IPv4Address__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPv4Address", p->soap_type() == SOAP_TYPE_tt__IPv4Address__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IPv4Address__(struct soap *soap, const char *URL, tt__IPv4Address__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPv4Address", p->soap_type() == SOAP_TYPE_tt__IPv4Address__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__IPv4Address__ * SOAP_FMAC4 soap_get_tt__IPv4Address__(struct soap*, tt__IPv4Address__ *, const char*, const char*);

inline int soap_read_tt__IPv4Address__(struct soap *soap, tt__IPv4Address__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__IPv4Address__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IPv4Address__(struct soap *soap, const char *URL, tt__IPv4Address__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IPv4Address__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IPv4Address__(struct soap *soap, tt__IPv4Address__ *p)
{
	if (::soap_read_tt__IPv4Address__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif
/* tt__IPv4Address is a typedef synonym of xsd__token */

#ifndef SOAP_TYPE_tt__IPv4Address_DEFINED
#define SOAP_TYPE_tt__IPv4Address_DEFINED

#define soap_default_tt__IPv4Address soap_default_xsd__token


#define soap_serialize_tt__IPv4Address soap_serialize_xsd__token


#define soap_tt__IPv4Address2s(soap, a) ((a).c_str())

#define soap_out_tt__IPv4Address soap_out_xsd__token


#define soap_s2tt__IPv4Address(soap, s, a) soap_s2stdchar((soap), (s), (a), 5, 0, -1, NULL)

#define soap_in_tt__IPv4Address soap_in_xsd__token


#define imageing_instantiate_tt__IPv4Address imageing_instantiate_xsd__token


#define soap_new_tt__IPv4Address soap_new_xsd__token


#define soap_put_tt__IPv4Address soap_put_xsd__token


#define soap_write_tt__IPv4Address soap_write_xsd__token


#define soap_PUT_tt__IPv4Address soap_PUT_xsd__token


#define soap_PATCH_tt__IPv4Address soap_PATCH_xsd__token


#define soap_POST_send_tt__IPv4Address soap_POST_send_xsd__token


#define soap_get_tt__IPv4Address soap_get_xsd__token


#define soap_read_tt__IPv4Address soap_read_xsd__token


#define soap_GET_tt__IPv4Address soap_GET_xsd__token


#define soap_POST_recv_tt__IPv4Address soap_POST_recv_xsd__token

#endif

#ifndef SOAP_TYPE_tt__AudioEncoding__DEFINED
#define SOAP_TYPE_tt__AudioEncoding__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoding_(struct soap*, const char*, int, const tt__AudioEncoding_ *, const char*);
SOAP_FMAC3 tt__AudioEncoding_ * SOAP_FMAC4 soap_in_tt__AudioEncoding_(struct soap*, const char*, tt__AudioEncoding_ *, const char*);
SOAP_FMAC1 tt__AudioEncoding_ * SOAP_FMAC2 imageing_instantiate_tt__AudioEncoding_(struct soap*, int, const char*, const char*, size_t*);

inline tt__AudioEncoding_ * soap_new_tt__AudioEncoding_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__AudioEncoding_(soap, n, NULL, NULL, NULL);
}

inline tt__AudioEncoding_ * soap_new_req_tt__AudioEncoding_(
	struct soap *soap,
	enum tt__AudioEncoding __item)
{
	tt__AudioEncoding_ *_p = ::soap_new_tt__AudioEncoding_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AudioEncoding_::__item = __item;
	}
	return _p;
}

inline tt__AudioEncoding_ * soap_new_set_tt__AudioEncoding_(
	struct soap *soap,
	enum tt__AudioEncoding __item,
	char *__item__1)
{
	tt__AudioEncoding_ *_p = ::soap_new_tt__AudioEncoding_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AudioEncoding_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__AudioEncoding_(struct soap *soap, tt__AudioEncoding_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioEncoding", p->soap_type() == SOAP_TYPE_tt__AudioEncoding_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__AudioEncoding_(struct soap *soap, const char *URL, tt__AudioEncoding_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioEncoding", p->soap_type() == SOAP_TYPE_tt__AudioEncoding_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__AudioEncoding_(struct soap *soap, const char *URL, tt__AudioEncoding_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioEncoding", p->soap_type() == SOAP_TYPE_tt__AudioEncoding_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__AudioEncoding_(struct soap *soap, const char *URL, tt__AudioEncoding_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioEncoding", p->soap_type() == SOAP_TYPE_tt__AudioEncoding_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__AudioEncoding_ * SOAP_FMAC4 soap_get_tt__AudioEncoding_(struct soap*, tt__AudioEncoding_ *, const char*, const char*);

inline int soap_read_tt__AudioEncoding_(struct soap *soap, tt__AudioEncoding_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__AudioEncoding_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__AudioEncoding_(struct soap *soap, const char *URL, tt__AudioEncoding_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__AudioEncoding_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__AudioEncoding_(struct soap *soap, tt__AudioEncoding_ *p)
{
	if (::soap_read_tt__AudioEncoding_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__H264Profile__DEFINED
#define SOAP_TYPE_tt__H264Profile__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Profile_(struct soap*, const char*, int, const tt__H264Profile_ *, const char*);
SOAP_FMAC3 tt__H264Profile_ * SOAP_FMAC4 soap_in_tt__H264Profile_(struct soap*, const char*, tt__H264Profile_ *, const char*);
SOAP_FMAC1 tt__H264Profile_ * SOAP_FMAC2 imageing_instantiate_tt__H264Profile_(struct soap*, int, const char*, const char*, size_t*);

inline tt__H264Profile_ * soap_new_tt__H264Profile_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__H264Profile_(soap, n, NULL, NULL, NULL);
}

inline tt__H264Profile_ * soap_new_req_tt__H264Profile_(
	struct soap *soap,
	enum tt__H264Profile __item)
{
	tt__H264Profile_ *_p = ::soap_new_tt__H264Profile_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__H264Profile_::__item = __item;
	}
	return _p;
}

inline tt__H264Profile_ * soap_new_set_tt__H264Profile_(
	struct soap *soap,
	enum tt__H264Profile __item,
	char *__item__1)
{
	tt__H264Profile_ *_p = ::soap_new_tt__H264Profile_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__H264Profile_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__H264Profile_(struct soap *soap, tt__H264Profile_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:H264Profile", p->soap_type() == SOAP_TYPE_tt__H264Profile_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__H264Profile_(struct soap *soap, const char *URL, tt__H264Profile_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:H264Profile", p->soap_type() == SOAP_TYPE_tt__H264Profile_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__H264Profile_(struct soap *soap, const char *URL, tt__H264Profile_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:H264Profile", p->soap_type() == SOAP_TYPE_tt__H264Profile_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__H264Profile_(struct soap *soap, const char *URL, tt__H264Profile_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:H264Profile", p->soap_type() == SOAP_TYPE_tt__H264Profile_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__H264Profile_ * SOAP_FMAC4 soap_get_tt__H264Profile_(struct soap*, tt__H264Profile_ *, const char*, const char*);

inline int soap_read_tt__H264Profile_(struct soap *soap, tt__H264Profile_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__H264Profile_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__H264Profile_(struct soap *soap, const char *URL, tt__H264Profile_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__H264Profile_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__H264Profile_(struct soap *soap, tt__H264Profile_ *p)
{
	if (::soap_read_tt__H264Profile_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Profile__DEFINED
#define SOAP_TYPE_tt__Mpeg4Profile__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Profile_(struct soap*, const char*, int, const tt__Mpeg4Profile_ *, const char*);
SOAP_FMAC3 tt__Mpeg4Profile_ * SOAP_FMAC4 soap_in_tt__Mpeg4Profile_(struct soap*, const char*, tt__Mpeg4Profile_ *, const char*);
SOAP_FMAC1 tt__Mpeg4Profile_ * SOAP_FMAC2 imageing_instantiate_tt__Mpeg4Profile_(struct soap*, int, const char*, const char*, size_t*);

inline tt__Mpeg4Profile_ * soap_new_tt__Mpeg4Profile_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Mpeg4Profile_(soap, n, NULL, NULL, NULL);
}

inline tt__Mpeg4Profile_ * soap_new_req_tt__Mpeg4Profile_(
	struct soap *soap,
	enum tt__Mpeg4Profile __item)
{
	tt__Mpeg4Profile_ *_p = ::soap_new_tt__Mpeg4Profile_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Mpeg4Profile_::__item = __item;
	}
	return _p;
}

inline tt__Mpeg4Profile_ * soap_new_set_tt__Mpeg4Profile_(
	struct soap *soap,
	enum tt__Mpeg4Profile __item,
	char *__item__1)
{
	tt__Mpeg4Profile_ *_p = ::soap_new_tt__Mpeg4Profile_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Mpeg4Profile_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Mpeg4Profile_(struct soap *soap, tt__Mpeg4Profile_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Mpeg4Profile", p->soap_type() == SOAP_TYPE_tt__Mpeg4Profile_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Mpeg4Profile_(struct soap *soap, const char *URL, tt__Mpeg4Profile_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Mpeg4Profile", p->soap_type() == SOAP_TYPE_tt__Mpeg4Profile_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Mpeg4Profile_(struct soap *soap, const char *URL, tt__Mpeg4Profile_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Mpeg4Profile", p->soap_type() == SOAP_TYPE_tt__Mpeg4Profile_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Mpeg4Profile_(struct soap *soap, const char *URL, tt__Mpeg4Profile_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Mpeg4Profile", p->soap_type() == SOAP_TYPE_tt__Mpeg4Profile_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Mpeg4Profile_ * SOAP_FMAC4 soap_get_tt__Mpeg4Profile_(struct soap*, tt__Mpeg4Profile_ *, const char*, const char*);

inline int soap_read_tt__Mpeg4Profile_(struct soap *soap, tt__Mpeg4Profile_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Mpeg4Profile_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Mpeg4Profile_(struct soap *soap, const char *URL, tt__Mpeg4Profile_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Mpeg4Profile_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Mpeg4Profile_(struct soap *soap, tt__Mpeg4Profile_ *p)
{
	if (::soap_read_tt__Mpeg4Profile_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__VideoEncoding__DEFINED
#define SOAP_TYPE_tt__VideoEncoding__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoding_(struct soap*, const char*, int, const tt__VideoEncoding_ *, const char*);
SOAP_FMAC3 tt__VideoEncoding_ * SOAP_FMAC4 soap_in_tt__VideoEncoding_(struct soap*, const char*, tt__VideoEncoding_ *, const char*);
SOAP_FMAC1 tt__VideoEncoding_ * SOAP_FMAC2 imageing_instantiate_tt__VideoEncoding_(struct soap*, int, const char*, const char*, size_t*);

inline tt__VideoEncoding_ * soap_new_tt__VideoEncoding_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__VideoEncoding_(soap, n, NULL, NULL, NULL);
}

inline tt__VideoEncoding_ * soap_new_req_tt__VideoEncoding_(
	struct soap *soap,
	enum tt__VideoEncoding __item)
{
	tt__VideoEncoding_ *_p = ::soap_new_tt__VideoEncoding_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoEncoding_::__item = __item;
	}
	return _p;
}

inline tt__VideoEncoding_ * soap_new_set_tt__VideoEncoding_(
	struct soap *soap,
	enum tt__VideoEncoding __item,
	char *__item__1)
{
	tt__VideoEncoding_ *_p = ::soap_new_tt__VideoEncoding_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoEncoding_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__VideoEncoding_(struct soap *soap, tt__VideoEncoding_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoEncoding", p->soap_type() == SOAP_TYPE_tt__VideoEncoding_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__VideoEncoding_(struct soap *soap, const char *URL, tt__VideoEncoding_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoEncoding", p->soap_type() == SOAP_TYPE_tt__VideoEncoding_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__VideoEncoding_(struct soap *soap, const char *URL, tt__VideoEncoding_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoEncoding", p->soap_type() == SOAP_TYPE_tt__VideoEncoding_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__VideoEncoding_(struct soap *soap, const char *URL, tt__VideoEncoding_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoEncoding", p->soap_type() == SOAP_TYPE_tt__VideoEncoding_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__VideoEncoding_ * SOAP_FMAC4 soap_get_tt__VideoEncoding_(struct soap*, tt__VideoEncoding_ *, const char*, const char*);

inline int soap_read_tt__VideoEncoding_(struct soap *soap, tt__VideoEncoding_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__VideoEncoding_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__VideoEncoding_(struct soap *soap, const char *URL, tt__VideoEncoding_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__VideoEncoding_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__VideoEncoding_(struct soap *soap, tt__VideoEncoding_ *p)
{
	if (::soap_read_tt__VideoEncoding_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__SceneOrientationMode__DEFINED
#define SOAP_TYPE_tt__SceneOrientationMode__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientationMode_(struct soap*, const char*, int, const tt__SceneOrientationMode_ *, const char*);
SOAP_FMAC3 tt__SceneOrientationMode_ * SOAP_FMAC4 soap_in_tt__SceneOrientationMode_(struct soap*, const char*, tt__SceneOrientationMode_ *, const char*);
SOAP_FMAC1 tt__SceneOrientationMode_ * SOAP_FMAC2 imageing_instantiate_tt__SceneOrientationMode_(struct soap*, int, const char*, const char*, size_t*);

inline tt__SceneOrientationMode_ * soap_new_tt__SceneOrientationMode_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__SceneOrientationMode_(soap, n, NULL, NULL, NULL);
}

inline tt__SceneOrientationMode_ * soap_new_req_tt__SceneOrientationMode_(
	struct soap *soap,
	enum tt__SceneOrientationMode __item)
{
	tt__SceneOrientationMode_ *_p = ::soap_new_tt__SceneOrientationMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__SceneOrientationMode_::__item = __item;
	}
	return _p;
}

inline tt__SceneOrientationMode_ * soap_new_set_tt__SceneOrientationMode_(
	struct soap *soap,
	enum tt__SceneOrientationMode __item,
	char *__item__1)
{
	tt__SceneOrientationMode_ *_p = ::soap_new_tt__SceneOrientationMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__SceneOrientationMode_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__SceneOrientationMode_(struct soap *soap, tt__SceneOrientationMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:SceneOrientationMode", p->soap_type() == SOAP_TYPE_tt__SceneOrientationMode_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__SceneOrientationMode_(struct soap *soap, const char *URL, tt__SceneOrientationMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:SceneOrientationMode", p->soap_type() == SOAP_TYPE_tt__SceneOrientationMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__SceneOrientationMode_(struct soap *soap, const char *URL, tt__SceneOrientationMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:SceneOrientationMode", p->soap_type() == SOAP_TYPE_tt__SceneOrientationMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__SceneOrientationMode_(struct soap *soap, const char *URL, tt__SceneOrientationMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:SceneOrientationMode", p->soap_type() == SOAP_TYPE_tt__SceneOrientationMode_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__SceneOrientationMode_ * SOAP_FMAC4 soap_get_tt__SceneOrientationMode_(struct soap*, tt__SceneOrientationMode_ *, const char*, const char*);

inline int soap_read_tt__SceneOrientationMode_(struct soap *soap, tt__SceneOrientationMode_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__SceneOrientationMode_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__SceneOrientationMode_(struct soap *soap, const char *URL, tt__SceneOrientationMode_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__SceneOrientationMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__SceneOrientationMode_(struct soap *soap, tt__SceneOrientationMode_ *p)
{
	if (::soap_read_tt__SceneOrientationMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__RotateMode__DEFINED
#define SOAP_TYPE_tt__RotateMode__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateMode_(struct soap*, const char*, int, const tt__RotateMode_ *, const char*);
SOAP_FMAC3 tt__RotateMode_ * SOAP_FMAC4 soap_in_tt__RotateMode_(struct soap*, const char*, tt__RotateMode_ *, const char*);
SOAP_FMAC1 tt__RotateMode_ * SOAP_FMAC2 imageing_instantiate_tt__RotateMode_(struct soap*, int, const char*, const char*, size_t*);

inline tt__RotateMode_ * soap_new_tt__RotateMode_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__RotateMode_(soap, n, NULL, NULL, NULL);
}

inline tt__RotateMode_ * soap_new_req_tt__RotateMode_(
	struct soap *soap,
	enum tt__RotateMode __item)
{
	tt__RotateMode_ *_p = ::soap_new_tt__RotateMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__RotateMode_::__item = __item;
	}
	return _p;
}

inline tt__RotateMode_ * soap_new_set_tt__RotateMode_(
	struct soap *soap,
	enum tt__RotateMode __item,
	char *__item__1)
{
	tt__RotateMode_ *_p = ::soap_new_tt__RotateMode_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__RotateMode_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__RotateMode_(struct soap *soap, tt__RotateMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RotateMode", p->soap_type() == SOAP_TYPE_tt__RotateMode_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__RotateMode_(struct soap *soap, const char *URL, tt__RotateMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RotateMode", p->soap_type() == SOAP_TYPE_tt__RotateMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__RotateMode_(struct soap *soap, const char *URL, tt__RotateMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RotateMode", p->soap_type() == SOAP_TYPE_tt__RotateMode_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__RotateMode_(struct soap *soap, const char *URL, tt__RotateMode_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RotateMode", p->soap_type() == SOAP_TYPE_tt__RotateMode_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__RotateMode_ * SOAP_FMAC4 soap_get_tt__RotateMode_(struct soap*, tt__RotateMode_ *, const char*, const char*);

inline int soap_read_tt__RotateMode_(struct soap *soap, tt__RotateMode_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__RotateMode_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__RotateMode_(struct soap *soap, const char *URL, tt__RotateMode_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__RotateMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__RotateMode_(struct soap *soap, tt__RotateMode_ *p)
{
	if (::soap_read_tt__RotateMode_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Name___DEFINED
#define SOAP_TYPE_tt__Name___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name__(struct soap*, const char*, int, const tt__Name__ *, const char*);
SOAP_FMAC3 tt__Name__ * SOAP_FMAC4 soap_in_tt__Name__(struct soap*, const char*, tt__Name__ *, const char*);
SOAP_FMAC1 tt__Name__ * SOAP_FMAC2 imageing_instantiate_tt__Name__(struct soap*, int, const char*, const char*, size_t*);

inline tt__Name__ * soap_new_tt__Name__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Name__(soap, n, NULL, NULL, NULL);
}

inline tt__Name__ * soap_new_req_tt__Name__(
	struct soap *soap,
	const std::string& __item)
{
	tt__Name__ *_p = ::soap_new_tt__Name__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Name__::__item = __item;
	}
	return _p;
}

inline tt__Name__ * soap_new_set_tt__Name__(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	tt__Name__ *_p = ::soap_new_tt__Name__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Name__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Name__(struct soap *soap, tt__Name__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Name", p->soap_type() == SOAP_TYPE_tt__Name__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Name__(struct soap *soap, const char *URL, tt__Name__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Name", p->soap_type() == SOAP_TYPE_tt__Name__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Name__(struct soap *soap, const char *URL, tt__Name__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Name", p->soap_type() == SOAP_TYPE_tt__Name__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Name__(struct soap *soap, const char *URL, tt__Name__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Name", p->soap_type() == SOAP_TYPE_tt__Name__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Name__ * SOAP_FMAC4 soap_get_tt__Name__(struct soap*, tt__Name__ *, const char*, const char*);

inline int soap_read_tt__Name__(struct soap *soap, tt__Name__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Name__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Name__(struct soap *soap, const char *URL, tt__Name__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Name__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Name__(struct soap *soap, tt__Name__ *p)
{
	if (::soap_read_tt__Name__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Name_DEFINED
#define SOAP_TYPE_tt__Name_DEFINED

inline void soap_default_tt__Name(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Name(struct soap*, const std::string *);

#define soap_tt__Name2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2tt__Name(soap, s, a) soap_s2stdchar((soap), (s), (a), 1, 0, 64, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__Name(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_tt__Name imageing_instantiate_std__string


#define soap_new_tt__Name soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Name(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_tt__Name(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__Name(soap, p, "tt:Name", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__Name(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__Name(soap, p, "tt:Name", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Name(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__Name(soap, p, "tt:Name", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Name(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__Name(soap, p, "tt:Name", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__Name(struct soap*, std::string *, const char*, const char*);

inline int soap_read_tt__Name(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__Name(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Name(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Name(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Name(struct soap *soap, std::string *p)
{
	if (::soap_read_tt__Name(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType_DEFINED
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType_DEFINED

inline void soap_default_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__AbsoluteOrRelativeTimeType(struct soap*, const std::string *);

#define soap_wsnt__AbsoluteOrRelativeTimeType2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__AbsoluteOrRelativeTimeType(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2wsnt__AbsoluteOrRelativeTimeType(soap, s, a) soap_s2stdchar((soap), (s), (a), 1, 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wsnt__AbsoluteOrRelativeTimeType(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_wsnt__AbsoluteOrRelativeTimeType imageing_instantiate_std__string


#define soap_new_wsnt__AbsoluteOrRelativeTimeType soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__AbsoluteOrRelativeTimeType(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_wsnt__AbsoluteOrRelativeTimeType(soap, p, "wsnt:AbsoluteOrRelativeTimeType", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsnt__AbsoluteOrRelativeTimeType(soap, p, "wsnt:AbsoluteOrRelativeTimeType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsnt__AbsoluteOrRelativeTimeType(soap, p, "wsnt:AbsoluteOrRelativeTimeType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsnt__AbsoluteOrRelativeTimeType(soap, p, "wsnt:AbsoluteOrRelativeTimeType", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wsnt__AbsoluteOrRelativeTimeType(struct soap*, std::string *, const char*, const char*);

inline int soap_read_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_wsnt__AbsoluteOrRelativeTimeType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__AbsoluteOrRelativeTimeType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *p)
{
	if (::soap_read_wsnt__AbsoluteOrRelativeTimeType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__StringList_DEFINED
#define SOAP_TYPE_tt__StringList_DEFINED

inline void soap_default_tt__StringList(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringList(struct soap*, const std::string *);

#define soap_tt__StringList2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringList(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2tt__StringList(soap, s, a) soap_s2stdchar((soap), (s), (a), 1, 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__StringList(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_tt__StringList imageing_instantiate_std__string


#define soap_new_tt__StringList soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringList(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_tt__StringList(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__StringList(soap, p, "tt:StringList", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__StringList(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__StringList(soap, p, "tt:StringList", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__StringList(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__StringList(soap, p, "tt:StringList", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__StringList(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__StringList(soap, p, "tt:StringList", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__StringList(struct soap*, std::string *, const char*, const char*);

inline int soap_read_tt__StringList(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__StringList(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__StringList(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__StringList(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__StringList(struct soap *soap, std::string *p)
{
	if (::soap_read_tt__StringList(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__StringAttrList_DEFINED
#define SOAP_TYPE_tt__StringAttrList_DEFINED

inline void soap_default_tt__StringAttrList(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringAttrList(struct soap*, const std::string *);

#define soap_tt__StringAttrList2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringAttrList(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2tt__StringAttrList(soap, s, a) soap_s2stdchar((soap), (s), (a), 1, 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__StringAttrList(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_tt__StringAttrList imageing_instantiate_std__string


#define soap_new_tt__StringAttrList soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringAttrList(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_tt__StringAttrList(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__StringAttrList(soap, p, "tt:StringAttrList", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__StringAttrList(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__StringAttrList(soap, p, "tt:StringAttrList", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__StringAttrList(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__StringAttrList(soap, p, "tt:StringAttrList", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__StringAttrList(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__StringAttrList(soap, p, "tt:StringAttrList", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__StringAttrList(struct soap*, std::string *, const char*, const char*);

inline int soap_read_tt__StringAttrList(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__StringAttrList(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__StringAttrList(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__StringAttrList(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__StringAttrList(struct soap *soap, std::string *p)
{
	if (::soap_read_tt__StringAttrList(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__FloatList_DEFINED
#define SOAP_TYPE_tt__FloatList_DEFINED

inline void soap_default_tt__FloatList(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatList(struct soap*, const std::string *);

#define soap_tt__FloatList2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatList(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2tt__FloatList(soap, s, a) soap_s2stdchar((soap), (s), (a), 1, 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__FloatList(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_tt__FloatList imageing_instantiate_std__string


#define soap_new_tt__FloatList soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatList(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_tt__FloatList(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__FloatList(soap, p, "tt:FloatList", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__FloatList(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__FloatList(soap, p, "tt:FloatList", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__FloatList(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__FloatList(soap, p, "tt:FloatList", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__FloatList(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__FloatList(soap, p, "tt:FloatList", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__FloatList(struct soap*, std::string *, const char*, const char*);

inline int soap_read_tt__FloatList(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__FloatList(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__FloatList(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__FloatList(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__FloatList(struct soap *soap, std::string *p)
{
	if (::soap_read_tt__FloatList(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IntList_DEFINED
#define SOAP_TYPE_tt__IntList_DEFINED

inline void soap_default_tt__IntList(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntList(struct soap*, const std::string *);

#define soap_tt__IntList2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntList(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2tt__IntList(soap, s, a) soap_s2stdchar((soap), (s), (a), 1, 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__IntList(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_tt__IntList imageing_instantiate_std__string


#define soap_new_tt__IntList soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntList(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_tt__IntList(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_tt__IntList(soap, p, "tt:IntList", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_tt__IntList(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__IntList(soap, p, "tt:IntList", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IntList(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__IntList(soap, p, "tt:IntList", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IntList(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_tt__IntList(soap, p, "tt:IntList", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__IntList(struct soap*, std::string *, const char*, const char*);

inline int soap_read_tt__IntList(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_tt__IntList(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IntList(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IntList(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IntList(struct soap *soap, std::string *p)
{
	if (::soap_read_tt__IntList(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wstop__TopicSetType_DEFINED
#define SOAP_TYPE_wstop__TopicSetType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicSetType(struct soap*, const char*, int, const wstop__TopicSetType *, const char*);
SOAP_FMAC3 wstop__TopicSetType * SOAP_FMAC4 soap_in_wstop__TopicSetType(struct soap*, const char*, wstop__TopicSetType *, const char*);
SOAP_FMAC1 wstop__TopicSetType * SOAP_FMAC2 imageing_instantiate_wstop__TopicSetType(struct soap*, int, const char*, const char*, size_t*);

inline wstop__TopicSetType * soap_new_wstop__TopicSetType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wstop__TopicSetType(soap, n, NULL, NULL, NULL);
}

inline wstop__TopicSetType * soap_new_req_wstop__TopicSetType(
	struct soap *soap)
{
	wstop__TopicSetType *_p = ::soap_new_wstop__TopicSetType(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wstop__TopicSetType * soap_new_set_wstop__TopicSetType(
	struct soap *soap,
	const std::vector<char *> & __any,
	wstop__Documentation *documentation__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wstop__TopicSetType *_p = ::soap_new_wstop__TopicSetType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wstop__TopicSetType::__any = __any;
		_p->wstop__ExtensibleDocumented::documentation = documentation__1;
		_p->wstop__ExtensibleDocumented::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wstop__TopicSetType(struct soap *soap, wstop__TopicSetType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicSetType", p->soap_type() == SOAP_TYPE_wstop__TopicSetType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wstop__TopicSetType(struct soap *soap, const char *URL, wstop__TopicSetType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicSetType", p->soap_type() == SOAP_TYPE_wstop__TopicSetType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wstop__TopicSetType(struct soap *soap, const char *URL, wstop__TopicSetType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicSetType", p->soap_type() == SOAP_TYPE_wstop__TopicSetType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wstop__TopicSetType(struct soap *soap, const char *URL, wstop__TopicSetType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicSetType", p->soap_type() == SOAP_TYPE_wstop__TopicSetType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wstop__TopicSetType * SOAP_FMAC4 soap_get_wstop__TopicSetType(struct soap*, wstop__TopicSetType *, const char*, const char*);

inline int soap_read_wstop__TopicSetType(struct soap *soap, wstop__TopicSetType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wstop__TopicSetType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wstop__TopicSetType(struct soap *soap, const char *URL, wstop__TopicSetType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wstop__TopicSetType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wstop__TopicSetType(struct soap *soap, wstop__TopicSetType *p)
{
	if (::soap_read_wstop__TopicSetType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wstop__TopicType_DEFINED
#define SOAP_TYPE_wstop__TopicType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicType(struct soap*, const char*, int, const wstop__TopicType *, const char*);
SOAP_FMAC3 wstop__TopicType * SOAP_FMAC4 soap_in_wstop__TopicType(struct soap*, const char*, wstop__TopicType *, const char*);
SOAP_FMAC1 wstop__TopicType * SOAP_FMAC2 imageing_instantiate_wstop__TopicType(struct soap*, int, const char*, const char*, size_t*);

inline wstop__TopicType * soap_new_wstop__TopicType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wstop__TopicType(soap, n, NULL, NULL, NULL);
}

inline wstop__TopicType * soap_new_req_wstop__TopicType(
	struct soap *soap,
	const std::string& name)
{
	wstop__TopicType *_p = ::soap_new_wstop__TopicType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wstop__TopicType::name = name;
	}
	return _p;
}

inline wstop__TopicType * soap_new_set_wstop__TopicType(
	struct soap *soap,
	wstop__QueryExpressionType *MessagePattern,
	const std::vector<wstop__TopicType *> & Topic,
	const std::vector<char *> & __any,
	const std::string& name,
	std::string *messageTypes,
	bool final_,
	wstop__Documentation *documentation__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wstop__TopicType *_p = ::soap_new_wstop__TopicType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wstop__TopicType::MessagePattern = MessagePattern;
		_p->wstop__TopicType::Topic = Topic;
		_p->wstop__TopicType::__any = __any;
		_p->wstop__TopicType::name = name;
		_p->wstop__TopicType::messageTypes = messageTypes;
		_p->wstop__TopicType::final_ = final_;
		_p->wstop__ExtensibleDocumented::documentation = documentation__1;
		_p->wstop__ExtensibleDocumented::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wstop__TopicType(struct soap *soap, wstop__TopicType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicType", p->soap_type() == SOAP_TYPE_wstop__TopicType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wstop__TopicType(struct soap *soap, const char *URL, wstop__TopicType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicType", p->soap_type() == SOAP_TYPE_wstop__TopicType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wstop__TopicType(struct soap *soap, const char *URL, wstop__TopicType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicType", p->soap_type() == SOAP_TYPE_wstop__TopicType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wstop__TopicType(struct soap *soap, const char *URL, wstop__TopicType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicType", p->soap_type() == SOAP_TYPE_wstop__TopicType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wstop__TopicType * SOAP_FMAC4 soap_get_wstop__TopicType(struct soap*, wstop__TopicType *, const char*, const char*);

inline int soap_read_wstop__TopicType(struct soap *soap, wstop__TopicType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wstop__TopicType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wstop__TopicType(struct soap *soap, const char *URL, wstop__TopicType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wstop__TopicType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wstop__TopicType(struct soap *soap, wstop__TopicType *p)
{
	if (::soap_read_wstop__TopicType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wstop__TopicNamespaceType_DEFINED
#define SOAP_TYPE_wstop__TopicNamespaceType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicNamespaceType(struct soap*, const char*, int, const wstop__TopicNamespaceType *, const char*);
SOAP_FMAC3 wstop__TopicNamespaceType * SOAP_FMAC4 soap_in_wstop__TopicNamespaceType(struct soap*, const char*, wstop__TopicNamespaceType *, const char*);
SOAP_FMAC1 wstop__TopicNamespaceType * SOAP_FMAC2 imageing_instantiate_wstop__TopicNamespaceType(struct soap*, int, const char*, const char*, size_t*);

inline wstop__TopicNamespaceType * soap_new_wstop__TopicNamespaceType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wstop__TopicNamespaceType(soap, n, NULL, NULL, NULL);
}

inline wstop__TopicNamespaceType * soap_new_req_wstop__TopicNamespaceType(
	struct soap *soap,
	const std::string& targetNamespace)
{
	wstop__TopicNamespaceType *_p = ::soap_new_wstop__TopicNamespaceType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wstop__TopicNamespaceType::targetNamespace = targetNamespace;
	}
	return _p;
}

inline wstop__TopicNamespaceType * soap_new_set_wstop__TopicNamespaceType(
	struct soap *soap,
	const std::vector<_wstop__TopicNamespaceType_Topic> & Topic,
	const std::vector<char *> & __any,
	std::string *name,
	const std::string& targetNamespace,
	bool final_,
	wstop__Documentation *documentation__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wstop__TopicNamespaceType *_p = ::soap_new_wstop__TopicNamespaceType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wstop__TopicNamespaceType::Topic = Topic;
		_p->wstop__TopicNamespaceType::__any = __any;
		_p->wstop__TopicNamespaceType::name = name;
		_p->wstop__TopicNamespaceType::targetNamespace = targetNamespace;
		_p->wstop__TopicNamespaceType::final_ = final_;
		_p->wstop__ExtensibleDocumented::documentation = documentation__1;
		_p->wstop__ExtensibleDocumented::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wstop__TopicNamespaceType(struct soap *soap, wstop__TopicNamespaceType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicNamespaceType", p->soap_type() == SOAP_TYPE_wstop__TopicNamespaceType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wstop__TopicNamespaceType(struct soap *soap, const char *URL, wstop__TopicNamespaceType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicNamespaceType", p->soap_type() == SOAP_TYPE_wstop__TopicNamespaceType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wstop__TopicNamespaceType(struct soap *soap, const char *URL, wstop__TopicNamespaceType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicNamespaceType", p->soap_type() == SOAP_TYPE_wstop__TopicNamespaceType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wstop__TopicNamespaceType(struct soap *soap, const char *URL, wstop__TopicNamespaceType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:TopicNamespaceType", p->soap_type() == SOAP_TYPE_wstop__TopicNamespaceType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wstop__TopicNamespaceType * SOAP_FMAC4 soap_get_wstop__TopicNamespaceType(struct soap*, wstop__TopicNamespaceType *, const char*, const char*);

inline int soap_read_wstop__TopicNamespaceType(struct soap *soap, wstop__TopicNamespaceType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wstop__TopicNamespaceType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wstop__TopicNamespaceType(struct soap *soap, const char *URL, wstop__TopicNamespaceType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wstop__TopicNamespaceType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wstop__TopicNamespaceType(struct soap *soap, wstop__TopicNamespaceType *p)
{
	if (::soap_read_wstop__TopicNamespaceType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wstop__QueryExpressionType_DEFINED
#define SOAP_TYPE_wstop__QueryExpressionType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__QueryExpressionType(struct soap*, const char*, int, const wstop__QueryExpressionType *, const char*);
SOAP_FMAC3 wstop__QueryExpressionType * SOAP_FMAC4 soap_in_wstop__QueryExpressionType(struct soap*, const char*, wstop__QueryExpressionType *, const char*);
SOAP_FMAC1 wstop__QueryExpressionType * SOAP_FMAC2 imageing_instantiate_wstop__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);

inline wstop__QueryExpressionType * soap_new_wstop__QueryExpressionType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wstop__QueryExpressionType(soap, n, NULL, NULL, NULL);
}

inline wstop__QueryExpressionType * soap_new_req_wstop__QueryExpressionType(
	struct soap *soap,
	const std::string& Dialect)
{
	wstop__QueryExpressionType *_p = ::soap_new_wstop__QueryExpressionType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wstop__QueryExpressionType::Dialect = Dialect;
	}
	return _p;
}

inline wstop__QueryExpressionType * soap_new_set_wstop__QueryExpressionType(
	struct soap *soap,
	char *__any,
	const std::string& Dialect,
	char *__mixed,
	char *__item__1)
{
	wstop__QueryExpressionType *_p = ::soap_new_wstop__QueryExpressionType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wstop__QueryExpressionType::__any = __any;
		_p->wstop__QueryExpressionType::Dialect = Dialect;
		_p->wstop__QueryExpressionType::__mixed = __mixed;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_wstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:QueryExpressionType", p->soap_type() == SOAP_TYPE_wstop__QueryExpressionType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wstop__QueryExpressionType(struct soap *soap, const char *URL, wstop__QueryExpressionType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:QueryExpressionType", p->soap_type() == SOAP_TYPE_wstop__QueryExpressionType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wstop__QueryExpressionType(struct soap *soap, const char *URL, wstop__QueryExpressionType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:QueryExpressionType", p->soap_type() == SOAP_TYPE_wstop__QueryExpressionType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wstop__QueryExpressionType(struct soap *soap, const char *URL, wstop__QueryExpressionType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:QueryExpressionType", p->soap_type() == SOAP_TYPE_wstop__QueryExpressionType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wstop__QueryExpressionType * SOAP_FMAC4 soap_get_wstop__QueryExpressionType(struct soap*, wstop__QueryExpressionType *, const char*, const char*);

inline int soap_read_wstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wstop__QueryExpressionType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wstop__QueryExpressionType(struct soap *soap, const char *URL, wstop__QueryExpressionType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wstop__QueryExpressionType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *p)
{
	if (::soap_read_wstop__QueryExpressionType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wstop__ExtensibleDocumented_DEFINED
#define SOAP_TYPE_wstop__ExtensibleDocumented_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ExtensibleDocumented(struct soap*, const char*, int, const wstop__ExtensibleDocumented *, const char*);
SOAP_FMAC3 wstop__ExtensibleDocumented * SOAP_FMAC4 soap_in_wstop__ExtensibleDocumented(struct soap*, const char*, wstop__ExtensibleDocumented *, const char*);
SOAP_FMAC1 wstop__ExtensibleDocumented * SOAP_FMAC2 imageing_instantiate_wstop__ExtensibleDocumented(struct soap*, int, const char*, const char*, size_t*);

inline wstop__ExtensibleDocumented * soap_new_wstop__ExtensibleDocumented(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wstop__ExtensibleDocumented(soap, n, NULL, NULL, NULL);
}

inline wstop__ExtensibleDocumented * soap_new_req_wstop__ExtensibleDocumented(
	struct soap *soap)
{
	wstop__ExtensibleDocumented *_p = ::soap_new_wstop__ExtensibleDocumented(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wstop__ExtensibleDocumented * soap_new_set_wstop__ExtensibleDocumented(
	struct soap *soap,
	wstop__Documentation *documentation,
	char *__anyAttribute,
	char *__item__1)
{
	wstop__ExtensibleDocumented *_p = ::soap_new_wstop__ExtensibleDocumented(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wstop__ExtensibleDocumented::documentation = documentation;
		_p->wstop__ExtensibleDocumented::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_wstop__ExtensibleDocumented(struct soap *soap, wstop__ExtensibleDocumented const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:ExtensibleDocumented", p->soap_type() == SOAP_TYPE_wstop__ExtensibleDocumented ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wstop__ExtensibleDocumented(struct soap *soap, const char *URL, wstop__ExtensibleDocumented const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:ExtensibleDocumented", p->soap_type() == SOAP_TYPE_wstop__ExtensibleDocumented ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wstop__ExtensibleDocumented(struct soap *soap, const char *URL, wstop__ExtensibleDocumented const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:ExtensibleDocumented", p->soap_type() == SOAP_TYPE_wstop__ExtensibleDocumented ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wstop__ExtensibleDocumented(struct soap *soap, const char *URL, wstop__ExtensibleDocumented const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:ExtensibleDocumented", p->soap_type() == SOAP_TYPE_wstop__ExtensibleDocumented ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wstop__ExtensibleDocumented * SOAP_FMAC4 soap_get_wstop__ExtensibleDocumented(struct soap*, wstop__ExtensibleDocumented *, const char*, const char*);

inline int soap_read_wstop__ExtensibleDocumented(struct soap *soap, wstop__ExtensibleDocumented *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wstop__ExtensibleDocumented(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wstop__ExtensibleDocumented(struct soap *soap, const char *URL, wstop__ExtensibleDocumented *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wstop__ExtensibleDocumented(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wstop__ExtensibleDocumented(struct soap *soap, wstop__ExtensibleDocumented *p)
{
	if (::soap_read_wstop__ExtensibleDocumented(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wstop__Documentation_DEFINED
#define SOAP_TYPE_wstop__Documentation_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__Documentation(struct soap*, const char*, int, const wstop__Documentation *, const char*);
SOAP_FMAC3 wstop__Documentation * SOAP_FMAC4 soap_in_wstop__Documentation(struct soap*, const char*, wstop__Documentation *, const char*);
SOAP_FMAC1 wstop__Documentation * SOAP_FMAC2 imageing_instantiate_wstop__Documentation(struct soap*, int, const char*, const char*, size_t*);

inline wstop__Documentation * soap_new_wstop__Documentation(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wstop__Documentation(soap, n, NULL, NULL, NULL);
}

inline wstop__Documentation * soap_new_req_wstop__Documentation(
	struct soap *soap)
{
	wstop__Documentation *_p = ::soap_new_wstop__Documentation(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wstop__Documentation * soap_new_set_wstop__Documentation(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__mixed,
	char *__item__1)
{
	wstop__Documentation *_p = ::soap_new_wstop__Documentation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wstop__Documentation::__any = __any;
		_p->wstop__Documentation::__mixed = __mixed;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_wstop__Documentation(struct soap *soap, wstop__Documentation const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:Documentation", p->soap_type() == SOAP_TYPE_wstop__Documentation ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wstop__Documentation(struct soap *soap, const char *URL, wstop__Documentation const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:Documentation", p->soap_type() == SOAP_TYPE_wstop__Documentation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wstop__Documentation(struct soap *soap, const char *URL, wstop__Documentation const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:Documentation", p->soap_type() == SOAP_TYPE_wstop__Documentation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wstop__Documentation(struct soap *soap, const char *URL, wstop__Documentation const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wstop:Documentation", p->soap_type() == SOAP_TYPE_wstop__Documentation ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wstop__Documentation * SOAP_FMAC4 soap_get_wstop__Documentation(struct soap*, wstop__Documentation *, const char*, const char*);

inline int soap_read_wstop__Documentation(struct soap *soap, wstop__Documentation *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wstop__Documentation(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wstop__Documentation(struct soap *soap, const char *URL, wstop__Documentation *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wstop__Documentation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wstop__Documentation(struct soap *soap, wstop__Documentation *p)
{
	if (::soap_read_wstop__Documentation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsrfbf__BaseFaultType_DEFINED
#define SOAP_TYPE_wsrfbf__BaseFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfbf__BaseFaultType(struct soap*, const char*, int, const wsrfbf__BaseFaultType *, const char*);
SOAP_FMAC3 wsrfbf__BaseFaultType * SOAP_FMAC4 soap_in_wsrfbf__BaseFaultType(struct soap*, const char*, wsrfbf__BaseFaultType *, const char*);
SOAP_FMAC1 wsrfbf__BaseFaultType * SOAP_FMAC2 imageing_instantiate_wsrfbf__BaseFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsrfbf__BaseFaultType * soap_new_wsrfbf__BaseFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsrfbf__BaseFaultType(soap, n, NULL, NULL, NULL);
}

inline wsrfbf__BaseFaultType * soap_new_req_wsrfbf__BaseFaultType(
	struct soap *soap,
	time_t Timestamp)
{
	wsrfbf__BaseFaultType *_p = ::soap_new_wsrfbf__BaseFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp;
	}
	return _p;
}

inline wsrfbf__BaseFaultType * soap_new_set_wsrfbf__BaseFaultType(
	struct soap *soap,
	const std::vector<char *> & __any,
	time_t Timestamp,
	struct wsa5__EndpointReferenceType *Originator,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause,
	char *__anyAttribute,
	char *__item__1)
{
	wsrfbf__BaseFaultType *_p = ::soap_new_wsrfbf__BaseFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp;
		_p->wsrfbf__BaseFaultType::Originator = Originator;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode;
		_p->wsrfbf__BaseFaultType::Description = Description;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_wsrfbf__BaseFaultType(struct soap *soap, wsrfbf__BaseFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType", p->soap_type() == SOAP_TYPE_wsrfbf__BaseFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsrfbf__BaseFaultType(struct soap *soap, const char *URL, wsrfbf__BaseFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType", p->soap_type() == SOAP_TYPE_wsrfbf__BaseFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsrfbf__BaseFaultType(struct soap *soap, const char *URL, wsrfbf__BaseFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType", p->soap_type() == SOAP_TYPE_wsrfbf__BaseFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsrfbf__BaseFaultType(struct soap *soap, const char *URL, wsrfbf__BaseFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrfbf:BaseFaultType", p->soap_type() == SOAP_TYPE_wsrfbf__BaseFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsrfbf__BaseFaultType * SOAP_FMAC4 soap_get_wsrfbf__BaseFaultType(struct soap*, wsrfbf__BaseFaultType *, const char*, const char*);

inline int soap_read_wsrfbf__BaseFaultType(struct soap *soap, wsrfbf__BaseFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsrfbf__BaseFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsrfbf__BaseFaultType(struct soap *soap, const char *URL, wsrfbf__BaseFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsrfbf__BaseFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsrfbf__BaseFaultType(struct soap *soap, wsrfbf__BaseFaultType *p)
{
	if (::soap_read_wsrfbf__BaseFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse_DEFINED
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscriptionResponse(struct soap*, const char*, int, const _wsnt__ResumeSubscriptionResponse *, const char*);
SOAP_FMAC3 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__ResumeSubscriptionResponse(struct soap*, const char*, _wsnt__ResumeSubscriptionResponse *, const char*);
SOAP_FMAC1 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC2 imageing_instantiate__wsnt__ResumeSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__ResumeSubscriptionResponse * soap_new__wsnt__ResumeSubscriptionResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__ResumeSubscriptionResponse(soap, n, NULL, NULL, NULL);
}

inline _wsnt__ResumeSubscriptionResponse * soap_new_req__wsnt__ResumeSubscriptionResponse(
	struct soap *soap)
{
	_wsnt__ResumeSubscriptionResponse *_p = ::soap_new__wsnt__ResumeSubscriptionResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__ResumeSubscriptionResponse * soap_new_set__wsnt__ResumeSubscriptionResponse(
	struct soap *soap,
	const std::vector<char *> & __any)
{
	_wsnt__ResumeSubscriptionResponse *_p = ::soap_new__wsnt__ResumeSubscriptionResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__ResumeSubscriptionResponse::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__ResumeSubscriptionResponse(struct soap *soap, _wsnt__ResumeSubscriptionResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:ResumeSubscriptionResponse", p->soap_type() == SOAP_TYPE__wsnt__ResumeSubscriptionResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *URL, _wsnt__ResumeSubscriptionResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:ResumeSubscriptionResponse", p->soap_type() == SOAP_TYPE__wsnt__ResumeSubscriptionResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *URL, _wsnt__ResumeSubscriptionResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:ResumeSubscriptionResponse", p->soap_type() == SOAP_TYPE__wsnt__ResumeSubscriptionResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *URL, _wsnt__ResumeSubscriptionResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:ResumeSubscriptionResponse", p->soap_type() == SOAP_TYPE__wsnt__ResumeSubscriptionResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__ResumeSubscriptionResponse(struct soap*, _wsnt__ResumeSubscriptionResponse *, const char*, const char*);

inline int soap_read__wsnt__ResumeSubscriptionResponse(struct soap *soap, _wsnt__ResumeSubscriptionResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__ResumeSubscriptionResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *URL, _wsnt__ResumeSubscriptionResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__ResumeSubscriptionResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__ResumeSubscriptionResponse(struct soap *soap, _wsnt__ResumeSubscriptionResponse *p)
{
	if (::soap_read__wsnt__ResumeSubscriptionResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__ResumeSubscription_DEFINED
#define SOAP_TYPE__wsnt__ResumeSubscription_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscription(struct soap*, const char*, int, const _wsnt__ResumeSubscription *, const char*);
SOAP_FMAC3 _wsnt__ResumeSubscription * SOAP_FMAC4 soap_in__wsnt__ResumeSubscription(struct soap*, const char*, _wsnt__ResumeSubscription *, const char*);
SOAP_FMAC1 _wsnt__ResumeSubscription * SOAP_FMAC2 imageing_instantiate__wsnt__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__ResumeSubscription * soap_new__wsnt__ResumeSubscription(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__ResumeSubscription(soap, n, NULL, NULL, NULL);
}

inline _wsnt__ResumeSubscription * soap_new_req__wsnt__ResumeSubscription(
	struct soap *soap)
{
	_wsnt__ResumeSubscription *_p = ::soap_new__wsnt__ResumeSubscription(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__ResumeSubscription * soap_new_set__wsnt__ResumeSubscription(
	struct soap *soap,
	const std::vector<char *> & __any)
{
	_wsnt__ResumeSubscription *_p = ::soap_new__wsnt__ResumeSubscription(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__ResumeSubscription::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__ResumeSubscription(struct soap *soap, _wsnt__ResumeSubscription const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:ResumeSubscription", p->soap_type() == SOAP_TYPE__wsnt__ResumeSubscription ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__ResumeSubscription(struct soap *soap, const char *URL, _wsnt__ResumeSubscription const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:ResumeSubscription", p->soap_type() == SOAP_TYPE__wsnt__ResumeSubscription ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__ResumeSubscription(struct soap *soap, const char *URL, _wsnt__ResumeSubscription const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:ResumeSubscription", p->soap_type() == SOAP_TYPE__wsnt__ResumeSubscription ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__ResumeSubscription(struct soap *soap, const char *URL, _wsnt__ResumeSubscription const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:ResumeSubscription", p->soap_type() == SOAP_TYPE__wsnt__ResumeSubscription ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__ResumeSubscription * SOAP_FMAC4 soap_get__wsnt__ResumeSubscription(struct soap*, _wsnt__ResumeSubscription *, const char*, const char*);

inline int soap_read__wsnt__ResumeSubscription(struct soap *soap, _wsnt__ResumeSubscription *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__ResumeSubscription(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__ResumeSubscription(struct soap *soap, const char *URL, _wsnt__ResumeSubscription *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__ResumeSubscription(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__ResumeSubscription(struct soap *soap, _wsnt__ResumeSubscription *p)
{
	if (::soap_read__wsnt__ResumeSubscription(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse_DEFINED
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscriptionResponse(struct soap*, const char*, int, const _wsnt__PauseSubscriptionResponse *, const char*);
SOAP_FMAC3 _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__PauseSubscriptionResponse(struct soap*, const char*, _wsnt__PauseSubscriptionResponse *, const char*);
SOAP_FMAC1 _wsnt__PauseSubscriptionResponse * SOAP_FMAC2 imageing_instantiate__wsnt__PauseSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__PauseSubscriptionResponse * soap_new__wsnt__PauseSubscriptionResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__PauseSubscriptionResponse(soap, n, NULL, NULL, NULL);
}

inline _wsnt__PauseSubscriptionResponse * soap_new_req__wsnt__PauseSubscriptionResponse(
	struct soap *soap)
{
	_wsnt__PauseSubscriptionResponse *_p = ::soap_new__wsnt__PauseSubscriptionResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__PauseSubscriptionResponse * soap_new_set__wsnt__PauseSubscriptionResponse(
	struct soap *soap,
	const std::vector<char *> & __any)
{
	_wsnt__PauseSubscriptionResponse *_p = ::soap_new__wsnt__PauseSubscriptionResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__PauseSubscriptionResponse::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__PauseSubscriptionResponse(struct soap *soap, _wsnt__PauseSubscriptionResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:PauseSubscriptionResponse", p->soap_type() == SOAP_TYPE__wsnt__PauseSubscriptionResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *URL, _wsnt__PauseSubscriptionResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:PauseSubscriptionResponse", p->soap_type() == SOAP_TYPE__wsnt__PauseSubscriptionResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *URL, _wsnt__PauseSubscriptionResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:PauseSubscriptionResponse", p->soap_type() == SOAP_TYPE__wsnt__PauseSubscriptionResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *URL, _wsnt__PauseSubscriptionResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:PauseSubscriptionResponse", p->soap_type() == SOAP_TYPE__wsnt__PauseSubscriptionResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__PauseSubscriptionResponse(struct soap*, _wsnt__PauseSubscriptionResponse *, const char*, const char*);

inline int soap_read__wsnt__PauseSubscriptionResponse(struct soap *soap, _wsnt__PauseSubscriptionResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__PauseSubscriptionResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *URL, _wsnt__PauseSubscriptionResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__PauseSubscriptionResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__PauseSubscriptionResponse(struct soap *soap, _wsnt__PauseSubscriptionResponse *p)
{
	if (::soap_read__wsnt__PauseSubscriptionResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__PauseSubscription_DEFINED
#define SOAP_TYPE__wsnt__PauseSubscription_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscription(struct soap*, const char*, int, const _wsnt__PauseSubscription *, const char*);
SOAP_FMAC3 _wsnt__PauseSubscription * SOAP_FMAC4 soap_in__wsnt__PauseSubscription(struct soap*, const char*, _wsnt__PauseSubscription *, const char*);
SOAP_FMAC1 _wsnt__PauseSubscription * SOAP_FMAC2 imageing_instantiate__wsnt__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__PauseSubscription * soap_new__wsnt__PauseSubscription(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__PauseSubscription(soap, n, NULL, NULL, NULL);
}

inline _wsnt__PauseSubscription * soap_new_req__wsnt__PauseSubscription(
	struct soap *soap)
{
	_wsnt__PauseSubscription *_p = ::soap_new__wsnt__PauseSubscription(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__PauseSubscription * soap_new_set__wsnt__PauseSubscription(
	struct soap *soap,
	const std::vector<char *> & __any)
{
	_wsnt__PauseSubscription *_p = ::soap_new__wsnt__PauseSubscription(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__PauseSubscription::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__PauseSubscription(struct soap *soap, _wsnt__PauseSubscription const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:PauseSubscription", p->soap_type() == SOAP_TYPE__wsnt__PauseSubscription ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__PauseSubscription(struct soap *soap, const char *URL, _wsnt__PauseSubscription const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:PauseSubscription", p->soap_type() == SOAP_TYPE__wsnt__PauseSubscription ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__PauseSubscription(struct soap *soap, const char *URL, _wsnt__PauseSubscription const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:PauseSubscription", p->soap_type() == SOAP_TYPE__wsnt__PauseSubscription ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__PauseSubscription(struct soap *soap, const char *URL, _wsnt__PauseSubscription const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:PauseSubscription", p->soap_type() == SOAP_TYPE__wsnt__PauseSubscription ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__PauseSubscription * SOAP_FMAC4 soap_get__wsnt__PauseSubscription(struct soap*, _wsnt__PauseSubscription *, const char*, const char*);

inline int soap_read__wsnt__PauseSubscription(struct soap *soap, _wsnt__PauseSubscription *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__PauseSubscription(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__PauseSubscription(struct soap *soap, const char *URL, _wsnt__PauseSubscription *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__PauseSubscription(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__PauseSubscription(struct soap *soap, _wsnt__PauseSubscription *p)
{
	if (::soap_read__wsnt__PauseSubscription(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse_DEFINED
#define SOAP_TYPE__wsnt__UnsubscribeResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsubscribeResponse(struct soap*, const char*, int, const _wsnt__UnsubscribeResponse *, const char*);
SOAP_FMAC3 _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_in__wsnt__UnsubscribeResponse(struct soap*, const char*, _wsnt__UnsubscribeResponse *, const char*);
SOAP_FMAC1 _wsnt__UnsubscribeResponse * SOAP_FMAC2 imageing_instantiate__wsnt__UnsubscribeResponse(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__UnsubscribeResponse * soap_new__wsnt__UnsubscribeResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__UnsubscribeResponse(soap, n, NULL, NULL, NULL);
}

inline _wsnt__UnsubscribeResponse * soap_new_req__wsnt__UnsubscribeResponse(
	struct soap *soap)
{
	_wsnt__UnsubscribeResponse *_p = ::soap_new__wsnt__UnsubscribeResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__UnsubscribeResponse * soap_new_set__wsnt__UnsubscribeResponse(
	struct soap *soap,
	const std::vector<char *> & __any)
{
	_wsnt__UnsubscribeResponse *_p = ::soap_new__wsnt__UnsubscribeResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__UnsubscribeResponse::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__UnsubscribeResponse(struct soap *soap, _wsnt__UnsubscribeResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnsubscribeResponse", p->soap_type() == SOAP_TYPE__wsnt__UnsubscribeResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__UnsubscribeResponse(struct soap *soap, const char *URL, _wsnt__UnsubscribeResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnsubscribeResponse", p->soap_type() == SOAP_TYPE__wsnt__UnsubscribeResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__UnsubscribeResponse(struct soap *soap, const char *URL, _wsnt__UnsubscribeResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnsubscribeResponse", p->soap_type() == SOAP_TYPE__wsnt__UnsubscribeResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__UnsubscribeResponse(struct soap *soap, const char *URL, _wsnt__UnsubscribeResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnsubscribeResponse", p->soap_type() == SOAP_TYPE__wsnt__UnsubscribeResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_get__wsnt__UnsubscribeResponse(struct soap*, _wsnt__UnsubscribeResponse *, const char*, const char*);

inline int soap_read__wsnt__UnsubscribeResponse(struct soap *soap, _wsnt__UnsubscribeResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__UnsubscribeResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__UnsubscribeResponse(struct soap *soap, const char *URL, _wsnt__UnsubscribeResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__UnsubscribeResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__UnsubscribeResponse(struct soap *soap, _wsnt__UnsubscribeResponse *p)
{
	if (::soap_read__wsnt__UnsubscribeResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__Unsubscribe_DEFINED
#define SOAP_TYPE__wsnt__Unsubscribe_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Unsubscribe(struct soap*, const char*, int, const _wsnt__Unsubscribe *, const char*);
SOAP_FMAC3 _wsnt__Unsubscribe * SOAP_FMAC4 soap_in__wsnt__Unsubscribe(struct soap*, const char*, _wsnt__Unsubscribe *, const char*);
SOAP_FMAC1 _wsnt__Unsubscribe * SOAP_FMAC2 imageing_instantiate__wsnt__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__Unsubscribe * soap_new__wsnt__Unsubscribe(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__Unsubscribe(soap, n, NULL, NULL, NULL);
}

inline _wsnt__Unsubscribe * soap_new_req__wsnt__Unsubscribe(
	struct soap *soap)
{
	_wsnt__Unsubscribe *_p = ::soap_new__wsnt__Unsubscribe(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__Unsubscribe * soap_new_set__wsnt__Unsubscribe(
	struct soap *soap,
	const std::vector<char *> & __any)
{
	_wsnt__Unsubscribe *_p = ::soap_new__wsnt__Unsubscribe(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__Unsubscribe::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__Unsubscribe(struct soap *soap, _wsnt__Unsubscribe const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Unsubscribe", p->soap_type() == SOAP_TYPE__wsnt__Unsubscribe ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__Unsubscribe(struct soap *soap, const char *URL, _wsnt__Unsubscribe const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Unsubscribe", p->soap_type() == SOAP_TYPE__wsnt__Unsubscribe ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__Unsubscribe(struct soap *soap, const char *URL, _wsnt__Unsubscribe const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Unsubscribe", p->soap_type() == SOAP_TYPE__wsnt__Unsubscribe ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__Unsubscribe(struct soap *soap, const char *URL, _wsnt__Unsubscribe const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Unsubscribe", p->soap_type() == SOAP_TYPE__wsnt__Unsubscribe ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__Unsubscribe * SOAP_FMAC4 soap_get__wsnt__Unsubscribe(struct soap*, _wsnt__Unsubscribe *, const char*, const char*);

inline int soap_read__wsnt__Unsubscribe(struct soap *soap, _wsnt__Unsubscribe *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__Unsubscribe(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__Unsubscribe(struct soap *soap, const char *URL, _wsnt__Unsubscribe *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__Unsubscribe(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__Unsubscribe(struct soap *soap, _wsnt__Unsubscribe *p)
{
	if (::soap_read__wsnt__Unsubscribe(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__RenewResponse_DEFINED
#define SOAP_TYPE__wsnt__RenewResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__RenewResponse(struct soap*, const char*, int, const _wsnt__RenewResponse *, const char*);
SOAP_FMAC3 _wsnt__RenewResponse * SOAP_FMAC4 soap_in__wsnt__RenewResponse(struct soap*, const char*, _wsnt__RenewResponse *, const char*);
SOAP_FMAC1 _wsnt__RenewResponse * SOAP_FMAC2 imageing_instantiate__wsnt__RenewResponse(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__RenewResponse * soap_new__wsnt__RenewResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__RenewResponse(soap, n, NULL, NULL, NULL);
}

inline _wsnt__RenewResponse * soap_new_req__wsnt__RenewResponse(
	struct soap *soap,
	time_t TerminationTime)
{
	_wsnt__RenewResponse *_p = ::soap_new__wsnt__RenewResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__RenewResponse::TerminationTime = TerminationTime;
	}
	return _p;
}

inline _wsnt__RenewResponse * soap_new_set__wsnt__RenewResponse(
	struct soap *soap,
	time_t TerminationTime,
	time_t *CurrentTime,
	const std::vector<char *> & __any)
{
	_wsnt__RenewResponse *_p = ::soap_new__wsnt__RenewResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__RenewResponse::TerminationTime = TerminationTime;
		_p->_wsnt__RenewResponse::CurrentTime = CurrentTime;
		_p->_wsnt__RenewResponse::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__RenewResponse(struct soap *soap, _wsnt__RenewResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:RenewResponse", p->soap_type() == SOAP_TYPE__wsnt__RenewResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__RenewResponse(struct soap *soap, const char *URL, _wsnt__RenewResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:RenewResponse", p->soap_type() == SOAP_TYPE__wsnt__RenewResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__RenewResponse(struct soap *soap, const char *URL, _wsnt__RenewResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:RenewResponse", p->soap_type() == SOAP_TYPE__wsnt__RenewResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__RenewResponse(struct soap *soap, const char *URL, _wsnt__RenewResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:RenewResponse", p->soap_type() == SOAP_TYPE__wsnt__RenewResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__RenewResponse * SOAP_FMAC4 soap_get__wsnt__RenewResponse(struct soap*, _wsnt__RenewResponse *, const char*, const char*);

inline int soap_read__wsnt__RenewResponse(struct soap *soap, _wsnt__RenewResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__RenewResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__RenewResponse(struct soap *soap, const char *URL, _wsnt__RenewResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__RenewResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__RenewResponse(struct soap *soap, _wsnt__RenewResponse *p)
{
	if (::soap_read__wsnt__RenewResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__Renew_DEFINED
#define SOAP_TYPE__wsnt__Renew_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Renew(struct soap*, const char*, int, const _wsnt__Renew *, const char*);
SOAP_FMAC3 _wsnt__Renew * SOAP_FMAC4 soap_in__wsnt__Renew(struct soap*, const char*, _wsnt__Renew *, const char*);
SOAP_FMAC1 _wsnt__Renew * SOAP_FMAC2 imageing_instantiate__wsnt__Renew(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__Renew * soap_new__wsnt__Renew(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__Renew(soap, n, NULL, NULL, NULL);
}

inline _wsnt__Renew * soap_new_req__wsnt__Renew(
	struct soap *soap,
	std::string *TerminationTime)
{
	_wsnt__Renew *_p = ::soap_new__wsnt__Renew(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__Renew::TerminationTime = TerminationTime;
	}
	return _p;
}

inline _wsnt__Renew * soap_new_set__wsnt__Renew(
	struct soap *soap,
	std::string *TerminationTime,
	const std::vector<char *> & __any)
{
	_wsnt__Renew *_p = ::soap_new__wsnt__Renew(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__Renew::TerminationTime = TerminationTime;
		_p->_wsnt__Renew::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__Renew(struct soap *soap, _wsnt__Renew const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Renew", p->soap_type() == SOAP_TYPE__wsnt__Renew ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__Renew(struct soap *soap, const char *URL, _wsnt__Renew const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Renew", p->soap_type() == SOAP_TYPE__wsnt__Renew ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__Renew(struct soap *soap, const char *URL, _wsnt__Renew const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Renew", p->soap_type() == SOAP_TYPE__wsnt__Renew ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__Renew(struct soap *soap, const char *URL, _wsnt__Renew const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Renew", p->soap_type() == SOAP_TYPE__wsnt__Renew ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__Renew * SOAP_FMAC4 soap_get__wsnt__Renew(struct soap*, _wsnt__Renew *, const char*, const char*);

inline int soap_read__wsnt__Renew(struct soap *soap, _wsnt__Renew *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__Renew(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__Renew(struct soap *soap, const char *URL, _wsnt__Renew *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__Renew(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__Renew(struct soap *soap, _wsnt__Renew *p)
{
	if (::soap_read__wsnt__Renew(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse_DEFINED
#define SOAP_TYPE__wsnt__CreatePullPointResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPointResponse(struct soap*, const char*, int, const _wsnt__CreatePullPointResponse *, const char*);
SOAP_FMAC3 _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_in__wsnt__CreatePullPointResponse(struct soap*, const char*, _wsnt__CreatePullPointResponse *, const char*);
SOAP_FMAC1 _wsnt__CreatePullPointResponse * SOAP_FMAC2 imageing_instantiate__wsnt__CreatePullPointResponse(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__CreatePullPointResponse * soap_new__wsnt__CreatePullPointResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__CreatePullPointResponse(soap, n, NULL, NULL, NULL);
}

inline _wsnt__CreatePullPointResponse * soap_new_req__wsnt__CreatePullPointResponse(
	struct soap *soap,
	const struct wsa5__EndpointReferenceType& PullPoint)
{
	_wsnt__CreatePullPointResponse *_p = ::soap_new__wsnt__CreatePullPointResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__CreatePullPointResponse::PullPoint = PullPoint;
	}
	return _p;
}

inline _wsnt__CreatePullPointResponse * soap_new_set__wsnt__CreatePullPointResponse(
	struct soap *soap,
	const struct wsa5__EndpointReferenceType& PullPoint,
	const std::vector<char *> & __any,
	char *__anyAttribute)
{
	_wsnt__CreatePullPointResponse *_p = ::soap_new__wsnt__CreatePullPointResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__CreatePullPointResponse::PullPoint = PullPoint;
		_p->_wsnt__CreatePullPointResponse::__any = __any;
		_p->_wsnt__CreatePullPointResponse::__anyAttribute = __anyAttribute;
	}
	return _p;
}

inline int soap_write__wsnt__CreatePullPointResponse(struct soap *soap, _wsnt__CreatePullPointResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:CreatePullPointResponse", p->soap_type() == SOAP_TYPE__wsnt__CreatePullPointResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__CreatePullPointResponse(struct soap *soap, const char *URL, _wsnt__CreatePullPointResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:CreatePullPointResponse", p->soap_type() == SOAP_TYPE__wsnt__CreatePullPointResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__CreatePullPointResponse(struct soap *soap, const char *URL, _wsnt__CreatePullPointResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:CreatePullPointResponse", p->soap_type() == SOAP_TYPE__wsnt__CreatePullPointResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__CreatePullPointResponse(struct soap *soap, const char *URL, _wsnt__CreatePullPointResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:CreatePullPointResponse", p->soap_type() == SOAP_TYPE__wsnt__CreatePullPointResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_get__wsnt__CreatePullPointResponse(struct soap*, _wsnt__CreatePullPointResponse *, const char*, const char*);

inline int soap_read__wsnt__CreatePullPointResponse(struct soap *soap, _wsnt__CreatePullPointResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__CreatePullPointResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__CreatePullPointResponse(struct soap *soap, const char *URL, _wsnt__CreatePullPointResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__CreatePullPointResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__CreatePullPointResponse(struct soap *soap, _wsnt__CreatePullPointResponse *p)
{
	if (::soap_read__wsnt__CreatePullPointResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__CreatePullPoint_DEFINED
#define SOAP_TYPE__wsnt__CreatePullPoint_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPoint(struct soap*, const char*, int, const _wsnt__CreatePullPoint *, const char*);
SOAP_FMAC3 _wsnt__CreatePullPoint * SOAP_FMAC4 soap_in__wsnt__CreatePullPoint(struct soap*, const char*, _wsnt__CreatePullPoint *, const char*);
SOAP_FMAC1 _wsnt__CreatePullPoint * SOAP_FMAC2 imageing_instantiate__wsnt__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__CreatePullPoint * soap_new__wsnt__CreatePullPoint(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__CreatePullPoint(soap, n, NULL, NULL, NULL);
}

inline _wsnt__CreatePullPoint * soap_new_req__wsnt__CreatePullPoint(
	struct soap *soap)
{
	_wsnt__CreatePullPoint *_p = ::soap_new__wsnt__CreatePullPoint(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__CreatePullPoint * soap_new_set__wsnt__CreatePullPoint(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__anyAttribute)
{
	_wsnt__CreatePullPoint *_p = ::soap_new__wsnt__CreatePullPoint(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__CreatePullPoint::__any = __any;
		_p->_wsnt__CreatePullPoint::__anyAttribute = __anyAttribute;
	}
	return _p;
}

inline int soap_write__wsnt__CreatePullPoint(struct soap *soap, _wsnt__CreatePullPoint const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:CreatePullPoint", p->soap_type() == SOAP_TYPE__wsnt__CreatePullPoint ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__CreatePullPoint(struct soap *soap, const char *URL, _wsnt__CreatePullPoint const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:CreatePullPoint", p->soap_type() == SOAP_TYPE__wsnt__CreatePullPoint ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__CreatePullPoint(struct soap *soap, const char *URL, _wsnt__CreatePullPoint const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:CreatePullPoint", p->soap_type() == SOAP_TYPE__wsnt__CreatePullPoint ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__CreatePullPoint(struct soap *soap, const char *URL, _wsnt__CreatePullPoint const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:CreatePullPoint", p->soap_type() == SOAP_TYPE__wsnt__CreatePullPoint ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__CreatePullPoint * SOAP_FMAC4 soap_get__wsnt__CreatePullPoint(struct soap*, _wsnt__CreatePullPoint *, const char*, const char*);

inline int soap_read__wsnt__CreatePullPoint(struct soap *soap, _wsnt__CreatePullPoint *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__CreatePullPoint(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__CreatePullPoint(struct soap *soap, const char *URL, _wsnt__CreatePullPoint *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__CreatePullPoint(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__CreatePullPoint(struct soap *soap, _wsnt__CreatePullPoint *p)
{
	if (::soap_read__wsnt__CreatePullPoint(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse_DEFINED
#define SOAP_TYPE__wsnt__DestroyPullPointResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPointResponse(struct soap*, const char*, int, const _wsnt__DestroyPullPointResponse *, const char*);
SOAP_FMAC3 _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_in__wsnt__DestroyPullPointResponse(struct soap*, const char*, _wsnt__DestroyPullPointResponse *, const char*);
SOAP_FMAC1 _wsnt__DestroyPullPointResponse * SOAP_FMAC2 imageing_instantiate__wsnt__DestroyPullPointResponse(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__DestroyPullPointResponse * soap_new__wsnt__DestroyPullPointResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__DestroyPullPointResponse(soap, n, NULL, NULL, NULL);
}

inline _wsnt__DestroyPullPointResponse * soap_new_req__wsnt__DestroyPullPointResponse(
	struct soap *soap)
{
	_wsnt__DestroyPullPointResponse *_p = ::soap_new__wsnt__DestroyPullPointResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__DestroyPullPointResponse * soap_new_set__wsnt__DestroyPullPointResponse(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__anyAttribute)
{
	_wsnt__DestroyPullPointResponse *_p = ::soap_new__wsnt__DestroyPullPointResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__DestroyPullPointResponse::__any = __any;
		_p->_wsnt__DestroyPullPointResponse::__anyAttribute = __anyAttribute;
	}
	return _p;
}

inline int soap_write__wsnt__DestroyPullPointResponse(struct soap *soap, _wsnt__DestroyPullPointResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:DestroyPullPointResponse", p->soap_type() == SOAP_TYPE__wsnt__DestroyPullPointResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__DestroyPullPointResponse(struct soap *soap, const char *URL, _wsnt__DestroyPullPointResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:DestroyPullPointResponse", p->soap_type() == SOAP_TYPE__wsnt__DestroyPullPointResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__DestroyPullPointResponse(struct soap *soap, const char *URL, _wsnt__DestroyPullPointResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:DestroyPullPointResponse", p->soap_type() == SOAP_TYPE__wsnt__DestroyPullPointResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__DestroyPullPointResponse(struct soap *soap, const char *URL, _wsnt__DestroyPullPointResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:DestroyPullPointResponse", p->soap_type() == SOAP_TYPE__wsnt__DestroyPullPointResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_get__wsnt__DestroyPullPointResponse(struct soap*, _wsnt__DestroyPullPointResponse *, const char*, const char*);

inline int soap_read__wsnt__DestroyPullPointResponse(struct soap *soap, _wsnt__DestroyPullPointResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__DestroyPullPointResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__DestroyPullPointResponse(struct soap *soap, const char *URL, _wsnt__DestroyPullPointResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__DestroyPullPointResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__DestroyPullPointResponse(struct soap *soap, _wsnt__DestroyPullPointResponse *p)
{
	if (::soap_read__wsnt__DestroyPullPointResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__DestroyPullPoint_DEFINED
#define SOAP_TYPE__wsnt__DestroyPullPoint_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPoint(struct soap*, const char*, int, const _wsnt__DestroyPullPoint *, const char*);
SOAP_FMAC3 _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_in__wsnt__DestroyPullPoint(struct soap*, const char*, _wsnt__DestroyPullPoint *, const char*);
SOAP_FMAC1 _wsnt__DestroyPullPoint * SOAP_FMAC2 imageing_instantiate__wsnt__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__DestroyPullPoint * soap_new__wsnt__DestroyPullPoint(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__DestroyPullPoint(soap, n, NULL, NULL, NULL);
}

inline _wsnt__DestroyPullPoint * soap_new_req__wsnt__DestroyPullPoint(
	struct soap *soap)
{
	_wsnt__DestroyPullPoint *_p = ::soap_new__wsnt__DestroyPullPoint(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__DestroyPullPoint * soap_new_set__wsnt__DestroyPullPoint(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__anyAttribute)
{
	_wsnt__DestroyPullPoint *_p = ::soap_new__wsnt__DestroyPullPoint(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__DestroyPullPoint::__any = __any;
		_p->_wsnt__DestroyPullPoint::__anyAttribute = __anyAttribute;
	}
	return _p;
}

inline int soap_write__wsnt__DestroyPullPoint(struct soap *soap, _wsnt__DestroyPullPoint const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:DestroyPullPoint", p->soap_type() == SOAP_TYPE__wsnt__DestroyPullPoint ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__DestroyPullPoint(struct soap *soap, const char *URL, _wsnt__DestroyPullPoint const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:DestroyPullPoint", p->soap_type() == SOAP_TYPE__wsnt__DestroyPullPoint ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__DestroyPullPoint(struct soap *soap, const char *URL, _wsnt__DestroyPullPoint const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:DestroyPullPoint", p->soap_type() == SOAP_TYPE__wsnt__DestroyPullPoint ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__DestroyPullPoint(struct soap *soap, const char *URL, _wsnt__DestroyPullPoint const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:DestroyPullPoint", p->soap_type() == SOAP_TYPE__wsnt__DestroyPullPoint ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_get__wsnt__DestroyPullPoint(struct soap*, _wsnt__DestroyPullPoint *, const char*, const char*);

inline int soap_read__wsnt__DestroyPullPoint(struct soap *soap, _wsnt__DestroyPullPoint *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__DestroyPullPoint(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__DestroyPullPoint(struct soap *soap, const char *URL, _wsnt__DestroyPullPoint *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__DestroyPullPoint(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__DestroyPullPoint(struct soap *soap, _wsnt__DestroyPullPoint *p)
{
	if (::soap_read__wsnt__DestroyPullPoint(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__GetMessagesResponse_DEFINED
#define SOAP_TYPE__wsnt__GetMessagesResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessagesResponse(struct soap*, const char*, int, const _wsnt__GetMessagesResponse *, const char*);
SOAP_FMAC3 _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_in__wsnt__GetMessagesResponse(struct soap*, const char*, _wsnt__GetMessagesResponse *, const char*);
SOAP_FMAC1 _wsnt__GetMessagesResponse * SOAP_FMAC2 imageing_instantiate__wsnt__GetMessagesResponse(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__GetMessagesResponse * soap_new__wsnt__GetMessagesResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__GetMessagesResponse(soap, n, NULL, NULL, NULL);
}

inline _wsnt__GetMessagesResponse * soap_new_req__wsnt__GetMessagesResponse(
	struct soap *soap)
{
	_wsnt__GetMessagesResponse *_p = ::soap_new__wsnt__GetMessagesResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__GetMessagesResponse * soap_new_set__wsnt__GetMessagesResponse(
	struct soap *soap,
	const std::vector<wsnt__NotificationMessageHolderType *> & NotificationMessage,
	const std::vector<char *> & __any,
	char *__anyAttribute)
{
	_wsnt__GetMessagesResponse *_p = ::soap_new__wsnt__GetMessagesResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__GetMessagesResponse::NotificationMessage = NotificationMessage;
		_p->_wsnt__GetMessagesResponse::__any = __any;
		_p->_wsnt__GetMessagesResponse::__anyAttribute = __anyAttribute;
	}
	return _p;
}

inline int soap_write__wsnt__GetMessagesResponse(struct soap *soap, _wsnt__GetMessagesResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetMessagesResponse", p->soap_type() == SOAP_TYPE__wsnt__GetMessagesResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__GetMessagesResponse(struct soap *soap, const char *URL, _wsnt__GetMessagesResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetMessagesResponse", p->soap_type() == SOAP_TYPE__wsnt__GetMessagesResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__GetMessagesResponse(struct soap *soap, const char *URL, _wsnt__GetMessagesResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetMessagesResponse", p->soap_type() == SOAP_TYPE__wsnt__GetMessagesResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__GetMessagesResponse(struct soap *soap, const char *URL, _wsnt__GetMessagesResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetMessagesResponse", p->soap_type() == SOAP_TYPE__wsnt__GetMessagesResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_get__wsnt__GetMessagesResponse(struct soap*, _wsnt__GetMessagesResponse *, const char*, const char*);

inline int soap_read__wsnt__GetMessagesResponse(struct soap *soap, _wsnt__GetMessagesResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__GetMessagesResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__GetMessagesResponse(struct soap *soap, const char *URL, _wsnt__GetMessagesResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__GetMessagesResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__GetMessagesResponse(struct soap *soap, _wsnt__GetMessagesResponse *p)
{
	if (::soap_read__wsnt__GetMessagesResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__GetMessages_DEFINED
#define SOAP_TYPE__wsnt__GetMessages_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessages(struct soap*, const char*, int, const _wsnt__GetMessages *, const char*);
SOAP_FMAC3 _wsnt__GetMessages * SOAP_FMAC4 soap_in__wsnt__GetMessages(struct soap*, const char*, _wsnt__GetMessages *, const char*);
SOAP_FMAC1 _wsnt__GetMessages * SOAP_FMAC2 imageing_instantiate__wsnt__GetMessages(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__GetMessages * soap_new__wsnt__GetMessages(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__GetMessages(soap, n, NULL, NULL, NULL);
}

inline _wsnt__GetMessages * soap_new_req__wsnt__GetMessages(
	struct soap *soap)
{
	_wsnt__GetMessages *_p = ::soap_new__wsnt__GetMessages(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__GetMessages * soap_new_set__wsnt__GetMessages(
	struct soap *soap,
	std::string *MaximumNumber,
	const std::vector<char *> & __any,
	char *__anyAttribute)
{
	_wsnt__GetMessages *_p = ::soap_new__wsnt__GetMessages(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__GetMessages::MaximumNumber = MaximumNumber;
		_p->_wsnt__GetMessages::__any = __any;
		_p->_wsnt__GetMessages::__anyAttribute = __anyAttribute;
	}
	return _p;
}

inline int soap_write__wsnt__GetMessages(struct soap *soap, _wsnt__GetMessages const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetMessages", p->soap_type() == SOAP_TYPE__wsnt__GetMessages ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__GetMessages(struct soap *soap, const char *URL, _wsnt__GetMessages const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetMessages", p->soap_type() == SOAP_TYPE__wsnt__GetMessages ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__GetMessages(struct soap *soap, const char *URL, _wsnt__GetMessages const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetMessages", p->soap_type() == SOAP_TYPE__wsnt__GetMessages ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__GetMessages(struct soap *soap, const char *URL, _wsnt__GetMessages const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetMessages", p->soap_type() == SOAP_TYPE__wsnt__GetMessages ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__GetMessages * SOAP_FMAC4 soap_get__wsnt__GetMessages(struct soap*, _wsnt__GetMessages *, const char*, const char*);

inline int soap_read__wsnt__GetMessages(struct soap *soap, _wsnt__GetMessages *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__GetMessages(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__GetMessages(struct soap *soap, const char *URL, _wsnt__GetMessages *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__GetMessages(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__GetMessages(struct soap *soap, _wsnt__GetMessages *p)
{
	if (::soap_read__wsnt__GetMessages(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse_DEFINED
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessageResponse(struct soap*, const char*, int, const _wsnt__GetCurrentMessageResponse *, const char*);
SOAP_FMAC3 _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessageResponse(struct soap*, const char*, _wsnt__GetCurrentMessageResponse *, const char*);
SOAP_FMAC1 _wsnt__GetCurrentMessageResponse * SOAP_FMAC2 imageing_instantiate__wsnt__GetCurrentMessageResponse(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__GetCurrentMessageResponse * soap_new__wsnt__GetCurrentMessageResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__GetCurrentMessageResponse(soap, n, NULL, NULL, NULL);
}

inline _wsnt__GetCurrentMessageResponse * soap_new_req__wsnt__GetCurrentMessageResponse(
	struct soap *soap)
{
	_wsnt__GetCurrentMessageResponse *_p = ::soap_new__wsnt__GetCurrentMessageResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__GetCurrentMessageResponse * soap_new_set__wsnt__GetCurrentMessageResponse(
	struct soap *soap,
	const std::vector<char *> & __any)
{
	_wsnt__GetCurrentMessageResponse *_p = ::soap_new__wsnt__GetCurrentMessageResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__GetCurrentMessageResponse::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__GetCurrentMessageResponse(struct soap *soap, _wsnt__GetCurrentMessageResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetCurrentMessageResponse", p->soap_type() == SOAP_TYPE__wsnt__GetCurrentMessageResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *URL, _wsnt__GetCurrentMessageResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetCurrentMessageResponse", p->soap_type() == SOAP_TYPE__wsnt__GetCurrentMessageResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *URL, _wsnt__GetCurrentMessageResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetCurrentMessageResponse", p->soap_type() == SOAP_TYPE__wsnt__GetCurrentMessageResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *URL, _wsnt__GetCurrentMessageResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetCurrentMessageResponse", p->soap_type() == SOAP_TYPE__wsnt__GetCurrentMessageResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessageResponse(struct soap*, _wsnt__GetCurrentMessageResponse *, const char*, const char*);

inline int soap_read__wsnt__GetCurrentMessageResponse(struct soap *soap, _wsnt__GetCurrentMessageResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__GetCurrentMessageResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *URL, _wsnt__GetCurrentMessageResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__GetCurrentMessageResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__GetCurrentMessageResponse(struct soap *soap, _wsnt__GetCurrentMessageResponse *p)
{
	if (::soap_read__wsnt__GetCurrentMessageResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__GetCurrentMessage_DEFINED
#define SOAP_TYPE__wsnt__GetCurrentMessage_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessage(struct soap*, const char*, int, const _wsnt__GetCurrentMessage *, const char*);
SOAP_FMAC3 _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessage(struct soap*, const char*, _wsnt__GetCurrentMessage *, const char*);
SOAP_FMAC1 _wsnt__GetCurrentMessage * SOAP_FMAC2 imageing_instantiate__wsnt__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__GetCurrentMessage * soap_new__wsnt__GetCurrentMessage(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__GetCurrentMessage(soap, n, NULL, NULL, NULL);
}

inline _wsnt__GetCurrentMessage * soap_new_req__wsnt__GetCurrentMessage(
	struct soap *soap,
	wsnt__TopicExpressionType *Topic)
{
	_wsnt__GetCurrentMessage *_p = ::soap_new__wsnt__GetCurrentMessage(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__GetCurrentMessage::Topic = Topic;
	}
	return _p;
}

inline _wsnt__GetCurrentMessage * soap_new_set__wsnt__GetCurrentMessage(
	struct soap *soap,
	wsnt__TopicExpressionType *Topic,
	const std::vector<char *> & __any)
{
	_wsnt__GetCurrentMessage *_p = ::soap_new__wsnt__GetCurrentMessage(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__GetCurrentMessage::Topic = Topic;
		_p->_wsnt__GetCurrentMessage::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__GetCurrentMessage(struct soap *soap, _wsnt__GetCurrentMessage const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetCurrentMessage", p->soap_type() == SOAP_TYPE__wsnt__GetCurrentMessage ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__GetCurrentMessage(struct soap *soap, const char *URL, _wsnt__GetCurrentMessage const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetCurrentMessage", p->soap_type() == SOAP_TYPE__wsnt__GetCurrentMessage ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__GetCurrentMessage(struct soap *soap, const char *URL, _wsnt__GetCurrentMessage const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetCurrentMessage", p->soap_type() == SOAP_TYPE__wsnt__GetCurrentMessage ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__GetCurrentMessage(struct soap *soap, const char *URL, _wsnt__GetCurrentMessage const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:GetCurrentMessage", p->soap_type() == SOAP_TYPE__wsnt__GetCurrentMessage ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessage(struct soap*, _wsnt__GetCurrentMessage *, const char*, const char*);

inline int soap_read__wsnt__GetCurrentMessage(struct soap *soap, _wsnt__GetCurrentMessage *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__GetCurrentMessage(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__GetCurrentMessage(struct soap *soap, const char *URL, _wsnt__GetCurrentMessage *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__GetCurrentMessage(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__GetCurrentMessage(struct soap *soap, _wsnt__GetCurrentMessage *p)
{
	if (::soap_read__wsnt__GetCurrentMessage(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__SubscribeResponse_DEFINED
#define SOAP_TYPE__wsnt__SubscribeResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeResponse(struct soap*, const char*, int, const _wsnt__SubscribeResponse *, const char*);
SOAP_FMAC3 _wsnt__SubscribeResponse * SOAP_FMAC4 soap_in__wsnt__SubscribeResponse(struct soap*, const char*, _wsnt__SubscribeResponse *, const char*);
SOAP_FMAC1 _wsnt__SubscribeResponse * SOAP_FMAC2 imageing_instantiate__wsnt__SubscribeResponse(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__SubscribeResponse * soap_new__wsnt__SubscribeResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__SubscribeResponse(soap, n, NULL, NULL, NULL);
}

inline _wsnt__SubscribeResponse * soap_new_req__wsnt__SubscribeResponse(
	struct soap *soap,
	const struct wsa5__EndpointReferenceType& SubscriptionReference)
{
	_wsnt__SubscribeResponse *_p = ::soap_new__wsnt__SubscribeResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__SubscribeResponse::SubscriptionReference = SubscriptionReference;
	}
	return _p;
}

inline _wsnt__SubscribeResponse * soap_new_set__wsnt__SubscribeResponse(
	struct soap *soap,
	const struct wsa5__EndpointReferenceType& SubscriptionReference,
	time_t *CurrentTime,
	time_t *TerminationTime,
	const std::vector<char *> & __any)
{
	_wsnt__SubscribeResponse *_p = ::soap_new__wsnt__SubscribeResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__SubscribeResponse::SubscriptionReference = SubscriptionReference;
		_p->_wsnt__SubscribeResponse::CurrentTime = CurrentTime;
		_p->_wsnt__SubscribeResponse::TerminationTime = TerminationTime;
		_p->_wsnt__SubscribeResponse::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__SubscribeResponse(struct soap *soap, _wsnt__SubscribeResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscribeResponse", p->soap_type() == SOAP_TYPE__wsnt__SubscribeResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__SubscribeResponse(struct soap *soap, const char *URL, _wsnt__SubscribeResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscribeResponse", p->soap_type() == SOAP_TYPE__wsnt__SubscribeResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__SubscribeResponse(struct soap *soap, const char *URL, _wsnt__SubscribeResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscribeResponse", p->soap_type() == SOAP_TYPE__wsnt__SubscribeResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__SubscribeResponse(struct soap *soap, const char *URL, _wsnt__SubscribeResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscribeResponse", p->soap_type() == SOAP_TYPE__wsnt__SubscribeResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__SubscribeResponse * SOAP_FMAC4 soap_get__wsnt__SubscribeResponse(struct soap*, _wsnt__SubscribeResponse *, const char*, const char*);

inline int soap_read__wsnt__SubscribeResponse(struct soap *soap, _wsnt__SubscribeResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__SubscribeResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__SubscribeResponse(struct soap *soap, const char *URL, _wsnt__SubscribeResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__SubscribeResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__SubscribeResponse(struct soap *soap, _wsnt__SubscribeResponse *p)
{
	if (::soap_read__wsnt__SubscribeResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__Subscribe_DEFINED
#define SOAP_TYPE__wsnt__Subscribe_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe(struct soap*, const char*, int, const _wsnt__Subscribe *, const char*);
SOAP_FMAC3 _wsnt__Subscribe * SOAP_FMAC4 soap_in__wsnt__Subscribe(struct soap*, const char*, _wsnt__Subscribe *, const char*);
SOAP_FMAC1 _wsnt__Subscribe * SOAP_FMAC2 imageing_instantiate__wsnt__Subscribe(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__Subscribe * soap_new__wsnt__Subscribe(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__Subscribe(soap, n, NULL, NULL, NULL);
}

inline _wsnt__Subscribe * soap_new_req__wsnt__Subscribe(
	struct soap *soap,
	const struct wsa5__EndpointReferenceType& ConsumerReference)
{
	_wsnt__Subscribe *_p = ::soap_new__wsnt__Subscribe(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__Subscribe::ConsumerReference = ConsumerReference;
	}
	return _p;
}

inline _wsnt__Subscribe * soap_new_set__wsnt__Subscribe(
	struct soap *soap,
	const struct wsa5__EndpointReferenceType& ConsumerReference,
	wsnt__FilterType *Filter,
	std::string *InitialTerminationTime,
	_wsnt__Subscribe_SubscriptionPolicy *SubscriptionPolicy,
	const std::vector<char *> & __any)
{
	_wsnt__Subscribe *_p = ::soap_new__wsnt__Subscribe(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__Subscribe::ConsumerReference = ConsumerReference;
		_p->_wsnt__Subscribe::Filter = Filter;
		_p->_wsnt__Subscribe::InitialTerminationTime = InitialTerminationTime;
		_p->_wsnt__Subscribe::SubscriptionPolicy = SubscriptionPolicy;
		_p->_wsnt__Subscribe::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__Subscribe(struct soap *soap, _wsnt__Subscribe const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Subscribe", p->soap_type() == SOAP_TYPE__wsnt__Subscribe ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__Subscribe(struct soap *soap, const char *URL, _wsnt__Subscribe const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Subscribe", p->soap_type() == SOAP_TYPE__wsnt__Subscribe ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__Subscribe(struct soap *soap, const char *URL, _wsnt__Subscribe const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Subscribe", p->soap_type() == SOAP_TYPE__wsnt__Subscribe ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__Subscribe(struct soap *soap, const char *URL, _wsnt__Subscribe const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Subscribe", p->soap_type() == SOAP_TYPE__wsnt__Subscribe ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__Subscribe * SOAP_FMAC4 soap_get__wsnt__Subscribe(struct soap*, _wsnt__Subscribe *, const char*, const char*);

inline int soap_read__wsnt__Subscribe(struct soap *soap, _wsnt__Subscribe *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__Subscribe(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__Subscribe(struct soap *soap, const char *URL, _wsnt__Subscribe *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__Subscribe(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__Subscribe(struct soap *soap, _wsnt__Subscribe *p)
{
	if (::soap_read__wsnt__Subscribe(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__UseRaw_DEFINED
#define SOAP_TYPE__wsnt__UseRaw_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UseRaw(struct soap*, const char*, int, const _wsnt__UseRaw *, const char*);
SOAP_FMAC3 _wsnt__UseRaw * SOAP_FMAC4 soap_in__wsnt__UseRaw(struct soap*, const char*, _wsnt__UseRaw *, const char*);
SOAP_FMAC1 _wsnt__UseRaw * SOAP_FMAC2 imageing_instantiate__wsnt__UseRaw(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__UseRaw * soap_new__wsnt__UseRaw(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__UseRaw(soap, n, NULL, NULL, NULL);
}

inline _wsnt__UseRaw * soap_new_req__wsnt__UseRaw(
	struct soap *soap)
{
	_wsnt__UseRaw *_p = ::soap_new__wsnt__UseRaw(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__UseRaw * soap_new_set__wsnt__UseRaw(
	struct soap *soap)
{
	_wsnt__UseRaw *_p = ::soap_new__wsnt__UseRaw(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline int soap_write__wsnt__UseRaw(struct soap *soap, _wsnt__UseRaw const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UseRaw", p->soap_type() == SOAP_TYPE__wsnt__UseRaw ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__UseRaw(struct soap *soap, const char *URL, _wsnt__UseRaw const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UseRaw", p->soap_type() == SOAP_TYPE__wsnt__UseRaw ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__UseRaw(struct soap *soap, const char *URL, _wsnt__UseRaw const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UseRaw", p->soap_type() == SOAP_TYPE__wsnt__UseRaw ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__UseRaw(struct soap *soap, const char *URL, _wsnt__UseRaw const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UseRaw", p->soap_type() == SOAP_TYPE__wsnt__UseRaw ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__UseRaw * SOAP_FMAC4 soap_get__wsnt__UseRaw(struct soap*, _wsnt__UseRaw *, const char*, const char*);

inline int soap_read__wsnt__UseRaw(struct soap *soap, _wsnt__UseRaw *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__UseRaw(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__UseRaw(struct soap *soap, const char *URL, _wsnt__UseRaw *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__UseRaw(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__UseRaw(struct soap *soap, _wsnt__UseRaw *p)
{
	if (::soap_read__wsnt__UseRaw(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__Notify_DEFINED
#define SOAP_TYPE__wsnt__Notify_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Notify(struct soap*, const char*, int, const _wsnt__Notify *, const char*);
SOAP_FMAC3 _wsnt__Notify * SOAP_FMAC4 soap_in__wsnt__Notify(struct soap*, const char*, _wsnt__Notify *, const char*);
SOAP_FMAC1 _wsnt__Notify * SOAP_FMAC2 imageing_instantiate__wsnt__Notify(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__Notify * soap_new__wsnt__Notify(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__Notify(soap, n, NULL, NULL, NULL);
}

inline _wsnt__Notify * soap_new_req__wsnt__Notify(
	struct soap *soap,
	const std::vector<wsnt__NotificationMessageHolderType *> & NotificationMessage)
{
	_wsnt__Notify *_p = ::soap_new__wsnt__Notify(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__Notify::NotificationMessage = NotificationMessage;
	}
	return _p;
}

inline _wsnt__Notify * soap_new_set__wsnt__Notify(
	struct soap *soap,
	const std::vector<wsnt__NotificationMessageHolderType *> & NotificationMessage,
	const std::vector<char *> & __any)
{
	_wsnt__Notify *_p = ::soap_new__wsnt__Notify(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__Notify::NotificationMessage = NotificationMessage;
		_p->_wsnt__Notify::__any = __any;
	}
	return _p;
}

inline int soap_write__wsnt__Notify(struct soap *soap, _wsnt__Notify const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Notify", p->soap_type() == SOAP_TYPE__wsnt__Notify ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__Notify(struct soap *soap, const char *URL, _wsnt__Notify const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Notify", p->soap_type() == SOAP_TYPE__wsnt__Notify ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__Notify(struct soap *soap, const char *URL, _wsnt__Notify const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Notify", p->soap_type() == SOAP_TYPE__wsnt__Notify ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__Notify(struct soap *soap, const char *URL, _wsnt__Notify const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:Notify", p->soap_type() == SOAP_TYPE__wsnt__Notify ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__Notify * SOAP_FMAC4 soap_get__wsnt__Notify(struct soap*, _wsnt__Notify *, const char*, const char*);

inline int soap_read__wsnt__Notify(struct soap *soap, _wsnt__Notify *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__Notify(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__Notify(struct soap *soap, const char *URL, _wsnt__Notify *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__Notify(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__Notify(struct soap *soap, _wsnt__Notify *p)
{
	if (::soap_read__wsnt__Notify(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP_DEFINED
#define SOAP_TYPE__wsnt__SubscriptionManagerRP_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscriptionManagerRP(struct soap*, const char*, int, const _wsnt__SubscriptionManagerRP *, const char*);
SOAP_FMAC3 _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_in__wsnt__SubscriptionManagerRP(struct soap*, const char*, _wsnt__SubscriptionManagerRP *, const char*);
SOAP_FMAC1 _wsnt__SubscriptionManagerRP * SOAP_FMAC2 imageing_instantiate__wsnt__SubscriptionManagerRP(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__SubscriptionManagerRP * soap_new__wsnt__SubscriptionManagerRP(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__SubscriptionManagerRP(soap, n, NULL, NULL, NULL);
}

inline _wsnt__SubscriptionManagerRP * soap_new_req__wsnt__SubscriptionManagerRP(
	struct soap *soap,
	const struct wsa5__EndpointReferenceType& ConsumerReference)
{
	_wsnt__SubscriptionManagerRP *_p = ::soap_new__wsnt__SubscriptionManagerRP(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__SubscriptionManagerRP::ConsumerReference = ConsumerReference;
	}
	return _p;
}

inline _wsnt__SubscriptionManagerRP * soap_new_set__wsnt__SubscriptionManagerRP(
	struct soap *soap,
	const struct wsa5__EndpointReferenceType& ConsumerReference,
	wsnt__FilterType *Filter,
	wsnt__SubscriptionPolicyType *SubscriptionPolicy,
	time_t *CreationTime)
{
	_wsnt__SubscriptionManagerRP *_p = ::soap_new__wsnt__SubscriptionManagerRP(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__SubscriptionManagerRP::ConsumerReference = ConsumerReference;
		_p->_wsnt__SubscriptionManagerRP::Filter = Filter;
		_p->_wsnt__SubscriptionManagerRP::SubscriptionPolicy = SubscriptionPolicy;
		_p->_wsnt__SubscriptionManagerRP::CreationTime = CreationTime;
	}
	return _p;
}

inline int soap_write__wsnt__SubscriptionManagerRP(struct soap *soap, _wsnt__SubscriptionManagerRP const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscriptionManagerRP", p->soap_type() == SOAP_TYPE__wsnt__SubscriptionManagerRP ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__SubscriptionManagerRP(struct soap *soap, const char *URL, _wsnt__SubscriptionManagerRP const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscriptionManagerRP", p->soap_type() == SOAP_TYPE__wsnt__SubscriptionManagerRP ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__SubscriptionManagerRP(struct soap *soap, const char *URL, _wsnt__SubscriptionManagerRP const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscriptionManagerRP", p->soap_type() == SOAP_TYPE__wsnt__SubscriptionManagerRP ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__SubscriptionManagerRP(struct soap *soap, const char *URL, _wsnt__SubscriptionManagerRP const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscriptionManagerRP", p->soap_type() == SOAP_TYPE__wsnt__SubscriptionManagerRP ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_get__wsnt__SubscriptionManagerRP(struct soap*, _wsnt__SubscriptionManagerRP *, const char*, const char*);

inline int soap_read__wsnt__SubscriptionManagerRP(struct soap *soap, _wsnt__SubscriptionManagerRP *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__SubscriptionManagerRP(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__SubscriptionManagerRP(struct soap *soap, const char *URL, _wsnt__SubscriptionManagerRP *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__SubscriptionManagerRP(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__SubscriptionManagerRP(struct soap *soap, _wsnt__SubscriptionManagerRP *p)
{
	if (::soap_read__wsnt__SubscriptionManagerRP(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__wsnt__NotificationProducerRP_DEFINED
#define SOAP_TYPE__wsnt__NotificationProducerRP_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationProducerRP(struct soap*, const char*, int, const _wsnt__NotificationProducerRP *, const char*);
SOAP_FMAC3 _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_in__wsnt__NotificationProducerRP(struct soap*, const char*, _wsnt__NotificationProducerRP *, const char*);
SOAP_FMAC1 _wsnt__NotificationProducerRP * SOAP_FMAC2 imageing_instantiate__wsnt__NotificationProducerRP(struct soap*, int, const char*, const char*, size_t*);

inline _wsnt__NotificationProducerRP * soap_new__wsnt__NotificationProducerRP(struct soap *soap, int n = -1)
{
	return imageing_instantiate__wsnt__NotificationProducerRP(soap, n, NULL, NULL, NULL);
}

inline _wsnt__NotificationProducerRP * soap_new_req__wsnt__NotificationProducerRP(
	struct soap *soap)
{
	_wsnt__NotificationProducerRP *_p = ::soap_new__wsnt__NotificationProducerRP(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _wsnt__NotificationProducerRP * soap_new_set__wsnt__NotificationProducerRP(
	struct soap *soap,
	const std::vector<wsnt__TopicExpressionType *> & TopicExpression,
	bool *FixedTopicSet,
	const std::vector<std::string> & TopicExpressionDialect,
	wstop__TopicSetType *wstop__TopicSet)
{
	_wsnt__NotificationProducerRP *_p = ::soap_new__wsnt__NotificationProducerRP(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_wsnt__NotificationProducerRP::TopicExpression = TopicExpression;
		_p->_wsnt__NotificationProducerRP::FixedTopicSet = FixedTopicSet;
		_p->_wsnt__NotificationProducerRP::TopicExpressionDialect = TopicExpressionDialect;
		_p->_wsnt__NotificationProducerRP::wstop__TopicSet = wstop__TopicSet;
	}
	return _p;
}

inline int soap_write__wsnt__NotificationProducerRP(struct soap *soap, _wsnt__NotificationProducerRP const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotificationProducerRP", p->soap_type() == SOAP_TYPE__wsnt__NotificationProducerRP ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsnt__NotificationProducerRP(struct soap *soap, const char *URL, _wsnt__NotificationProducerRP const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotificationProducerRP", p->soap_type() == SOAP_TYPE__wsnt__NotificationProducerRP ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsnt__NotificationProducerRP(struct soap *soap, const char *URL, _wsnt__NotificationProducerRP const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotificationProducerRP", p->soap_type() == SOAP_TYPE__wsnt__NotificationProducerRP ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsnt__NotificationProducerRP(struct soap *soap, const char *URL, _wsnt__NotificationProducerRP const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotificationProducerRP", p->soap_type() == SOAP_TYPE__wsnt__NotificationProducerRP ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_get__wsnt__NotificationProducerRP(struct soap*, _wsnt__NotificationProducerRP *, const char*, const char*);

inline int soap_read__wsnt__NotificationProducerRP(struct soap *soap, _wsnt__NotificationProducerRP *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__wsnt__NotificationProducerRP(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__wsnt__NotificationProducerRP(struct soap *soap, const char *URL, _wsnt__NotificationProducerRP *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__wsnt__NotificationProducerRP(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__wsnt__NotificationProducerRP(struct soap *soap, _wsnt__NotificationProducerRP *p)
{
	if (::soap_read__wsnt__NotificationProducerRP(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType_DEFINED
#define SOAP_TYPE_wsnt__ResumeFailedFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__ResumeFailedFaultType(struct soap*, const char*, int, const wsnt__ResumeFailedFaultType *, const char*);
SOAP_FMAC3 wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_in_wsnt__ResumeFailedFaultType(struct soap*, const char*, wsnt__ResumeFailedFaultType *, const char*);
SOAP_FMAC1 wsnt__ResumeFailedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__ResumeFailedFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__ResumeFailedFaultType * soap_new_wsnt__ResumeFailedFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__ResumeFailedFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__ResumeFailedFaultType * soap_new_req_wsnt__ResumeFailedFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__ResumeFailedFaultType *_p = ::soap_new_wsnt__ResumeFailedFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__ResumeFailedFaultType * soap_new_set_wsnt__ResumeFailedFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__ResumeFailedFaultType *_p = ::soap_new_wsnt__ResumeFailedFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__ResumeFailedFaultType(struct soap *soap, wsnt__ResumeFailedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:ResumeFailedFaultType", p->soap_type() == SOAP_TYPE_wsnt__ResumeFailedFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__ResumeFailedFaultType(struct soap *soap, const char *URL, wsnt__ResumeFailedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:ResumeFailedFaultType", p->soap_type() == SOAP_TYPE_wsnt__ResumeFailedFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__ResumeFailedFaultType(struct soap *soap, const char *URL, wsnt__ResumeFailedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:ResumeFailedFaultType", p->soap_type() == SOAP_TYPE_wsnt__ResumeFailedFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__ResumeFailedFaultType(struct soap *soap, const char *URL, wsnt__ResumeFailedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:ResumeFailedFaultType", p->soap_type() == SOAP_TYPE_wsnt__ResumeFailedFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_get_wsnt__ResumeFailedFaultType(struct soap*, wsnt__ResumeFailedFaultType *, const char*, const char*);

inline int soap_read_wsnt__ResumeFailedFaultType(struct soap *soap, wsnt__ResumeFailedFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__ResumeFailedFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__ResumeFailedFaultType(struct soap *soap, const char *URL, wsnt__ResumeFailedFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__ResumeFailedFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__ResumeFailedFaultType(struct soap *soap, wsnt__ResumeFailedFaultType *p)
{
	if (::soap_read_wsnt__ResumeFailedFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType_DEFINED
#define SOAP_TYPE_wsnt__PauseFailedFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__PauseFailedFaultType(struct soap*, const char*, int, const wsnt__PauseFailedFaultType *, const char*);
SOAP_FMAC3 wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_in_wsnt__PauseFailedFaultType(struct soap*, const char*, wsnt__PauseFailedFaultType *, const char*);
SOAP_FMAC1 wsnt__PauseFailedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__PauseFailedFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__PauseFailedFaultType * soap_new_wsnt__PauseFailedFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__PauseFailedFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__PauseFailedFaultType * soap_new_req_wsnt__PauseFailedFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__PauseFailedFaultType *_p = ::soap_new_wsnt__PauseFailedFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__PauseFailedFaultType * soap_new_set_wsnt__PauseFailedFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__PauseFailedFaultType *_p = ::soap_new_wsnt__PauseFailedFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__PauseFailedFaultType(struct soap *soap, wsnt__PauseFailedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:PauseFailedFaultType", p->soap_type() == SOAP_TYPE_wsnt__PauseFailedFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__PauseFailedFaultType(struct soap *soap, const char *URL, wsnt__PauseFailedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:PauseFailedFaultType", p->soap_type() == SOAP_TYPE_wsnt__PauseFailedFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__PauseFailedFaultType(struct soap *soap, const char *URL, wsnt__PauseFailedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:PauseFailedFaultType", p->soap_type() == SOAP_TYPE_wsnt__PauseFailedFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__PauseFailedFaultType(struct soap *soap, const char *URL, wsnt__PauseFailedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:PauseFailedFaultType", p->soap_type() == SOAP_TYPE_wsnt__PauseFailedFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_get_wsnt__PauseFailedFaultType(struct soap*, wsnt__PauseFailedFaultType *, const char*, const char*);

inline int soap_read_wsnt__PauseFailedFaultType(struct soap *soap, wsnt__PauseFailedFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__PauseFailedFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__PauseFailedFaultType(struct soap *soap, const char *URL, wsnt__PauseFailedFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__PauseFailedFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__PauseFailedFaultType(struct soap *soap, wsnt__PauseFailedFaultType *p)
{
	if (::soap_read_wsnt__PauseFailedFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType_DEFINED
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, const char*, int, const wsnt__UnableToDestroySubscriptionFaultType *, const char*);
SOAP_FMAC3 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, const char*, wsnt__UnableToDestroySubscriptionFaultType *, const char*);
SOAP_FMAC1 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__UnableToDestroySubscriptionFaultType * soap_new_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__UnableToDestroySubscriptionFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__UnableToDestroySubscriptionFaultType * soap_new_req_wsnt__UnableToDestroySubscriptionFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__UnableToDestroySubscriptionFaultType *_p = ::soap_new_wsnt__UnableToDestroySubscriptionFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__UnableToDestroySubscriptionFaultType * soap_new_set_wsnt__UnableToDestroySubscriptionFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__UnableToDestroySubscriptionFaultType *_p = ::soap_new_wsnt__UnableToDestroySubscriptionFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, wsnt__UnableToDestroySubscriptionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToDestroySubscriptionFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *URL, wsnt__UnableToDestroySubscriptionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToDestroySubscriptionFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *URL, wsnt__UnableToDestroySubscriptionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToDestroySubscriptionFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *URL, wsnt__UnableToDestroySubscriptionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToDestroySubscriptionFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, wsnt__UnableToDestroySubscriptionFaultType *, const char*, const char*);

inline int soap_read_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, wsnt__UnableToDestroySubscriptionFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__UnableToDestroySubscriptionFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *URL, wsnt__UnableToDestroySubscriptionFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__UnableToDestroySubscriptionFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, wsnt__UnableToDestroySubscriptionFaultType *p)
{
	if (::soap_read_wsnt__UnableToDestroySubscriptionFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType_DEFINED
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, const char*, int, const wsnt__UnacceptableTerminationTimeFaultType *, const char*);
SOAP_FMAC3 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, const char*, wsnt__UnacceptableTerminationTimeFaultType *, const char*);
SOAP_FMAC1 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__UnacceptableTerminationTimeFaultType * soap_new_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__UnacceptableTerminationTimeFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__UnacceptableTerminationTimeFaultType * soap_new_req_wsnt__UnacceptableTerminationTimeFaultType(
	struct soap *soap,
	time_t MinimumTime,
	time_t Timestamp__1)
{
	wsnt__UnacceptableTerminationTimeFaultType *_p = ::soap_new_wsnt__UnacceptableTerminationTimeFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime = MinimumTime;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__UnacceptableTerminationTimeFaultType * soap_new_set_wsnt__UnacceptableTerminationTimeFaultType(
	struct soap *soap,
	time_t MinimumTime,
	time_t *MaximumTime,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__UnacceptableTerminationTimeFaultType *_p = ::soap_new_wsnt__UnacceptableTerminationTimeFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime = MinimumTime;
		_p->wsnt__UnacceptableTerminationTimeFaultType::MaximumTime = MaximumTime;
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableTerminationTimeFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnacceptableTerminationTimeFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *URL, wsnt__UnacceptableTerminationTimeFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnacceptableTerminationTimeFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *URL, wsnt__UnacceptableTerminationTimeFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnacceptableTerminationTimeFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *URL, wsnt__UnacceptableTerminationTimeFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnacceptableTerminationTimeFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, wsnt__UnacceptableTerminationTimeFaultType *, const char*, const char*);

inline int soap_read_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableTerminationTimeFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__UnacceptableTerminationTimeFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *URL, wsnt__UnacceptableTerminationTimeFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__UnacceptableTerminationTimeFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableTerminationTimeFaultType *p)
{
	if (::soap_read_wsnt__UnacceptableTerminationTimeFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType_DEFINED
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToCreatePullPointFaultType(struct soap*, const char*, int, const wsnt__UnableToCreatePullPointFaultType *, const char*);
SOAP_FMAC3 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToCreatePullPointFaultType(struct soap*, const char*, wsnt__UnableToCreatePullPointFaultType *, const char*);
SOAP_FMAC1 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnableToCreatePullPointFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__UnableToCreatePullPointFaultType * soap_new_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__UnableToCreatePullPointFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__UnableToCreatePullPointFaultType * soap_new_req_wsnt__UnableToCreatePullPointFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__UnableToCreatePullPointFaultType *_p = ::soap_new_wsnt__UnableToCreatePullPointFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__UnableToCreatePullPointFaultType * soap_new_set_wsnt__UnableToCreatePullPointFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__UnableToCreatePullPointFaultType *_p = ::soap_new_wsnt__UnableToCreatePullPointFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, wsnt__UnableToCreatePullPointFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToCreatePullPointFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *URL, wsnt__UnableToCreatePullPointFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToCreatePullPointFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *URL, wsnt__UnableToCreatePullPointFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToCreatePullPointFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *URL, wsnt__UnableToCreatePullPointFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToCreatePullPointFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToCreatePullPointFaultType(struct soap*, wsnt__UnableToCreatePullPointFaultType *, const char*, const char*);

inline int soap_read_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, wsnt__UnableToCreatePullPointFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__UnableToCreatePullPointFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *URL, wsnt__UnableToCreatePullPointFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__UnableToCreatePullPointFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, wsnt__UnableToCreatePullPointFaultType *p)
{
	if (::soap_read_wsnt__UnableToCreatePullPointFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType_DEFINED
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroyPullPointFaultType(struct soap*, const char*, int, const wsnt__UnableToDestroyPullPointFaultType *, const char*);
SOAP_FMAC3 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroyPullPointFaultType(struct soap*, const char*, wsnt__UnableToDestroyPullPointFaultType *, const char*);
SOAP_FMAC1 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnableToDestroyPullPointFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__UnableToDestroyPullPointFaultType * soap_new_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__UnableToDestroyPullPointFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__UnableToDestroyPullPointFaultType * soap_new_req_wsnt__UnableToDestroyPullPointFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__UnableToDestroyPullPointFaultType *_p = ::soap_new_wsnt__UnableToDestroyPullPointFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__UnableToDestroyPullPointFaultType * soap_new_set_wsnt__UnableToDestroyPullPointFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__UnableToDestroyPullPointFaultType *_p = ::soap_new_wsnt__UnableToDestroyPullPointFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, wsnt__UnableToDestroyPullPointFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToDestroyPullPointFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *URL, wsnt__UnableToDestroyPullPointFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToDestroyPullPointFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *URL, wsnt__UnableToDestroyPullPointFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToDestroyPullPointFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *URL, wsnt__UnableToDestroyPullPointFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToDestroyPullPointFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroyPullPointFaultType(struct soap*, wsnt__UnableToDestroyPullPointFaultType *, const char*, const char*);

inline int soap_read_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, wsnt__UnableToDestroyPullPointFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__UnableToDestroyPullPointFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *URL, wsnt__UnableToDestroyPullPointFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__UnableToDestroyPullPointFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, wsnt__UnableToDestroyPullPointFaultType *p)
{
	if (::soap_read_wsnt__UnableToDestroyPullPointFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType_DEFINED
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToGetMessagesFaultType(struct soap*, const char*, int, const wsnt__UnableToGetMessagesFaultType *, const char*);
SOAP_FMAC3 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToGetMessagesFaultType(struct soap*, const char*, wsnt__UnableToGetMessagesFaultType *, const char*);
SOAP_FMAC1 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnableToGetMessagesFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__UnableToGetMessagesFaultType * soap_new_wsnt__UnableToGetMessagesFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__UnableToGetMessagesFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__UnableToGetMessagesFaultType * soap_new_req_wsnt__UnableToGetMessagesFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__UnableToGetMessagesFaultType *_p = ::soap_new_wsnt__UnableToGetMessagesFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__UnableToGetMessagesFaultType * soap_new_set_wsnt__UnableToGetMessagesFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__UnableToGetMessagesFaultType *_p = ::soap_new_wsnt__UnableToGetMessagesFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__UnableToGetMessagesFaultType(struct soap *soap, wsnt__UnableToGetMessagesFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToGetMessagesFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToGetMessagesFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *URL, wsnt__UnableToGetMessagesFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToGetMessagesFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToGetMessagesFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *URL, wsnt__UnableToGetMessagesFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToGetMessagesFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToGetMessagesFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *URL, wsnt__UnableToGetMessagesFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnableToGetMessagesFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnableToGetMessagesFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToGetMessagesFaultType(struct soap*, wsnt__UnableToGetMessagesFaultType *, const char*, const char*);

inline int soap_read_wsnt__UnableToGetMessagesFaultType(struct soap *soap, wsnt__UnableToGetMessagesFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__UnableToGetMessagesFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *URL, wsnt__UnableToGetMessagesFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__UnableToGetMessagesFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__UnableToGetMessagesFaultType(struct soap *soap, wsnt__UnableToGetMessagesFaultType *p)
{
	if (::soap_read_wsnt__UnableToGetMessagesFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType_DEFINED
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, const char*, int, const wsnt__NoCurrentMessageOnTopicFaultType *, const char*);
SOAP_FMAC3 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_in_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, const char*, wsnt__NoCurrentMessageOnTopicFaultType *, const char*);
SOAP_FMAC1 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__NoCurrentMessageOnTopicFaultType * soap_new_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__NoCurrentMessageOnTopicFaultType * soap_new_req_wsnt__NoCurrentMessageOnTopicFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__NoCurrentMessageOnTopicFaultType *_p = ::soap_new_wsnt__NoCurrentMessageOnTopicFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__NoCurrentMessageOnTopicFaultType * soap_new_set_wsnt__NoCurrentMessageOnTopicFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__NoCurrentMessageOnTopicFaultType *_p = ::soap_new_wsnt__NoCurrentMessageOnTopicFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, wsnt__NoCurrentMessageOnTopicFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NoCurrentMessageOnTopicFaultType", p->soap_type() == SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *URL, wsnt__NoCurrentMessageOnTopicFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NoCurrentMessageOnTopicFaultType", p->soap_type() == SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *URL, wsnt__NoCurrentMessageOnTopicFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NoCurrentMessageOnTopicFaultType", p->soap_type() == SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *URL, wsnt__NoCurrentMessageOnTopicFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NoCurrentMessageOnTopicFaultType", p->soap_type() == SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_get_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, wsnt__NoCurrentMessageOnTopicFaultType *, const char*, const char*);

inline int soap_read_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, wsnt__NoCurrentMessageOnTopicFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__NoCurrentMessageOnTopicFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *URL, wsnt__NoCurrentMessageOnTopicFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__NoCurrentMessageOnTopicFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, wsnt__NoCurrentMessageOnTopicFaultType *p)
{
	if (::soap_read_wsnt__NoCurrentMessageOnTopicFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType_DEFINED
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, const char*, int, const wsnt__UnacceptableInitialTerminationTimeFaultType *, const char*);
SOAP_FMAC3 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, const char*, wsnt__UnacceptableInitialTerminationTimeFaultType *, const char*);
SOAP_FMAC1 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__UnacceptableInitialTerminationTimeFaultType * soap_new_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__UnacceptableInitialTerminationTimeFaultType * soap_new_req_wsnt__UnacceptableInitialTerminationTimeFaultType(
	struct soap *soap,
	time_t MinimumTime,
	time_t Timestamp__1)
{
	wsnt__UnacceptableInitialTerminationTimeFaultType *_p = ::soap_new_wsnt__UnacceptableInitialTerminationTimeFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime = MinimumTime;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__UnacceptableInitialTerminationTimeFaultType * soap_new_set_wsnt__UnacceptableInitialTerminationTimeFaultType(
	struct soap *soap,
	time_t MinimumTime,
	time_t *MaximumTime,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__UnacceptableInitialTerminationTimeFaultType *_p = ::soap_new_wsnt__UnacceptableInitialTerminationTimeFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime = MinimumTime;
		_p->wsnt__UnacceptableInitialTerminationTimeFaultType::MaximumTime = MaximumTime;
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableInitialTerminationTimeFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnacceptableInitialTerminationTimeFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *URL, wsnt__UnacceptableInitialTerminationTimeFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnacceptableInitialTerminationTimeFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *URL, wsnt__UnacceptableInitialTerminationTimeFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnacceptableInitialTerminationTimeFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *URL, wsnt__UnacceptableInitialTerminationTimeFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnacceptableInitialTerminationTimeFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, wsnt__UnacceptableInitialTerminationTimeFaultType *, const char*, const char*);

inline int soap_read_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableInitialTerminationTimeFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *URL, wsnt__UnacceptableInitialTerminationTimeFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableInitialTerminationTimeFaultType *p)
{
	if (::soap_read_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType_DEFINED
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, const char*, int, const wsnt__NotifyMessageNotSupportedFaultType *, const char*);
SOAP_FMAC3 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, const char*, wsnt__NotifyMessageNotSupportedFaultType *, const char*);
SOAP_FMAC1 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__NotifyMessageNotSupportedFaultType * soap_new_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__NotifyMessageNotSupportedFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__NotifyMessageNotSupportedFaultType * soap_new_req_wsnt__NotifyMessageNotSupportedFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__NotifyMessageNotSupportedFaultType *_p = ::soap_new_wsnt__NotifyMessageNotSupportedFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__NotifyMessageNotSupportedFaultType * soap_new_set_wsnt__NotifyMessageNotSupportedFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__NotifyMessageNotSupportedFaultType *_p = ::soap_new_wsnt__NotifyMessageNotSupportedFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, wsnt__NotifyMessageNotSupportedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotifyMessageNotSupportedFaultType", p->soap_type() == SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *URL, wsnt__NotifyMessageNotSupportedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotifyMessageNotSupportedFaultType", p->soap_type() == SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *URL, wsnt__NotifyMessageNotSupportedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotifyMessageNotSupportedFaultType", p->soap_type() == SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *URL, wsnt__NotifyMessageNotSupportedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotifyMessageNotSupportedFaultType", p->soap_type() == SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, wsnt__NotifyMessageNotSupportedFaultType *, const char*, const char*);

inline int soap_read_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, wsnt__NotifyMessageNotSupportedFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__NotifyMessageNotSupportedFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *URL, wsnt__NotifyMessageNotSupportedFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__NotifyMessageNotSupportedFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, wsnt__NotifyMessageNotSupportedFaultType *p)
{
	if (::soap_read_wsnt__NotifyMessageNotSupportedFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType_DEFINED
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, const char*, int, const wsnt__UnsupportedPolicyRequestFaultType *, const char*);
SOAP_FMAC3 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, const char*, wsnt__UnsupportedPolicyRequestFaultType *, const char*);
SOAP_FMAC1 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__UnsupportedPolicyRequestFaultType * soap_new_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__UnsupportedPolicyRequestFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__UnsupportedPolicyRequestFaultType * soap_new_req_wsnt__UnsupportedPolicyRequestFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__UnsupportedPolicyRequestFaultType *_p = ::soap_new_wsnt__UnsupportedPolicyRequestFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__UnsupportedPolicyRequestFaultType * soap_new_set_wsnt__UnsupportedPolicyRequestFaultType(
	struct soap *soap,
	const std::vector<std::string> & UnsupportedPolicy,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__UnsupportedPolicyRequestFaultType *_p = ::soap_new_wsnt__UnsupportedPolicyRequestFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__UnsupportedPolicyRequestFaultType::UnsupportedPolicy = UnsupportedPolicy;
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, wsnt__UnsupportedPolicyRequestFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnsupportedPolicyRequestFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *URL, wsnt__UnsupportedPolicyRequestFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnsupportedPolicyRequestFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *URL, wsnt__UnsupportedPolicyRequestFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnsupportedPolicyRequestFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *URL, wsnt__UnsupportedPolicyRequestFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnsupportedPolicyRequestFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, wsnt__UnsupportedPolicyRequestFaultType *, const char*, const char*);

inline int soap_read_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, wsnt__UnsupportedPolicyRequestFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__UnsupportedPolicyRequestFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *URL, wsnt__UnsupportedPolicyRequestFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__UnsupportedPolicyRequestFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, wsnt__UnsupportedPolicyRequestFaultType *p)
{
	if (::soap_read_wsnt__UnsupportedPolicyRequestFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType_DEFINED
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, const char*, int, const wsnt__UnrecognizedPolicyRequestFaultType *, const char*);
SOAP_FMAC3 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, const char*, wsnt__UnrecognizedPolicyRequestFaultType *, const char*);
SOAP_FMAC1 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__UnrecognizedPolicyRequestFaultType * soap_new_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__UnrecognizedPolicyRequestFaultType * soap_new_req_wsnt__UnrecognizedPolicyRequestFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__UnrecognizedPolicyRequestFaultType *_p = ::soap_new_wsnt__UnrecognizedPolicyRequestFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__UnrecognizedPolicyRequestFaultType * soap_new_set_wsnt__UnrecognizedPolicyRequestFaultType(
	struct soap *soap,
	const std::vector<std::string> & UnrecognizedPolicy,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__UnrecognizedPolicyRequestFaultType *_p = ::soap_new_wsnt__UnrecognizedPolicyRequestFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy = UnrecognizedPolicy;
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, wsnt__UnrecognizedPolicyRequestFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnrecognizedPolicyRequestFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *URL, wsnt__UnrecognizedPolicyRequestFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnrecognizedPolicyRequestFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *URL, wsnt__UnrecognizedPolicyRequestFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnrecognizedPolicyRequestFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *URL, wsnt__UnrecognizedPolicyRequestFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:UnrecognizedPolicyRequestFaultType", p->soap_type() == SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, wsnt__UnrecognizedPolicyRequestFaultType *, const char*, const char*);

inline int soap_read_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, wsnt__UnrecognizedPolicyRequestFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__UnrecognizedPolicyRequestFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *URL, wsnt__UnrecognizedPolicyRequestFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__UnrecognizedPolicyRequestFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, wsnt__UnrecognizedPolicyRequestFaultType *p)
{
	if (::soap_read_wsnt__UnrecognizedPolicyRequestFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType_DEFINED
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, const char*, int, const wsnt__InvalidMessageContentExpressionFaultType *, const char*);
SOAP_FMAC3 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, const char*, wsnt__InvalidMessageContentExpressionFaultType *, const char*);
SOAP_FMAC1 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__InvalidMessageContentExpressionFaultType * soap_new_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__InvalidMessageContentExpressionFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__InvalidMessageContentExpressionFaultType * soap_new_req_wsnt__InvalidMessageContentExpressionFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__InvalidMessageContentExpressionFaultType *_p = ::soap_new_wsnt__InvalidMessageContentExpressionFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__InvalidMessageContentExpressionFaultType * soap_new_set_wsnt__InvalidMessageContentExpressionFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__InvalidMessageContentExpressionFaultType *_p = ::soap_new_wsnt__InvalidMessageContentExpressionFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, wsnt__InvalidMessageContentExpressionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidMessageContentExpressionFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *URL, wsnt__InvalidMessageContentExpressionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidMessageContentExpressionFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *URL, wsnt__InvalidMessageContentExpressionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidMessageContentExpressionFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *URL, wsnt__InvalidMessageContentExpressionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidMessageContentExpressionFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, wsnt__InvalidMessageContentExpressionFaultType *, const char*, const char*);

inline int soap_read_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, wsnt__InvalidMessageContentExpressionFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__InvalidMessageContentExpressionFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *URL, wsnt__InvalidMessageContentExpressionFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__InvalidMessageContentExpressionFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, wsnt__InvalidMessageContentExpressionFaultType *p)
{
	if (::soap_read_wsnt__InvalidMessageContentExpressionFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType_DEFINED
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, const char*, int, const wsnt__InvalidProducerPropertiesExpressionFaultType *, const char*);
SOAP_FMAC3 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, const char*, wsnt__InvalidProducerPropertiesExpressionFaultType *, const char*);
SOAP_FMAC1 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__InvalidProducerPropertiesExpressionFaultType * soap_new_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__InvalidProducerPropertiesExpressionFaultType * soap_new_req_wsnt__InvalidProducerPropertiesExpressionFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__InvalidProducerPropertiesExpressionFaultType *_p = ::soap_new_wsnt__InvalidProducerPropertiesExpressionFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__InvalidProducerPropertiesExpressionFaultType * soap_new_set_wsnt__InvalidProducerPropertiesExpressionFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__InvalidProducerPropertiesExpressionFaultType *_p = ::soap_new_wsnt__InvalidProducerPropertiesExpressionFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, wsnt__InvalidProducerPropertiesExpressionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidProducerPropertiesExpressionFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *URL, wsnt__InvalidProducerPropertiesExpressionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidProducerPropertiesExpressionFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *URL, wsnt__InvalidProducerPropertiesExpressionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidProducerPropertiesExpressionFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *URL, wsnt__InvalidProducerPropertiesExpressionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidProducerPropertiesExpressionFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, wsnt__InvalidProducerPropertiesExpressionFaultType *, const char*, const char*);

inline int soap_read_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, wsnt__InvalidProducerPropertiesExpressionFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *URL, wsnt__InvalidProducerPropertiesExpressionFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, wsnt__InvalidProducerPropertiesExpressionFaultType *p)
{
	if (::soap_read_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType_DEFINED
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, const char*, int, const wsnt__MultipleTopicsSpecifiedFaultType *, const char*);
SOAP_FMAC3 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_in_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, const char*, wsnt__MultipleTopicsSpecifiedFaultType *, const char*);
SOAP_FMAC1 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__MultipleTopicsSpecifiedFaultType * soap_new_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__MultipleTopicsSpecifiedFaultType * soap_new_req_wsnt__MultipleTopicsSpecifiedFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__MultipleTopicsSpecifiedFaultType *_p = ::soap_new_wsnt__MultipleTopicsSpecifiedFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__MultipleTopicsSpecifiedFaultType * soap_new_set_wsnt__MultipleTopicsSpecifiedFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__MultipleTopicsSpecifiedFaultType *_p = ::soap_new_wsnt__MultipleTopicsSpecifiedFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, wsnt__MultipleTopicsSpecifiedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:MultipleTopicsSpecifiedFaultType", p->soap_type() == SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *URL, wsnt__MultipleTopicsSpecifiedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:MultipleTopicsSpecifiedFaultType", p->soap_type() == SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *URL, wsnt__MultipleTopicsSpecifiedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:MultipleTopicsSpecifiedFaultType", p->soap_type() == SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *URL, wsnt__MultipleTopicsSpecifiedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:MultipleTopicsSpecifiedFaultType", p->soap_type() == SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_get_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, wsnt__MultipleTopicsSpecifiedFaultType *, const char*, const char*);

inline int soap_read_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, wsnt__MultipleTopicsSpecifiedFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__MultipleTopicsSpecifiedFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *URL, wsnt__MultipleTopicsSpecifiedFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__MultipleTopicsSpecifiedFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, wsnt__MultipleTopicsSpecifiedFaultType *p)
{
	if (::soap_read_wsnt__MultipleTopicsSpecifiedFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType_DEFINED
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicNotSupportedFaultType(struct soap*, const char*, int, const wsnt__TopicNotSupportedFaultType *, const char*);
SOAP_FMAC3 wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__TopicNotSupportedFaultType(struct soap*, const char*, wsnt__TopicNotSupportedFaultType *, const char*);
SOAP_FMAC1 wsnt__TopicNotSupportedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__TopicNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__TopicNotSupportedFaultType * soap_new_wsnt__TopicNotSupportedFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__TopicNotSupportedFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__TopicNotSupportedFaultType * soap_new_req_wsnt__TopicNotSupportedFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__TopicNotSupportedFaultType *_p = ::soap_new_wsnt__TopicNotSupportedFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__TopicNotSupportedFaultType * soap_new_set_wsnt__TopicNotSupportedFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__TopicNotSupportedFaultType *_p = ::soap_new_wsnt__TopicNotSupportedFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__TopicNotSupportedFaultType(struct soap *soap, wsnt__TopicNotSupportedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:TopicNotSupportedFaultType", p->soap_type() == SOAP_TYPE_wsnt__TopicNotSupportedFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *URL, wsnt__TopicNotSupportedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:TopicNotSupportedFaultType", p->soap_type() == SOAP_TYPE_wsnt__TopicNotSupportedFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *URL, wsnt__TopicNotSupportedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:TopicNotSupportedFaultType", p->soap_type() == SOAP_TYPE_wsnt__TopicNotSupportedFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *URL, wsnt__TopicNotSupportedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:TopicNotSupportedFaultType", p->soap_type() == SOAP_TYPE_wsnt__TopicNotSupportedFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__TopicNotSupportedFaultType(struct soap*, wsnt__TopicNotSupportedFaultType *, const char*, const char*);

inline int soap_read_wsnt__TopicNotSupportedFaultType(struct soap *soap, wsnt__TopicNotSupportedFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__TopicNotSupportedFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *URL, wsnt__TopicNotSupportedFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__TopicNotSupportedFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__TopicNotSupportedFaultType(struct soap *soap, wsnt__TopicNotSupportedFaultType *p)
{
	if (::soap_read_wsnt__TopicNotSupportedFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType_DEFINED
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidTopicExpressionFaultType(struct soap*, const char*, int, const wsnt__InvalidTopicExpressionFaultType *, const char*);
SOAP_FMAC3 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidTopicExpressionFaultType(struct soap*, const char*, wsnt__InvalidTopicExpressionFaultType *, const char*);
SOAP_FMAC1 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__InvalidTopicExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__InvalidTopicExpressionFaultType * soap_new_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__InvalidTopicExpressionFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__InvalidTopicExpressionFaultType * soap_new_req_wsnt__InvalidTopicExpressionFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__InvalidTopicExpressionFaultType *_p = ::soap_new_wsnt__InvalidTopicExpressionFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__InvalidTopicExpressionFaultType * soap_new_set_wsnt__InvalidTopicExpressionFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__InvalidTopicExpressionFaultType *_p = ::soap_new_wsnt__InvalidTopicExpressionFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, wsnt__InvalidTopicExpressionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidTopicExpressionFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *URL, wsnt__InvalidTopicExpressionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidTopicExpressionFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *URL, wsnt__InvalidTopicExpressionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidTopicExpressionFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *URL, wsnt__InvalidTopicExpressionFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidTopicExpressionFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidTopicExpressionFaultType(struct soap*, wsnt__InvalidTopicExpressionFaultType *, const char*, const char*);

inline int soap_read_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, wsnt__InvalidTopicExpressionFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__InvalidTopicExpressionFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *URL, wsnt__InvalidTopicExpressionFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__InvalidTopicExpressionFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, wsnt__InvalidTopicExpressionFaultType *p)
{
	if (::soap_read_wsnt__InvalidTopicExpressionFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType_DEFINED
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, const char*, int, const wsnt__TopicExpressionDialectUnknownFaultType *, const char*);
SOAP_FMAC3 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, const char*, wsnt__TopicExpressionDialectUnknownFaultType *, const char*);
SOAP_FMAC1 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__TopicExpressionDialectUnknownFaultType * soap_new_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__TopicExpressionDialectUnknownFaultType * soap_new_req_wsnt__TopicExpressionDialectUnknownFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__TopicExpressionDialectUnknownFaultType *_p = ::soap_new_wsnt__TopicExpressionDialectUnknownFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__TopicExpressionDialectUnknownFaultType * soap_new_set_wsnt__TopicExpressionDialectUnknownFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__TopicExpressionDialectUnknownFaultType *_p = ::soap_new_wsnt__TopicExpressionDialectUnknownFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, wsnt__TopicExpressionDialectUnknownFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:TopicExpressionDialectUnknownFaultType", p->soap_type() == SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *URL, wsnt__TopicExpressionDialectUnknownFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:TopicExpressionDialectUnknownFaultType", p->soap_type() == SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *URL, wsnt__TopicExpressionDialectUnknownFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:TopicExpressionDialectUnknownFaultType", p->soap_type() == SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *URL, wsnt__TopicExpressionDialectUnknownFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:TopicExpressionDialectUnknownFaultType", p->soap_type() == SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, wsnt__TopicExpressionDialectUnknownFaultType *, const char*, const char*);

inline int soap_read_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, wsnt__TopicExpressionDialectUnknownFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__TopicExpressionDialectUnknownFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *URL, wsnt__TopicExpressionDialectUnknownFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__TopicExpressionDialectUnknownFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, wsnt__TopicExpressionDialectUnknownFaultType *p)
{
	if (::soap_read_wsnt__TopicExpressionDialectUnknownFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType_DEFINED
#define SOAP_TYPE_wsnt__InvalidFilterFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidFilterFaultType(struct soap*, const char*, int, const wsnt__InvalidFilterFaultType *, const char*);
SOAP_FMAC3 wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidFilterFaultType(struct soap*, const char*, wsnt__InvalidFilterFaultType *, const char*);
SOAP_FMAC1 wsnt__InvalidFilterFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__InvalidFilterFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__InvalidFilterFaultType * soap_new_wsnt__InvalidFilterFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__InvalidFilterFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__InvalidFilterFaultType * soap_new_req_wsnt__InvalidFilterFaultType(
	struct soap *soap,
	const std::vector<std::string> & UnknownFilter,
	time_t Timestamp__1)
{
	wsnt__InvalidFilterFaultType *_p = ::soap_new_wsnt__InvalidFilterFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__InvalidFilterFaultType::UnknownFilter = UnknownFilter;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__InvalidFilterFaultType * soap_new_set_wsnt__InvalidFilterFaultType(
	struct soap *soap,
	const std::vector<std::string> & UnknownFilter,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__InvalidFilterFaultType *_p = ::soap_new_wsnt__InvalidFilterFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__InvalidFilterFaultType::UnknownFilter = UnknownFilter;
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__InvalidFilterFaultType(struct soap *soap, wsnt__InvalidFilterFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidFilterFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidFilterFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__InvalidFilterFaultType(struct soap *soap, const char *URL, wsnt__InvalidFilterFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidFilterFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidFilterFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__InvalidFilterFaultType(struct soap *soap, const char *URL, wsnt__InvalidFilterFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidFilterFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidFilterFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__InvalidFilterFaultType(struct soap *soap, const char *URL, wsnt__InvalidFilterFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:InvalidFilterFaultType", p->soap_type() == SOAP_TYPE_wsnt__InvalidFilterFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidFilterFaultType(struct soap*, wsnt__InvalidFilterFaultType *, const char*, const char*);

inline int soap_read_wsnt__InvalidFilterFaultType(struct soap *soap, wsnt__InvalidFilterFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__InvalidFilterFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__InvalidFilterFaultType(struct soap *soap, const char *URL, wsnt__InvalidFilterFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__InvalidFilterFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__InvalidFilterFaultType(struct soap *soap, wsnt__InvalidFilterFaultType *p)
{
	if (::soap_read_wsnt__InvalidFilterFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType_DEFINED
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscribeCreationFailedFaultType(struct soap*, const char*, int, const wsnt__SubscribeCreationFailedFaultType *, const char*);
SOAP_FMAC3 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_wsnt__SubscribeCreationFailedFaultType(struct soap*, const char*, wsnt__SubscribeCreationFailedFaultType *, const char*);
SOAP_FMAC1 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__SubscribeCreationFailedFaultType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__SubscribeCreationFailedFaultType * soap_new_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__SubscribeCreationFailedFaultType(soap, n, NULL, NULL, NULL);
}

inline wsnt__SubscribeCreationFailedFaultType * soap_new_req_wsnt__SubscribeCreationFailedFaultType(
	struct soap *soap,
	time_t Timestamp__1)
{
	wsnt__SubscribeCreationFailedFaultType *_p = ::soap_new_wsnt__SubscribeCreationFailedFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
	}
	return _p;
}

inline wsnt__SubscribeCreationFailedFaultType * soap_new_set_wsnt__SubscribeCreationFailedFaultType(
	struct soap *soap,
	const std::vector<char *> & __any__1,
	time_t Timestamp__1,
	struct wsa5__EndpointReferenceType *Originator__1,
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode__1,
	const std::vector<_wsrfbf__BaseFaultType_Description> & Description__1,
	_wsrfbf__BaseFaultType_FaultCause *FaultCause__1,
	char *__anyAttribute__1,
	char *__item__2)
{
	wsnt__SubscribeCreationFailedFaultType *_p = ::soap_new_wsnt__SubscribeCreationFailedFaultType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrfbf__BaseFaultType::__any = __any__1;
		_p->wsrfbf__BaseFaultType::Timestamp = Timestamp__1;
		_p->wsrfbf__BaseFaultType::Originator = Originator__1;
		_p->wsrfbf__BaseFaultType::ErrorCode = ErrorCode__1;
		_p->wsrfbf__BaseFaultType::Description = Description__1;
		_p->wsrfbf__BaseFaultType::FaultCause = FaultCause__1;
		_p->wsrfbf__BaseFaultType::__anyAttribute = __anyAttribute__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, wsnt__SubscribeCreationFailedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscribeCreationFailedFaultType", p->soap_type() == SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *URL, wsnt__SubscribeCreationFailedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscribeCreationFailedFaultType", p->soap_type() == SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *URL, wsnt__SubscribeCreationFailedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscribeCreationFailedFaultType", p->soap_type() == SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *URL, wsnt__SubscribeCreationFailedFaultType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscribeCreationFailedFaultType", p->soap_type() == SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_wsnt__SubscribeCreationFailedFaultType(struct soap*, wsnt__SubscribeCreationFailedFaultType *, const char*, const char*);

inline int soap_read_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, wsnt__SubscribeCreationFailedFaultType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__SubscribeCreationFailedFaultType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *URL, wsnt__SubscribeCreationFailedFaultType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__SubscribeCreationFailedFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, wsnt__SubscribeCreationFailedFaultType *p)
{
	if (::soap_read_wsnt__SubscribeCreationFailedFaultType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType_DEFINED
#define SOAP_TYPE_wsnt__NotificationMessageHolderType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotificationMessageHolderType(struct soap*, const char*, int, const wsnt__NotificationMessageHolderType *, const char*);
SOAP_FMAC3 wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_in_wsnt__NotificationMessageHolderType(struct soap*, const char*, wsnt__NotificationMessageHolderType *, const char*);
SOAP_FMAC1 wsnt__NotificationMessageHolderType * SOAP_FMAC2 imageing_instantiate_wsnt__NotificationMessageHolderType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__NotificationMessageHolderType * soap_new_wsnt__NotificationMessageHolderType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__NotificationMessageHolderType(soap, n, NULL, NULL, NULL);
}

inline wsnt__NotificationMessageHolderType * soap_new_req_wsnt__NotificationMessageHolderType(
	struct soap *soap,
	const _wsnt__NotificationMessageHolderType_Message& Message)
{
	wsnt__NotificationMessageHolderType *_p = ::soap_new_wsnt__NotificationMessageHolderType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__NotificationMessageHolderType::Message = Message;
	}
	return _p;
}

inline wsnt__NotificationMessageHolderType * soap_new_set_wsnt__NotificationMessageHolderType(
	struct soap *soap,
	struct wsa5__EndpointReferenceType *SubscriptionReference,
	wsnt__TopicExpressionType *Topic,
	struct wsa5__EndpointReferenceType *ProducerReference,
	const _wsnt__NotificationMessageHolderType_Message& Message,
	char *__item__1)
{
	wsnt__NotificationMessageHolderType *_p = ::soap_new_wsnt__NotificationMessageHolderType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__NotificationMessageHolderType::SubscriptionReference = SubscriptionReference;
		_p->wsnt__NotificationMessageHolderType::Topic = Topic;
		_p->wsnt__NotificationMessageHolderType::ProducerReference = ProducerReference;
		_p->wsnt__NotificationMessageHolderType::Message = Message;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_wsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotificationMessageHolderType", p->soap_type() == SOAP_TYPE_wsnt__NotificationMessageHolderType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__NotificationMessageHolderType(struct soap *soap, const char *URL, wsnt__NotificationMessageHolderType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotificationMessageHolderType", p->soap_type() == SOAP_TYPE_wsnt__NotificationMessageHolderType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__NotificationMessageHolderType(struct soap *soap, const char *URL, wsnt__NotificationMessageHolderType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotificationMessageHolderType", p->soap_type() == SOAP_TYPE_wsnt__NotificationMessageHolderType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__NotificationMessageHolderType(struct soap *soap, const char *URL, wsnt__NotificationMessageHolderType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:NotificationMessageHolderType", p->soap_type() == SOAP_TYPE_wsnt__NotificationMessageHolderType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_get_wsnt__NotificationMessageHolderType(struct soap*, wsnt__NotificationMessageHolderType *, const char*, const char*);

inline int soap_read_wsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__NotificationMessageHolderType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__NotificationMessageHolderType(struct soap *soap, const char *URL, wsnt__NotificationMessageHolderType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__NotificationMessageHolderType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType *p)
{
	if (::soap_read_wsnt__NotificationMessageHolderType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType_DEFINED
#define SOAP_TYPE_wsnt__SubscriptionPolicyType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscriptionPolicyType(struct soap*, const char*, int, const wsnt__SubscriptionPolicyType *, const char*);
SOAP_FMAC3 wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_in_wsnt__SubscriptionPolicyType(struct soap*, const char*, wsnt__SubscriptionPolicyType *, const char*);
SOAP_FMAC1 wsnt__SubscriptionPolicyType * SOAP_FMAC2 imageing_instantiate_wsnt__SubscriptionPolicyType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__SubscriptionPolicyType * soap_new_wsnt__SubscriptionPolicyType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__SubscriptionPolicyType(soap, n, NULL, NULL, NULL);
}

inline wsnt__SubscriptionPolicyType * soap_new_req_wsnt__SubscriptionPolicyType(
	struct soap *soap)
{
	wsnt__SubscriptionPolicyType *_p = ::soap_new_wsnt__SubscriptionPolicyType(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsnt__SubscriptionPolicyType * soap_new_set_wsnt__SubscriptionPolicyType(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	wsnt__SubscriptionPolicyType *_p = ::soap_new_wsnt__SubscriptionPolicyType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__SubscriptionPolicyType::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_wsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscriptionPolicyType", p->soap_type() == SOAP_TYPE_wsnt__SubscriptionPolicyType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__SubscriptionPolicyType(struct soap *soap, const char *URL, wsnt__SubscriptionPolicyType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscriptionPolicyType", p->soap_type() == SOAP_TYPE_wsnt__SubscriptionPolicyType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__SubscriptionPolicyType(struct soap *soap, const char *URL, wsnt__SubscriptionPolicyType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscriptionPolicyType", p->soap_type() == SOAP_TYPE_wsnt__SubscriptionPolicyType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__SubscriptionPolicyType(struct soap *soap, const char *URL, wsnt__SubscriptionPolicyType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:SubscriptionPolicyType", p->soap_type() == SOAP_TYPE_wsnt__SubscriptionPolicyType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_get_wsnt__SubscriptionPolicyType(struct soap*, wsnt__SubscriptionPolicyType *, const char*, const char*);

inline int soap_read_wsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__SubscriptionPolicyType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__SubscriptionPolicyType(struct soap *soap, const char *URL, wsnt__SubscriptionPolicyType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__SubscriptionPolicyType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *p)
{
	if (::soap_read_wsnt__SubscriptionPolicyType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__FilterType_DEFINED
#define SOAP_TYPE_wsnt__FilterType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__FilterType(struct soap*, const char*, int, const wsnt__FilterType *, const char*);
SOAP_FMAC3 wsnt__FilterType * SOAP_FMAC4 soap_in_wsnt__FilterType(struct soap*, const char*, wsnt__FilterType *, const char*);
SOAP_FMAC1 wsnt__FilterType * SOAP_FMAC2 imageing_instantiate_wsnt__FilterType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__FilterType * soap_new_wsnt__FilterType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__FilterType(soap, n, NULL, NULL, NULL);
}

inline wsnt__FilterType * soap_new_req_wsnt__FilterType(
	struct soap *soap)
{
	wsnt__FilterType *_p = ::soap_new_wsnt__FilterType(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsnt__FilterType * soap_new_set_wsnt__FilterType(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	wsnt__FilterType *_p = ::soap_new_wsnt__FilterType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__FilterType::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_wsnt__FilterType(struct soap *soap, wsnt__FilterType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:FilterType", p->soap_type() == SOAP_TYPE_wsnt__FilterType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__FilterType(struct soap *soap, const char *URL, wsnt__FilterType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:FilterType", p->soap_type() == SOAP_TYPE_wsnt__FilterType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__FilterType(struct soap *soap, const char *URL, wsnt__FilterType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:FilterType", p->soap_type() == SOAP_TYPE_wsnt__FilterType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__FilterType(struct soap *soap, const char *URL, wsnt__FilterType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:FilterType", p->soap_type() == SOAP_TYPE_wsnt__FilterType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__FilterType * SOAP_FMAC4 soap_get_wsnt__FilterType(struct soap*, wsnt__FilterType *, const char*, const char*);

inline int soap_read_wsnt__FilterType(struct soap *soap, wsnt__FilterType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__FilterType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__FilterType(struct soap *soap, const char *URL, wsnt__FilterType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__FilterType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__FilterType(struct soap *soap, wsnt__FilterType *p)
{
	if (::soap_read_wsnt__FilterType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__TopicExpressionType_DEFINED
#define SOAP_TYPE_wsnt__TopicExpressionType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionType(struct soap*, const char*, int, const wsnt__TopicExpressionType *, const char*);
SOAP_FMAC3 wsnt__TopicExpressionType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionType(struct soap*, const char*, wsnt__TopicExpressionType *, const char*);
SOAP_FMAC1 wsnt__TopicExpressionType * SOAP_FMAC2 imageing_instantiate_wsnt__TopicExpressionType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__TopicExpressionType * soap_new_wsnt__TopicExpressionType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__TopicExpressionType(soap, n, NULL, NULL, NULL);
}

inline wsnt__TopicExpressionType * soap_new_req_wsnt__TopicExpressionType(
	struct soap *soap,
	const std::string& Dialect)
{
	wsnt__TopicExpressionType *_p = ::soap_new_wsnt__TopicExpressionType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__TopicExpressionType::Dialect = Dialect;
	}
	return _p;
}

inline wsnt__TopicExpressionType * soap_new_set_wsnt__TopicExpressionType(
	struct soap *soap,
	char *__any,
	const std::string& Dialect,
	char *__anyAttribute,
	char *__mixed,
	char *__item__1)
{
	wsnt__TopicExpressionType *_p = ::soap_new_wsnt__TopicExpressionType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__TopicExpressionType::__any = __any;
		_p->wsnt__TopicExpressionType::Dialect = Dialect;
		_p->wsnt__TopicExpressionType::__anyAttribute = __anyAttribute;
		_p->wsnt__TopicExpressionType::__mixed = __mixed;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_wsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:TopicExpressionType", p->soap_type() == SOAP_TYPE_wsnt__TopicExpressionType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__TopicExpressionType(struct soap *soap, const char *URL, wsnt__TopicExpressionType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:TopicExpressionType", p->soap_type() == SOAP_TYPE_wsnt__TopicExpressionType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__TopicExpressionType(struct soap *soap, const char *URL, wsnt__TopicExpressionType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:TopicExpressionType", p->soap_type() == SOAP_TYPE_wsnt__TopicExpressionType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__TopicExpressionType(struct soap *soap, const char *URL, wsnt__TopicExpressionType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:TopicExpressionType", p->soap_type() == SOAP_TYPE_wsnt__TopicExpressionType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__TopicExpressionType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionType(struct soap*, wsnt__TopicExpressionType *, const char*, const char*);

inline int soap_read_wsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__TopicExpressionType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__TopicExpressionType(struct soap *soap, const char *URL, wsnt__TopicExpressionType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__TopicExpressionType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType *p)
{
	if (::soap_read_wsnt__TopicExpressionType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsnt__QueryExpressionType_DEFINED
#define SOAP_TYPE_wsnt__QueryExpressionType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__QueryExpressionType(struct soap*, const char*, int, const wsnt__QueryExpressionType *, const char*);
SOAP_FMAC3 wsnt__QueryExpressionType * SOAP_FMAC4 soap_in_wsnt__QueryExpressionType(struct soap*, const char*, wsnt__QueryExpressionType *, const char*);
SOAP_FMAC1 wsnt__QueryExpressionType * SOAP_FMAC2 imageing_instantiate_wsnt__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);

inline wsnt__QueryExpressionType * soap_new_wsnt__QueryExpressionType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsnt__QueryExpressionType(soap, n, NULL, NULL, NULL);
}

inline wsnt__QueryExpressionType * soap_new_req_wsnt__QueryExpressionType(
	struct soap *soap,
	const std::string& Dialect)
{
	wsnt__QueryExpressionType *_p = ::soap_new_wsnt__QueryExpressionType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__QueryExpressionType::Dialect = Dialect;
	}
	return _p;
}

inline wsnt__QueryExpressionType * soap_new_set_wsnt__QueryExpressionType(
	struct soap *soap,
	char *__any,
	const std::string& Dialect,
	char *__mixed,
	char *__item__1)
{
	wsnt__QueryExpressionType *_p = ::soap_new_wsnt__QueryExpressionType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsnt__QueryExpressionType::__any = __any;
		_p->wsnt__QueryExpressionType::Dialect = Dialect;
		_p->wsnt__QueryExpressionType::__mixed = __mixed;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_wsnt__QueryExpressionType(struct soap *soap, wsnt__QueryExpressionType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:QueryExpressionType", p->soap_type() == SOAP_TYPE_wsnt__QueryExpressionType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsnt__QueryExpressionType(struct soap *soap, const char *URL, wsnt__QueryExpressionType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:QueryExpressionType", p->soap_type() == SOAP_TYPE_wsnt__QueryExpressionType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsnt__QueryExpressionType(struct soap *soap, const char *URL, wsnt__QueryExpressionType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:QueryExpressionType", p->soap_type() == SOAP_TYPE_wsnt__QueryExpressionType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsnt__QueryExpressionType(struct soap *soap, const char *URL, wsnt__QueryExpressionType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsnt:QueryExpressionType", p->soap_type() == SOAP_TYPE_wsnt__QueryExpressionType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsnt__QueryExpressionType * SOAP_FMAC4 soap_get_wsnt__QueryExpressionType(struct soap*, wsnt__QueryExpressionType *, const char*, const char*);

inline int soap_read_wsnt__QueryExpressionType(struct soap *soap, wsnt__QueryExpressionType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsnt__QueryExpressionType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsnt__QueryExpressionType(struct soap *soap, const char *URL, wsnt__QueryExpressionType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsnt__QueryExpressionType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsnt__QueryExpressionType(struct soap *soap, wsnt__QueryExpressionType *p)
{
	if (::soap_read_wsnt__QueryExpressionType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__tt__Message_DEFINED
#define SOAP_TYPE__tt__Message_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Message(struct soap*, const char*, int, const _tt__Message *, const char*);
SOAP_FMAC3 _tt__Message * SOAP_FMAC4 soap_in__tt__Message(struct soap*, const char*, _tt__Message *, const char*);
SOAP_FMAC1 _tt__Message * SOAP_FMAC2 imageing_instantiate__tt__Message(struct soap*, int, const char*, const char*, size_t*);

inline _tt__Message * soap_new__tt__Message(struct soap *soap, int n = -1)
{
	return imageing_instantiate__tt__Message(soap, n, NULL, NULL, NULL);
}

inline _tt__Message * soap_new_req__tt__Message(
	struct soap *soap,
	time_t UtcTime)
{
	_tt__Message *_p = ::soap_new__tt__Message(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_tt__Message::UtcTime = UtcTime;
	}
	return _p;
}

inline _tt__Message * soap_new_set__tt__Message(
	struct soap *soap,
	tt__ItemList *Source,
	tt__ItemList *Key,
	tt__ItemList *Data,
	tt__MessageExtension *Extension,
	time_t UtcTime,
	enum tt__PropertyOperation *PropertyOperation,
	char *__anyAttribute)
{
	_tt__Message *_p = ::soap_new__tt__Message(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_tt__Message::Source = Source;
		_p->_tt__Message::Key = Key;
		_p->_tt__Message::Data = Data;
		_p->_tt__Message::Extension = Extension;
		_p->_tt__Message::UtcTime = UtcTime;
		_p->_tt__Message::PropertyOperation = PropertyOperation;
		_p->_tt__Message::__anyAttribute = __anyAttribute;
	}
	return _p;
}

inline int soap_write__tt__Message(struct soap *soap, _tt__Message const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Message", p->soap_type() == SOAP_TYPE__tt__Message ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__tt__Message(struct soap *soap, const char *URL, _tt__Message const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Message", p->soap_type() == SOAP_TYPE__tt__Message ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__tt__Message(struct soap *soap, const char *URL, _tt__Message const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Message", p->soap_type() == SOAP_TYPE__tt__Message ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__tt__Message(struct soap *soap, const char *URL, _tt__Message const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Message", p->soap_type() == SOAP_TYPE__tt__Message ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _tt__Message * SOAP_FMAC4 soap_get__tt__Message(struct soap*, _tt__Message *, const char*, const char*);

inline int soap_read__tt__Message(struct soap *soap, _tt__Message *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__tt__Message(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__tt__Message(struct soap *soap, const char *URL, _tt__Message *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__tt__Message(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__tt__Message(struct soap *soap, _tt__Message *p)
{
	if (::soap_read__tt__Message(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__tt__StringItems_DEFINED
#define SOAP_TYPE__tt__StringItems_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__StringItems(struct soap*, const char*, int, const _tt__StringItems *, const char*);
SOAP_FMAC3 _tt__StringItems * SOAP_FMAC4 soap_in__tt__StringItems(struct soap*, const char*, _tt__StringItems *, const char*);
SOAP_FMAC1 _tt__StringItems * SOAP_FMAC2 imageing_instantiate__tt__StringItems(struct soap*, int, const char*, const char*, size_t*);

inline _tt__StringItems * soap_new__tt__StringItems(struct soap *soap, int n = -1)
{
	return imageing_instantiate__tt__StringItems(soap, n, NULL, NULL, NULL);
}

inline _tt__StringItems * soap_new_req__tt__StringItems(
	struct soap *soap,
	const std::vector<std::string> & Item)
{
	_tt__StringItems *_p = ::soap_new__tt__StringItems(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_tt__StringItems::Item = Item;
	}
	return _p;
}

inline _tt__StringItems * soap_new_set__tt__StringItems(
	struct soap *soap,
	const std::vector<std::string> & Item)
{
	_tt__StringItems *_p = ::soap_new__tt__StringItems(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_tt__StringItems::Item = Item;
	}
	return _p;
}

inline int soap_write__tt__StringItems(struct soap *soap, _tt__StringItems const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:StringItems", p->soap_type() == SOAP_TYPE__tt__StringItems ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__tt__StringItems(struct soap *soap, const char *URL, _tt__StringItems const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:StringItems", p->soap_type() == SOAP_TYPE__tt__StringItems ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__tt__StringItems(struct soap *soap, const char *URL, _tt__StringItems const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:StringItems", p->soap_type() == SOAP_TYPE__tt__StringItems ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__tt__StringItems(struct soap *soap, const char *URL, _tt__StringItems const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:StringItems", p->soap_type() == SOAP_TYPE__tt__StringItems ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _tt__StringItems * SOAP_FMAC4 soap_get__tt__StringItems(struct soap*, _tt__StringItems *, const char*, const char*);

inline int soap_read__tt__StringItems(struct soap *soap, _tt__StringItems *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__tt__StringItems(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__tt__StringItems(struct soap *soap, const char *URL, _tt__StringItems *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__tt__StringItems(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__tt__StringItems(struct soap *soap, _tt__StringItems *p)
{
	if (::soap_read__tt__StringItems(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Polygon_DEFINED
#define SOAP_TYPE_tt__Polygon_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polygon(struct soap*, const char*, int, const tt__Polygon *, const char*);
SOAP_FMAC3 tt__Polygon * SOAP_FMAC4 soap_in_tt__Polygon(struct soap*, const char*, tt__Polygon *, const char*);
SOAP_FMAC1 tt__Polygon * SOAP_FMAC2 imageing_instantiate_tt__Polygon(struct soap*, int, const char*, const char*, size_t*);

inline tt__Polygon * soap_new_tt__Polygon(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Polygon(soap, n, NULL, NULL, NULL);
}

inline tt__Polygon * soap_new_req_tt__Polygon(
	struct soap *soap,
	const std::vector<tt__Vector *> & Point)
{
	tt__Polygon *_p = ::soap_new_tt__Polygon(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Polygon::Point = Point;
	}
	return _p;
}

inline tt__Polygon * soap_new_set_tt__Polygon(
	struct soap *soap,
	const std::vector<tt__Vector *> & Point,
	char *__item__1)
{
	tt__Polygon *_p = ::soap_new_tt__Polygon(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Polygon::Point = Point;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Polygon(struct soap *soap, tt__Polygon const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Polygon", p->soap_type() == SOAP_TYPE_tt__Polygon ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Polygon(struct soap *soap, const char *URL, tt__Polygon const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Polygon", p->soap_type() == SOAP_TYPE_tt__Polygon ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Polygon(struct soap *soap, const char *URL, tt__Polygon const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Polygon", p->soap_type() == SOAP_TYPE_tt__Polygon ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Polygon(struct soap *soap, const char *URL, tt__Polygon const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Polygon", p->soap_type() == SOAP_TYPE_tt__Polygon ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Polygon * SOAP_FMAC4 soap_get_tt__Polygon(struct soap*, tt__Polygon *, const char*, const char*);

inline int soap_read_tt__Polygon(struct soap *soap, tt__Polygon *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Polygon(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Polygon(struct soap *soap, const char *URL, tt__Polygon *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Polygon(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Polygon(struct soap *soap, tt__Polygon *p)
{
	if (::soap_read_tt__Polygon(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Rectangle_DEFINED
#define SOAP_TYPE_tt__Rectangle_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rectangle(struct soap*, const char*, int, const tt__Rectangle *, const char*);
SOAP_FMAC3 tt__Rectangle * SOAP_FMAC4 soap_in_tt__Rectangle(struct soap*, const char*, tt__Rectangle *, const char*);
SOAP_FMAC1 tt__Rectangle * SOAP_FMAC2 imageing_instantiate_tt__Rectangle(struct soap*, int, const char*, const char*, size_t*);

inline tt__Rectangle * soap_new_tt__Rectangle(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Rectangle(soap, n, NULL, NULL, NULL);
}

inline tt__Rectangle * soap_new_req_tt__Rectangle(
	struct soap *soap)
{
	tt__Rectangle *_p = ::soap_new_tt__Rectangle(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__Rectangle * soap_new_set_tt__Rectangle(
	struct soap *soap,
	float *bottom,
	float *top,
	float *right,
	float *left,
	char *__item__1)
{
	tt__Rectangle *_p = ::soap_new_tt__Rectangle(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Rectangle::bottom = bottom;
		_p->tt__Rectangle::top = top;
		_p->tt__Rectangle::right = right;
		_p->tt__Rectangle::left = left;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Rectangle(struct soap *soap, tt__Rectangle const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Rectangle", p->soap_type() == SOAP_TYPE_tt__Rectangle ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Rectangle(struct soap *soap, const char *URL, tt__Rectangle const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Rectangle", p->soap_type() == SOAP_TYPE_tt__Rectangle ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Rectangle(struct soap *soap, const char *URL, tt__Rectangle const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Rectangle", p->soap_type() == SOAP_TYPE_tt__Rectangle ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Rectangle(struct soap *soap, const char *URL, tt__Rectangle const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Rectangle", p->soap_type() == SOAP_TYPE_tt__Rectangle ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Rectangle * SOAP_FMAC4 soap_get_tt__Rectangle(struct soap*, tt__Rectangle *, const char*, const char*);

inline int soap_read_tt__Rectangle(struct soap *soap, tt__Rectangle *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Rectangle(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Rectangle(struct soap *soap, const char *URL, tt__Rectangle *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Rectangle(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Rectangle(struct soap *soap, tt__Rectangle *p)
{
	if (::soap_read_tt__Rectangle(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Vector_DEFINED
#define SOAP_TYPE_tt__Vector_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector(struct soap*, const char*, int, const tt__Vector *, const char*);
SOAP_FMAC3 tt__Vector * SOAP_FMAC4 soap_in_tt__Vector(struct soap*, const char*, tt__Vector *, const char*);
SOAP_FMAC1 tt__Vector * SOAP_FMAC2 imageing_instantiate_tt__Vector(struct soap*, int, const char*, const char*, size_t*);

inline tt__Vector * soap_new_tt__Vector(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Vector(soap, n, NULL, NULL, NULL);
}

inline tt__Vector * soap_new_req_tt__Vector(
	struct soap *soap)
{
	tt__Vector *_p = ::soap_new_tt__Vector(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__Vector * soap_new_set_tt__Vector(
	struct soap *soap,
	float *x,
	float *y,
	char *__item__1)
{
	tt__Vector *_p = ::soap_new_tt__Vector(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Vector::x = x;
		_p->tt__Vector::y = y;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Vector(struct soap *soap, tt__Vector const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Vector", p->soap_type() == SOAP_TYPE_tt__Vector ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Vector(struct soap *soap, const char *URL, tt__Vector const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Vector", p->soap_type() == SOAP_TYPE_tt__Vector ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Vector(struct soap *soap, const char *URL, tt__Vector const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Vector", p->soap_type() == SOAP_TYPE_tt__Vector ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Vector(struct soap *soap, const char *URL, tt__Vector const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Vector", p->soap_type() == SOAP_TYPE_tt__Vector ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Vector * SOAP_FMAC4 soap_get_tt__Vector(struct soap*, tt__Vector *, const char*, const char*);

inline int soap_read_tt__Vector(struct soap *soap, tt__Vector *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Vector(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Vector(struct soap *soap, const char *URL, tt__Vector *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Vector(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Vector(struct soap *soap, tt__Vector *p)
{
	if (::soap_read_tt__Vector(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Vector1D_DEFINED
#define SOAP_TYPE_tt__Vector1D_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector1D(struct soap*, const char*, int, const tt__Vector1D *, const char*);
SOAP_FMAC3 tt__Vector1D * SOAP_FMAC4 soap_in_tt__Vector1D(struct soap*, const char*, tt__Vector1D *, const char*);
SOAP_FMAC1 tt__Vector1D * SOAP_FMAC2 imageing_instantiate_tt__Vector1D(struct soap*, int, const char*, const char*, size_t*);

inline tt__Vector1D * soap_new_tt__Vector1D(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Vector1D(soap, n, NULL, NULL, NULL);
}

inline tt__Vector1D * soap_new_req_tt__Vector1D(
	struct soap *soap,
	float x)
{
	tt__Vector1D *_p = ::soap_new_tt__Vector1D(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Vector1D::x = x;
	}
	return _p;
}

inline tt__Vector1D * soap_new_set_tt__Vector1D(
	struct soap *soap,
	float x,
	std::string *space,
	char *__item__1)
{
	tt__Vector1D *_p = ::soap_new_tt__Vector1D(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Vector1D::x = x;
		_p->tt__Vector1D::space = space;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Vector1D(struct soap *soap, tt__Vector1D const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Vector1D", p->soap_type() == SOAP_TYPE_tt__Vector1D ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Vector1D(struct soap *soap, const char *URL, tt__Vector1D const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Vector1D", p->soap_type() == SOAP_TYPE_tt__Vector1D ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Vector1D(struct soap *soap, const char *URL, tt__Vector1D const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Vector1D", p->soap_type() == SOAP_TYPE_tt__Vector1D ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Vector1D(struct soap *soap, const char *URL, tt__Vector1D const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Vector1D", p->soap_type() == SOAP_TYPE_tt__Vector1D ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Vector1D * SOAP_FMAC4 soap_get_tt__Vector1D(struct soap*, tt__Vector1D *, const char*, const char*);

inline int soap_read_tt__Vector1D(struct soap *soap, tt__Vector1D *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Vector1D(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Vector1D(struct soap *soap, const char *URL, tt__Vector1D *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Vector1D(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Vector1D(struct soap *soap, tt__Vector1D *p)
{
	if (::soap_read_tt__Vector1D(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Vector2D_DEFINED
#define SOAP_TYPE_tt__Vector2D_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector2D(struct soap*, const char*, int, const tt__Vector2D *, const char*);
SOAP_FMAC3 tt__Vector2D * SOAP_FMAC4 soap_in_tt__Vector2D(struct soap*, const char*, tt__Vector2D *, const char*);
SOAP_FMAC1 tt__Vector2D * SOAP_FMAC2 imageing_instantiate_tt__Vector2D(struct soap*, int, const char*, const char*, size_t*);

inline tt__Vector2D * soap_new_tt__Vector2D(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Vector2D(soap, n, NULL, NULL, NULL);
}

inline tt__Vector2D * soap_new_req_tt__Vector2D(
	struct soap *soap,
	float x,
	float y)
{
	tt__Vector2D *_p = ::soap_new_tt__Vector2D(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Vector2D::x = x;
		_p->tt__Vector2D::y = y;
	}
	return _p;
}

inline tt__Vector2D * soap_new_set_tt__Vector2D(
	struct soap *soap,
	float x,
	float y,
	std::string *space,
	char *__item__1)
{
	tt__Vector2D *_p = ::soap_new_tt__Vector2D(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Vector2D::x = x;
		_p->tt__Vector2D::y = y;
		_p->tt__Vector2D::space = space;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Vector2D(struct soap *soap, tt__Vector2D const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Vector2D", p->soap_type() == SOAP_TYPE_tt__Vector2D ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Vector2D(struct soap *soap, const char *URL, tt__Vector2D const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Vector2D", p->soap_type() == SOAP_TYPE_tt__Vector2D ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Vector2D(struct soap *soap, const char *URL, tt__Vector2D const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Vector2D", p->soap_type() == SOAP_TYPE_tt__Vector2D ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Vector2D(struct soap *soap, const char *URL, tt__Vector2D const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Vector2D", p->soap_type() == SOAP_TYPE_tt__Vector2D ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Vector2D * SOAP_FMAC4 soap_get_tt__Vector2D(struct soap*, tt__Vector2D *, const char*, const char*);

inline int soap_read_tt__Vector2D(struct soap *soap, tt__Vector2D *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Vector2D(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Vector2D(struct soap *soap, const char *URL, tt__Vector2D *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Vector2D(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Vector2D(struct soap *soap, tt__Vector2D *p)
{
	if (::soap_read_tt__Vector2D(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IntRange_DEFINED
#define SOAP_TYPE_tt__IntRange_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRange(struct soap*, const char*, int, const tt__IntRange *, const char*);
SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_in_tt__IntRange(struct soap*, const char*, tt__IntRange *, const char*);
SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 imageing_instantiate_tt__IntRange(struct soap*, int, const char*, const char*, size_t*);

inline tt__IntRange * soap_new_tt__IntRange(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__IntRange(soap, n, NULL, NULL, NULL);
}

inline tt__IntRange * soap_new_req_tt__IntRange(
	struct soap *soap,
	int Min,
	int Max)
{
	tt__IntRange *_p = ::soap_new_tt__IntRange(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IntRange::Min = Min;
		_p->tt__IntRange::Max = Max;
	}
	return _p;
}

inline tt__IntRange * soap_new_set_tt__IntRange(
	struct soap *soap,
	int Min,
	int Max,
	char *__item__1)
{
	tt__IntRange *_p = ::soap_new_tt__IntRange(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IntRange::Min = Min;
		_p->tt__IntRange::Max = Max;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__IntRange(struct soap *soap, tt__IntRange const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IntRange", p->soap_type() == SOAP_TYPE_tt__IntRange ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__IntRange(struct soap *soap, const char *URL, tt__IntRange const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IntRange", p->soap_type() == SOAP_TYPE_tt__IntRange ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IntRange(struct soap *soap, const char *URL, tt__IntRange const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IntRange", p->soap_type() == SOAP_TYPE_tt__IntRange ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IntRange(struct soap *soap, const char *URL, tt__IntRange const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IntRange", p->soap_type() == SOAP_TYPE_tt__IntRange ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_get_tt__IntRange(struct soap*, tt__IntRange *, const char*, const char*);

inline int soap_read_tt__IntRange(struct soap *soap, tt__IntRange *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__IntRange(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IntRange(struct soap *soap, const char *URL, tt__IntRange *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IntRange(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IntRange(struct soap *soap, tt__IntRange *p)
{
	if (::soap_read_tt__IntRange(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__PolygonOptions_DEFINED
#define SOAP_TYPE_tt__PolygonOptions_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolygonOptions(struct soap*, const char*, int, const tt__PolygonOptions *, const char*);
SOAP_FMAC3 tt__PolygonOptions * SOAP_FMAC4 soap_in_tt__PolygonOptions(struct soap*, const char*, tt__PolygonOptions *, const char*);
SOAP_FMAC1 tt__PolygonOptions * SOAP_FMAC2 imageing_instantiate_tt__PolygonOptions(struct soap*, int, const char*, const char*, size_t*);

inline tt__PolygonOptions * soap_new_tt__PolygonOptions(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__PolygonOptions(soap, n, NULL, NULL, NULL);
}

inline tt__PolygonOptions * soap_new_req_tt__PolygonOptions(
	struct soap *soap)
{
	tt__PolygonOptions *_p = ::soap_new_tt__PolygonOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__PolygonOptions * soap_new_set_tt__PolygonOptions(
	struct soap *soap,
	bool *RectangleOnly,
	tt__IntRange *VertexLimits,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	char *__item__1)
{
	tt__PolygonOptions *_p = ::soap_new_tt__PolygonOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PolygonOptions::RectangleOnly = RectangleOnly;
		_p->tt__PolygonOptions::VertexLimits = VertexLimits;
		_p->tt__PolygonOptions::__any = __any;
		_p->tt__PolygonOptions::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__PolygonOptions(struct soap *soap, tt__PolygonOptions const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PolygonOptions", p->soap_type() == SOAP_TYPE_tt__PolygonOptions ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__PolygonOptions(struct soap *soap, const char *URL, tt__PolygonOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PolygonOptions", p->soap_type() == SOAP_TYPE_tt__PolygonOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__PolygonOptions(struct soap *soap, const char *URL, tt__PolygonOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PolygonOptions", p->soap_type() == SOAP_TYPE_tt__PolygonOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__PolygonOptions(struct soap *soap, const char *URL, tt__PolygonOptions const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PolygonOptions", p->soap_type() == SOAP_TYPE_tt__PolygonOptions ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__PolygonOptions * SOAP_FMAC4 soap_get_tt__PolygonOptions(struct soap*, tt__PolygonOptions *, const char*, const char*);

inline int soap_read_tt__PolygonOptions(struct soap *soap, tt__PolygonOptions *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__PolygonOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__PolygonOptions(struct soap *soap, const char *URL, tt__PolygonOptions *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__PolygonOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__PolygonOptions(struct soap *soap, tt__PolygonOptions *p)
{
	if (::soap_read_tt__PolygonOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Config_DEFINED
#define SOAP_TYPE_tt__Config_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Config(struct soap*, const char*, int, const tt__Config *, const char*);
SOAP_FMAC3 tt__Config * SOAP_FMAC4 soap_in_tt__Config(struct soap*, const char*, tt__Config *, const char*);
SOAP_FMAC1 tt__Config * SOAP_FMAC2 imageing_instantiate_tt__Config(struct soap*, int, const char*, const char*, size_t*);

inline tt__Config * soap_new_tt__Config(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Config(soap, n, NULL, NULL, NULL);
}

inline tt__Config * soap_new_req_tt__Config(
	struct soap *soap,
	tt__ItemList *Parameters,
	const std::string& Name,
	const std::string& Type)
{
	tt__Config *_p = ::soap_new_tt__Config(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Config::Parameters = Parameters;
		_p->tt__Config::Name = Name;
		_p->tt__Config::Type = Type;
	}
	return _p;
}

inline tt__Config * soap_new_set_tt__Config(
	struct soap *soap,
	tt__ItemList *Parameters,
	const std::string& Name,
	const std::string& Type,
	char *__item__1)
{
	tt__Config *_p = ::soap_new_tt__Config(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Config::Parameters = Parameters;
		_p->tt__Config::Name = Name;
		_p->tt__Config::Type = Type;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Config(struct soap *soap, tt__Config const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Config", p->soap_type() == SOAP_TYPE_tt__Config ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Config(struct soap *soap, const char *URL, tt__Config const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Config", p->soap_type() == SOAP_TYPE_tt__Config ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Config(struct soap *soap, const char *URL, tt__Config const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Config", p->soap_type() == SOAP_TYPE_tt__Config ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Config(struct soap *soap, const char *URL, tt__Config const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Config", p->soap_type() == SOAP_TYPE_tt__Config ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Config * SOAP_FMAC4 soap_get_tt__Config(struct soap*, tt__Config *, const char*, const char*);

inline int soap_read_tt__Config(struct soap *soap, tt__Config *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Config(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Config(struct soap *soap, const char *URL, tt__Config *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Config(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Config(struct soap *soap, tt__Config *p)
{
	if (::soap_read_tt__Config(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension_DEFINED
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfigurationExtension(struct soap*, const char*, int, const tt__RuleEngineConfigurationExtension *, const char*);
SOAP_FMAC3 tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__RuleEngineConfigurationExtension(struct soap*, const char*, tt__RuleEngineConfigurationExtension *, const char*);
SOAP_FMAC1 tt__RuleEngineConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__RuleEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__RuleEngineConfigurationExtension * soap_new_tt__RuleEngineConfigurationExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__RuleEngineConfigurationExtension(soap, n, NULL, NULL, NULL);
}

inline tt__RuleEngineConfigurationExtension * soap_new_req_tt__RuleEngineConfigurationExtension(
	struct soap *soap)
{
	tt__RuleEngineConfigurationExtension *_p = ::soap_new_tt__RuleEngineConfigurationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__RuleEngineConfigurationExtension * soap_new_set_tt__RuleEngineConfigurationExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__RuleEngineConfigurationExtension *_p = ::soap_new_tt__RuleEngineConfigurationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__RuleEngineConfigurationExtension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RuleEngineConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__RuleEngineConfigurationExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *URL, tt__RuleEngineConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RuleEngineConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__RuleEngineConfigurationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *URL, tt__RuleEngineConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RuleEngineConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__RuleEngineConfigurationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *URL, tt__RuleEngineConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RuleEngineConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__RuleEngineConfigurationExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__RuleEngineConfigurationExtension(struct soap*, tt__RuleEngineConfigurationExtension *, const char*, const char*);

inline int soap_read_tt__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__RuleEngineConfigurationExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *URL, tt__RuleEngineConfigurationExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__RuleEngineConfigurationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *p)
{
	if (::soap_read_tt__RuleEngineConfigurationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__RuleEngineConfiguration_DEFINED
#define SOAP_TYPE_tt__RuleEngineConfiguration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfiguration(struct soap*, const char*, int, const tt__RuleEngineConfiguration *, const char*);
SOAP_FMAC3 tt__RuleEngineConfiguration * SOAP_FMAC4 soap_in_tt__RuleEngineConfiguration(struct soap*, const char*, tt__RuleEngineConfiguration *, const char*);
SOAP_FMAC1 tt__RuleEngineConfiguration * SOAP_FMAC2 imageing_instantiate_tt__RuleEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);

inline tt__RuleEngineConfiguration * soap_new_tt__RuleEngineConfiguration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__RuleEngineConfiguration(soap, n, NULL, NULL, NULL);
}

inline tt__RuleEngineConfiguration * soap_new_req_tt__RuleEngineConfiguration(
	struct soap *soap)
{
	tt__RuleEngineConfiguration *_p = ::soap_new_tt__RuleEngineConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__RuleEngineConfiguration * soap_new_set_tt__RuleEngineConfiguration(
	struct soap *soap,
	const std::vector<tt__Config *> & Rule,
	tt__RuleEngineConfigurationExtension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__RuleEngineConfiguration *_p = ::soap_new_tt__RuleEngineConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__RuleEngineConfiguration::Rule = Rule;
		_p->tt__RuleEngineConfiguration::Extension = Extension;
		_p->tt__RuleEngineConfiguration::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RuleEngineConfiguration", p->soap_type() == SOAP_TYPE_tt__RuleEngineConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__RuleEngineConfiguration(struct soap *soap, const char *URL, tt__RuleEngineConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RuleEngineConfiguration", p->soap_type() == SOAP_TYPE_tt__RuleEngineConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__RuleEngineConfiguration(struct soap *soap, const char *URL, tt__RuleEngineConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RuleEngineConfiguration", p->soap_type() == SOAP_TYPE_tt__RuleEngineConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__RuleEngineConfiguration(struct soap *soap, const char *URL, tt__RuleEngineConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RuleEngineConfiguration", p->soap_type() == SOAP_TYPE_tt__RuleEngineConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__RuleEngineConfiguration * SOAP_FMAC4 soap_get_tt__RuleEngineConfiguration(struct soap*, tt__RuleEngineConfiguration *, const char*, const char*);

inline int soap_read_tt__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__RuleEngineConfiguration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__RuleEngineConfiguration(struct soap *soap, const char *URL, tt__RuleEngineConfiguration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__RuleEngineConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *p)
{
	if (::soap_read_tt__RuleEngineConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension_DEFINED
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfigurationExtension(struct soap*, const char*, int, const tt__AnalyticsEngineConfigurationExtension *, const char*);
SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfigurationExtension(struct soap*, const char*, tt__AnalyticsEngineConfigurationExtension *, const char*);
SOAP_FMAC1 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__AnalyticsEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__AnalyticsEngineConfigurationExtension * soap_new_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__AnalyticsEngineConfigurationExtension(soap, n, NULL, NULL, NULL);
}

inline tt__AnalyticsEngineConfigurationExtension * soap_new_req_tt__AnalyticsEngineConfigurationExtension(
	struct soap *soap)
{
	tt__AnalyticsEngineConfigurationExtension *_p = ::soap_new_tt__AnalyticsEngineConfigurationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__AnalyticsEngineConfigurationExtension * soap_new_set_tt__AnalyticsEngineConfigurationExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__AnalyticsEngineConfigurationExtension *_p = ::soap_new_tt__AnalyticsEngineConfigurationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AnalyticsEngineConfigurationExtension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AnalyticsEngineConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *URL, tt__AnalyticsEngineConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AnalyticsEngineConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *URL, tt__AnalyticsEngineConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AnalyticsEngineConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *URL, tt__AnalyticsEngineConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AnalyticsEngineConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfigurationExtension(struct soap*, tt__AnalyticsEngineConfigurationExtension *, const char*, const char*);

inline int soap_read_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__AnalyticsEngineConfigurationExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *URL, tt__AnalyticsEngineConfigurationExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__AnalyticsEngineConfigurationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *p)
{
	if (::soap_read_tt__AnalyticsEngineConfigurationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration_DEFINED
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfiguration(struct soap*, const char*, int, const tt__AnalyticsEngineConfiguration *, const char*);
SOAP_FMAC3 tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfiguration(struct soap*, const char*, tt__AnalyticsEngineConfiguration *, const char*);
SOAP_FMAC1 tt__AnalyticsEngineConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AnalyticsEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);

inline tt__AnalyticsEngineConfiguration * soap_new_tt__AnalyticsEngineConfiguration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__AnalyticsEngineConfiguration(soap, n, NULL, NULL, NULL);
}

inline tt__AnalyticsEngineConfiguration * soap_new_req_tt__AnalyticsEngineConfiguration(
	struct soap *soap)
{
	tt__AnalyticsEngineConfiguration *_p = ::soap_new_tt__AnalyticsEngineConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__AnalyticsEngineConfiguration * soap_new_set_tt__AnalyticsEngineConfiguration(
	struct soap *soap,
	const std::vector<tt__Config *> & AnalyticsModule,
	tt__AnalyticsEngineConfigurationExtension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__AnalyticsEngineConfiguration *_p = ::soap_new_tt__AnalyticsEngineConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AnalyticsEngineConfiguration::AnalyticsModule = AnalyticsModule;
		_p->tt__AnalyticsEngineConfiguration::Extension = Extension;
		_p->tt__AnalyticsEngineConfiguration::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AnalyticsEngineConfiguration", p->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *URL, tt__AnalyticsEngineConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AnalyticsEngineConfiguration", p->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *URL, tt__AnalyticsEngineConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AnalyticsEngineConfiguration", p->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *URL, tt__AnalyticsEngineConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AnalyticsEngineConfiguration", p->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfiguration(struct soap*, tt__AnalyticsEngineConfiguration *, const char*, const char*);

inline int soap_read_tt__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__AnalyticsEngineConfiguration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *URL, tt__AnalyticsEngineConfiguration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__AnalyticsEngineConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *p)
{
	if (::soap_read_tt__AnalyticsEngineConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Polyline_DEFINED
#define SOAP_TYPE_tt__Polyline_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polyline(struct soap*, const char*, int, const tt__Polyline *, const char*);
SOAP_FMAC3 tt__Polyline * SOAP_FMAC4 soap_in_tt__Polyline(struct soap*, const char*, tt__Polyline *, const char*);
SOAP_FMAC1 tt__Polyline * SOAP_FMAC2 imageing_instantiate_tt__Polyline(struct soap*, int, const char*, const char*, size_t*);

inline tt__Polyline * soap_new_tt__Polyline(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Polyline(soap, n, NULL, NULL, NULL);
}

inline tt__Polyline * soap_new_req_tt__Polyline(
	struct soap *soap,
	const std::vector<tt__Vector *> & Point)
{
	tt__Polyline *_p = ::soap_new_tt__Polyline(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Polyline::Point = Point;
	}
	return _p;
}

inline tt__Polyline * soap_new_set_tt__Polyline(
	struct soap *soap,
	const std::vector<tt__Vector *> & Point,
	char *__item__1)
{
	tt__Polyline *_p = ::soap_new_tt__Polyline(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Polyline::Point = Point;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Polyline(struct soap *soap, tt__Polyline const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Polyline", p->soap_type() == SOAP_TYPE_tt__Polyline ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Polyline(struct soap *soap, const char *URL, tt__Polyline const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Polyline", p->soap_type() == SOAP_TYPE_tt__Polyline ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Polyline(struct soap *soap, const char *URL, tt__Polyline const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Polyline", p->soap_type() == SOAP_TYPE_tt__Polyline ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Polyline(struct soap *soap, const char *URL, tt__Polyline const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Polyline", p->soap_type() == SOAP_TYPE_tt__Polyline ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Polyline * SOAP_FMAC4 soap_get_tt__Polyline(struct soap*, tt__Polyline *, const char*, const char*);

inline int soap_read_tt__Polyline(struct soap *soap, tt__Polyline *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Polyline(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Polyline(struct soap *soap, const char *URL, tt__Polyline *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Polyline(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Polyline(struct soap *soap, tt__Polyline *p)
{
	if (::soap_read_tt__Polyline(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ItemListExtension_DEFINED
#define SOAP_TYPE_tt__ItemListExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListExtension(struct soap*, const char*, int, const tt__ItemListExtension *, const char*);
SOAP_FMAC3 tt__ItemListExtension * SOAP_FMAC4 soap_in_tt__ItemListExtension(struct soap*, const char*, tt__ItemListExtension *, const char*);
SOAP_FMAC1 tt__ItemListExtension * SOAP_FMAC2 imageing_instantiate_tt__ItemListExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__ItemListExtension * soap_new_tt__ItemListExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ItemListExtension(soap, n, NULL, NULL, NULL);
}

inline tt__ItemListExtension * soap_new_req_tt__ItemListExtension(
	struct soap *soap)
{
	tt__ItemListExtension *_p = ::soap_new_tt__ItemListExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ItemListExtension * soap_new_set_tt__ItemListExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__ItemListExtension *_p = ::soap_new_tt__ItemListExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ItemListExtension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ItemListExtension(struct soap *soap, tt__ItemListExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemListExtension", p->soap_type() == SOAP_TYPE_tt__ItemListExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ItemListExtension(struct soap *soap, const char *URL, tt__ItemListExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemListExtension", p->soap_type() == SOAP_TYPE_tt__ItemListExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ItemListExtension(struct soap *soap, const char *URL, tt__ItemListExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemListExtension", p->soap_type() == SOAP_TYPE_tt__ItemListExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ItemListExtension(struct soap *soap, const char *URL, tt__ItemListExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemListExtension", p->soap_type() == SOAP_TYPE_tt__ItemListExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ItemListExtension * SOAP_FMAC4 soap_get_tt__ItemListExtension(struct soap*, tt__ItemListExtension *, const char*, const char*);

inline int soap_read_tt__ItemListExtension(struct soap *soap, tt__ItemListExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ItemListExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ItemListExtension(struct soap *soap, const char *URL, tt__ItemListExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ItemListExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ItemListExtension(struct soap *soap, tt__ItemListExtension *p)
{
	if (::soap_read_tt__ItemListExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ItemList_DEFINED
#define SOAP_TYPE_tt__ItemList_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemList(struct soap*, const char*, int, const tt__ItemList *, const char*);
SOAP_FMAC3 tt__ItemList * SOAP_FMAC4 soap_in_tt__ItemList(struct soap*, const char*, tt__ItemList *, const char*);
SOAP_FMAC1 tt__ItemList * SOAP_FMAC2 imageing_instantiate_tt__ItemList(struct soap*, int, const char*, const char*, size_t*);

inline tt__ItemList * soap_new_tt__ItemList(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ItemList(soap, n, NULL, NULL, NULL);
}

inline tt__ItemList * soap_new_req_tt__ItemList(
	struct soap *soap)
{
	tt__ItemList *_p = ::soap_new_tt__ItemList(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ItemList * soap_new_set_tt__ItemList(
	struct soap *soap,
	const std::vector<_tt__ItemList_SimpleItem> & SimpleItem,
	const std::vector<_tt__ItemList_ElementItem> & ElementItem,
	tt__ItemListExtension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__ItemList *_p = ::soap_new_tt__ItemList(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ItemList::SimpleItem = SimpleItem;
		_p->tt__ItemList::ElementItem = ElementItem;
		_p->tt__ItemList::Extension = Extension;
		_p->tt__ItemList::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ItemList(struct soap *soap, tt__ItemList const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemList", p->soap_type() == SOAP_TYPE_tt__ItemList ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ItemList(struct soap *soap, const char *URL, tt__ItemList const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemList", p->soap_type() == SOAP_TYPE_tt__ItemList ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ItemList(struct soap *soap, const char *URL, tt__ItemList const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemList", p->soap_type() == SOAP_TYPE_tt__ItemList ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ItemList(struct soap *soap, const char *URL, tt__ItemList const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ItemList", p->soap_type() == SOAP_TYPE_tt__ItemList ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ItemList * SOAP_FMAC4 soap_get_tt__ItemList(struct soap*, tt__ItemList *, const char*, const char*);

inline int soap_read_tt__ItemList(struct soap *soap, tt__ItemList *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ItemList(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ItemList(struct soap *soap, const char *URL, tt__ItemList *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ItemList(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ItemList(struct soap *soap, tt__ItemList *p)
{
	if (::soap_read_tt__ItemList(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__MessageExtension_DEFINED
#define SOAP_TYPE_tt__MessageExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageExtension(struct soap*, const char*, int, const tt__MessageExtension *, const char*);
SOAP_FMAC3 tt__MessageExtension * SOAP_FMAC4 soap_in_tt__MessageExtension(struct soap*, const char*, tt__MessageExtension *, const char*);
SOAP_FMAC1 tt__MessageExtension * SOAP_FMAC2 imageing_instantiate_tt__MessageExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__MessageExtension * soap_new_tt__MessageExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__MessageExtension(soap, n, NULL, NULL, NULL);
}

inline tt__MessageExtension * soap_new_req_tt__MessageExtension(
	struct soap *soap)
{
	tt__MessageExtension *_p = ::soap_new_tt__MessageExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__MessageExtension * soap_new_set_tt__MessageExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__MessageExtension *_p = ::soap_new_tt__MessageExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__MessageExtension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__MessageExtension(struct soap *soap, tt__MessageExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MessageExtension", p->soap_type() == SOAP_TYPE_tt__MessageExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__MessageExtension(struct soap *soap, const char *URL, tt__MessageExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MessageExtension", p->soap_type() == SOAP_TYPE_tt__MessageExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__MessageExtension(struct soap *soap, const char *URL, tt__MessageExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MessageExtension", p->soap_type() == SOAP_TYPE_tt__MessageExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__MessageExtension(struct soap *soap, const char *URL, tt__MessageExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MessageExtension", p->soap_type() == SOAP_TYPE_tt__MessageExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__MessageExtension * SOAP_FMAC4 soap_get_tt__MessageExtension(struct soap*, tt__MessageExtension *, const char*, const char*);

inline int soap_read_tt__MessageExtension(struct soap *soap, tt__MessageExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__MessageExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__MessageExtension(struct soap *soap, const char *URL, tt__MessageExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__MessageExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__MessageExtension(struct soap *soap, tt__MessageExtension *p)
{
	if (::soap_read_tt__MessageExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__NoiseReductionOptions_DEFINED
#define SOAP_TYPE_tt__NoiseReductionOptions_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NoiseReductionOptions(struct soap*, const char*, int, const tt__NoiseReductionOptions *, const char*);
SOAP_FMAC3 tt__NoiseReductionOptions * SOAP_FMAC4 soap_in_tt__NoiseReductionOptions(struct soap*, const char*, tt__NoiseReductionOptions *, const char*);
SOAP_FMAC1 tt__NoiseReductionOptions * SOAP_FMAC2 imageing_instantiate_tt__NoiseReductionOptions(struct soap*, int, const char*, const char*, size_t*);

inline tt__NoiseReductionOptions * soap_new_tt__NoiseReductionOptions(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__NoiseReductionOptions(soap, n, NULL, NULL, NULL);
}

inline tt__NoiseReductionOptions * soap_new_req_tt__NoiseReductionOptions(
	struct soap *soap,
	bool Level)
{
	tt__NoiseReductionOptions *_p = ::soap_new_tt__NoiseReductionOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__NoiseReductionOptions::Level = Level;
	}
	return _p;
}

inline tt__NoiseReductionOptions * soap_new_set_tt__NoiseReductionOptions(
	struct soap *soap,
	bool Level,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	char *__item__1)
{
	tt__NoiseReductionOptions *_p = ::soap_new_tt__NoiseReductionOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__NoiseReductionOptions::Level = Level;
		_p->tt__NoiseReductionOptions::__any = __any;
		_p->tt__NoiseReductionOptions::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:NoiseReductionOptions", p->soap_type() == SOAP_TYPE_tt__NoiseReductionOptions ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__NoiseReductionOptions(struct soap *soap, const char *URL, tt__NoiseReductionOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:NoiseReductionOptions", p->soap_type() == SOAP_TYPE_tt__NoiseReductionOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__NoiseReductionOptions(struct soap *soap, const char *URL, tt__NoiseReductionOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:NoiseReductionOptions", p->soap_type() == SOAP_TYPE_tt__NoiseReductionOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__NoiseReductionOptions(struct soap *soap, const char *URL, tt__NoiseReductionOptions const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:NoiseReductionOptions", p->soap_type() == SOAP_TYPE_tt__NoiseReductionOptions ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__NoiseReductionOptions * SOAP_FMAC4 soap_get_tt__NoiseReductionOptions(struct soap*, tt__NoiseReductionOptions *, const char*, const char*);

inline int soap_read_tt__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__NoiseReductionOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__NoiseReductionOptions(struct soap *soap, const char *URL, tt__NoiseReductionOptions *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__NoiseReductionOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions *p)
{
	if (::soap_read_tt__NoiseReductionOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__DefoggingOptions_DEFINED
#define SOAP_TYPE_tt__DefoggingOptions_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingOptions(struct soap*, const char*, int, const tt__DefoggingOptions *, const char*);
SOAP_FMAC3 tt__DefoggingOptions * SOAP_FMAC4 soap_in_tt__DefoggingOptions(struct soap*, const char*, tt__DefoggingOptions *, const char*);
SOAP_FMAC1 tt__DefoggingOptions * SOAP_FMAC2 imageing_instantiate_tt__DefoggingOptions(struct soap*, int, const char*, const char*, size_t*);

inline tt__DefoggingOptions * soap_new_tt__DefoggingOptions(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__DefoggingOptions(soap, n, NULL, NULL, NULL);
}

inline tt__DefoggingOptions * soap_new_req_tt__DefoggingOptions(
	struct soap *soap,
	const std::vector<std::string> & Mode,
	bool Level)
{
	tt__DefoggingOptions *_p = ::soap_new_tt__DefoggingOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__DefoggingOptions::Mode = Mode;
		_p->tt__DefoggingOptions::Level = Level;
	}
	return _p;
}

inline tt__DefoggingOptions * soap_new_set_tt__DefoggingOptions(
	struct soap *soap,
	const std::vector<std::string> & Mode,
	bool Level,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	char *__item__1)
{
	tt__DefoggingOptions *_p = ::soap_new_tt__DefoggingOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__DefoggingOptions::Mode = Mode;
		_p->tt__DefoggingOptions::Level = Level;
		_p->tt__DefoggingOptions::__any = __any;
		_p->tt__DefoggingOptions::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__DefoggingOptions(struct soap *soap, tt__DefoggingOptions const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:DefoggingOptions", p->soap_type() == SOAP_TYPE_tt__DefoggingOptions ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__DefoggingOptions(struct soap *soap, const char *URL, tt__DefoggingOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:DefoggingOptions", p->soap_type() == SOAP_TYPE_tt__DefoggingOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__DefoggingOptions(struct soap *soap, const char *URL, tt__DefoggingOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:DefoggingOptions", p->soap_type() == SOAP_TYPE_tt__DefoggingOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__DefoggingOptions(struct soap *soap, const char *URL, tt__DefoggingOptions const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:DefoggingOptions", p->soap_type() == SOAP_TYPE_tt__DefoggingOptions ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__DefoggingOptions * SOAP_FMAC4 soap_get_tt__DefoggingOptions(struct soap*, tt__DefoggingOptions *, const char*, const char*);

inline int soap_read_tt__DefoggingOptions(struct soap *soap, tt__DefoggingOptions *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__DefoggingOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__DefoggingOptions(struct soap *soap, const char *URL, tt__DefoggingOptions *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__DefoggingOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__DefoggingOptions(struct soap *soap, tt__DefoggingOptions *p)
{
	if (::soap_read_tt__DefoggingOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ToneCompensationOptions_DEFINED
#define SOAP_TYPE_tt__ToneCompensationOptions_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationOptions(struct soap*, const char*, int, const tt__ToneCompensationOptions *, const char*);
SOAP_FMAC3 tt__ToneCompensationOptions * SOAP_FMAC4 soap_in_tt__ToneCompensationOptions(struct soap*, const char*, tt__ToneCompensationOptions *, const char*);
SOAP_FMAC1 tt__ToneCompensationOptions * SOAP_FMAC2 imageing_instantiate_tt__ToneCompensationOptions(struct soap*, int, const char*, const char*, size_t*);

inline tt__ToneCompensationOptions * soap_new_tt__ToneCompensationOptions(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ToneCompensationOptions(soap, n, NULL, NULL, NULL);
}

inline tt__ToneCompensationOptions * soap_new_req_tt__ToneCompensationOptions(
	struct soap *soap,
	const std::vector<std::string> & Mode,
	bool Level)
{
	tt__ToneCompensationOptions *_p = ::soap_new_tt__ToneCompensationOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ToneCompensationOptions::Mode = Mode;
		_p->tt__ToneCompensationOptions::Level = Level;
	}
	return _p;
}

inline tt__ToneCompensationOptions * soap_new_set_tt__ToneCompensationOptions(
	struct soap *soap,
	const std::vector<std::string> & Mode,
	bool Level,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	char *__item__1)
{
	tt__ToneCompensationOptions *_p = ::soap_new_tt__ToneCompensationOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ToneCompensationOptions::Mode = Mode;
		_p->tt__ToneCompensationOptions::Level = Level;
		_p->tt__ToneCompensationOptions::__any = __any;
		_p->tt__ToneCompensationOptions::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ToneCompensationOptions", p->soap_type() == SOAP_TYPE_tt__ToneCompensationOptions ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ToneCompensationOptions(struct soap *soap, const char *URL, tt__ToneCompensationOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ToneCompensationOptions", p->soap_type() == SOAP_TYPE_tt__ToneCompensationOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ToneCompensationOptions(struct soap *soap, const char *URL, tt__ToneCompensationOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ToneCompensationOptions", p->soap_type() == SOAP_TYPE_tt__ToneCompensationOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ToneCompensationOptions(struct soap *soap, const char *URL, tt__ToneCompensationOptions const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ToneCompensationOptions", p->soap_type() == SOAP_TYPE_tt__ToneCompensationOptions ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ToneCompensationOptions * SOAP_FMAC4 soap_get_tt__ToneCompensationOptions(struct soap*, tt__ToneCompensationOptions *, const char*, const char*);

inline int soap_read_tt__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ToneCompensationOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ToneCompensationOptions(struct soap *soap, const char *URL, tt__ToneCompensationOptions *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ToneCompensationOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions *p)
{
	if (::soap_read_tt__ToneCompensationOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__FocusOptions20Extension_DEFINED
#define SOAP_TYPE_tt__FocusOptions20Extension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20Extension(struct soap*, const char*, int, const tt__FocusOptions20Extension *, const char*);
SOAP_FMAC3 tt__FocusOptions20Extension * SOAP_FMAC4 soap_in_tt__FocusOptions20Extension(struct soap*, const char*, tt__FocusOptions20Extension *, const char*);
SOAP_FMAC1 tt__FocusOptions20Extension * SOAP_FMAC2 imageing_instantiate_tt__FocusOptions20Extension(struct soap*, int, const char*, const char*, size_t*);

inline tt__FocusOptions20Extension * soap_new_tt__FocusOptions20Extension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__FocusOptions20Extension(soap, n, NULL, NULL, NULL);
}

inline tt__FocusOptions20Extension * soap_new_req_tt__FocusOptions20Extension(
	struct soap *soap)
{
	tt__FocusOptions20Extension *_p = ::soap_new_tt__FocusOptions20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__FocusOptions20Extension * soap_new_set_tt__FocusOptions20Extension(
	struct soap *soap,
	const std::vector<char *> & __any,
	std::string *AFModes,
	char *__item__1)
{
	tt__FocusOptions20Extension *_p = ::soap_new_tt__FocusOptions20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__FocusOptions20Extension::__any = __any;
		_p->tt__FocusOptions20Extension::AFModes = AFModes;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusOptions20Extension", p->soap_type() == SOAP_TYPE_tt__FocusOptions20Extension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__FocusOptions20Extension(struct soap *soap, const char *URL, tt__FocusOptions20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusOptions20Extension", p->soap_type() == SOAP_TYPE_tt__FocusOptions20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__FocusOptions20Extension(struct soap *soap, const char *URL, tt__FocusOptions20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusOptions20Extension", p->soap_type() == SOAP_TYPE_tt__FocusOptions20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__FocusOptions20Extension(struct soap *soap, const char *URL, tt__FocusOptions20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusOptions20Extension", p->soap_type() == SOAP_TYPE_tt__FocusOptions20Extension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__FocusOptions20Extension * SOAP_FMAC4 soap_get_tt__FocusOptions20Extension(struct soap*, tt__FocusOptions20Extension *, const char*, const char*);

inline int soap_read_tt__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__FocusOptions20Extension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__FocusOptions20Extension(struct soap *soap, const char *URL, tt__FocusOptions20Extension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__FocusOptions20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension *p)
{
	if (::soap_read_tt__FocusOptions20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__FocusOptions20_DEFINED
#define SOAP_TYPE_tt__FocusOptions20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20(struct soap*, const char*, int, const tt__FocusOptions20 *, const char*);
SOAP_FMAC3 tt__FocusOptions20 * SOAP_FMAC4 soap_in_tt__FocusOptions20(struct soap*, const char*, tt__FocusOptions20 *, const char*);
SOAP_FMAC1 tt__FocusOptions20 * SOAP_FMAC2 imageing_instantiate_tt__FocusOptions20(struct soap*, int, const char*, const char*, size_t*);

inline tt__FocusOptions20 * soap_new_tt__FocusOptions20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__FocusOptions20(soap, n, NULL, NULL, NULL);
}

inline tt__FocusOptions20 * soap_new_req_tt__FocusOptions20(
	struct soap *soap)
{
	tt__FocusOptions20 *_p = ::soap_new_tt__FocusOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__FocusOptions20 * soap_new_set_tt__FocusOptions20(
	struct soap *soap,
	const std::vector<enum tt__AutoFocusMode> & AutoFocusModes,
	tt__FloatRange *DefaultSpeed,
	tt__FloatRange *NearLimit,
	tt__FloatRange *FarLimit,
	tt__FocusOptions20Extension *Extension,
	char *__item__1)
{
	tt__FocusOptions20 *_p = ::soap_new_tt__FocusOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__FocusOptions20::AutoFocusModes = AutoFocusModes;
		_p->tt__FocusOptions20::DefaultSpeed = DefaultSpeed;
		_p->tt__FocusOptions20::NearLimit = NearLimit;
		_p->tt__FocusOptions20::FarLimit = FarLimit;
		_p->tt__FocusOptions20::Extension = Extension;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__FocusOptions20(struct soap *soap, tt__FocusOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusOptions20", p->soap_type() == SOAP_TYPE_tt__FocusOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__FocusOptions20(struct soap *soap, const char *URL, tt__FocusOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusOptions20", p->soap_type() == SOAP_TYPE_tt__FocusOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__FocusOptions20(struct soap *soap, const char *URL, tt__FocusOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusOptions20", p->soap_type() == SOAP_TYPE_tt__FocusOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__FocusOptions20(struct soap *soap, const char *URL, tt__FocusOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusOptions20", p->soap_type() == SOAP_TYPE_tt__FocusOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__FocusOptions20 * SOAP_FMAC4 soap_get_tt__FocusOptions20(struct soap*, tt__FocusOptions20 *, const char*, const char*);

inline int soap_read_tt__FocusOptions20(struct soap *soap, tt__FocusOptions20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__FocusOptions20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__FocusOptions20(struct soap *soap, const char *URL, tt__FocusOptions20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__FocusOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__FocusOptions20(struct soap *soap, tt__FocusOptions20 *p)
{
	if (::soap_read_tt__FocusOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension_DEFINED
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20Extension(struct soap*, const char*, int, const tt__WhiteBalanceOptions20Extension *, const char*);
SOAP_FMAC3 tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20Extension(struct soap*, const char*, tt__WhiteBalanceOptions20Extension *, const char*);
SOAP_FMAC1 tt__WhiteBalanceOptions20Extension * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalanceOptions20Extension(struct soap*, int, const char*, const char*, size_t*);

inline tt__WhiteBalanceOptions20Extension * soap_new_tt__WhiteBalanceOptions20Extension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__WhiteBalanceOptions20Extension(soap, n, NULL, NULL, NULL);
}

inline tt__WhiteBalanceOptions20Extension * soap_new_req_tt__WhiteBalanceOptions20Extension(
	struct soap *soap)
{
	tt__WhiteBalanceOptions20Extension *_p = ::soap_new_tt__WhiteBalanceOptions20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__WhiteBalanceOptions20Extension * soap_new_set_tt__WhiteBalanceOptions20Extension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__WhiteBalanceOptions20Extension *_p = ::soap_new_tt__WhiteBalanceOptions20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WhiteBalanceOptions20Extension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalanceOptions20Extension", p->soap_type() == SOAP_TYPE_tt__WhiteBalanceOptions20Extension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *URL, tt__WhiteBalanceOptions20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalanceOptions20Extension", p->soap_type() == SOAP_TYPE_tt__WhiteBalanceOptions20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *URL, tt__WhiteBalanceOptions20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalanceOptions20Extension", p->soap_type() == SOAP_TYPE_tt__WhiteBalanceOptions20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *URL, tt__WhiteBalanceOptions20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalanceOptions20Extension", p->soap_type() == SOAP_TYPE_tt__WhiteBalanceOptions20Extension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20Extension(struct soap*, tt__WhiteBalanceOptions20Extension *, const char*, const char*);

inline int soap_read_tt__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__WhiteBalanceOptions20Extension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *URL, tt__WhiteBalanceOptions20Extension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__WhiteBalanceOptions20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension *p)
{
	if (::soap_read_tt__WhiteBalanceOptions20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20_DEFINED
#define SOAP_TYPE_tt__WhiteBalanceOptions20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20(struct soap*, const char*, int, const tt__WhiteBalanceOptions20 *, const char*);
SOAP_FMAC3 tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20(struct soap*, const char*, tt__WhiteBalanceOptions20 *, const char*);
SOAP_FMAC1 tt__WhiteBalanceOptions20 * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalanceOptions20(struct soap*, int, const char*, const char*, size_t*);

inline tt__WhiteBalanceOptions20 * soap_new_tt__WhiteBalanceOptions20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__WhiteBalanceOptions20(soap, n, NULL, NULL, NULL);
}

inline tt__WhiteBalanceOptions20 * soap_new_req_tt__WhiteBalanceOptions20(
	struct soap *soap,
	const std::vector<enum tt__WhiteBalanceMode> & Mode)
{
	tt__WhiteBalanceOptions20 *_p = ::soap_new_tt__WhiteBalanceOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WhiteBalanceOptions20::Mode = Mode;
	}
	return _p;
}

inline tt__WhiteBalanceOptions20 * soap_new_set_tt__WhiteBalanceOptions20(
	struct soap *soap,
	const std::vector<enum tt__WhiteBalanceMode> & Mode,
	tt__FloatRange *YrGain,
	tt__FloatRange *YbGain,
	tt__WhiteBalanceOptions20Extension *Extension,
	char *__item__1)
{
	tt__WhiteBalanceOptions20 *_p = ::soap_new_tt__WhiteBalanceOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WhiteBalanceOptions20::Mode = Mode;
		_p->tt__WhiteBalanceOptions20::YrGain = YrGain;
		_p->tt__WhiteBalanceOptions20::YbGain = YbGain;
		_p->tt__WhiteBalanceOptions20::Extension = Extension;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalanceOptions20", p->soap_type() == SOAP_TYPE_tt__WhiteBalanceOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__WhiteBalanceOptions20(struct soap *soap, const char *URL, tt__WhiteBalanceOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalanceOptions20", p->soap_type() == SOAP_TYPE_tt__WhiteBalanceOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__WhiteBalanceOptions20(struct soap *soap, const char *URL, tt__WhiteBalanceOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalanceOptions20", p->soap_type() == SOAP_TYPE_tt__WhiteBalanceOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__WhiteBalanceOptions20(struct soap *soap, const char *URL, tt__WhiteBalanceOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalanceOptions20", p->soap_type() == SOAP_TYPE_tt__WhiteBalanceOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20(struct soap*, tt__WhiteBalanceOptions20 *, const char*, const char*);

inline int soap_read_tt__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__WhiteBalanceOptions20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__WhiteBalanceOptions20(struct soap *soap, const char *URL, tt__WhiteBalanceOptions20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__WhiteBalanceOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 *p)
{
	if (::soap_read_tt__WhiteBalanceOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension_DEFINED
#define SOAP_TYPE_tt__FocusConfiguration20Extension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20Extension(struct soap*, const char*, int, const tt__FocusConfiguration20Extension *, const char*);
SOAP_FMAC3 tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_in_tt__FocusConfiguration20Extension(struct soap*, const char*, tt__FocusConfiguration20Extension *, const char*);
SOAP_FMAC1 tt__FocusConfiguration20Extension * SOAP_FMAC2 imageing_instantiate_tt__FocusConfiguration20Extension(struct soap*, int, const char*, const char*, size_t*);

inline tt__FocusConfiguration20Extension * soap_new_tt__FocusConfiguration20Extension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__FocusConfiguration20Extension(soap, n, NULL, NULL, NULL);
}

inline tt__FocusConfiguration20Extension * soap_new_req_tt__FocusConfiguration20Extension(
	struct soap *soap)
{
	tt__FocusConfiguration20Extension *_p = ::soap_new_tt__FocusConfiguration20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__FocusConfiguration20Extension * soap_new_set_tt__FocusConfiguration20Extension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__FocusConfiguration20Extension *_p = ::soap_new_tt__FocusConfiguration20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__FocusConfiguration20Extension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusConfiguration20Extension", p->soap_type() == SOAP_TYPE_tt__FocusConfiguration20Extension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__FocusConfiguration20Extension(struct soap *soap, const char *URL, tt__FocusConfiguration20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusConfiguration20Extension", p->soap_type() == SOAP_TYPE_tt__FocusConfiguration20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__FocusConfiguration20Extension(struct soap *soap, const char *URL, tt__FocusConfiguration20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusConfiguration20Extension", p->soap_type() == SOAP_TYPE_tt__FocusConfiguration20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__FocusConfiguration20Extension(struct soap *soap, const char *URL, tt__FocusConfiguration20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusConfiguration20Extension", p->soap_type() == SOAP_TYPE_tt__FocusConfiguration20Extension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_get_tt__FocusConfiguration20Extension(struct soap*, tt__FocusConfiguration20Extension *, const char*, const char*);

inline int soap_read_tt__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__FocusConfiguration20Extension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__FocusConfiguration20Extension(struct soap *soap, const char *URL, tt__FocusConfiguration20Extension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__FocusConfiguration20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension *p)
{
	if (::soap_read_tt__FocusConfiguration20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__FocusConfiguration20_DEFINED
#define SOAP_TYPE_tt__FocusConfiguration20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20(struct soap*, const char*, int, const tt__FocusConfiguration20 *, const char*);
SOAP_FMAC3 tt__FocusConfiguration20 * SOAP_FMAC4 soap_in_tt__FocusConfiguration20(struct soap*, const char*, tt__FocusConfiguration20 *, const char*);
SOAP_FMAC1 tt__FocusConfiguration20 * SOAP_FMAC2 imageing_instantiate_tt__FocusConfiguration20(struct soap*, int, const char*, const char*, size_t*);

inline tt__FocusConfiguration20 * soap_new_tt__FocusConfiguration20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__FocusConfiguration20(soap, n, NULL, NULL, NULL);
}

inline tt__FocusConfiguration20 * soap_new_req_tt__FocusConfiguration20(
	struct soap *soap,
	enum tt__AutoFocusMode AutoFocusMode)
{
	tt__FocusConfiguration20 *_p = ::soap_new_tt__FocusConfiguration20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__FocusConfiguration20::AutoFocusMode = AutoFocusMode;
	}
	return _p;
}

inline tt__FocusConfiguration20 * soap_new_set_tt__FocusConfiguration20(
	struct soap *soap,
	enum tt__AutoFocusMode AutoFocusMode,
	float *DefaultSpeed,
	float *NearLimit,
	float *FarLimit,
	tt__FocusConfiguration20Extension *Extension,
	std::string *AFMode,
	char *__anyAttribute,
	char *__item__1)
{
	tt__FocusConfiguration20 *_p = ::soap_new_tt__FocusConfiguration20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__FocusConfiguration20::AutoFocusMode = AutoFocusMode;
		_p->tt__FocusConfiguration20::DefaultSpeed = DefaultSpeed;
		_p->tt__FocusConfiguration20::NearLimit = NearLimit;
		_p->tt__FocusConfiguration20::FarLimit = FarLimit;
		_p->tt__FocusConfiguration20::Extension = Extension;
		_p->tt__FocusConfiguration20::AFMode = AFMode;
		_p->tt__FocusConfiguration20::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusConfiguration20", p->soap_type() == SOAP_TYPE_tt__FocusConfiguration20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__FocusConfiguration20(struct soap *soap, const char *URL, tt__FocusConfiguration20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusConfiguration20", p->soap_type() == SOAP_TYPE_tt__FocusConfiguration20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__FocusConfiguration20(struct soap *soap, const char *URL, tt__FocusConfiguration20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusConfiguration20", p->soap_type() == SOAP_TYPE_tt__FocusConfiguration20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__FocusConfiguration20(struct soap *soap, const char *URL, tt__FocusConfiguration20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusConfiguration20", p->soap_type() == SOAP_TYPE_tt__FocusConfiguration20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__FocusConfiguration20 * SOAP_FMAC4 soap_get_tt__FocusConfiguration20(struct soap*, tt__FocusConfiguration20 *, const char*, const char*);

inline int soap_read_tt__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__FocusConfiguration20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__FocusConfiguration20(struct soap *soap, const char *URL, tt__FocusConfiguration20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__FocusConfiguration20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 *p)
{
	if (::soap_read_tt__FocusConfiguration20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__WhiteBalance20Extension_DEFINED
#define SOAP_TYPE_tt__WhiteBalance20Extension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20Extension(struct soap*, const char*, int, const tt__WhiteBalance20Extension *, const char*);
SOAP_FMAC3 tt__WhiteBalance20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalance20Extension(struct soap*, const char*, tt__WhiteBalance20Extension *, const char*);
SOAP_FMAC1 tt__WhiteBalance20Extension * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalance20Extension(struct soap*, int, const char*, const char*, size_t*);

inline tt__WhiteBalance20Extension * soap_new_tt__WhiteBalance20Extension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__WhiteBalance20Extension(soap, n, NULL, NULL, NULL);
}

inline tt__WhiteBalance20Extension * soap_new_req_tt__WhiteBalance20Extension(
	struct soap *soap)
{
	tt__WhiteBalance20Extension *_p = ::soap_new_tt__WhiteBalance20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__WhiteBalance20Extension * soap_new_set_tt__WhiteBalance20Extension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__WhiteBalance20Extension *_p = ::soap_new_tt__WhiteBalance20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WhiteBalance20Extension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalance20Extension", p->soap_type() == SOAP_TYPE_tt__WhiteBalance20Extension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__WhiteBalance20Extension(struct soap *soap, const char *URL, tt__WhiteBalance20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalance20Extension", p->soap_type() == SOAP_TYPE_tt__WhiteBalance20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__WhiteBalance20Extension(struct soap *soap, const char *URL, tt__WhiteBalance20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalance20Extension", p->soap_type() == SOAP_TYPE_tt__WhiteBalance20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__WhiteBalance20Extension(struct soap *soap, const char *URL, tt__WhiteBalance20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalance20Extension", p->soap_type() == SOAP_TYPE_tt__WhiteBalance20Extension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__WhiteBalance20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalance20Extension(struct soap*, tt__WhiteBalance20Extension *, const char*, const char*);

inline int soap_read_tt__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__WhiteBalance20Extension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__WhiteBalance20Extension(struct soap *soap, const char *URL, tt__WhiteBalance20Extension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__WhiteBalance20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension *p)
{
	if (::soap_read_tt__WhiteBalance20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__WhiteBalance20_DEFINED
#define SOAP_TYPE_tt__WhiteBalance20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20(struct soap*, const char*, int, const tt__WhiteBalance20 *, const char*);
SOAP_FMAC3 tt__WhiteBalance20 * SOAP_FMAC4 soap_in_tt__WhiteBalance20(struct soap*, const char*, tt__WhiteBalance20 *, const char*);
SOAP_FMAC1 tt__WhiteBalance20 * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalance20(struct soap*, int, const char*, const char*, size_t*);

inline tt__WhiteBalance20 * soap_new_tt__WhiteBalance20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__WhiteBalance20(soap, n, NULL, NULL, NULL);
}

inline tt__WhiteBalance20 * soap_new_req_tt__WhiteBalance20(
	struct soap *soap,
	enum tt__WhiteBalanceMode Mode)
{
	tt__WhiteBalance20 *_p = ::soap_new_tt__WhiteBalance20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WhiteBalance20::Mode = Mode;
	}
	return _p;
}

inline tt__WhiteBalance20 * soap_new_set_tt__WhiteBalance20(
	struct soap *soap,
	enum tt__WhiteBalanceMode Mode,
	float *CrGain,
	float *CbGain,
	tt__WhiteBalance20Extension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__WhiteBalance20 *_p = ::soap_new_tt__WhiteBalance20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WhiteBalance20::Mode = Mode;
		_p->tt__WhiteBalance20::CrGain = CrGain;
		_p->tt__WhiteBalance20::CbGain = CbGain;
		_p->tt__WhiteBalance20::Extension = Extension;
		_p->tt__WhiteBalance20::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalance20", p->soap_type() == SOAP_TYPE_tt__WhiteBalance20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__WhiteBalance20(struct soap *soap, const char *URL, tt__WhiteBalance20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalance20", p->soap_type() == SOAP_TYPE_tt__WhiteBalance20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__WhiteBalance20(struct soap *soap, const char *URL, tt__WhiteBalance20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalance20", p->soap_type() == SOAP_TYPE_tt__WhiteBalance20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__WhiteBalance20(struct soap *soap, const char *URL, tt__WhiteBalance20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WhiteBalance20", p->soap_type() == SOAP_TYPE_tt__WhiteBalance20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__WhiteBalance20 * SOAP_FMAC4 soap_get_tt__WhiteBalance20(struct soap*, tt__WhiteBalance20 *, const char*, const char*);

inline int soap_read_tt__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__WhiteBalance20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__WhiteBalance20(struct soap *soap, const char *URL, tt__WhiteBalance20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__WhiteBalance20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 *p)
{
	if (::soap_read_tt__WhiteBalance20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__RelativeFocusOptions20_DEFINED
#define SOAP_TYPE_tt__RelativeFocusOptions20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocusOptions20(struct soap*, const char*, int, const tt__RelativeFocusOptions20 *, const char*);
SOAP_FMAC3 tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_in_tt__RelativeFocusOptions20(struct soap*, const char*, tt__RelativeFocusOptions20 *, const char*);
SOAP_FMAC1 tt__RelativeFocusOptions20 * SOAP_FMAC2 imageing_instantiate_tt__RelativeFocusOptions20(struct soap*, int, const char*, const char*, size_t*);

inline tt__RelativeFocusOptions20 * soap_new_tt__RelativeFocusOptions20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__RelativeFocusOptions20(soap, n, NULL, NULL, NULL);
}

inline tt__RelativeFocusOptions20 * soap_new_req_tt__RelativeFocusOptions20(
	struct soap *soap,
	tt__FloatRange *Distance)
{
	tt__RelativeFocusOptions20 *_p = ::soap_new_tt__RelativeFocusOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__RelativeFocusOptions20::Distance = Distance;
	}
	return _p;
}

inline tt__RelativeFocusOptions20 * soap_new_set_tt__RelativeFocusOptions20(
	struct soap *soap,
	tt__FloatRange *Distance,
	tt__FloatRange *Speed,
	char *__item__1)
{
	tt__RelativeFocusOptions20 *_p = ::soap_new_tt__RelativeFocusOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__RelativeFocusOptions20::Distance = Distance;
		_p->tt__RelativeFocusOptions20::Speed = Speed;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RelativeFocusOptions20", p->soap_type() == SOAP_TYPE_tt__RelativeFocusOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__RelativeFocusOptions20(struct soap *soap, const char *URL, tt__RelativeFocusOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RelativeFocusOptions20", p->soap_type() == SOAP_TYPE_tt__RelativeFocusOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__RelativeFocusOptions20(struct soap *soap, const char *URL, tt__RelativeFocusOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RelativeFocusOptions20", p->soap_type() == SOAP_TYPE_tt__RelativeFocusOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__RelativeFocusOptions20(struct soap *soap, const char *URL, tt__RelativeFocusOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RelativeFocusOptions20", p->soap_type() == SOAP_TYPE_tt__RelativeFocusOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_get_tt__RelativeFocusOptions20(struct soap*, tt__RelativeFocusOptions20 *, const char*, const char*);

inline int soap_read_tt__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__RelativeFocusOptions20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__RelativeFocusOptions20(struct soap *soap, const char *URL, tt__RelativeFocusOptions20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__RelativeFocusOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 *p)
{
	if (::soap_read_tt__RelativeFocusOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__MoveOptions20_DEFINED
#define SOAP_TYPE_tt__MoveOptions20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveOptions20(struct soap*, const char*, int, const tt__MoveOptions20 *, const char*);
SOAP_FMAC3 tt__MoveOptions20 * SOAP_FMAC4 soap_in_tt__MoveOptions20(struct soap*, const char*, tt__MoveOptions20 *, const char*);
SOAP_FMAC1 tt__MoveOptions20 * SOAP_FMAC2 imageing_instantiate_tt__MoveOptions20(struct soap*, int, const char*, const char*, size_t*);

inline tt__MoveOptions20 * soap_new_tt__MoveOptions20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__MoveOptions20(soap, n, NULL, NULL, NULL);
}

inline tt__MoveOptions20 * soap_new_req_tt__MoveOptions20(
	struct soap *soap)
{
	tt__MoveOptions20 *_p = ::soap_new_tt__MoveOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__MoveOptions20 * soap_new_set_tt__MoveOptions20(
	struct soap *soap,
	tt__AbsoluteFocusOptions *Absolute,
	tt__RelativeFocusOptions20 *Relative,
	tt__ContinuousFocusOptions *Continuous,
	char *__item__1)
{
	tt__MoveOptions20 *_p = ::soap_new_tt__MoveOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__MoveOptions20::Absolute = Absolute;
		_p->tt__MoveOptions20::Relative = Relative;
		_p->tt__MoveOptions20::Continuous = Continuous;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__MoveOptions20(struct soap *soap, tt__MoveOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MoveOptions20", p->soap_type() == SOAP_TYPE_tt__MoveOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__MoveOptions20(struct soap *soap, const char *URL, tt__MoveOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MoveOptions20", p->soap_type() == SOAP_TYPE_tt__MoveOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__MoveOptions20(struct soap *soap, const char *URL, tt__MoveOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MoveOptions20", p->soap_type() == SOAP_TYPE_tt__MoveOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__MoveOptions20(struct soap *soap, const char *URL, tt__MoveOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MoveOptions20", p->soap_type() == SOAP_TYPE_tt__MoveOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__MoveOptions20 * SOAP_FMAC4 soap_get_tt__MoveOptions20(struct soap*, tt__MoveOptions20 *, const char*, const char*);

inline int soap_read_tt__MoveOptions20(struct soap *soap, tt__MoveOptions20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__MoveOptions20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__MoveOptions20(struct soap *soap, const char *URL, tt__MoveOptions20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__MoveOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__MoveOptions20(struct soap *soap, tt__MoveOptions20 *p)
{
	if (::soap_read_tt__MoveOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ExposureOptions20_DEFINED
#define SOAP_TYPE_tt__ExposureOptions20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureOptions20(struct soap*, const char*, int, const tt__ExposureOptions20 *, const char*);
SOAP_FMAC3 tt__ExposureOptions20 * SOAP_FMAC4 soap_in_tt__ExposureOptions20(struct soap*, const char*, tt__ExposureOptions20 *, const char*);
SOAP_FMAC1 tt__ExposureOptions20 * SOAP_FMAC2 imageing_instantiate_tt__ExposureOptions20(struct soap*, int, const char*, const char*, size_t*);

inline tt__ExposureOptions20 * soap_new_tt__ExposureOptions20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ExposureOptions20(soap, n, NULL, NULL, NULL);
}

inline tt__ExposureOptions20 * soap_new_req_tt__ExposureOptions20(
	struct soap *soap,
	const std::vector<enum tt__ExposureMode> & Mode)
{
	tt__ExposureOptions20 *_p = ::soap_new_tt__ExposureOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ExposureOptions20::Mode = Mode;
	}
	return _p;
}

inline tt__ExposureOptions20 * soap_new_set_tt__ExposureOptions20(
	struct soap *soap,
	const std::vector<enum tt__ExposureMode> & Mode,
	const std::vector<enum tt__ExposurePriority> & Priority,
	tt__FloatRange *MinExposureTime,
	tt__FloatRange *MaxExposureTime,
	tt__FloatRange *MinGain,
	tt__FloatRange *MaxGain,
	tt__FloatRange *MinIris,
	tt__FloatRange *MaxIris,
	tt__FloatRange *ExposureTime,
	tt__FloatRange *Gain,
	tt__FloatRange *Iris,
	char *__item__1)
{
	tt__ExposureOptions20 *_p = ::soap_new_tt__ExposureOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ExposureOptions20::Mode = Mode;
		_p->tt__ExposureOptions20::Priority = Priority;
		_p->tt__ExposureOptions20::MinExposureTime = MinExposureTime;
		_p->tt__ExposureOptions20::MaxExposureTime = MaxExposureTime;
		_p->tt__ExposureOptions20::MinGain = MinGain;
		_p->tt__ExposureOptions20::MaxGain = MaxGain;
		_p->tt__ExposureOptions20::MinIris = MinIris;
		_p->tt__ExposureOptions20::MaxIris = MaxIris;
		_p->tt__ExposureOptions20::ExposureTime = ExposureTime;
		_p->tt__ExposureOptions20::Gain = Gain;
		_p->tt__ExposureOptions20::Iris = Iris;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ExposureOptions20", p->soap_type() == SOAP_TYPE_tt__ExposureOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ExposureOptions20(struct soap *soap, const char *URL, tt__ExposureOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ExposureOptions20", p->soap_type() == SOAP_TYPE_tt__ExposureOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ExposureOptions20(struct soap *soap, const char *URL, tt__ExposureOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ExposureOptions20", p->soap_type() == SOAP_TYPE_tt__ExposureOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ExposureOptions20(struct soap *soap, const char *URL, tt__ExposureOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ExposureOptions20", p->soap_type() == SOAP_TYPE_tt__ExposureOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ExposureOptions20 * SOAP_FMAC4 soap_get_tt__ExposureOptions20(struct soap*, tt__ExposureOptions20 *, const char*, const char*);

inline int soap_read_tt__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ExposureOptions20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ExposureOptions20(struct soap *soap, const char *URL, tt__ExposureOptions20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ExposureOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 *p)
{
	if (::soap_read_tt__ExposureOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20_DEFINED
#define SOAP_TYPE_tt__BacklightCompensationOptions20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationOptions20(struct soap*, const char*, int, const tt__BacklightCompensationOptions20 *, const char*);
SOAP_FMAC3 tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_in_tt__BacklightCompensationOptions20(struct soap*, const char*, tt__BacklightCompensationOptions20 *, const char*);
SOAP_FMAC1 tt__BacklightCompensationOptions20 * SOAP_FMAC2 imageing_instantiate_tt__BacklightCompensationOptions20(struct soap*, int, const char*, const char*, size_t*);

inline tt__BacklightCompensationOptions20 * soap_new_tt__BacklightCompensationOptions20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__BacklightCompensationOptions20(soap, n, NULL, NULL, NULL);
}

inline tt__BacklightCompensationOptions20 * soap_new_req_tt__BacklightCompensationOptions20(
	struct soap *soap,
	const std::vector<enum tt__BacklightCompensationMode> & Mode)
{
	tt__BacklightCompensationOptions20 *_p = ::soap_new_tt__BacklightCompensationOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__BacklightCompensationOptions20::Mode = Mode;
	}
	return _p;
}

inline tt__BacklightCompensationOptions20 * soap_new_set_tt__BacklightCompensationOptions20(
	struct soap *soap,
	const std::vector<enum tt__BacklightCompensationMode> & Mode,
	tt__FloatRange *Level,
	char *__item__1)
{
	tt__BacklightCompensationOptions20 *_p = ::soap_new_tt__BacklightCompensationOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__BacklightCompensationOptions20::Mode = Mode;
		_p->tt__BacklightCompensationOptions20::Level = Level;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:BacklightCompensationOptions20", p->soap_type() == SOAP_TYPE_tt__BacklightCompensationOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__BacklightCompensationOptions20(struct soap *soap, const char *URL, tt__BacklightCompensationOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:BacklightCompensationOptions20", p->soap_type() == SOAP_TYPE_tt__BacklightCompensationOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__BacklightCompensationOptions20(struct soap *soap, const char *URL, tt__BacklightCompensationOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:BacklightCompensationOptions20", p->soap_type() == SOAP_TYPE_tt__BacklightCompensationOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__BacklightCompensationOptions20(struct soap *soap, const char *URL, tt__BacklightCompensationOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:BacklightCompensationOptions20", p->soap_type() == SOAP_TYPE_tt__BacklightCompensationOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_get_tt__BacklightCompensationOptions20(struct soap*, tt__BacklightCompensationOptions20 *, const char*, const char*);

inline int soap_read_tt__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__BacklightCompensationOptions20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__BacklightCompensationOptions20(struct soap *soap, const char *URL, tt__BacklightCompensationOptions20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__BacklightCompensationOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 *p)
{
	if (::soap_read_tt__BacklightCompensationOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20_DEFINED
#define SOAP_TYPE_tt__WideDynamicRangeOptions20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRangeOptions20(struct soap*, const char*, int, const tt__WideDynamicRangeOptions20 *, const char*);
SOAP_FMAC3 tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_in_tt__WideDynamicRangeOptions20(struct soap*, const char*, tt__WideDynamicRangeOptions20 *, const char*);
SOAP_FMAC1 tt__WideDynamicRangeOptions20 * SOAP_FMAC2 imageing_instantiate_tt__WideDynamicRangeOptions20(struct soap*, int, const char*, const char*, size_t*);

inline tt__WideDynamicRangeOptions20 * soap_new_tt__WideDynamicRangeOptions20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__WideDynamicRangeOptions20(soap, n, NULL, NULL, NULL);
}

inline tt__WideDynamicRangeOptions20 * soap_new_req_tt__WideDynamicRangeOptions20(
	struct soap *soap,
	const std::vector<enum tt__WideDynamicMode> & Mode)
{
	tt__WideDynamicRangeOptions20 *_p = ::soap_new_tt__WideDynamicRangeOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WideDynamicRangeOptions20::Mode = Mode;
	}
	return _p;
}

inline tt__WideDynamicRangeOptions20 * soap_new_set_tt__WideDynamicRangeOptions20(
	struct soap *soap,
	const std::vector<enum tt__WideDynamicMode> & Mode,
	tt__FloatRange *Level,
	char *__item__1)
{
	tt__WideDynamicRangeOptions20 *_p = ::soap_new_tt__WideDynamicRangeOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WideDynamicRangeOptions20::Mode = Mode;
		_p->tt__WideDynamicRangeOptions20::Level = Level;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WideDynamicRangeOptions20", p->soap_type() == SOAP_TYPE_tt__WideDynamicRangeOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__WideDynamicRangeOptions20(struct soap *soap, const char *URL, tt__WideDynamicRangeOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WideDynamicRangeOptions20", p->soap_type() == SOAP_TYPE_tt__WideDynamicRangeOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__WideDynamicRangeOptions20(struct soap *soap, const char *URL, tt__WideDynamicRangeOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WideDynamicRangeOptions20", p->soap_type() == SOAP_TYPE_tt__WideDynamicRangeOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__WideDynamicRangeOptions20(struct soap *soap, const char *URL, tt__WideDynamicRangeOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WideDynamicRangeOptions20", p->soap_type() == SOAP_TYPE_tt__WideDynamicRangeOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_get_tt__WideDynamicRangeOptions20(struct soap*, tt__WideDynamicRangeOptions20 *, const char*, const char*);

inline int soap_read_tt__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__WideDynamicRangeOptions20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__WideDynamicRangeOptions20(struct soap *soap, const char *URL, tt__WideDynamicRangeOptions20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__WideDynamicRangeOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 *p)
{
	if (::soap_read_tt__WideDynamicRangeOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension_DEFINED
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, const char*, int, const tt__IrCutFilterAutoAdjustmentOptionsExtension *, const char*);
SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, const char*, tt__IrCutFilterAutoAdjustmentOptionsExtension *, const char*);
SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__IrCutFilterAutoAdjustmentOptionsExtension * soap_new_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, n, NULL, NULL, NULL);
}

inline tt__IrCutFilterAutoAdjustmentOptionsExtension * soap_new_req_tt__IrCutFilterAutoAdjustmentOptionsExtension(
	struct soap *soap)
{
	tt__IrCutFilterAutoAdjustmentOptionsExtension *_p = ::soap_new_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__IrCutFilterAutoAdjustmentOptionsExtension * soap_new_set_tt__IrCutFilterAutoAdjustmentOptionsExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__IrCutFilterAutoAdjustmentOptionsExtension *_p = ::soap_new_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IrCutFilterAutoAdjustmentOptionsExtension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustmentOptionsExtension", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustmentOptionsExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustmentOptionsExtension", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustmentOptionsExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustmentOptionsExtension", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustmentOptionsExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustmentOptionsExtension", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, tt__IrCutFilterAutoAdjustmentOptionsExtension *, const char*, const char*);

inline int soap_read_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustmentOptionsExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension *p)
{
	if (::soap_read_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions_DEFINED
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentOptions(struct soap*, const char*, int, const tt__IrCutFilterAutoAdjustmentOptions *, const char*);
SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentOptions(struct soap*, const char*, tt__IrCutFilterAutoAdjustmentOptions *, const char*);
SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptions(struct soap*, int, const char*, const char*, size_t*);

inline tt__IrCutFilterAutoAdjustmentOptions * soap_new_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptions(soap, n, NULL, NULL, NULL);
}

inline tt__IrCutFilterAutoAdjustmentOptions * soap_new_req_tt__IrCutFilterAutoAdjustmentOptions(
	struct soap *soap,
	const std::vector<std::string> & BoundaryType)
{
	tt__IrCutFilterAutoAdjustmentOptions *_p = ::soap_new_tt__IrCutFilterAutoAdjustmentOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType = BoundaryType;
	}
	return _p;
}

inline tt__IrCutFilterAutoAdjustmentOptions * soap_new_set_tt__IrCutFilterAutoAdjustmentOptions(
	struct soap *soap,
	const std::vector<std::string> & BoundaryType,
	bool *BoundaryOffset,
	tt__DurationRange *ResponseTimeRange,
	tt__IrCutFilterAutoAdjustmentOptionsExtension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__IrCutFilterAutoAdjustmentOptions *_p = ::soap_new_tt__IrCutFilterAutoAdjustmentOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType = BoundaryType;
		_p->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset = BoundaryOffset;
		_p->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange = ResponseTimeRange;
		_p->tt__IrCutFilterAutoAdjustmentOptions::Extension = Extension;
		_p->tt__IrCutFilterAutoAdjustmentOptions::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustmentOptions", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustmentOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustmentOptions", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustmentOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustmentOptions", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustmentOptions const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustmentOptions", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentOptions(struct soap*, tt__IrCutFilterAutoAdjustmentOptions *, const char*, const char*);

inline int soap_read_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__IrCutFilterAutoAdjustmentOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustmentOptions *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IrCutFilterAutoAdjustmentOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions *p)
{
	if (::soap_read_tt__IrCutFilterAutoAdjustmentOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationOptionsExtension_DEFINED
#define SOAP_TYPE_tt__ImageStabilizationOptionsExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationOptionsExtension(struct soap*, const char*, int, const tt__ImageStabilizationOptionsExtension *, const char*);
SOAP_FMAC3 tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_in_tt__ImageStabilizationOptionsExtension(struct soap*, const char*, tt__ImageStabilizationOptionsExtension *, const char*);
SOAP_FMAC1 tt__ImageStabilizationOptionsExtension * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilizationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImageStabilizationOptionsExtension * soap_new_tt__ImageStabilizationOptionsExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImageStabilizationOptionsExtension(soap, n, NULL, NULL, NULL);
}

inline tt__ImageStabilizationOptionsExtension * soap_new_req_tt__ImageStabilizationOptionsExtension(
	struct soap *soap)
{
	tt__ImageStabilizationOptionsExtension *_p = ::soap_new_tt__ImageStabilizationOptionsExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImageStabilizationOptionsExtension * soap_new_set_tt__ImageStabilizationOptionsExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__ImageStabilizationOptionsExtension *_p = ::soap_new_tt__ImageStabilizationOptionsExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImageStabilizationOptionsExtension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationOptionsExtension", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationOptionsExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *URL, tt__ImageStabilizationOptionsExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationOptionsExtension", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationOptionsExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *URL, tt__ImageStabilizationOptionsExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationOptionsExtension", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationOptionsExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *URL, tt__ImageStabilizationOptionsExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationOptionsExtension", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationOptionsExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_get_tt__ImageStabilizationOptionsExtension(struct soap*, tt__ImageStabilizationOptionsExtension *, const char*, const char*);

inline int soap_read_tt__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImageStabilizationOptionsExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *URL, tt__ImageStabilizationOptionsExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImageStabilizationOptionsExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension *p)
{
	if (::soap_read_tt__ImageStabilizationOptionsExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationOptions_DEFINED
#define SOAP_TYPE_tt__ImageStabilizationOptions_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationOptions(struct soap*, const char*, int, const tt__ImageStabilizationOptions *, const char*);
SOAP_FMAC3 tt__ImageStabilizationOptions * SOAP_FMAC4 soap_in_tt__ImageStabilizationOptions(struct soap*, const char*, tt__ImageStabilizationOptions *, const char*);
SOAP_FMAC1 tt__ImageStabilizationOptions * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilizationOptions(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImageStabilizationOptions * soap_new_tt__ImageStabilizationOptions(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImageStabilizationOptions(soap, n, NULL, NULL, NULL);
}

inline tt__ImageStabilizationOptions * soap_new_req_tt__ImageStabilizationOptions(
	struct soap *soap,
	const std::vector<enum tt__ImageStabilizationMode> & Mode)
{
	tt__ImageStabilizationOptions *_p = ::soap_new_tt__ImageStabilizationOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImageStabilizationOptions::Mode = Mode;
	}
	return _p;
}

inline tt__ImageStabilizationOptions * soap_new_set_tt__ImageStabilizationOptions(
	struct soap *soap,
	const std::vector<enum tt__ImageStabilizationMode> & Mode,
	tt__FloatRange *Level,
	tt__ImageStabilizationOptionsExtension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__ImageStabilizationOptions *_p = ::soap_new_tt__ImageStabilizationOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImageStabilizationOptions::Mode = Mode;
		_p->tt__ImageStabilizationOptions::Level = Level;
		_p->tt__ImageStabilizationOptions::Extension = Extension;
		_p->tt__ImageStabilizationOptions::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationOptions", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationOptions ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImageStabilizationOptions(struct soap *soap, const char *URL, tt__ImageStabilizationOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationOptions", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImageStabilizationOptions(struct soap *soap, const char *URL, tt__ImageStabilizationOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationOptions", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImageStabilizationOptions(struct soap *soap, const char *URL, tt__ImageStabilizationOptions const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationOptions", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationOptions ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImageStabilizationOptions * SOAP_FMAC4 soap_get_tt__ImageStabilizationOptions(struct soap*, tt__ImageStabilizationOptions *, const char*, const char*);

inline int soap_read_tt__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImageStabilizationOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImageStabilizationOptions(struct soap *soap, const char *URL, tt__ImageStabilizationOptions *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImageStabilizationOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions *p)
{
	if (::soap_read_tt__ImageStabilizationOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20Extension4_DEFINED
#define SOAP_TYPE_tt__ImagingOptions20Extension4_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension4(struct soap*, const char*, int, const tt__ImagingOptions20Extension4 *, const char*);
SOAP_FMAC3 tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension4(struct soap*, const char*, tt__ImagingOptions20Extension4 *, const char*);
SOAP_FMAC1 tt__ImagingOptions20Extension4 * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20Extension4(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImagingOptions20Extension4 * soap_new_tt__ImagingOptions20Extension4(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImagingOptions20Extension4(soap, n, NULL, NULL, NULL);
}

inline tt__ImagingOptions20Extension4 * soap_new_req_tt__ImagingOptions20Extension4(
	struct soap *soap)
{
	tt__ImagingOptions20Extension4 *_p = ::soap_new_tt__ImagingOptions20Extension4(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImagingOptions20Extension4 * soap_new_set_tt__ImagingOptions20Extension4(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__ImagingOptions20Extension4 *_p = ::soap_new_tt__ImagingOptions20Extension4(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImagingOptions20Extension4::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension4", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension4 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImagingOptions20Extension4(struct soap *soap, const char *URL, tt__ImagingOptions20Extension4 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension4", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension4 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImagingOptions20Extension4(struct soap *soap, const char *URL, tt__ImagingOptions20Extension4 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension4", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension4 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImagingOptions20Extension4(struct soap *soap, const char *URL, tt__ImagingOptions20Extension4 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension4", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension4 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension4(struct soap*, tt__ImagingOptions20Extension4 *, const char*, const char*);

inline int soap_read_tt__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImagingOptions20Extension4(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImagingOptions20Extension4(struct soap *soap, const char *URL, tt__ImagingOptions20Extension4 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImagingOptions20Extension4(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 *p)
{
	if (::soap_read_tt__ImagingOptions20Extension4(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20Extension3_DEFINED
#define SOAP_TYPE_tt__ImagingOptions20Extension3_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension3(struct soap*, const char*, int, const tt__ImagingOptions20Extension3 *, const char*);
SOAP_FMAC3 tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension3(struct soap*, const char*, tt__ImagingOptions20Extension3 *, const char*);
SOAP_FMAC1 tt__ImagingOptions20Extension3 * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20Extension3(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImagingOptions20Extension3 * soap_new_tt__ImagingOptions20Extension3(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImagingOptions20Extension3(soap, n, NULL, NULL, NULL);
}

inline tt__ImagingOptions20Extension3 * soap_new_req_tt__ImagingOptions20Extension3(
	struct soap *soap)
{
	tt__ImagingOptions20Extension3 *_p = ::soap_new_tt__ImagingOptions20Extension3(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImagingOptions20Extension3 * soap_new_set_tt__ImagingOptions20Extension3(
	struct soap *soap,
	tt__ToneCompensationOptions *ToneCompensationOptions,
	tt__DefoggingOptions *DefoggingOptions,
	tt__NoiseReductionOptions *NoiseReductionOptions,
	tt__ImagingOptions20Extension4 *Extension,
	char *__item__1)
{
	tt__ImagingOptions20Extension3 *_p = ::soap_new_tt__ImagingOptions20Extension3(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImagingOptions20Extension3::ToneCompensationOptions = ToneCompensationOptions;
		_p->tt__ImagingOptions20Extension3::DefoggingOptions = DefoggingOptions;
		_p->tt__ImagingOptions20Extension3::NoiseReductionOptions = NoiseReductionOptions;
		_p->tt__ImagingOptions20Extension3::Extension = Extension;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension3", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension3 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImagingOptions20Extension3(struct soap *soap, const char *URL, tt__ImagingOptions20Extension3 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension3", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension3 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImagingOptions20Extension3(struct soap *soap, const char *URL, tt__ImagingOptions20Extension3 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension3", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension3 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImagingOptions20Extension3(struct soap *soap, const char *URL, tt__ImagingOptions20Extension3 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension3", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension3 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension3(struct soap*, tt__ImagingOptions20Extension3 *, const char*, const char*);

inline int soap_read_tt__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImagingOptions20Extension3(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImagingOptions20Extension3(struct soap *soap, const char *URL, tt__ImagingOptions20Extension3 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImagingOptions20Extension3(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 *p)
{
	if (::soap_read_tt__ImagingOptions20Extension3(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20Extension2_DEFINED
#define SOAP_TYPE_tt__ImagingOptions20Extension2_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension2(struct soap*, const char*, int, const tt__ImagingOptions20Extension2 *, const char*);
SOAP_FMAC3 tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension2(struct soap*, const char*, tt__ImagingOptions20Extension2 *, const char*);
SOAP_FMAC1 tt__ImagingOptions20Extension2 * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20Extension2(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImagingOptions20Extension2 * soap_new_tt__ImagingOptions20Extension2(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImagingOptions20Extension2(soap, n, NULL, NULL, NULL);
}

inline tt__ImagingOptions20Extension2 * soap_new_req_tt__ImagingOptions20Extension2(
	struct soap *soap)
{
	tt__ImagingOptions20Extension2 *_p = ::soap_new_tt__ImagingOptions20Extension2(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImagingOptions20Extension2 * soap_new_set_tt__ImagingOptions20Extension2(
	struct soap *soap,
	tt__IrCutFilterAutoAdjustmentOptions *IrCutFilterAutoAdjustment,
	tt__ImagingOptions20Extension3 *Extension,
	char *__item__1)
{
	tt__ImagingOptions20Extension2 *_p = ::soap_new_tt__ImagingOptions20Extension2(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment = IrCutFilterAutoAdjustment;
		_p->tt__ImagingOptions20Extension2::Extension = Extension;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension2", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension2 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImagingOptions20Extension2(struct soap *soap, const char *URL, tt__ImagingOptions20Extension2 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension2", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension2 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImagingOptions20Extension2(struct soap *soap, const char *URL, tt__ImagingOptions20Extension2 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension2", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension2 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImagingOptions20Extension2(struct soap *soap, const char *URL, tt__ImagingOptions20Extension2 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension2", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension2 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension2(struct soap*, tt__ImagingOptions20Extension2 *, const char*, const char*);

inline int soap_read_tt__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImagingOptions20Extension2(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImagingOptions20Extension2(struct soap *soap, const char *URL, tt__ImagingOptions20Extension2 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImagingOptions20Extension2(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 *p)
{
	if (::soap_read_tt__ImagingOptions20Extension2(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20Extension_DEFINED
#define SOAP_TYPE_tt__ImagingOptions20Extension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension(struct soap*, const char*, int, const tt__ImagingOptions20Extension *, const char*);
SOAP_FMAC3 tt__ImagingOptions20Extension * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension(struct soap*, const char*, tt__ImagingOptions20Extension *, const char*);
SOAP_FMAC1 tt__ImagingOptions20Extension * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20Extension(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImagingOptions20Extension * soap_new_tt__ImagingOptions20Extension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImagingOptions20Extension(soap, n, NULL, NULL, NULL);
}

inline tt__ImagingOptions20Extension * soap_new_req_tt__ImagingOptions20Extension(
	struct soap *soap)
{
	tt__ImagingOptions20Extension *_p = ::soap_new_tt__ImagingOptions20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImagingOptions20Extension * soap_new_set_tt__ImagingOptions20Extension(
	struct soap *soap,
	const std::vector<char *> & __any,
	tt__ImageStabilizationOptions *ImageStabilization,
	tt__ImagingOptions20Extension2 *Extension,
	char *__item__1)
{
	tt__ImagingOptions20Extension *_p = ::soap_new_tt__ImagingOptions20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImagingOptions20Extension::__any = __any;
		_p->tt__ImagingOptions20Extension::ImageStabilization = ImageStabilization;
		_p->tt__ImagingOptions20Extension::Extension = Extension;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImagingOptions20Extension(struct soap *soap, const char *URL, tt__ImagingOptions20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImagingOptions20Extension(struct soap *soap, const char *URL, tt__ImagingOptions20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImagingOptions20Extension(struct soap *soap, const char *URL, tt__ImagingOptions20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20Extension", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImagingOptions20Extension * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension(struct soap*, tt__ImagingOptions20Extension *, const char*, const char*);

inline int soap_read_tt__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImagingOptions20Extension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImagingOptions20Extension(struct soap *soap, const char *URL, tt__ImagingOptions20Extension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImagingOptions20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension *p)
{
	if (::soap_read_tt__ImagingOptions20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20_DEFINED
#define SOAP_TYPE_tt__ImagingOptions20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20(struct soap*, const char*, int, const tt__ImagingOptions20 *, const char*);
SOAP_FMAC3 tt__ImagingOptions20 * SOAP_FMAC4 soap_in_tt__ImagingOptions20(struct soap*, const char*, tt__ImagingOptions20 *, const char*);
SOAP_FMAC1 tt__ImagingOptions20 * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImagingOptions20 * soap_new_tt__ImagingOptions20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImagingOptions20(soap, n, NULL, NULL, NULL);
}

inline tt__ImagingOptions20 * soap_new_req_tt__ImagingOptions20(
	struct soap *soap)
{
	tt__ImagingOptions20 *_p = ::soap_new_tt__ImagingOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImagingOptions20 * soap_new_set_tt__ImagingOptions20(
	struct soap *soap,
	tt__BacklightCompensationOptions20 *BacklightCompensation,
	tt__FloatRange *Brightness,
	tt__FloatRange *ColorSaturation,
	tt__FloatRange *Contrast,
	tt__ExposureOptions20 *Exposure,
	tt__FocusOptions20 *Focus,
	const std::vector<enum tt__IrCutFilterMode> & IrCutFilterModes,
	tt__FloatRange *Sharpness,
	tt__WideDynamicRangeOptions20 *WideDynamicRange,
	tt__WhiteBalanceOptions20 *WhiteBalance,
	tt__ImagingOptions20Extension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__ImagingOptions20 *_p = ::soap_new_tt__ImagingOptions20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImagingOptions20::BacklightCompensation = BacklightCompensation;
		_p->tt__ImagingOptions20::Brightness = Brightness;
		_p->tt__ImagingOptions20::ColorSaturation = ColorSaturation;
		_p->tt__ImagingOptions20::Contrast = Contrast;
		_p->tt__ImagingOptions20::Exposure = Exposure;
		_p->tt__ImagingOptions20::Focus = Focus;
		_p->tt__ImagingOptions20::IrCutFilterModes = IrCutFilterModes;
		_p->tt__ImagingOptions20::Sharpness = Sharpness;
		_p->tt__ImagingOptions20::WideDynamicRange = WideDynamicRange;
		_p->tt__ImagingOptions20::WhiteBalance = WhiteBalance;
		_p->tt__ImagingOptions20::Extension = Extension;
		_p->tt__ImagingOptions20::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImagingOptions20(struct soap *soap, const char *URL, tt__ImagingOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImagingOptions20(struct soap *soap, const char *URL, tt__ImagingOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImagingOptions20(struct soap *soap, const char *URL, tt__ImagingOptions20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingOptions20", p->soap_type() == SOAP_TYPE_tt__ImagingOptions20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImagingOptions20 * SOAP_FMAC4 soap_get_tt__ImagingOptions20(struct soap*, tt__ImagingOptions20 *, const char*, const char*);

inline int soap_read_tt__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImagingOptions20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImagingOptions20(struct soap *soap, const char *URL, tt__ImagingOptions20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImagingOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 *p)
{
	if (::soap_read_tt__ImagingOptions20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__NoiseReduction_DEFINED
#define SOAP_TYPE_tt__NoiseReduction_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NoiseReduction(struct soap*, const char*, int, const tt__NoiseReduction *, const char*);
SOAP_FMAC3 tt__NoiseReduction * SOAP_FMAC4 soap_in_tt__NoiseReduction(struct soap*, const char*, tt__NoiseReduction *, const char*);
SOAP_FMAC1 tt__NoiseReduction * SOAP_FMAC2 imageing_instantiate_tt__NoiseReduction(struct soap*, int, const char*, const char*, size_t*);

inline tt__NoiseReduction * soap_new_tt__NoiseReduction(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__NoiseReduction(soap, n, NULL, NULL, NULL);
}

inline tt__NoiseReduction * soap_new_req_tt__NoiseReduction(
	struct soap *soap,
	float Level)
{
	tt__NoiseReduction *_p = ::soap_new_tt__NoiseReduction(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__NoiseReduction::Level = Level;
	}
	return _p;
}

inline tt__NoiseReduction * soap_new_set_tt__NoiseReduction(
	struct soap *soap,
	float Level,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	char *__item__1)
{
	tt__NoiseReduction *_p = ::soap_new_tt__NoiseReduction(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__NoiseReduction::Level = Level;
		_p->tt__NoiseReduction::__any = __any;
		_p->tt__NoiseReduction::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__NoiseReduction(struct soap *soap, tt__NoiseReduction const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:NoiseReduction", p->soap_type() == SOAP_TYPE_tt__NoiseReduction ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__NoiseReduction(struct soap *soap, const char *URL, tt__NoiseReduction const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:NoiseReduction", p->soap_type() == SOAP_TYPE_tt__NoiseReduction ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__NoiseReduction(struct soap *soap, const char *URL, tt__NoiseReduction const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:NoiseReduction", p->soap_type() == SOAP_TYPE_tt__NoiseReduction ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__NoiseReduction(struct soap *soap, const char *URL, tt__NoiseReduction const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:NoiseReduction", p->soap_type() == SOAP_TYPE_tt__NoiseReduction ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__NoiseReduction * SOAP_FMAC4 soap_get_tt__NoiseReduction(struct soap*, tt__NoiseReduction *, const char*, const char*);

inline int soap_read_tt__NoiseReduction(struct soap *soap, tt__NoiseReduction *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__NoiseReduction(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__NoiseReduction(struct soap *soap, const char *URL, tt__NoiseReduction *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__NoiseReduction(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__NoiseReduction(struct soap *soap, tt__NoiseReduction *p)
{
	if (::soap_read_tt__NoiseReduction(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__DefoggingExtension_DEFINED
#define SOAP_TYPE_tt__DefoggingExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingExtension(struct soap*, const char*, int, const tt__DefoggingExtension *, const char*);
SOAP_FMAC3 tt__DefoggingExtension * SOAP_FMAC4 soap_in_tt__DefoggingExtension(struct soap*, const char*, tt__DefoggingExtension *, const char*);
SOAP_FMAC1 tt__DefoggingExtension * SOAP_FMAC2 imageing_instantiate_tt__DefoggingExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__DefoggingExtension * soap_new_tt__DefoggingExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__DefoggingExtension(soap, n, NULL, NULL, NULL);
}

inline tt__DefoggingExtension * soap_new_req_tt__DefoggingExtension(
	struct soap *soap)
{
	tt__DefoggingExtension *_p = ::soap_new_tt__DefoggingExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__DefoggingExtension * soap_new_set_tt__DefoggingExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__DefoggingExtension *_p = ::soap_new_tt__DefoggingExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__DefoggingExtension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__DefoggingExtension(struct soap *soap, tt__DefoggingExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:DefoggingExtension", p->soap_type() == SOAP_TYPE_tt__DefoggingExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__DefoggingExtension(struct soap *soap, const char *URL, tt__DefoggingExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:DefoggingExtension", p->soap_type() == SOAP_TYPE_tt__DefoggingExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__DefoggingExtension(struct soap *soap, const char *URL, tt__DefoggingExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:DefoggingExtension", p->soap_type() == SOAP_TYPE_tt__DefoggingExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__DefoggingExtension(struct soap *soap, const char *URL, tt__DefoggingExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:DefoggingExtension", p->soap_type() == SOAP_TYPE_tt__DefoggingExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__DefoggingExtension * SOAP_FMAC4 soap_get_tt__DefoggingExtension(struct soap*, tt__DefoggingExtension *, const char*, const char*);

inline int soap_read_tt__DefoggingExtension(struct soap *soap, tt__DefoggingExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__DefoggingExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__DefoggingExtension(struct soap *soap, const char *URL, tt__DefoggingExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__DefoggingExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__DefoggingExtension(struct soap *soap, tt__DefoggingExtension *p)
{
	if (::soap_read_tt__DefoggingExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Defogging_DEFINED
#define SOAP_TYPE_tt__Defogging_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Defogging(struct soap*, const char*, int, const tt__Defogging *, const char*);
SOAP_FMAC3 tt__Defogging * SOAP_FMAC4 soap_in_tt__Defogging(struct soap*, const char*, tt__Defogging *, const char*);
SOAP_FMAC1 tt__Defogging * SOAP_FMAC2 imageing_instantiate_tt__Defogging(struct soap*, int, const char*, const char*, size_t*);

inline tt__Defogging * soap_new_tt__Defogging(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Defogging(soap, n, NULL, NULL, NULL);
}

inline tt__Defogging * soap_new_req_tt__Defogging(
	struct soap *soap,
	const std::string& Mode)
{
	tt__Defogging *_p = ::soap_new_tt__Defogging(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Defogging::Mode = Mode;
	}
	return _p;
}

inline tt__Defogging * soap_new_set_tt__Defogging(
	struct soap *soap,
	const std::string& Mode,
	float *Level,
	tt__DefoggingExtension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__Defogging *_p = ::soap_new_tt__Defogging(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Defogging::Mode = Mode;
		_p->tt__Defogging::Level = Level;
		_p->tt__Defogging::Extension = Extension;
		_p->tt__Defogging::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Defogging(struct soap *soap, tt__Defogging const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Defogging", p->soap_type() == SOAP_TYPE_tt__Defogging ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Defogging(struct soap *soap, const char *URL, tt__Defogging const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Defogging", p->soap_type() == SOAP_TYPE_tt__Defogging ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Defogging(struct soap *soap, const char *URL, tt__Defogging const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Defogging", p->soap_type() == SOAP_TYPE_tt__Defogging ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Defogging(struct soap *soap, const char *URL, tt__Defogging const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Defogging", p->soap_type() == SOAP_TYPE_tt__Defogging ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Defogging * SOAP_FMAC4 soap_get_tt__Defogging(struct soap*, tt__Defogging *, const char*, const char*);

inline int soap_read_tt__Defogging(struct soap *soap, tt__Defogging *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Defogging(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Defogging(struct soap *soap, const char *URL, tt__Defogging *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Defogging(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Defogging(struct soap *soap, tt__Defogging *p)
{
	if (::soap_read_tt__Defogging(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ToneCompensationExtension_DEFINED
#define SOAP_TYPE_tt__ToneCompensationExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationExtension(struct soap*, const char*, int, const tt__ToneCompensationExtension *, const char*);
SOAP_FMAC3 tt__ToneCompensationExtension * SOAP_FMAC4 soap_in_tt__ToneCompensationExtension(struct soap*, const char*, tt__ToneCompensationExtension *, const char*);
SOAP_FMAC1 tt__ToneCompensationExtension * SOAP_FMAC2 imageing_instantiate_tt__ToneCompensationExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__ToneCompensationExtension * soap_new_tt__ToneCompensationExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ToneCompensationExtension(soap, n, NULL, NULL, NULL);
}

inline tt__ToneCompensationExtension * soap_new_req_tt__ToneCompensationExtension(
	struct soap *soap)
{
	tt__ToneCompensationExtension *_p = ::soap_new_tt__ToneCompensationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ToneCompensationExtension * soap_new_set_tt__ToneCompensationExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__ToneCompensationExtension *_p = ::soap_new_tt__ToneCompensationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ToneCompensationExtension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ToneCompensationExtension", p->soap_type() == SOAP_TYPE_tt__ToneCompensationExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ToneCompensationExtension(struct soap *soap, const char *URL, tt__ToneCompensationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ToneCompensationExtension", p->soap_type() == SOAP_TYPE_tt__ToneCompensationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ToneCompensationExtension(struct soap *soap, const char *URL, tt__ToneCompensationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ToneCompensationExtension", p->soap_type() == SOAP_TYPE_tt__ToneCompensationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ToneCompensationExtension(struct soap *soap, const char *URL, tt__ToneCompensationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ToneCompensationExtension", p->soap_type() == SOAP_TYPE_tt__ToneCompensationExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ToneCompensationExtension * SOAP_FMAC4 soap_get_tt__ToneCompensationExtension(struct soap*, tt__ToneCompensationExtension *, const char*, const char*);

inline int soap_read_tt__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ToneCompensationExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ToneCompensationExtension(struct soap *soap, const char *URL, tt__ToneCompensationExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ToneCompensationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension *p)
{
	if (::soap_read_tt__ToneCompensationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ToneCompensation_DEFINED
#define SOAP_TYPE_tt__ToneCompensation_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensation(struct soap*, const char*, int, const tt__ToneCompensation *, const char*);
SOAP_FMAC3 tt__ToneCompensation * SOAP_FMAC4 soap_in_tt__ToneCompensation(struct soap*, const char*, tt__ToneCompensation *, const char*);
SOAP_FMAC1 tt__ToneCompensation * SOAP_FMAC2 imageing_instantiate_tt__ToneCompensation(struct soap*, int, const char*, const char*, size_t*);

inline tt__ToneCompensation * soap_new_tt__ToneCompensation(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ToneCompensation(soap, n, NULL, NULL, NULL);
}

inline tt__ToneCompensation * soap_new_req_tt__ToneCompensation(
	struct soap *soap,
	const std::string& Mode)
{
	tt__ToneCompensation *_p = ::soap_new_tt__ToneCompensation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ToneCompensation::Mode = Mode;
	}
	return _p;
}

inline tt__ToneCompensation * soap_new_set_tt__ToneCompensation(
	struct soap *soap,
	const std::string& Mode,
	float *Level,
	tt__ToneCompensationExtension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__ToneCompensation *_p = ::soap_new_tt__ToneCompensation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ToneCompensation::Mode = Mode;
		_p->tt__ToneCompensation::Level = Level;
		_p->tt__ToneCompensation::Extension = Extension;
		_p->tt__ToneCompensation::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ToneCompensation(struct soap *soap, tt__ToneCompensation const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ToneCompensation", p->soap_type() == SOAP_TYPE_tt__ToneCompensation ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ToneCompensation(struct soap *soap, const char *URL, tt__ToneCompensation const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ToneCompensation", p->soap_type() == SOAP_TYPE_tt__ToneCompensation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ToneCompensation(struct soap *soap, const char *URL, tt__ToneCompensation const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ToneCompensation", p->soap_type() == SOAP_TYPE_tt__ToneCompensation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ToneCompensation(struct soap *soap, const char *URL, tt__ToneCompensation const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ToneCompensation", p->soap_type() == SOAP_TYPE_tt__ToneCompensation ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ToneCompensation * SOAP_FMAC4 soap_get_tt__ToneCompensation(struct soap*, tt__ToneCompensation *, const char*, const char*);

inline int soap_read_tt__ToneCompensation(struct soap *soap, tt__ToneCompensation *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ToneCompensation(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ToneCompensation(struct soap *soap, const char *URL, tt__ToneCompensation *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ToneCompensation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ToneCompensation(struct soap *soap, tt__ToneCompensation *p)
{
	if (::soap_read_tt__ToneCompensation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Exposure20_DEFINED
#define SOAP_TYPE_tt__Exposure20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Exposure20(struct soap*, const char*, int, const tt__Exposure20 *, const char*);
SOAP_FMAC3 tt__Exposure20 * SOAP_FMAC4 soap_in_tt__Exposure20(struct soap*, const char*, tt__Exposure20 *, const char*);
SOAP_FMAC1 tt__Exposure20 * SOAP_FMAC2 imageing_instantiate_tt__Exposure20(struct soap*, int, const char*, const char*, size_t*);

inline tt__Exposure20 * soap_new_tt__Exposure20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Exposure20(soap, n, NULL, NULL, NULL);
}

inline tt__Exposure20 * soap_new_req_tt__Exposure20(
	struct soap *soap,
	enum tt__ExposureMode Mode)
{
	tt__Exposure20 *_p = ::soap_new_tt__Exposure20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Exposure20::Mode = Mode;
	}
	return _p;
}

inline tt__Exposure20 * soap_new_set_tt__Exposure20(
	struct soap *soap,
	enum tt__ExposureMode Mode,
	enum tt__ExposurePriority *Priority,
	tt__Rectangle *Window,
	float *MinExposureTime,
	float *MaxExposureTime,
	float *MinGain,
	float *MaxGain,
	float *MinIris,
	float *MaxIris,
	float *ExposureTime,
	float *Gain,
	float *Iris,
	char *__item__1)
{
	tt__Exposure20 *_p = ::soap_new_tt__Exposure20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Exposure20::Mode = Mode;
		_p->tt__Exposure20::Priority = Priority;
		_p->tt__Exposure20::Window = Window;
		_p->tt__Exposure20::MinExposureTime = MinExposureTime;
		_p->tt__Exposure20::MaxExposureTime = MaxExposureTime;
		_p->tt__Exposure20::MinGain = MinGain;
		_p->tt__Exposure20::MaxGain = MaxGain;
		_p->tt__Exposure20::MinIris = MinIris;
		_p->tt__Exposure20::MaxIris = MaxIris;
		_p->tt__Exposure20::ExposureTime = ExposureTime;
		_p->tt__Exposure20::Gain = Gain;
		_p->tt__Exposure20::Iris = Iris;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Exposure20(struct soap *soap, tt__Exposure20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Exposure20", p->soap_type() == SOAP_TYPE_tt__Exposure20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Exposure20(struct soap *soap, const char *URL, tt__Exposure20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Exposure20", p->soap_type() == SOAP_TYPE_tt__Exposure20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Exposure20(struct soap *soap, const char *URL, tt__Exposure20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Exposure20", p->soap_type() == SOAP_TYPE_tt__Exposure20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Exposure20(struct soap *soap, const char *URL, tt__Exposure20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Exposure20", p->soap_type() == SOAP_TYPE_tt__Exposure20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Exposure20 * SOAP_FMAC4 soap_get_tt__Exposure20(struct soap*, tt__Exposure20 *, const char*, const char*);

inline int soap_read_tt__Exposure20(struct soap *soap, tt__Exposure20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Exposure20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Exposure20(struct soap *soap, const char *URL, tt__Exposure20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Exposure20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Exposure20(struct soap *soap, tt__Exposure20 *p)
{
	if (::soap_read_tt__Exposure20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensation20_DEFINED
#define SOAP_TYPE_tt__BacklightCompensation20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensation20(struct soap*, const char*, int, const tt__BacklightCompensation20 *, const char*);
SOAP_FMAC3 tt__BacklightCompensation20 * SOAP_FMAC4 soap_in_tt__BacklightCompensation20(struct soap*, const char*, tt__BacklightCompensation20 *, const char*);
SOAP_FMAC1 tt__BacklightCompensation20 * SOAP_FMAC2 imageing_instantiate_tt__BacklightCompensation20(struct soap*, int, const char*, const char*, size_t*);

inline tt__BacklightCompensation20 * soap_new_tt__BacklightCompensation20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__BacklightCompensation20(soap, n, NULL, NULL, NULL);
}

inline tt__BacklightCompensation20 * soap_new_req_tt__BacklightCompensation20(
	struct soap *soap,
	enum tt__BacklightCompensationMode Mode)
{
	tt__BacklightCompensation20 *_p = ::soap_new_tt__BacklightCompensation20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__BacklightCompensation20::Mode = Mode;
	}
	return _p;
}

inline tt__BacklightCompensation20 * soap_new_set_tt__BacklightCompensation20(
	struct soap *soap,
	enum tt__BacklightCompensationMode Mode,
	float *Level,
	char *__item__1)
{
	tt__BacklightCompensation20 *_p = ::soap_new_tt__BacklightCompensation20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__BacklightCompensation20::Mode = Mode;
		_p->tt__BacklightCompensation20::Level = Level;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:BacklightCompensation20", p->soap_type() == SOAP_TYPE_tt__BacklightCompensation20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__BacklightCompensation20(struct soap *soap, const char *URL, tt__BacklightCompensation20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:BacklightCompensation20", p->soap_type() == SOAP_TYPE_tt__BacklightCompensation20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__BacklightCompensation20(struct soap *soap, const char *URL, tt__BacklightCompensation20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:BacklightCompensation20", p->soap_type() == SOAP_TYPE_tt__BacklightCompensation20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__BacklightCompensation20(struct soap *soap, const char *URL, tt__BacklightCompensation20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:BacklightCompensation20", p->soap_type() == SOAP_TYPE_tt__BacklightCompensation20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__BacklightCompensation20 * SOAP_FMAC4 soap_get_tt__BacklightCompensation20(struct soap*, tt__BacklightCompensation20 *, const char*, const char*);

inline int soap_read_tt__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__BacklightCompensation20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__BacklightCompensation20(struct soap *soap, const char *URL, tt__BacklightCompensation20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__BacklightCompensation20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 *p)
{
	if (::soap_read_tt__BacklightCompensation20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRange20_DEFINED
#define SOAP_TYPE_tt__WideDynamicRange20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRange20(struct soap*, const char*, int, const tt__WideDynamicRange20 *, const char*);
SOAP_FMAC3 tt__WideDynamicRange20 * SOAP_FMAC4 soap_in_tt__WideDynamicRange20(struct soap*, const char*, tt__WideDynamicRange20 *, const char*);
SOAP_FMAC1 tt__WideDynamicRange20 * SOAP_FMAC2 imageing_instantiate_tt__WideDynamicRange20(struct soap*, int, const char*, const char*, size_t*);

inline tt__WideDynamicRange20 * soap_new_tt__WideDynamicRange20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__WideDynamicRange20(soap, n, NULL, NULL, NULL);
}

inline tt__WideDynamicRange20 * soap_new_req_tt__WideDynamicRange20(
	struct soap *soap,
	enum tt__WideDynamicMode Mode)
{
	tt__WideDynamicRange20 *_p = ::soap_new_tt__WideDynamicRange20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WideDynamicRange20::Mode = Mode;
	}
	return _p;
}

inline tt__WideDynamicRange20 * soap_new_set_tt__WideDynamicRange20(
	struct soap *soap,
	enum tt__WideDynamicMode Mode,
	float *Level,
	char *__item__1)
{
	tt__WideDynamicRange20 *_p = ::soap_new_tt__WideDynamicRange20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__WideDynamicRange20::Mode = Mode;
		_p->tt__WideDynamicRange20::Level = Level;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WideDynamicRange20", p->soap_type() == SOAP_TYPE_tt__WideDynamicRange20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__WideDynamicRange20(struct soap *soap, const char *URL, tt__WideDynamicRange20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WideDynamicRange20", p->soap_type() == SOAP_TYPE_tt__WideDynamicRange20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__WideDynamicRange20(struct soap *soap, const char *URL, tt__WideDynamicRange20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WideDynamicRange20", p->soap_type() == SOAP_TYPE_tt__WideDynamicRange20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__WideDynamicRange20(struct soap *soap, const char *URL, tt__WideDynamicRange20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:WideDynamicRange20", p->soap_type() == SOAP_TYPE_tt__WideDynamicRange20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__WideDynamicRange20 * SOAP_FMAC4 soap_get_tt__WideDynamicRange20(struct soap*, tt__WideDynamicRange20 *, const char*, const char*);

inline int soap_read_tt__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__WideDynamicRange20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__WideDynamicRange20(struct soap *soap, const char *URL, tt__WideDynamicRange20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__WideDynamicRange20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 *p)
{
	if (::soap_read_tt__WideDynamicRange20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension_DEFINED
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentExtension(struct soap*, const char*, int, const tt__IrCutFilterAutoAdjustmentExtension *, const char*);
SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentExtension(struct soap*, const char*, tt__IrCutFilterAutoAdjustmentExtension *, const char*);
SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterAutoAdjustmentExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__IrCutFilterAutoAdjustmentExtension * soap_new_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__IrCutFilterAutoAdjustmentExtension(soap, n, NULL, NULL, NULL);
}

inline tt__IrCutFilterAutoAdjustmentExtension * soap_new_req_tt__IrCutFilterAutoAdjustmentExtension(
	struct soap *soap)
{
	tt__IrCutFilterAutoAdjustmentExtension *_p = ::soap_new_tt__IrCutFilterAutoAdjustmentExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__IrCutFilterAutoAdjustmentExtension * soap_new_set_tt__IrCutFilterAutoAdjustmentExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__IrCutFilterAutoAdjustmentExtension *_p = ::soap_new_tt__IrCutFilterAutoAdjustmentExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IrCutFilterAutoAdjustmentExtension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustmentExtension", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustmentExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustmentExtension", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustmentExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustmentExtension", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustmentExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustmentExtension", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentExtension(struct soap*, tt__IrCutFilterAutoAdjustmentExtension *, const char*, const char*);

inline int soap_read_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__IrCutFilterAutoAdjustmentExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustmentExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IrCutFilterAutoAdjustmentExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension *p)
{
	if (::soap_read_tt__IrCutFilterAutoAdjustmentExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustment_DEFINED
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustment_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustment(struct soap*, const char*, int, const tt__IrCutFilterAutoAdjustment *, const char*);
SOAP_FMAC3 tt__IrCutFilterAutoAdjustment * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustment(struct soap*, const char*, tt__IrCutFilterAutoAdjustment *, const char*);
SOAP_FMAC1 tt__IrCutFilterAutoAdjustment * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterAutoAdjustment(struct soap*, int, const char*, const char*, size_t*);

inline tt__IrCutFilterAutoAdjustment * soap_new_tt__IrCutFilterAutoAdjustment(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__IrCutFilterAutoAdjustment(soap, n, NULL, NULL, NULL);
}

inline tt__IrCutFilterAutoAdjustment * soap_new_req_tt__IrCutFilterAutoAdjustment(
	struct soap *soap,
	const std::string& BoundaryType)
{
	tt__IrCutFilterAutoAdjustment *_p = ::soap_new_tt__IrCutFilterAutoAdjustment(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IrCutFilterAutoAdjustment::BoundaryType = BoundaryType;
	}
	return _p;
}

inline tt__IrCutFilterAutoAdjustment * soap_new_set_tt__IrCutFilterAutoAdjustment(
	struct soap *soap,
	const std::string& BoundaryType,
	float *BoundaryOffset,
	std::string *ResponseTime,
	tt__IrCutFilterAutoAdjustmentExtension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__IrCutFilterAutoAdjustment *_p = ::soap_new_tt__IrCutFilterAutoAdjustment(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IrCutFilterAutoAdjustment::BoundaryType = BoundaryType;
		_p->tt__IrCutFilterAutoAdjustment::BoundaryOffset = BoundaryOffset;
		_p->tt__IrCutFilterAutoAdjustment::ResponseTime = ResponseTime;
		_p->tt__IrCutFilterAutoAdjustment::Extension = Extension;
		_p->tt__IrCutFilterAutoAdjustment::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustment", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustment ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__IrCutFilterAutoAdjustment(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustment const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustment", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustment ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IrCutFilterAutoAdjustment(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustment const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustment", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustment ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IrCutFilterAutoAdjustment(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustment const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IrCutFilterAutoAdjustment", p->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustment ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__IrCutFilterAutoAdjustment * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustment(struct soap*, tt__IrCutFilterAutoAdjustment *, const char*, const char*);

inline int soap_read_tt__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__IrCutFilterAutoAdjustment(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IrCutFilterAutoAdjustment(struct soap *soap, const char *URL, tt__IrCutFilterAutoAdjustment *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IrCutFilterAutoAdjustment(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment *p)
{
	if (::soap_read_tt__IrCutFilterAutoAdjustment(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationExtension_DEFINED
#define SOAP_TYPE_tt__ImageStabilizationExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationExtension(struct soap*, const char*, int, const tt__ImageStabilizationExtension *, const char*);
SOAP_FMAC3 tt__ImageStabilizationExtension * SOAP_FMAC4 soap_in_tt__ImageStabilizationExtension(struct soap*, const char*, tt__ImageStabilizationExtension *, const char*);
SOAP_FMAC1 tt__ImageStabilizationExtension * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilizationExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImageStabilizationExtension * soap_new_tt__ImageStabilizationExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImageStabilizationExtension(soap, n, NULL, NULL, NULL);
}

inline tt__ImageStabilizationExtension * soap_new_req_tt__ImageStabilizationExtension(
	struct soap *soap)
{
	tt__ImageStabilizationExtension *_p = ::soap_new_tt__ImageStabilizationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImageStabilizationExtension * soap_new_set_tt__ImageStabilizationExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__ImageStabilizationExtension *_p = ::soap_new_tt__ImageStabilizationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImageStabilizationExtension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationExtension", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImageStabilizationExtension(struct soap *soap, const char *URL, tt__ImageStabilizationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationExtension", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImageStabilizationExtension(struct soap *soap, const char *URL, tt__ImageStabilizationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationExtension", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImageStabilizationExtension(struct soap *soap, const char *URL, tt__ImageStabilizationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilizationExtension", p->soap_type() == SOAP_TYPE_tt__ImageStabilizationExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImageStabilizationExtension * SOAP_FMAC4 soap_get_tt__ImageStabilizationExtension(struct soap*, tt__ImageStabilizationExtension *, const char*, const char*);

inline int soap_read_tt__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImageStabilizationExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImageStabilizationExtension(struct soap *soap, const char *URL, tt__ImageStabilizationExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImageStabilizationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension *p)
{
	if (::soap_read_tt__ImageStabilizationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImageStabilization_DEFINED
#define SOAP_TYPE_tt__ImageStabilization_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilization(struct soap*, const char*, int, const tt__ImageStabilization *, const char*);
SOAP_FMAC3 tt__ImageStabilization * SOAP_FMAC4 soap_in_tt__ImageStabilization(struct soap*, const char*, tt__ImageStabilization *, const char*);
SOAP_FMAC1 tt__ImageStabilization * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilization(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImageStabilization * soap_new_tt__ImageStabilization(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImageStabilization(soap, n, NULL, NULL, NULL);
}

inline tt__ImageStabilization * soap_new_req_tt__ImageStabilization(
	struct soap *soap,
	enum tt__ImageStabilizationMode Mode)
{
	tt__ImageStabilization *_p = ::soap_new_tt__ImageStabilization(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImageStabilization::Mode = Mode;
	}
	return _p;
}

inline tt__ImageStabilization * soap_new_set_tt__ImageStabilization(
	struct soap *soap,
	enum tt__ImageStabilizationMode Mode,
	float *Level,
	tt__ImageStabilizationExtension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__ImageStabilization *_p = ::soap_new_tt__ImageStabilization(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImageStabilization::Mode = Mode;
		_p->tt__ImageStabilization::Level = Level;
		_p->tt__ImageStabilization::Extension = Extension;
		_p->tt__ImageStabilization::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImageStabilization(struct soap *soap, tt__ImageStabilization const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilization", p->soap_type() == SOAP_TYPE_tt__ImageStabilization ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImageStabilization(struct soap *soap, const char *URL, tt__ImageStabilization const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilization", p->soap_type() == SOAP_TYPE_tt__ImageStabilization ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImageStabilization(struct soap *soap, const char *URL, tt__ImageStabilization const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilization", p->soap_type() == SOAP_TYPE_tt__ImageStabilization ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImageStabilization(struct soap *soap, const char *URL, tt__ImageStabilization const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImageStabilization", p->soap_type() == SOAP_TYPE_tt__ImageStabilization ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImageStabilization * SOAP_FMAC4 soap_get_tt__ImageStabilization(struct soap*, tt__ImageStabilization *, const char*, const char*);

inline int soap_read_tt__ImageStabilization(struct soap *soap, tt__ImageStabilization *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImageStabilization(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImageStabilization(struct soap *soap, const char *URL, tt__ImageStabilization *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImageStabilization(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImageStabilization(struct soap *soap, tt__ImageStabilization *p)
{
	if (::soap_read_tt__ImageStabilization(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension204_DEFINED
#define SOAP_TYPE_tt__ImagingSettingsExtension204_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension204(struct soap*, const char*, int, const tt__ImagingSettingsExtension204 *, const char*);
SOAP_FMAC3 tt__ImagingSettingsExtension204 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension204(struct soap*, const char*, tt__ImagingSettingsExtension204 *, const char*);
SOAP_FMAC1 tt__ImagingSettingsExtension204 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettingsExtension204(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImagingSettingsExtension204 * soap_new_tt__ImagingSettingsExtension204(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImagingSettingsExtension204(soap, n, NULL, NULL, NULL);
}

inline tt__ImagingSettingsExtension204 * soap_new_req_tt__ImagingSettingsExtension204(
	struct soap *soap)
{
	tt__ImagingSettingsExtension204 *_p = ::soap_new_tt__ImagingSettingsExtension204(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImagingSettingsExtension204 * soap_new_set_tt__ImagingSettingsExtension204(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__ImagingSettingsExtension204 *_p = ::soap_new_tt__ImagingSettingsExtension204(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImagingSettingsExtension204::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension204", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension204 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImagingSettingsExtension204(struct soap *soap, const char *URL, tt__ImagingSettingsExtension204 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension204", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension204 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImagingSettingsExtension204(struct soap *soap, const char *URL, tt__ImagingSettingsExtension204 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension204", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension204 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImagingSettingsExtension204(struct soap *soap, const char *URL, tt__ImagingSettingsExtension204 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension204", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension204 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImagingSettingsExtension204 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension204(struct soap*, tt__ImagingSettingsExtension204 *, const char*, const char*);

inline int soap_read_tt__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImagingSettingsExtension204(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImagingSettingsExtension204(struct soap *soap, const char *URL, tt__ImagingSettingsExtension204 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImagingSettingsExtension204(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 *p)
{
	if (::soap_read_tt__ImagingSettingsExtension204(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension203_DEFINED
#define SOAP_TYPE_tt__ImagingSettingsExtension203_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension203(struct soap*, const char*, int, const tt__ImagingSettingsExtension203 *, const char*);
SOAP_FMAC3 tt__ImagingSettingsExtension203 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension203(struct soap*, const char*, tt__ImagingSettingsExtension203 *, const char*);
SOAP_FMAC1 tt__ImagingSettingsExtension203 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettingsExtension203(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImagingSettingsExtension203 * soap_new_tt__ImagingSettingsExtension203(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImagingSettingsExtension203(soap, n, NULL, NULL, NULL);
}

inline tt__ImagingSettingsExtension203 * soap_new_req_tt__ImagingSettingsExtension203(
	struct soap *soap)
{
	tt__ImagingSettingsExtension203 *_p = ::soap_new_tt__ImagingSettingsExtension203(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImagingSettingsExtension203 * soap_new_set_tt__ImagingSettingsExtension203(
	struct soap *soap,
	tt__ToneCompensation *ToneCompensation,
	tt__Defogging *Defogging,
	tt__NoiseReduction *NoiseReduction,
	tt__ImagingSettingsExtension204 *Extension,
	char *__item__1)
{
	tt__ImagingSettingsExtension203 *_p = ::soap_new_tt__ImagingSettingsExtension203(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImagingSettingsExtension203::ToneCompensation = ToneCompensation;
		_p->tt__ImagingSettingsExtension203::Defogging = Defogging;
		_p->tt__ImagingSettingsExtension203::NoiseReduction = NoiseReduction;
		_p->tt__ImagingSettingsExtension203::Extension = Extension;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension203", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension203 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImagingSettingsExtension203(struct soap *soap, const char *URL, tt__ImagingSettingsExtension203 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension203", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension203 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImagingSettingsExtension203(struct soap *soap, const char *URL, tt__ImagingSettingsExtension203 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension203", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension203 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImagingSettingsExtension203(struct soap *soap, const char *URL, tt__ImagingSettingsExtension203 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension203", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension203 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImagingSettingsExtension203 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension203(struct soap*, tt__ImagingSettingsExtension203 *, const char*, const char*);

inline int soap_read_tt__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImagingSettingsExtension203(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImagingSettingsExtension203(struct soap *soap, const char *URL, tt__ImagingSettingsExtension203 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImagingSettingsExtension203(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 *p)
{
	if (::soap_read_tt__ImagingSettingsExtension203(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension202_DEFINED
#define SOAP_TYPE_tt__ImagingSettingsExtension202_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension202(struct soap*, const char*, int, const tt__ImagingSettingsExtension202 *, const char*);
SOAP_FMAC3 tt__ImagingSettingsExtension202 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension202(struct soap*, const char*, tt__ImagingSettingsExtension202 *, const char*);
SOAP_FMAC1 tt__ImagingSettingsExtension202 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettingsExtension202(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImagingSettingsExtension202 * soap_new_tt__ImagingSettingsExtension202(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImagingSettingsExtension202(soap, n, NULL, NULL, NULL);
}

inline tt__ImagingSettingsExtension202 * soap_new_req_tt__ImagingSettingsExtension202(
	struct soap *soap)
{
	tt__ImagingSettingsExtension202 *_p = ::soap_new_tt__ImagingSettingsExtension202(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImagingSettingsExtension202 * soap_new_set_tt__ImagingSettingsExtension202(
	struct soap *soap,
	const std::vector<tt__IrCutFilterAutoAdjustment *> & IrCutFilterAutoAdjustment,
	tt__ImagingSettingsExtension203 *Extension,
	char *__item__1)
{
	tt__ImagingSettingsExtension202 *_p = ::soap_new_tt__ImagingSettingsExtension202(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment = IrCutFilterAutoAdjustment;
		_p->tt__ImagingSettingsExtension202::Extension = Extension;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension202", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension202 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImagingSettingsExtension202(struct soap *soap, const char *URL, tt__ImagingSettingsExtension202 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension202", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension202 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImagingSettingsExtension202(struct soap *soap, const char *URL, tt__ImagingSettingsExtension202 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension202", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension202 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImagingSettingsExtension202(struct soap *soap, const char *URL, tt__ImagingSettingsExtension202 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension202", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension202 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImagingSettingsExtension202 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension202(struct soap*, tt__ImagingSettingsExtension202 *, const char*, const char*);

inline int soap_read_tt__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImagingSettingsExtension202(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImagingSettingsExtension202(struct soap *soap, const char *URL, tt__ImagingSettingsExtension202 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImagingSettingsExtension202(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 *p)
{
	if (::soap_read_tt__ImagingSettingsExtension202(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20_DEFINED
#define SOAP_TYPE_tt__ImagingSettingsExtension20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension20(struct soap*, const char*, int, const tt__ImagingSettingsExtension20 *, const char*);
SOAP_FMAC3 tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension20(struct soap*, const char*, tt__ImagingSettingsExtension20 *, const char*);
SOAP_FMAC1 tt__ImagingSettingsExtension20 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettingsExtension20(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImagingSettingsExtension20 * soap_new_tt__ImagingSettingsExtension20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImagingSettingsExtension20(soap, n, NULL, NULL, NULL);
}

inline tt__ImagingSettingsExtension20 * soap_new_req_tt__ImagingSettingsExtension20(
	struct soap *soap)
{
	tt__ImagingSettingsExtension20 *_p = ::soap_new_tt__ImagingSettingsExtension20(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImagingSettingsExtension20 * soap_new_set_tt__ImagingSettingsExtension20(
	struct soap *soap,
	const std::vector<char *> & __any,
	tt__ImageStabilization *ImageStabilization,
	tt__ImagingSettingsExtension202 *Extension,
	char *__item__1)
{
	tt__ImagingSettingsExtension20 *_p = ::soap_new_tt__ImagingSettingsExtension20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImagingSettingsExtension20::__any = __any;
		_p->tt__ImagingSettingsExtension20::ImageStabilization = ImageStabilization;
		_p->tt__ImagingSettingsExtension20::Extension = Extension;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension20", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImagingSettingsExtension20(struct soap *soap, const char *URL, tt__ImagingSettingsExtension20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension20", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImagingSettingsExtension20(struct soap *soap, const char *URL, tt__ImagingSettingsExtension20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension20", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImagingSettingsExtension20(struct soap *soap, const char *URL, tt__ImagingSettingsExtension20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettingsExtension20", p->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension20(struct soap*, tt__ImagingSettingsExtension20 *, const char*, const char*);

inline int soap_read_tt__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImagingSettingsExtension20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImagingSettingsExtension20(struct soap *soap, const char *URL, tt__ImagingSettingsExtension20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImagingSettingsExtension20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 *p)
{
	if (::soap_read_tt__ImagingSettingsExtension20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImagingSettings20_DEFINED
#define SOAP_TYPE_tt__ImagingSettings20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettings20(struct soap*, const char*, int, const tt__ImagingSettings20 *, const char*);
SOAP_FMAC3 tt__ImagingSettings20 * SOAP_FMAC4 soap_in_tt__ImagingSettings20(struct soap*, const char*, tt__ImagingSettings20 *, const char*);
SOAP_FMAC1 tt__ImagingSettings20 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettings20(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImagingSettings20 * soap_new_tt__ImagingSettings20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImagingSettings20(soap, n, NULL, NULL, NULL);
}

inline tt__ImagingSettings20 * soap_new_req_tt__ImagingSettings20(
	struct soap *soap)
{
	tt__ImagingSettings20 *_p = ::soap_new_tt__ImagingSettings20(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImagingSettings20 * soap_new_set_tt__ImagingSettings20(
	struct soap *soap,
	tt__BacklightCompensation20 *BacklightCompensation,
	float *Brightness,
	float *ColorSaturation,
	float *Contrast,
	tt__Exposure20 *Exposure,
	tt__FocusConfiguration20 *Focus,
	enum tt__IrCutFilterMode *IrCutFilter,
	float *Sharpness,
	tt__WideDynamicRange20 *WideDynamicRange,
	tt__WhiteBalance20 *WhiteBalance,
	tt__ImagingSettingsExtension20 *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__ImagingSettings20 *_p = ::soap_new_tt__ImagingSettings20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImagingSettings20::BacklightCompensation = BacklightCompensation;
		_p->tt__ImagingSettings20::Brightness = Brightness;
		_p->tt__ImagingSettings20::ColorSaturation = ColorSaturation;
		_p->tt__ImagingSettings20::Contrast = Contrast;
		_p->tt__ImagingSettings20::Exposure = Exposure;
		_p->tt__ImagingSettings20::Focus = Focus;
		_p->tt__ImagingSettings20::IrCutFilter = IrCutFilter;
		_p->tt__ImagingSettings20::Sharpness = Sharpness;
		_p->tt__ImagingSettings20::WideDynamicRange = WideDynamicRange;
		_p->tt__ImagingSettings20::WhiteBalance = WhiteBalance;
		_p->tt__ImagingSettings20::Extension = Extension;
		_p->tt__ImagingSettings20::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettings20", p->soap_type() == SOAP_TYPE_tt__ImagingSettings20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImagingSettings20(struct soap *soap, const char *URL, tt__ImagingSettings20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettings20", p->soap_type() == SOAP_TYPE_tt__ImagingSettings20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImagingSettings20(struct soap *soap, const char *URL, tt__ImagingSettings20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettings20", p->soap_type() == SOAP_TYPE_tt__ImagingSettings20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImagingSettings20(struct soap *soap, const char *URL, tt__ImagingSettings20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingSettings20", p->soap_type() == SOAP_TYPE_tt__ImagingSettings20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImagingSettings20 * SOAP_FMAC4 soap_get_tt__ImagingSettings20(struct soap*, tt__ImagingSettings20 *, const char*, const char*);

inline int soap_read_tt__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImagingSettings20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImagingSettings20(struct soap *soap, const char *URL, tt__ImagingSettings20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImagingSettings20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 *p)
{
	if (::soap_read_tt__ImagingSettings20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__FocusStatus20Extension_DEFINED
#define SOAP_TYPE_tt__FocusStatus20Extension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20Extension(struct soap*, const char*, int, const tt__FocusStatus20Extension *, const char*);
SOAP_FMAC3 tt__FocusStatus20Extension * SOAP_FMAC4 soap_in_tt__FocusStatus20Extension(struct soap*, const char*, tt__FocusStatus20Extension *, const char*);
SOAP_FMAC1 tt__FocusStatus20Extension * SOAP_FMAC2 imageing_instantiate_tt__FocusStatus20Extension(struct soap*, int, const char*, const char*, size_t*);

inline tt__FocusStatus20Extension * soap_new_tt__FocusStatus20Extension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__FocusStatus20Extension(soap, n, NULL, NULL, NULL);
}

inline tt__FocusStatus20Extension * soap_new_req_tt__FocusStatus20Extension(
	struct soap *soap)
{
	tt__FocusStatus20Extension *_p = ::soap_new_tt__FocusStatus20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__FocusStatus20Extension * soap_new_set_tt__FocusStatus20Extension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__FocusStatus20Extension *_p = ::soap_new_tt__FocusStatus20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__FocusStatus20Extension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusStatus20Extension", p->soap_type() == SOAP_TYPE_tt__FocusStatus20Extension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__FocusStatus20Extension(struct soap *soap, const char *URL, tt__FocusStatus20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusStatus20Extension", p->soap_type() == SOAP_TYPE_tt__FocusStatus20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__FocusStatus20Extension(struct soap *soap, const char *URL, tt__FocusStatus20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusStatus20Extension", p->soap_type() == SOAP_TYPE_tt__FocusStatus20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__FocusStatus20Extension(struct soap *soap, const char *URL, tt__FocusStatus20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusStatus20Extension", p->soap_type() == SOAP_TYPE_tt__FocusStatus20Extension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__FocusStatus20Extension * SOAP_FMAC4 soap_get_tt__FocusStatus20Extension(struct soap*, tt__FocusStatus20Extension *, const char*, const char*);

inline int soap_read_tt__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__FocusStatus20Extension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__FocusStatus20Extension(struct soap *soap, const char *URL, tt__FocusStatus20Extension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__FocusStatus20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension *p)
{
	if (::soap_read_tt__FocusStatus20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__FocusStatus20_DEFINED
#define SOAP_TYPE_tt__FocusStatus20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20(struct soap*, const char*, int, const tt__FocusStatus20 *, const char*);
SOAP_FMAC3 tt__FocusStatus20 * SOAP_FMAC4 soap_in_tt__FocusStatus20(struct soap*, const char*, tt__FocusStatus20 *, const char*);
SOAP_FMAC1 tt__FocusStatus20 * SOAP_FMAC2 imageing_instantiate_tt__FocusStatus20(struct soap*, int, const char*, const char*, size_t*);

inline tt__FocusStatus20 * soap_new_tt__FocusStatus20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__FocusStatus20(soap, n, NULL, NULL, NULL);
}

inline tt__FocusStatus20 * soap_new_req_tt__FocusStatus20(
	struct soap *soap,
	float Position,
	enum tt__MoveStatus MoveStatus)
{
	tt__FocusStatus20 *_p = ::soap_new_tt__FocusStatus20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__FocusStatus20::Position = Position;
		_p->tt__FocusStatus20::MoveStatus = MoveStatus;
	}
	return _p;
}

inline tt__FocusStatus20 * soap_new_set_tt__FocusStatus20(
	struct soap *soap,
	float Position,
	enum tt__MoveStatus MoveStatus,
	std::string *Error,
	tt__FocusStatus20Extension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__FocusStatus20 *_p = ::soap_new_tt__FocusStatus20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__FocusStatus20::Position = Position;
		_p->tt__FocusStatus20::MoveStatus = MoveStatus;
		_p->tt__FocusStatus20::Error = Error;
		_p->tt__FocusStatus20::Extension = Extension;
		_p->tt__FocusStatus20::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__FocusStatus20(struct soap *soap, tt__FocusStatus20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusStatus20", p->soap_type() == SOAP_TYPE_tt__FocusStatus20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__FocusStatus20(struct soap *soap, const char *URL, tt__FocusStatus20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusStatus20", p->soap_type() == SOAP_TYPE_tt__FocusStatus20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__FocusStatus20(struct soap *soap, const char *URL, tt__FocusStatus20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusStatus20", p->soap_type() == SOAP_TYPE_tt__FocusStatus20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__FocusStatus20(struct soap *soap, const char *URL, tt__FocusStatus20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusStatus20", p->soap_type() == SOAP_TYPE_tt__FocusStatus20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__FocusStatus20 * SOAP_FMAC4 soap_get_tt__FocusStatus20(struct soap*, tt__FocusStatus20 *, const char*, const char*);

inline int soap_read_tt__FocusStatus20(struct soap *soap, tt__FocusStatus20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__FocusStatus20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__FocusStatus20(struct soap *soap, const char *URL, tt__FocusStatus20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__FocusStatus20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__FocusStatus20(struct soap *soap, tt__FocusStatus20 *p)
{
	if (::soap_read_tt__FocusStatus20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImagingStatus20Extension_DEFINED
#define SOAP_TYPE_tt__ImagingStatus20Extension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20Extension(struct soap*, const char*, int, const tt__ImagingStatus20Extension *, const char*);
SOAP_FMAC3 tt__ImagingStatus20Extension * SOAP_FMAC4 soap_in_tt__ImagingStatus20Extension(struct soap*, const char*, tt__ImagingStatus20Extension *, const char*);
SOAP_FMAC1 tt__ImagingStatus20Extension * SOAP_FMAC2 imageing_instantiate_tt__ImagingStatus20Extension(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImagingStatus20Extension * soap_new_tt__ImagingStatus20Extension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImagingStatus20Extension(soap, n, NULL, NULL, NULL);
}

inline tt__ImagingStatus20Extension * soap_new_req_tt__ImagingStatus20Extension(
	struct soap *soap)
{
	tt__ImagingStatus20Extension *_p = ::soap_new_tt__ImagingStatus20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImagingStatus20Extension * soap_new_set_tt__ImagingStatus20Extension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__ImagingStatus20Extension *_p = ::soap_new_tt__ImagingStatus20Extension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImagingStatus20Extension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingStatus20Extension", p->soap_type() == SOAP_TYPE_tt__ImagingStatus20Extension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImagingStatus20Extension(struct soap *soap, const char *URL, tt__ImagingStatus20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingStatus20Extension", p->soap_type() == SOAP_TYPE_tt__ImagingStatus20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImagingStatus20Extension(struct soap *soap, const char *URL, tt__ImagingStatus20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingStatus20Extension", p->soap_type() == SOAP_TYPE_tt__ImagingStatus20Extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImagingStatus20Extension(struct soap *soap, const char *URL, tt__ImagingStatus20Extension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingStatus20Extension", p->soap_type() == SOAP_TYPE_tt__ImagingStatus20Extension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImagingStatus20Extension * SOAP_FMAC4 soap_get_tt__ImagingStatus20Extension(struct soap*, tt__ImagingStatus20Extension *, const char*, const char*);

inline int soap_read_tt__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImagingStatus20Extension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImagingStatus20Extension(struct soap *soap, const char *URL, tt__ImagingStatus20Extension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImagingStatus20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension *p)
{
	if (::soap_read_tt__ImagingStatus20Extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ImagingStatus20_DEFINED
#define SOAP_TYPE_tt__ImagingStatus20_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20(struct soap*, const char*, int, const tt__ImagingStatus20 *, const char*);
SOAP_FMAC3 tt__ImagingStatus20 * SOAP_FMAC4 soap_in_tt__ImagingStatus20(struct soap*, const char*, tt__ImagingStatus20 *, const char*);
SOAP_FMAC1 tt__ImagingStatus20 * SOAP_FMAC2 imageing_instantiate_tt__ImagingStatus20(struct soap*, int, const char*, const char*, size_t*);

inline tt__ImagingStatus20 * soap_new_tt__ImagingStatus20(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ImagingStatus20(soap, n, NULL, NULL, NULL);
}

inline tt__ImagingStatus20 * soap_new_req_tt__ImagingStatus20(
	struct soap *soap)
{
	tt__ImagingStatus20 *_p = ::soap_new_tt__ImagingStatus20(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__ImagingStatus20 * soap_new_set_tt__ImagingStatus20(
	struct soap *soap,
	tt__FocusStatus20 *FocusStatus20,
	tt__ImagingStatus20Extension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__ImagingStatus20 *_p = ::soap_new_tt__ImagingStatus20(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ImagingStatus20::FocusStatus20 = FocusStatus20;
		_p->tt__ImagingStatus20::Extension = Extension;
		_p->tt__ImagingStatus20::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingStatus20", p->soap_type() == SOAP_TYPE_tt__ImagingStatus20 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ImagingStatus20(struct soap *soap, const char *URL, tt__ImagingStatus20 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingStatus20", p->soap_type() == SOAP_TYPE_tt__ImagingStatus20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ImagingStatus20(struct soap *soap, const char *URL, tt__ImagingStatus20 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingStatus20", p->soap_type() == SOAP_TYPE_tt__ImagingStatus20 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ImagingStatus20(struct soap *soap, const char *URL, tt__ImagingStatus20 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ImagingStatus20", p->soap_type() == SOAP_TYPE_tt__ImagingStatus20 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ImagingStatus20 * SOAP_FMAC4 soap_get_tt__ImagingStatus20(struct soap*, tt__ImagingStatus20 *, const char*, const char*);

inline int soap_read_tt__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ImagingStatus20(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ImagingStatus20(struct soap *soap, const char *URL, tt__ImagingStatus20 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ImagingStatus20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 *p)
{
	if (::soap_read_tt__ImagingStatus20(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ContinuousFocusOptions_DEFINED
#define SOAP_TYPE_tt__ContinuousFocusOptions_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocusOptions(struct soap*, const char*, int, const tt__ContinuousFocusOptions *, const char*);
SOAP_FMAC3 tt__ContinuousFocusOptions * SOAP_FMAC4 soap_in_tt__ContinuousFocusOptions(struct soap*, const char*, tt__ContinuousFocusOptions *, const char*);
SOAP_FMAC1 tt__ContinuousFocusOptions * SOAP_FMAC2 imageing_instantiate_tt__ContinuousFocusOptions(struct soap*, int, const char*, const char*, size_t*);

inline tt__ContinuousFocusOptions * soap_new_tt__ContinuousFocusOptions(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ContinuousFocusOptions(soap, n, NULL, NULL, NULL);
}

inline tt__ContinuousFocusOptions * soap_new_req_tt__ContinuousFocusOptions(
	struct soap *soap,
	tt__FloatRange *Speed)
{
	tt__ContinuousFocusOptions *_p = ::soap_new_tt__ContinuousFocusOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ContinuousFocusOptions::Speed = Speed;
	}
	return _p;
}

inline tt__ContinuousFocusOptions * soap_new_set_tt__ContinuousFocusOptions(
	struct soap *soap,
	tt__FloatRange *Speed,
	char *__item__1)
{
	tt__ContinuousFocusOptions *_p = ::soap_new_tt__ContinuousFocusOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ContinuousFocusOptions::Speed = Speed;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ContinuousFocusOptions", p->soap_type() == SOAP_TYPE_tt__ContinuousFocusOptions ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ContinuousFocusOptions(struct soap *soap, const char *URL, tt__ContinuousFocusOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ContinuousFocusOptions", p->soap_type() == SOAP_TYPE_tt__ContinuousFocusOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ContinuousFocusOptions(struct soap *soap, const char *URL, tt__ContinuousFocusOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ContinuousFocusOptions", p->soap_type() == SOAP_TYPE_tt__ContinuousFocusOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ContinuousFocusOptions(struct soap *soap, const char *URL, tt__ContinuousFocusOptions const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ContinuousFocusOptions", p->soap_type() == SOAP_TYPE_tt__ContinuousFocusOptions ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ContinuousFocusOptions * SOAP_FMAC4 soap_get_tt__ContinuousFocusOptions(struct soap*, tt__ContinuousFocusOptions *, const char*, const char*);

inline int soap_read_tt__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ContinuousFocusOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ContinuousFocusOptions(struct soap *soap, const char *URL, tt__ContinuousFocusOptions *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ContinuousFocusOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions *p)
{
	if (::soap_read_tt__ContinuousFocusOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions_DEFINED
#define SOAP_TYPE_tt__AbsoluteFocusOptions_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocusOptions(struct soap*, const char*, int, const tt__AbsoluteFocusOptions *, const char*);
SOAP_FMAC3 tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_in_tt__AbsoluteFocusOptions(struct soap*, const char*, tt__AbsoluteFocusOptions *, const char*);
SOAP_FMAC1 tt__AbsoluteFocusOptions * SOAP_FMAC2 imageing_instantiate_tt__AbsoluteFocusOptions(struct soap*, int, const char*, const char*, size_t*);

inline tt__AbsoluteFocusOptions * soap_new_tt__AbsoluteFocusOptions(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__AbsoluteFocusOptions(soap, n, NULL, NULL, NULL);
}

inline tt__AbsoluteFocusOptions * soap_new_req_tt__AbsoluteFocusOptions(
	struct soap *soap,
	tt__FloatRange *Position)
{
	tt__AbsoluteFocusOptions *_p = ::soap_new_tt__AbsoluteFocusOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AbsoluteFocusOptions::Position = Position;
	}
	return _p;
}

inline tt__AbsoluteFocusOptions * soap_new_set_tt__AbsoluteFocusOptions(
	struct soap *soap,
	tt__FloatRange *Position,
	tt__FloatRange *Speed,
	char *__item__1)
{
	tt__AbsoluteFocusOptions *_p = ::soap_new_tt__AbsoluteFocusOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AbsoluteFocusOptions::Position = Position;
		_p->tt__AbsoluteFocusOptions::Speed = Speed;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AbsoluteFocusOptions", p->soap_type() == SOAP_TYPE_tt__AbsoluteFocusOptions ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__AbsoluteFocusOptions(struct soap *soap, const char *URL, tt__AbsoluteFocusOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AbsoluteFocusOptions", p->soap_type() == SOAP_TYPE_tt__AbsoluteFocusOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__AbsoluteFocusOptions(struct soap *soap, const char *URL, tt__AbsoluteFocusOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AbsoluteFocusOptions", p->soap_type() == SOAP_TYPE_tt__AbsoluteFocusOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__AbsoluteFocusOptions(struct soap *soap, const char *URL, tt__AbsoluteFocusOptions const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AbsoluteFocusOptions", p->soap_type() == SOAP_TYPE_tt__AbsoluteFocusOptions ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_get_tt__AbsoluteFocusOptions(struct soap*, tt__AbsoluteFocusOptions *, const char*, const char*);

inline int soap_read_tt__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__AbsoluteFocusOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__AbsoluteFocusOptions(struct soap *soap, const char *URL, tt__AbsoluteFocusOptions *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__AbsoluteFocusOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions *p)
{
	if (::soap_read_tt__AbsoluteFocusOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ContinuousFocus_DEFINED
#define SOAP_TYPE_tt__ContinuousFocus_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocus(struct soap*, const char*, int, const tt__ContinuousFocus *, const char*);
SOAP_FMAC3 tt__ContinuousFocus * SOAP_FMAC4 soap_in_tt__ContinuousFocus(struct soap*, const char*, tt__ContinuousFocus *, const char*);
SOAP_FMAC1 tt__ContinuousFocus * SOAP_FMAC2 imageing_instantiate_tt__ContinuousFocus(struct soap*, int, const char*, const char*, size_t*);

inline tt__ContinuousFocus * soap_new_tt__ContinuousFocus(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ContinuousFocus(soap, n, NULL, NULL, NULL);
}

inline tt__ContinuousFocus * soap_new_req_tt__ContinuousFocus(
	struct soap *soap,
	float Speed)
{
	tt__ContinuousFocus *_p = ::soap_new_tt__ContinuousFocus(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ContinuousFocus::Speed = Speed;
	}
	return _p;
}

inline tt__ContinuousFocus * soap_new_set_tt__ContinuousFocus(
	struct soap *soap,
	float Speed,
	char *__item__1)
{
	tt__ContinuousFocus *_p = ::soap_new_tt__ContinuousFocus(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ContinuousFocus::Speed = Speed;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ContinuousFocus(struct soap *soap, tt__ContinuousFocus const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ContinuousFocus", p->soap_type() == SOAP_TYPE_tt__ContinuousFocus ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ContinuousFocus(struct soap *soap, const char *URL, tt__ContinuousFocus const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ContinuousFocus", p->soap_type() == SOAP_TYPE_tt__ContinuousFocus ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ContinuousFocus(struct soap *soap, const char *URL, tt__ContinuousFocus const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ContinuousFocus", p->soap_type() == SOAP_TYPE_tt__ContinuousFocus ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ContinuousFocus(struct soap *soap, const char *URL, tt__ContinuousFocus const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ContinuousFocus", p->soap_type() == SOAP_TYPE_tt__ContinuousFocus ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ContinuousFocus * SOAP_FMAC4 soap_get_tt__ContinuousFocus(struct soap*, tt__ContinuousFocus *, const char*, const char*);

inline int soap_read_tt__ContinuousFocus(struct soap *soap, tt__ContinuousFocus *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ContinuousFocus(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ContinuousFocus(struct soap *soap, const char *URL, tt__ContinuousFocus *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ContinuousFocus(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ContinuousFocus(struct soap *soap, tt__ContinuousFocus *p)
{
	if (::soap_read_tt__ContinuousFocus(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__RelativeFocus_DEFINED
#define SOAP_TYPE_tt__RelativeFocus_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocus(struct soap*, const char*, int, const tt__RelativeFocus *, const char*);
SOAP_FMAC3 tt__RelativeFocus * SOAP_FMAC4 soap_in_tt__RelativeFocus(struct soap*, const char*, tt__RelativeFocus *, const char*);
SOAP_FMAC1 tt__RelativeFocus * SOAP_FMAC2 imageing_instantiate_tt__RelativeFocus(struct soap*, int, const char*, const char*, size_t*);

inline tt__RelativeFocus * soap_new_tt__RelativeFocus(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__RelativeFocus(soap, n, NULL, NULL, NULL);
}

inline tt__RelativeFocus * soap_new_req_tt__RelativeFocus(
	struct soap *soap,
	float Distance)
{
	tt__RelativeFocus *_p = ::soap_new_tt__RelativeFocus(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__RelativeFocus::Distance = Distance;
	}
	return _p;
}

inline tt__RelativeFocus * soap_new_set_tt__RelativeFocus(
	struct soap *soap,
	float Distance,
	float *Speed,
	char *__item__1)
{
	tt__RelativeFocus *_p = ::soap_new_tt__RelativeFocus(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__RelativeFocus::Distance = Distance;
		_p->tt__RelativeFocus::Speed = Speed;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__RelativeFocus(struct soap *soap, tt__RelativeFocus const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RelativeFocus", p->soap_type() == SOAP_TYPE_tt__RelativeFocus ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__RelativeFocus(struct soap *soap, const char *URL, tt__RelativeFocus const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RelativeFocus", p->soap_type() == SOAP_TYPE_tt__RelativeFocus ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__RelativeFocus(struct soap *soap, const char *URL, tt__RelativeFocus const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RelativeFocus", p->soap_type() == SOAP_TYPE_tt__RelativeFocus ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__RelativeFocus(struct soap *soap, const char *URL, tt__RelativeFocus const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RelativeFocus", p->soap_type() == SOAP_TYPE_tt__RelativeFocus ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__RelativeFocus * SOAP_FMAC4 soap_get_tt__RelativeFocus(struct soap*, tt__RelativeFocus *, const char*, const char*);

inline int soap_read_tt__RelativeFocus(struct soap *soap, tt__RelativeFocus *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__RelativeFocus(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__RelativeFocus(struct soap *soap, const char *URL, tt__RelativeFocus *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__RelativeFocus(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__RelativeFocus(struct soap *soap, tt__RelativeFocus *p)
{
	if (::soap_read_tt__RelativeFocus(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__AbsoluteFocus_DEFINED
#define SOAP_TYPE_tt__AbsoluteFocus_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocus(struct soap*, const char*, int, const tt__AbsoluteFocus *, const char*);
SOAP_FMAC3 tt__AbsoluteFocus * SOAP_FMAC4 soap_in_tt__AbsoluteFocus(struct soap*, const char*, tt__AbsoluteFocus *, const char*);
SOAP_FMAC1 tt__AbsoluteFocus * SOAP_FMAC2 imageing_instantiate_tt__AbsoluteFocus(struct soap*, int, const char*, const char*, size_t*);

inline tt__AbsoluteFocus * soap_new_tt__AbsoluteFocus(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__AbsoluteFocus(soap, n, NULL, NULL, NULL);
}

inline tt__AbsoluteFocus * soap_new_req_tt__AbsoluteFocus(
	struct soap *soap,
	float Position)
{
	tt__AbsoluteFocus *_p = ::soap_new_tt__AbsoluteFocus(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AbsoluteFocus::Position = Position;
	}
	return _p;
}

inline tt__AbsoluteFocus * soap_new_set_tt__AbsoluteFocus(
	struct soap *soap,
	float Position,
	float *Speed,
	char *__item__1)
{
	tt__AbsoluteFocus *_p = ::soap_new_tt__AbsoluteFocus(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AbsoluteFocus::Position = Position;
		_p->tt__AbsoluteFocus::Speed = Speed;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AbsoluteFocus", p->soap_type() == SOAP_TYPE_tt__AbsoluteFocus ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__AbsoluteFocus(struct soap *soap, const char *URL, tt__AbsoluteFocus const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AbsoluteFocus", p->soap_type() == SOAP_TYPE_tt__AbsoluteFocus ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__AbsoluteFocus(struct soap *soap, const char *URL, tt__AbsoluteFocus const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AbsoluteFocus", p->soap_type() == SOAP_TYPE_tt__AbsoluteFocus ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__AbsoluteFocus(struct soap *soap, const char *URL, tt__AbsoluteFocus const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AbsoluteFocus", p->soap_type() == SOAP_TYPE_tt__AbsoluteFocus ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__AbsoluteFocus * SOAP_FMAC4 soap_get_tt__AbsoluteFocus(struct soap*, tt__AbsoluteFocus *, const char*, const char*);

inline int soap_read_tt__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__AbsoluteFocus(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__AbsoluteFocus(struct soap *soap, const char *URL, tt__AbsoluteFocus *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__AbsoluteFocus(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus *p)
{
	if (::soap_read_tt__AbsoluteFocus(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__FocusMove_DEFINED
#define SOAP_TYPE_tt__FocusMove_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusMove(struct soap*, const char*, int, const tt__FocusMove *, const char*);
SOAP_FMAC3 tt__FocusMove * SOAP_FMAC4 soap_in_tt__FocusMove(struct soap*, const char*, tt__FocusMove *, const char*);
SOAP_FMAC1 tt__FocusMove * SOAP_FMAC2 imageing_instantiate_tt__FocusMove(struct soap*, int, const char*, const char*, size_t*);

inline tt__FocusMove * soap_new_tt__FocusMove(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__FocusMove(soap, n, NULL, NULL, NULL);
}

inline tt__FocusMove * soap_new_req_tt__FocusMove(
	struct soap *soap)
{
	tt__FocusMove *_p = ::soap_new_tt__FocusMove(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__FocusMove * soap_new_set_tt__FocusMove(
	struct soap *soap,
	tt__AbsoluteFocus *Absolute,
	tt__RelativeFocus *Relative,
	tt__ContinuousFocus *Continuous,
	char *__item__1)
{
	tt__FocusMove *_p = ::soap_new_tt__FocusMove(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__FocusMove::Absolute = Absolute;
		_p->tt__FocusMove::Relative = Relative;
		_p->tt__FocusMove::Continuous = Continuous;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__FocusMove(struct soap *soap, tt__FocusMove const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusMove", p->soap_type() == SOAP_TYPE_tt__FocusMove ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__FocusMove(struct soap *soap, const char *URL, tt__FocusMove const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusMove", p->soap_type() == SOAP_TYPE_tt__FocusMove ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__FocusMove(struct soap *soap, const char *URL, tt__FocusMove const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusMove", p->soap_type() == SOAP_TYPE_tt__FocusMove ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__FocusMove(struct soap *soap, const char *URL, tt__FocusMove const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FocusMove", p->soap_type() == SOAP_TYPE_tt__FocusMove ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__FocusMove * SOAP_FMAC4 soap_get_tt__FocusMove(struct soap*, tt__FocusMove *, const char*, const char*);

inline int soap_read_tt__FocusMove(struct soap *soap, tt__FocusMove *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__FocusMove(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__FocusMove(struct soap *soap, const char *URL, tt__FocusMove *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__FocusMove(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__FocusMove(struct soap *soap, tt__FocusMove *p)
{
	if (::soap_read_tt__FocusMove(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__PTZSpeed_DEFINED
#define SOAP_TYPE_tt__PTZSpeed_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpeed(struct soap*, const char*, int, const tt__PTZSpeed *, const char*);
SOAP_FMAC3 tt__PTZSpeed * SOAP_FMAC4 soap_in_tt__PTZSpeed(struct soap*, const char*, tt__PTZSpeed *, const char*);
SOAP_FMAC1 tt__PTZSpeed * SOAP_FMAC2 imageing_instantiate_tt__PTZSpeed(struct soap*, int, const char*, const char*, size_t*);

inline tt__PTZSpeed * soap_new_tt__PTZSpeed(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__PTZSpeed(soap, n, NULL, NULL, NULL);
}

inline tt__PTZSpeed * soap_new_req_tt__PTZSpeed(
	struct soap *soap)
{
	tt__PTZSpeed *_p = ::soap_new_tt__PTZSpeed(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__PTZSpeed * soap_new_set_tt__PTZSpeed(
	struct soap *soap,
	tt__Vector2D *PanTilt,
	tt__Vector1D *Zoom,
	char *__item__1)
{
	tt__PTZSpeed *_p = ::soap_new_tt__PTZSpeed(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PTZSpeed::PanTilt = PanTilt;
		_p->tt__PTZSpeed::Zoom = Zoom;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__PTZSpeed(struct soap *soap, tt__PTZSpeed const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZSpeed", p->soap_type() == SOAP_TYPE_tt__PTZSpeed ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__PTZSpeed(struct soap *soap, const char *URL, tt__PTZSpeed const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZSpeed", p->soap_type() == SOAP_TYPE_tt__PTZSpeed ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__PTZSpeed(struct soap *soap, const char *URL, tt__PTZSpeed const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZSpeed", p->soap_type() == SOAP_TYPE_tt__PTZSpeed ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__PTZSpeed(struct soap *soap, const char *URL, tt__PTZSpeed const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZSpeed", p->soap_type() == SOAP_TYPE_tt__PTZSpeed ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__PTZSpeed * SOAP_FMAC4 soap_get_tt__PTZSpeed(struct soap*, tt__PTZSpeed *, const char*, const char*);

inline int soap_read_tt__PTZSpeed(struct soap *soap, tt__PTZSpeed *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__PTZSpeed(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__PTZSpeed(struct soap *soap, const char *URL, tt__PTZSpeed *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__PTZSpeed(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__PTZSpeed(struct soap *soap, tt__PTZSpeed *p)
{
	if (::soap_read_tt__PTZSpeed(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Space1DDescription_DEFINED
#define SOAP_TYPE_tt__Space1DDescription_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space1DDescription(struct soap*, const char*, int, const tt__Space1DDescription *, const char*);
SOAP_FMAC3 tt__Space1DDescription * SOAP_FMAC4 soap_in_tt__Space1DDescription(struct soap*, const char*, tt__Space1DDescription *, const char*);
SOAP_FMAC1 tt__Space1DDescription * SOAP_FMAC2 imageing_instantiate_tt__Space1DDescription(struct soap*, int, const char*, const char*, size_t*);

inline tt__Space1DDescription * soap_new_tt__Space1DDescription(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Space1DDescription(soap, n, NULL, NULL, NULL);
}

inline tt__Space1DDescription * soap_new_req_tt__Space1DDescription(
	struct soap *soap,
	const std::string& URI,
	tt__FloatRange *XRange)
{
	tt__Space1DDescription *_p = ::soap_new_tt__Space1DDescription(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Space1DDescription::URI = URI;
		_p->tt__Space1DDescription::XRange = XRange;
	}
	return _p;
}

inline tt__Space1DDescription * soap_new_set_tt__Space1DDescription(
	struct soap *soap,
	const std::string& URI,
	tt__FloatRange *XRange,
	char *__item__1)
{
	tt__Space1DDescription *_p = ::soap_new_tt__Space1DDescription(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Space1DDescription::URI = URI;
		_p->tt__Space1DDescription::XRange = XRange;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Space1DDescription(struct soap *soap, tt__Space1DDescription const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Space1DDescription", p->soap_type() == SOAP_TYPE_tt__Space1DDescription ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Space1DDescription(struct soap *soap, const char *URL, tt__Space1DDescription const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Space1DDescription", p->soap_type() == SOAP_TYPE_tt__Space1DDescription ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Space1DDescription(struct soap *soap, const char *URL, tt__Space1DDescription const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Space1DDescription", p->soap_type() == SOAP_TYPE_tt__Space1DDescription ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Space1DDescription(struct soap *soap, const char *URL, tt__Space1DDescription const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Space1DDescription", p->soap_type() == SOAP_TYPE_tt__Space1DDescription ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Space1DDescription * SOAP_FMAC4 soap_get_tt__Space1DDescription(struct soap*, tt__Space1DDescription *, const char*, const char*);

inline int soap_read_tt__Space1DDescription(struct soap *soap, tt__Space1DDescription *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Space1DDescription(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Space1DDescription(struct soap *soap, const char *URL, tt__Space1DDescription *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Space1DDescription(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Space1DDescription(struct soap *soap, tt__Space1DDescription *p)
{
	if (::soap_read_tt__Space1DDescription(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Space2DDescription_DEFINED
#define SOAP_TYPE_tt__Space2DDescription_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space2DDescription(struct soap*, const char*, int, const tt__Space2DDescription *, const char*);
SOAP_FMAC3 tt__Space2DDescription * SOAP_FMAC4 soap_in_tt__Space2DDescription(struct soap*, const char*, tt__Space2DDescription *, const char*);
SOAP_FMAC1 tt__Space2DDescription * SOAP_FMAC2 imageing_instantiate_tt__Space2DDescription(struct soap*, int, const char*, const char*, size_t*);

inline tt__Space2DDescription * soap_new_tt__Space2DDescription(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Space2DDescription(soap, n, NULL, NULL, NULL);
}

inline tt__Space2DDescription * soap_new_req_tt__Space2DDescription(
	struct soap *soap,
	const std::string& URI,
	tt__FloatRange *XRange,
	tt__FloatRange *YRange)
{
	tt__Space2DDescription *_p = ::soap_new_tt__Space2DDescription(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Space2DDescription::URI = URI;
		_p->tt__Space2DDescription::XRange = XRange;
		_p->tt__Space2DDescription::YRange = YRange;
	}
	return _p;
}

inline tt__Space2DDescription * soap_new_set_tt__Space2DDescription(
	struct soap *soap,
	const std::string& URI,
	tt__FloatRange *XRange,
	tt__FloatRange *YRange,
	char *__item__1)
{
	tt__Space2DDescription *_p = ::soap_new_tt__Space2DDescription(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Space2DDescription::URI = URI;
		_p->tt__Space2DDescription::XRange = XRange;
		_p->tt__Space2DDescription::YRange = YRange;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Space2DDescription(struct soap *soap, tt__Space2DDescription const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Space2DDescription", p->soap_type() == SOAP_TYPE_tt__Space2DDescription ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Space2DDescription(struct soap *soap, const char *URL, tt__Space2DDescription const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Space2DDescription", p->soap_type() == SOAP_TYPE_tt__Space2DDescription ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Space2DDescription(struct soap *soap, const char *URL, tt__Space2DDescription const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Space2DDescription", p->soap_type() == SOAP_TYPE_tt__Space2DDescription ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Space2DDescription(struct soap *soap, const char *URL, tt__Space2DDescription const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Space2DDescription", p->soap_type() == SOAP_TYPE_tt__Space2DDescription ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Space2DDescription * SOAP_FMAC4 soap_get_tt__Space2DDescription(struct soap*, tt__Space2DDescription *, const char*, const char*);

inline int soap_read_tt__Space2DDescription(struct soap *soap, tt__Space2DDescription *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Space2DDescription(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Space2DDescription(struct soap *soap, const char *URL, tt__Space2DDescription *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Space2DDescription(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Space2DDescription(struct soap *soap, tt__Space2DDescription *p)
{
	if (::soap_read_tt__Space2DDescription(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ZoomLimits_DEFINED
#define SOAP_TYPE_tt__ZoomLimits_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ZoomLimits(struct soap*, const char*, int, const tt__ZoomLimits *, const char*);
SOAP_FMAC3 tt__ZoomLimits * SOAP_FMAC4 soap_in_tt__ZoomLimits(struct soap*, const char*, tt__ZoomLimits *, const char*);
SOAP_FMAC1 tt__ZoomLimits * SOAP_FMAC2 imageing_instantiate_tt__ZoomLimits(struct soap*, int, const char*, const char*, size_t*);

inline tt__ZoomLimits * soap_new_tt__ZoomLimits(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ZoomLimits(soap, n, NULL, NULL, NULL);
}

inline tt__ZoomLimits * soap_new_req_tt__ZoomLimits(
	struct soap *soap,
	tt__Space1DDescription *Range)
{
	tt__ZoomLimits *_p = ::soap_new_tt__ZoomLimits(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ZoomLimits::Range = Range;
	}
	return _p;
}

inline tt__ZoomLimits * soap_new_set_tt__ZoomLimits(
	struct soap *soap,
	tt__Space1DDescription *Range,
	char *__item__1)
{
	tt__ZoomLimits *_p = ::soap_new_tt__ZoomLimits(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ZoomLimits::Range = Range;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ZoomLimits(struct soap *soap, tt__ZoomLimits const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ZoomLimits", p->soap_type() == SOAP_TYPE_tt__ZoomLimits ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ZoomLimits(struct soap *soap, const char *URL, tt__ZoomLimits const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ZoomLimits", p->soap_type() == SOAP_TYPE_tt__ZoomLimits ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ZoomLimits(struct soap *soap, const char *URL, tt__ZoomLimits const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ZoomLimits", p->soap_type() == SOAP_TYPE_tt__ZoomLimits ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ZoomLimits(struct soap *soap, const char *URL, tt__ZoomLimits const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ZoomLimits", p->soap_type() == SOAP_TYPE_tt__ZoomLimits ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ZoomLimits * SOAP_FMAC4 soap_get_tt__ZoomLimits(struct soap*, tt__ZoomLimits *, const char*, const char*);

inline int soap_read_tt__ZoomLimits(struct soap *soap, tt__ZoomLimits *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ZoomLimits(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ZoomLimits(struct soap *soap, const char *URL, tt__ZoomLimits *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ZoomLimits(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ZoomLimits(struct soap *soap, tt__ZoomLimits *p)
{
	if (::soap_read_tt__ZoomLimits(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__PanTiltLimits_DEFINED
#define SOAP_TYPE_tt__PanTiltLimits_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PanTiltLimits(struct soap*, const char*, int, const tt__PanTiltLimits *, const char*);
SOAP_FMAC3 tt__PanTiltLimits * SOAP_FMAC4 soap_in_tt__PanTiltLimits(struct soap*, const char*, tt__PanTiltLimits *, const char*);
SOAP_FMAC1 tt__PanTiltLimits * SOAP_FMAC2 imageing_instantiate_tt__PanTiltLimits(struct soap*, int, const char*, const char*, size_t*);

inline tt__PanTiltLimits * soap_new_tt__PanTiltLimits(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__PanTiltLimits(soap, n, NULL, NULL, NULL);
}

inline tt__PanTiltLimits * soap_new_req_tt__PanTiltLimits(
	struct soap *soap,
	tt__Space2DDescription *Range)
{
	tt__PanTiltLimits *_p = ::soap_new_tt__PanTiltLimits(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PanTiltLimits::Range = Range;
	}
	return _p;
}

inline tt__PanTiltLimits * soap_new_set_tt__PanTiltLimits(
	struct soap *soap,
	tt__Space2DDescription *Range,
	char *__item__1)
{
	tt__PanTiltLimits *_p = ::soap_new_tt__PanTiltLimits(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PanTiltLimits::Range = Range;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__PanTiltLimits(struct soap *soap, tt__PanTiltLimits const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PanTiltLimits", p->soap_type() == SOAP_TYPE_tt__PanTiltLimits ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__PanTiltLimits(struct soap *soap, const char *URL, tt__PanTiltLimits const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PanTiltLimits", p->soap_type() == SOAP_TYPE_tt__PanTiltLimits ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__PanTiltLimits(struct soap *soap, const char *URL, tt__PanTiltLimits const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PanTiltLimits", p->soap_type() == SOAP_TYPE_tt__PanTiltLimits ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__PanTiltLimits(struct soap *soap, const char *URL, tt__PanTiltLimits const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PanTiltLimits", p->soap_type() == SOAP_TYPE_tt__PanTiltLimits ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__PanTiltLimits * SOAP_FMAC4 soap_get_tt__PanTiltLimits(struct soap*, tt__PanTiltLimits *, const char*, const char*);

inline int soap_read_tt__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__PanTiltLimits(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__PanTiltLimits(struct soap *soap, const char *URL, tt__PanTiltLimits *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__PanTiltLimits(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *p)
{
	if (::soap_read_tt__PanTiltLimits(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Reverse_DEFINED
#define SOAP_TYPE_tt__Reverse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Reverse(struct soap*, const char*, int, const tt__Reverse *, const char*);
SOAP_FMAC3 tt__Reverse * SOAP_FMAC4 soap_in_tt__Reverse(struct soap*, const char*, tt__Reverse *, const char*);
SOAP_FMAC1 tt__Reverse * SOAP_FMAC2 imageing_instantiate_tt__Reverse(struct soap*, int, const char*, const char*, size_t*);

inline tt__Reverse * soap_new_tt__Reverse(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Reverse(soap, n, NULL, NULL, NULL);
}

inline tt__Reverse * soap_new_req_tt__Reverse(
	struct soap *soap,
	enum tt__ReverseMode Mode)
{
	tt__Reverse *_p = ::soap_new_tt__Reverse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Reverse::Mode = Mode;
	}
	return _p;
}

inline tt__Reverse * soap_new_set_tt__Reverse(
	struct soap *soap,
	enum tt__ReverseMode Mode,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	char *__item__1)
{
	tt__Reverse *_p = ::soap_new_tt__Reverse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Reverse::Mode = Mode;
		_p->tt__Reverse::__any = __any;
		_p->tt__Reverse::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Reverse(struct soap *soap, tt__Reverse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Reverse", p->soap_type() == SOAP_TYPE_tt__Reverse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Reverse(struct soap *soap, const char *URL, tt__Reverse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Reverse", p->soap_type() == SOAP_TYPE_tt__Reverse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Reverse(struct soap *soap, const char *URL, tt__Reverse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Reverse", p->soap_type() == SOAP_TYPE_tt__Reverse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Reverse(struct soap *soap, const char *URL, tt__Reverse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Reverse", p->soap_type() == SOAP_TYPE_tt__Reverse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Reverse * SOAP_FMAC4 soap_get_tt__Reverse(struct soap*, tt__Reverse *, const char*, const char*);

inline int soap_read_tt__Reverse(struct soap *soap, tt__Reverse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Reverse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Reverse(struct soap *soap, const char *URL, tt__Reverse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Reverse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Reverse(struct soap *soap, tt__Reverse *p)
{
	if (::soap_read_tt__Reverse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__EFlip_DEFINED
#define SOAP_TYPE_tt__EFlip_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlip(struct soap*, const char*, int, const tt__EFlip *, const char*);
SOAP_FMAC3 tt__EFlip * SOAP_FMAC4 soap_in_tt__EFlip(struct soap*, const char*, tt__EFlip *, const char*);
SOAP_FMAC1 tt__EFlip * SOAP_FMAC2 imageing_instantiate_tt__EFlip(struct soap*, int, const char*, const char*, size_t*);

inline tt__EFlip * soap_new_tt__EFlip(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__EFlip(soap, n, NULL, NULL, NULL);
}

inline tt__EFlip * soap_new_req_tt__EFlip(
	struct soap *soap,
	enum tt__EFlipMode Mode)
{
	tt__EFlip *_p = ::soap_new_tt__EFlip(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__EFlip::Mode = Mode;
	}
	return _p;
}

inline tt__EFlip * soap_new_set_tt__EFlip(
	struct soap *soap,
	enum tt__EFlipMode Mode,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	char *__item__1)
{
	tt__EFlip *_p = ::soap_new_tt__EFlip(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__EFlip::Mode = Mode;
		_p->tt__EFlip::__any = __any;
		_p->tt__EFlip::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__EFlip(struct soap *soap, tt__EFlip const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EFlip", p->soap_type() == SOAP_TYPE_tt__EFlip ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__EFlip(struct soap *soap, const char *URL, tt__EFlip const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EFlip", p->soap_type() == SOAP_TYPE_tt__EFlip ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__EFlip(struct soap *soap, const char *URL, tt__EFlip const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EFlip", p->soap_type() == SOAP_TYPE_tt__EFlip ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__EFlip(struct soap *soap, const char *URL, tt__EFlip const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EFlip", p->soap_type() == SOAP_TYPE_tt__EFlip ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__EFlip * SOAP_FMAC4 soap_get_tt__EFlip(struct soap*, tt__EFlip *, const char*, const char*);

inline int soap_read_tt__EFlip(struct soap *soap, tt__EFlip *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__EFlip(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__EFlip(struct soap *soap, const char *URL, tt__EFlip *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__EFlip(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__EFlip(struct soap *soap, tt__EFlip *p)
{
	if (::soap_read_tt__EFlip(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__PTControlDirectionExtension_DEFINED
#define SOAP_TYPE_tt__PTControlDirectionExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionExtension(struct soap*, const char*, int, const tt__PTControlDirectionExtension *, const char*);
SOAP_FMAC3 tt__PTControlDirectionExtension * SOAP_FMAC4 soap_in_tt__PTControlDirectionExtension(struct soap*, const char*, tt__PTControlDirectionExtension *, const char*);
SOAP_FMAC1 tt__PTControlDirectionExtension * SOAP_FMAC2 imageing_instantiate_tt__PTControlDirectionExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__PTControlDirectionExtension * soap_new_tt__PTControlDirectionExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__PTControlDirectionExtension(soap, n, NULL, NULL, NULL);
}

inline tt__PTControlDirectionExtension * soap_new_req_tt__PTControlDirectionExtension(
	struct soap *soap)
{
	tt__PTControlDirectionExtension *_p = ::soap_new_tt__PTControlDirectionExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__PTControlDirectionExtension * soap_new_set_tt__PTControlDirectionExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	char *__item__1)
{
	tt__PTControlDirectionExtension *_p = ::soap_new_tt__PTControlDirectionExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PTControlDirectionExtension::__any = __any;
		_p->tt__PTControlDirectionExtension::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTControlDirectionExtension", p->soap_type() == SOAP_TYPE_tt__PTControlDirectionExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__PTControlDirectionExtension(struct soap *soap, const char *URL, tt__PTControlDirectionExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTControlDirectionExtension", p->soap_type() == SOAP_TYPE_tt__PTControlDirectionExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__PTControlDirectionExtension(struct soap *soap, const char *URL, tt__PTControlDirectionExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTControlDirectionExtension", p->soap_type() == SOAP_TYPE_tt__PTControlDirectionExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__PTControlDirectionExtension(struct soap *soap, const char *URL, tt__PTControlDirectionExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTControlDirectionExtension", p->soap_type() == SOAP_TYPE_tt__PTControlDirectionExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__PTControlDirectionExtension * SOAP_FMAC4 soap_get_tt__PTControlDirectionExtension(struct soap*, tt__PTControlDirectionExtension *, const char*, const char*);

inline int soap_read_tt__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__PTControlDirectionExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__PTControlDirectionExtension(struct soap *soap, const char *URL, tt__PTControlDirectionExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__PTControlDirectionExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension *p)
{
	if (::soap_read_tt__PTControlDirectionExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__PTControlDirection_DEFINED
#define SOAP_TYPE_tt__PTControlDirection_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirection(struct soap*, const char*, int, const tt__PTControlDirection *, const char*);
SOAP_FMAC3 tt__PTControlDirection * SOAP_FMAC4 soap_in_tt__PTControlDirection(struct soap*, const char*, tt__PTControlDirection *, const char*);
SOAP_FMAC1 tt__PTControlDirection * SOAP_FMAC2 imageing_instantiate_tt__PTControlDirection(struct soap*, int, const char*, const char*, size_t*);

inline tt__PTControlDirection * soap_new_tt__PTControlDirection(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__PTControlDirection(soap, n, NULL, NULL, NULL);
}

inline tt__PTControlDirection * soap_new_req_tt__PTControlDirection(
	struct soap *soap)
{
	tt__PTControlDirection *_p = ::soap_new_tt__PTControlDirection(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__PTControlDirection * soap_new_set_tt__PTControlDirection(
	struct soap *soap,
	tt__EFlip *EFlip,
	tt__Reverse *Reverse,
	tt__PTControlDirectionExtension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__PTControlDirection *_p = ::soap_new_tt__PTControlDirection(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PTControlDirection::EFlip = EFlip;
		_p->tt__PTControlDirection::Reverse = Reverse;
		_p->tt__PTControlDirection::Extension = Extension;
		_p->tt__PTControlDirection::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__PTControlDirection(struct soap *soap, tt__PTControlDirection const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTControlDirection", p->soap_type() == SOAP_TYPE_tt__PTControlDirection ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__PTControlDirection(struct soap *soap, const char *URL, tt__PTControlDirection const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTControlDirection", p->soap_type() == SOAP_TYPE_tt__PTControlDirection ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__PTControlDirection(struct soap *soap, const char *URL, tt__PTControlDirection const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTControlDirection", p->soap_type() == SOAP_TYPE_tt__PTControlDirection ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__PTControlDirection(struct soap *soap, const char *URL, tt__PTControlDirection const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTControlDirection", p->soap_type() == SOAP_TYPE_tt__PTControlDirection ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__PTControlDirection * SOAP_FMAC4 soap_get_tt__PTControlDirection(struct soap*, tt__PTControlDirection *, const char*, const char*);

inline int soap_read_tt__PTControlDirection(struct soap *soap, tt__PTControlDirection *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__PTControlDirection(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__PTControlDirection(struct soap *soap, const char *URL, tt__PTControlDirection *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__PTControlDirection(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__PTControlDirection(struct soap *soap, tt__PTControlDirection *p)
{
	if (::soap_read_tt__PTControlDirection(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__PTZConfigurationExtension2_DEFINED
#define SOAP_TYPE_tt__PTZConfigurationExtension2_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension2(struct soap*, const char*, int, const tt__PTZConfigurationExtension2 *, const char*);
SOAP_FMAC3 tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension2(struct soap*, const char*, tt__PTZConfigurationExtension2 *, const char*);
SOAP_FMAC1 tt__PTZConfigurationExtension2 * SOAP_FMAC2 imageing_instantiate_tt__PTZConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);

inline tt__PTZConfigurationExtension2 * soap_new_tt__PTZConfigurationExtension2(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__PTZConfigurationExtension2(soap, n, NULL, NULL, NULL);
}

inline tt__PTZConfigurationExtension2 * soap_new_req_tt__PTZConfigurationExtension2(
	struct soap *soap)
{
	tt__PTZConfigurationExtension2 *_p = ::soap_new_tt__PTZConfigurationExtension2(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__PTZConfigurationExtension2 * soap_new_set_tt__PTZConfigurationExtension2(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__PTZConfigurationExtension2 *_p = ::soap_new_tt__PTZConfigurationExtension2(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PTZConfigurationExtension2::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZConfigurationExtension2", p->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension2 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__PTZConfigurationExtension2(struct soap *soap, const char *URL, tt__PTZConfigurationExtension2 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZConfigurationExtension2", p->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension2 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__PTZConfigurationExtension2(struct soap *soap, const char *URL, tt__PTZConfigurationExtension2 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZConfigurationExtension2", p->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension2 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__PTZConfigurationExtension2(struct soap *soap, const char *URL, tt__PTZConfigurationExtension2 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZConfigurationExtension2", p->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension2 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension2(struct soap*, tt__PTZConfigurationExtension2 *, const char*, const char*);

inline int soap_read_tt__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__PTZConfigurationExtension2(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__PTZConfigurationExtension2(struct soap *soap, const char *URL, tt__PTZConfigurationExtension2 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__PTZConfigurationExtension2(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 *p)
{
	if (::soap_read_tt__PTZConfigurationExtension2(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__PTZConfigurationExtension_DEFINED
#define SOAP_TYPE_tt__PTZConfigurationExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension(struct soap*, const char*, int, const tt__PTZConfigurationExtension *, const char*);
SOAP_FMAC3 tt__PTZConfigurationExtension * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension(struct soap*, const char*, tt__PTZConfigurationExtension *, const char*);
SOAP_FMAC1 tt__PTZConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__PTZConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__PTZConfigurationExtension * soap_new_tt__PTZConfigurationExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__PTZConfigurationExtension(soap, n, NULL, NULL, NULL);
}

inline tt__PTZConfigurationExtension * soap_new_req_tt__PTZConfigurationExtension(
	struct soap *soap)
{
	tt__PTZConfigurationExtension *_p = ::soap_new_tt__PTZConfigurationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__PTZConfigurationExtension * soap_new_set_tt__PTZConfigurationExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	tt__PTControlDirection *PTControlDirection,
	tt__PTZConfigurationExtension2 *Extension,
	char *__item__1)
{
	tt__PTZConfigurationExtension *_p = ::soap_new_tt__PTZConfigurationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PTZConfigurationExtension::__any = __any;
		_p->tt__PTZConfigurationExtension::PTControlDirection = PTControlDirection;
		_p->tt__PTZConfigurationExtension::Extension = Extension;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__PTZConfigurationExtension(struct soap *soap, const char *URL, tt__PTZConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__PTZConfigurationExtension(struct soap *soap, const char *URL, tt__PTZConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__PTZConfigurationExtension(struct soap *soap, const char *URL, tt__PTZConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__PTZConfigurationExtension * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension(struct soap*, tt__PTZConfigurationExtension *, const char*, const char*);

inline int soap_read_tt__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__PTZConfigurationExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__PTZConfigurationExtension(struct soap *soap, const char *URL, tt__PTZConfigurationExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__PTZConfigurationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *p)
{
	if (::soap_read_tt__PTZConfigurationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__PTZConfiguration_DEFINED
#define SOAP_TYPE_tt__PTZConfiguration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfiguration(struct soap*, const char*, int, const tt__PTZConfiguration *, const char*);
SOAP_FMAC3 tt__PTZConfiguration * SOAP_FMAC4 soap_in_tt__PTZConfiguration(struct soap*, const char*, tt__PTZConfiguration *, const char*);
SOAP_FMAC1 tt__PTZConfiguration * SOAP_FMAC2 imageing_instantiate_tt__PTZConfiguration(struct soap*, int, const char*, const char*, size_t*);

inline tt__PTZConfiguration * soap_new_tt__PTZConfiguration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__PTZConfiguration(soap, n, NULL, NULL, NULL);
}

inline tt__PTZConfiguration * soap_new_req_tt__PTZConfiguration(
	struct soap *soap,
	const std::string& NodeToken,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1)
{
	tt__PTZConfiguration *_p = ::soap_new_tt__PTZConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PTZConfiguration::NodeToken = NodeToken;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
	}
	return _p;
}

inline tt__PTZConfiguration * soap_new_set_tt__PTZConfiguration(
	struct soap *soap,
	const std::string& NodeToken,
	std::string *DefaultAbsolutePantTiltPositionSpace,
	std::string *DefaultAbsoluteZoomPositionSpace,
	std::string *DefaultRelativePanTiltTranslationSpace,
	std::string *DefaultRelativeZoomTranslationSpace,
	std::string *DefaultContinuousPanTiltVelocitySpace,
	std::string *DefaultContinuousZoomVelocitySpace,
	tt__PTZSpeed *DefaultPTZSpeed,
	std::string *DefaultPTZTimeout,
	tt__PanTiltLimits *PanTiltLimits,
	tt__ZoomLimits *ZoomLimits,
	tt__PTZConfigurationExtension *Extension,
	int *MoveRamp,
	int *PresetRamp,
	int *PresetTourRamp,
	char *__anyAttribute,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1,
	char *__item__2)
{
	tt__PTZConfiguration *_p = ::soap_new_tt__PTZConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PTZConfiguration::NodeToken = NodeToken;
		_p->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace = DefaultAbsolutePantTiltPositionSpace;
		_p->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace = DefaultAbsoluteZoomPositionSpace;
		_p->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace = DefaultRelativePanTiltTranslationSpace;
		_p->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace = DefaultRelativeZoomTranslationSpace;
		_p->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace = DefaultContinuousPanTiltVelocitySpace;
		_p->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace = DefaultContinuousZoomVelocitySpace;
		_p->tt__PTZConfiguration::DefaultPTZSpeed = DefaultPTZSpeed;
		_p->tt__PTZConfiguration::DefaultPTZTimeout = DefaultPTZTimeout;
		_p->tt__PTZConfiguration::PanTiltLimits = PanTiltLimits;
		_p->tt__PTZConfiguration::ZoomLimits = ZoomLimits;
		_p->tt__PTZConfiguration::Extension = Extension;
		_p->tt__PTZConfiguration::MoveRamp = MoveRamp;
		_p->tt__PTZConfiguration::PresetRamp = PresetRamp;
		_p->tt__PTZConfiguration::PresetTourRamp = PresetTourRamp;
		_p->tt__PTZConfiguration::__anyAttribute = __anyAttribute;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_tt__PTZConfiguration(struct soap *soap, tt__PTZConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZConfiguration", p->soap_type() == SOAP_TYPE_tt__PTZConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__PTZConfiguration(struct soap *soap, const char *URL, tt__PTZConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZConfiguration", p->soap_type() == SOAP_TYPE_tt__PTZConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__PTZConfiguration(struct soap *soap, const char *URL, tt__PTZConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZConfiguration", p->soap_type() == SOAP_TYPE_tt__PTZConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__PTZConfiguration(struct soap *soap, const char *URL, tt__PTZConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZConfiguration", p->soap_type() == SOAP_TYPE_tt__PTZConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__PTZConfiguration * SOAP_FMAC4 soap_get_tt__PTZConfiguration(struct soap*, tt__PTZConfiguration *, const char*, const char*);

inline int soap_read_tt__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__PTZConfiguration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__PTZConfiguration(struct soap *soap, const char *URL, tt__PTZConfiguration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__PTZConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *p)
{
	if (::soap_read_tt__PTZConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IPAddress_DEFINED
#define SOAP_TYPE_tt__IPAddress_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddress(struct soap*, const char*, int, const tt__IPAddress *, const char*);
SOAP_FMAC3 tt__IPAddress * SOAP_FMAC4 soap_in_tt__IPAddress(struct soap*, const char*, tt__IPAddress *, const char*);
SOAP_FMAC1 tt__IPAddress * SOAP_FMAC2 imageing_instantiate_tt__IPAddress(struct soap*, int, const char*, const char*, size_t*);

inline tt__IPAddress * soap_new_tt__IPAddress(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__IPAddress(soap, n, NULL, NULL, NULL);
}

inline tt__IPAddress * soap_new_req_tt__IPAddress(
	struct soap *soap,
	enum tt__IPType Type)
{
	tt__IPAddress *_p = ::soap_new_tt__IPAddress(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IPAddress::Type = Type;
	}
	return _p;
}

inline tt__IPAddress * soap_new_set_tt__IPAddress(
	struct soap *soap,
	enum tt__IPType Type,
	std::string *IPv4Address,
	std::string *IPv6Address,
	char *__item__1)
{
	tt__IPAddress *_p = ::soap_new_tt__IPAddress(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IPAddress::Type = Type;
		_p->tt__IPAddress::IPv4Address = IPv4Address;
		_p->tt__IPAddress::IPv6Address = IPv6Address;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__IPAddress(struct soap *soap, tt__IPAddress const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPAddress", p->soap_type() == SOAP_TYPE_tt__IPAddress ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__IPAddress(struct soap *soap, const char *URL, tt__IPAddress const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPAddress", p->soap_type() == SOAP_TYPE_tt__IPAddress ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IPAddress(struct soap *soap, const char *URL, tt__IPAddress const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPAddress", p->soap_type() == SOAP_TYPE_tt__IPAddress ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IPAddress(struct soap *soap, const char *URL, tt__IPAddress const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IPAddress", p->soap_type() == SOAP_TYPE_tt__IPAddress ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__IPAddress * SOAP_FMAC4 soap_get_tt__IPAddress(struct soap*, tt__IPAddress *, const char*, const char*);

inline int soap_read_tt__IPAddress(struct soap *soap, tt__IPAddress *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__IPAddress(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IPAddress(struct soap *soap, const char *URL, tt__IPAddress *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IPAddress(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IPAddress(struct soap *soap, tt__IPAddress *p)
{
	if (::soap_read_tt__IPAddress(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__MulticastConfiguration_DEFINED
#define SOAP_TYPE_tt__MulticastConfiguration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MulticastConfiguration(struct soap*, const char*, int, const tt__MulticastConfiguration *, const char*);
SOAP_FMAC3 tt__MulticastConfiguration * SOAP_FMAC4 soap_in_tt__MulticastConfiguration(struct soap*, const char*, tt__MulticastConfiguration *, const char*);
SOAP_FMAC1 tt__MulticastConfiguration * SOAP_FMAC2 imageing_instantiate_tt__MulticastConfiguration(struct soap*, int, const char*, const char*, size_t*);

inline tt__MulticastConfiguration * soap_new_tt__MulticastConfiguration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__MulticastConfiguration(soap, n, NULL, NULL, NULL);
}

inline tt__MulticastConfiguration * soap_new_req_tt__MulticastConfiguration(
	struct soap *soap,
	tt__IPAddress *Address,
	int Port,
	int TTL,
	bool AutoStart)
{
	tt__MulticastConfiguration *_p = ::soap_new_tt__MulticastConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__MulticastConfiguration::Address = Address;
		_p->tt__MulticastConfiguration::Port = Port;
		_p->tt__MulticastConfiguration::TTL = TTL;
		_p->tt__MulticastConfiguration::AutoStart = AutoStart;
	}
	return _p;
}

inline tt__MulticastConfiguration * soap_new_set_tt__MulticastConfiguration(
	struct soap *soap,
	tt__IPAddress *Address,
	int Port,
	int TTL,
	bool AutoStart,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	char *__item__1)
{
	tt__MulticastConfiguration *_p = ::soap_new_tt__MulticastConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__MulticastConfiguration::Address = Address;
		_p->tt__MulticastConfiguration::Port = Port;
		_p->tt__MulticastConfiguration::TTL = TTL;
		_p->tt__MulticastConfiguration::AutoStart = AutoStart;
		_p->tt__MulticastConfiguration::__any = __any;
		_p->tt__MulticastConfiguration::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MulticastConfiguration", p->soap_type() == SOAP_TYPE_tt__MulticastConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__MulticastConfiguration(struct soap *soap, const char *URL, tt__MulticastConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MulticastConfiguration", p->soap_type() == SOAP_TYPE_tt__MulticastConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__MulticastConfiguration(struct soap *soap, const char *URL, tt__MulticastConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MulticastConfiguration", p->soap_type() == SOAP_TYPE_tt__MulticastConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__MulticastConfiguration(struct soap *soap, const char *URL, tt__MulticastConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MulticastConfiguration", p->soap_type() == SOAP_TYPE_tt__MulticastConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__MulticastConfiguration * SOAP_FMAC4 soap_get_tt__MulticastConfiguration(struct soap*, tt__MulticastConfiguration *, const char*, const char*);

inline int soap_read_tt__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__MulticastConfiguration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__MulticastConfiguration(struct soap *soap, const char *URL, tt__MulticastConfiguration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__MulticastConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *p)
{
	if (::soap_read_tt__MulticastConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__AudioDecoderConfiguration_DEFINED
#define SOAP_TYPE_tt__AudioDecoderConfiguration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfiguration(struct soap*, const char*, int, const tt__AudioDecoderConfiguration *, const char*);
SOAP_FMAC3 tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioDecoderConfiguration(struct soap*, const char*, tt__AudioDecoderConfiguration *, const char*);
SOAP_FMAC1 tt__AudioDecoderConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);

inline tt__AudioDecoderConfiguration * soap_new_tt__AudioDecoderConfiguration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__AudioDecoderConfiguration(soap, n, NULL, NULL, NULL);
}

inline tt__AudioDecoderConfiguration * soap_new_req_tt__AudioDecoderConfiguration(
	struct soap *soap,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1)
{
	tt__AudioDecoderConfiguration *_p = ::soap_new_tt__AudioDecoderConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
	}
	return _p;
}

inline tt__AudioDecoderConfiguration * soap_new_set_tt__AudioDecoderConfiguration(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1,
	char *__item__2)
{
	tt__AudioDecoderConfiguration *_p = ::soap_new_tt__AudioDecoderConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AudioDecoderConfiguration::__any = __any;
		_p->tt__AudioDecoderConfiguration::__anyAttribute = __anyAttribute;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_tt__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioDecoderConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioDecoderConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__AudioDecoderConfiguration(struct soap *soap, const char *URL, tt__AudioDecoderConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioDecoderConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioDecoderConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__AudioDecoderConfiguration(struct soap *soap, const char *URL, tt__AudioDecoderConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioDecoderConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioDecoderConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__AudioDecoderConfiguration(struct soap *soap, const char *URL, tt__AudioDecoderConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioDecoderConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioDecoderConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioDecoderConfiguration(struct soap*, tt__AudioDecoderConfiguration *, const char*, const char*);

inline int soap_read_tt__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__AudioDecoderConfiguration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__AudioDecoderConfiguration(struct soap *soap, const char *URL, tt__AudioDecoderConfiguration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__AudioDecoderConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration *p)
{
	if (::soap_read_tt__AudioDecoderConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__AudioOutputConfiguration_DEFINED
#define SOAP_TYPE_tt__AudioOutputConfiguration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutputConfiguration(struct soap*, const char*, int, const tt__AudioOutputConfiguration *, const char*);
SOAP_FMAC3 tt__AudioOutputConfiguration * SOAP_FMAC4 soap_in_tt__AudioOutputConfiguration(struct soap*, const char*, tt__AudioOutputConfiguration *, const char*);
SOAP_FMAC1 tt__AudioOutputConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);

inline tt__AudioOutputConfiguration * soap_new_tt__AudioOutputConfiguration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__AudioOutputConfiguration(soap, n, NULL, NULL, NULL);
}

inline tt__AudioOutputConfiguration * soap_new_req_tt__AudioOutputConfiguration(
	struct soap *soap,
	const std::string& OutputToken,
	int OutputLevel,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1)
{
	tt__AudioOutputConfiguration *_p = ::soap_new_tt__AudioOutputConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AudioOutputConfiguration::OutputToken = OutputToken;
		_p->tt__AudioOutputConfiguration::OutputLevel = OutputLevel;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
	}
	return _p;
}

inline tt__AudioOutputConfiguration * soap_new_set_tt__AudioOutputConfiguration(
	struct soap *soap,
	const std::string& OutputToken,
	std::string *SendPrimacy,
	int OutputLevel,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1,
	char *__item__2)
{
	tt__AudioOutputConfiguration *_p = ::soap_new_tt__AudioOutputConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AudioOutputConfiguration::OutputToken = OutputToken;
		_p->tt__AudioOutputConfiguration::SendPrimacy = SendPrimacy;
		_p->tt__AudioOutputConfiguration::OutputLevel = OutputLevel;
		_p->tt__AudioOutputConfiguration::__any = __any;
		_p->tt__AudioOutputConfiguration::__anyAttribute = __anyAttribute;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_tt__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioOutputConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioOutputConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__AudioOutputConfiguration(struct soap *soap, const char *URL, tt__AudioOutputConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioOutputConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioOutputConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__AudioOutputConfiguration(struct soap *soap, const char *URL, tt__AudioOutputConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioOutputConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioOutputConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__AudioOutputConfiguration(struct soap *soap, const char *URL, tt__AudioOutputConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioOutputConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioOutputConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__AudioOutputConfiguration * SOAP_FMAC4 soap_get_tt__AudioOutputConfiguration(struct soap*, tt__AudioOutputConfiguration *, const char*, const char*);

inline int soap_read_tt__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__AudioOutputConfiguration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__AudioOutputConfiguration(struct soap *soap, const char *URL, tt__AudioOutputConfiguration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__AudioOutputConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration *p)
{
	if (::soap_read_tt__AudioOutputConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__EventSubscription_DEFINED
#define SOAP_TYPE_tt__EventSubscription_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventSubscription(struct soap*, const char*, int, const tt__EventSubscription *, const char*);
SOAP_FMAC3 tt__EventSubscription * SOAP_FMAC4 soap_in_tt__EventSubscription(struct soap*, const char*, tt__EventSubscription *, const char*);
SOAP_FMAC1 tt__EventSubscription * SOAP_FMAC2 imageing_instantiate_tt__EventSubscription(struct soap*, int, const char*, const char*, size_t*);

inline tt__EventSubscription * soap_new_tt__EventSubscription(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__EventSubscription(soap, n, NULL, NULL, NULL);
}

inline tt__EventSubscription * soap_new_req_tt__EventSubscription(
	struct soap *soap)
{
	tt__EventSubscription *_p = ::soap_new_tt__EventSubscription(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__EventSubscription * soap_new_set_tt__EventSubscription(
	struct soap *soap,
	wsnt__FilterType *Filter,
	_tt__EventSubscription_SubscriptionPolicy *SubscriptionPolicy,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	char *__item__1)
{
	tt__EventSubscription *_p = ::soap_new_tt__EventSubscription(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__EventSubscription::Filter = Filter;
		_p->tt__EventSubscription::SubscriptionPolicy = SubscriptionPolicy;
		_p->tt__EventSubscription::__any = __any;
		_p->tt__EventSubscription::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__EventSubscription(struct soap *soap, tt__EventSubscription const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EventSubscription", p->soap_type() == SOAP_TYPE_tt__EventSubscription ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__EventSubscription(struct soap *soap, const char *URL, tt__EventSubscription const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EventSubscription", p->soap_type() == SOAP_TYPE_tt__EventSubscription ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__EventSubscription(struct soap *soap, const char *URL, tt__EventSubscription const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EventSubscription", p->soap_type() == SOAP_TYPE_tt__EventSubscription ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__EventSubscription(struct soap *soap, const char *URL, tt__EventSubscription const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:EventSubscription", p->soap_type() == SOAP_TYPE_tt__EventSubscription ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__EventSubscription * SOAP_FMAC4 soap_get_tt__EventSubscription(struct soap*, tt__EventSubscription *, const char*, const char*);

inline int soap_read_tt__EventSubscription(struct soap *soap, tt__EventSubscription *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__EventSubscription(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__EventSubscription(struct soap *soap, const char *URL, tt__EventSubscription *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__EventSubscription(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__EventSubscription(struct soap *soap, tt__EventSubscription *p)
{
	if (::soap_read_tt__EventSubscription(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__PTZFilter_DEFINED
#define SOAP_TYPE_tt__PTZFilter_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZFilter(struct soap*, const char*, int, const tt__PTZFilter *, const char*);
SOAP_FMAC3 tt__PTZFilter * SOAP_FMAC4 soap_in_tt__PTZFilter(struct soap*, const char*, tt__PTZFilter *, const char*);
SOAP_FMAC1 tt__PTZFilter * SOAP_FMAC2 imageing_instantiate_tt__PTZFilter(struct soap*, int, const char*, const char*, size_t*);

inline tt__PTZFilter * soap_new_tt__PTZFilter(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__PTZFilter(soap, n, NULL, NULL, NULL);
}

inline tt__PTZFilter * soap_new_req_tt__PTZFilter(
	struct soap *soap,
	bool Status,
	bool Position)
{
	tt__PTZFilter *_p = ::soap_new_tt__PTZFilter(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PTZFilter::Status = Status;
		_p->tt__PTZFilter::Position = Position;
	}
	return _p;
}

inline tt__PTZFilter * soap_new_set_tt__PTZFilter(
	struct soap *soap,
	bool Status,
	bool Position,
	char *__anyAttribute,
	char *__item__1)
{
	tt__PTZFilter *_p = ::soap_new_tt__PTZFilter(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__PTZFilter::Status = Status;
		_p->tt__PTZFilter::Position = Position;
		_p->tt__PTZFilter::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__PTZFilter(struct soap *soap, tt__PTZFilter const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZFilter", p->soap_type() == SOAP_TYPE_tt__PTZFilter ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__PTZFilter(struct soap *soap, const char *URL, tt__PTZFilter const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZFilter", p->soap_type() == SOAP_TYPE_tt__PTZFilter ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__PTZFilter(struct soap *soap, const char *URL, tt__PTZFilter const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZFilter", p->soap_type() == SOAP_TYPE_tt__PTZFilter ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__PTZFilter(struct soap *soap, const char *URL, tt__PTZFilter const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:PTZFilter", p->soap_type() == SOAP_TYPE_tt__PTZFilter ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__PTZFilter * SOAP_FMAC4 soap_get_tt__PTZFilter(struct soap*, tt__PTZFilter *, const char*, const char*);

inline int soap_read_tt__PTZFilter(struct soap *soap, tt__PTZFilter *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__PTZFilter(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__PTZFilter(struct soap *soap, const char *URL, tt__PTZFilter *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__PTZFilter(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__PTZFilter(struct soap *soap, tt__PTZFilter *p)
{
	if (::soap_read_tt__PTZFilter(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__MetadataConfigurationExtension_DEFINED
#define SOAP_TYPE_tt__MetadataConfigurationExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationExtension(struct soap*, const char*, int, const tt__MetadataConfigurationExtension *, const char*);
SOAP_FMAC3 tt__MetadataConfigurationExtension * SOAP_FMAC4 soap_in_tt__MetadataConfigurationExtension(struct soap*, const char*, tt__MetadataConfigurationExtension *, const char*);
SOAP_FMAC1 tt__MetadataConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__MetadataConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__MetadataConfigurationExtension * soap_new_tt__MetadataConfigurationExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__MetadataConfigurationExtension(soap, n, NULL, NULL, NULL);
}

inline tt__MetadataConfigurationExtension * soap_new_req_tt__MetadataConfigurationExtension(
	struct soap *soap)
{
	tt__MetadataConfigurationExtension *_p = ::soap_new_tt__MetadataConfigurationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__MetadataConfigurationExtension * soap_new_set_tt__MetadataConfigurationExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__MetadataConfigurationExtension *_p = ::soap_new_tt__MetadataConfigurationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__MetadataConfigurationExtension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MetadataConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__MetadataConfigurationExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__MetadataConfigurationExtension(struct soap *soap, const char *URL, tt__MetadataConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MetadataConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__MetadataConfigurationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__MetadataConfigurationExtension(struct soap *soap, const char *URL, tt__MetadataConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MetadataConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__MetadataConfigurationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__MetadataConfigurationExtension(struct soap *soap, const char *URL, tt__MetadataConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MetadataConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__MetadataConfigurationExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__MetadataConfigurationExtension * SOAP_FMAC4 soap_get_tt__MetadataConfigurationExtension(struct soap*, tt__MetadataConfigurationExtension *, const char*, const char*);

inline int soap_read_tt__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__MetadataConfigurationExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__MetadataConfigurationExtension(struct soap *soap, const char *URL, tt__MetadataConfigurationExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__MetadataConfigurationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *p)
{
	if (::soap_read_tt__MetadataConfigurationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__MetadataConfiguration_DEFINED
#define SOAP_TYPE_tt__MetadataConfiguration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfiguration(struct soap*, const char*, int, const tt__MetadataConfiguration *, const char*);
SOAP_FMAC3 tt__MetadataConfiguration * SOAP_FMAC4 soap_in_tt__MetadataConfiguration(struct soap*, const char*, tt__MetadataConfiguration *, const char*);
SOAP_FMAC1 tt__MetadataConfiguration * SOAP_FMAC2 imageing_instantiate_tt__MetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);

inline tt__MetadataConfiguration * soap_new_tt__MetadataConfiguration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__MetadataConfiguration(soap, n, NULL, NULL, NULL);
}

inline tt__MetadataConfiguration * soap_new_req_tt__MetadataConfiguration(
	struct soap *soap,
	tt__MulticastConfiguration *Multicast,
	const std::string& SessionTimeout,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1)
{
	tt__MetadataConfiguration *_p = ::soap_new_tt__MetadataConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__MetadataConfiguration::Multicast = Multicast;
		_p->tt__MetadataConfiguration::SessionTimeout = SessionTimeout;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
	}
	return _p;
}

inline tt__MetadataConfiguration * soap_new_set_tt__MetadataConfiguration(
	struct soap *soap,
	tt__PTZFilter *PTZStatus,
	tt__EventSubscription *Events,
	bool *Analytics,
	tt__MulticastConfiguration *Multicast,
	const std::string& SessionTimeout,
	const std::vector<char *> & __any,
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration,
	tt__MetadataConfigurationExtension *Extension,
	std::string *CompressionType,
	bool *GeoLocation,
	bool *ShapePolygon,
	char *__anyAttribute,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1,
	char *__item__2)
{
	tt__MetadataConfiguration *_p = ::soap_new_tt__MetadataConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__MetadataConfiguration::PTZStatus = PTZStatus;
		_p->tt__MetadataConfiguration::Events = Events;
		_p->tt__MetadataConfiguration::Analytics = Analytics;
		_p->tt__MetadataConfiguration::Multicast = Multicast;
		_p->tt__MetadataConfiguration::SessionTimeout = SessionTimeout;
		_p->tt__MetadataConfiguration::__any = __any;
		_p->tt__MetadataConfiguration::AnalyticsEngineConfiguration = AnalyticsEngineConfiguration;
		_p->tt__MetadataConfiguration::Extension = Extension;
		_p->tt__MetadataConfiguration::CompressionType = CompressionType;
		_p->tt__MetadataConfiguration::GeoLocation = GeoLocation;
		_p->tt__MetadataConfiguration::ShapePolygon = ShapePolygon;
		_p->tt__MetadataConfiguration::__anyAttribute = __anyAttribute;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_tt__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MetadataConfiguration", p->soap_type() == SOAP_TYPE_tt__MetadataConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__MetadataConfiguration(struct soap *soap, const char *URL, tt__MetadataConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MetadataConfiguration", p->soap_type() == SOAP_TYPE_tt__MetadataConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__MetadataConfiguration(struct soap *soap, const char *URL, tt__MetadataConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MetadataConfiguration", p->soap_type() == SOAP_TYPE_tt__MetadataConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__MetadataConfiguration(struct soap *soap, const char *URL, tt__MetadataConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:MetadataConfiguration", p->soap_type() == SOAP_TYPE_tt__MetadataConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__MetadataConfiguration * SOAP_FMAC4 soap_get_tt__MetadataConfiguration(struct soap*, tt__MetadataConfiguration *, const char*, const char*);

inline int soap_read_tt__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__MetadataConfiguration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__MetadataConfiguration(struct soap *soap, const char *URL, tt__MetadataConfiguration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__MetadataConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration *p)
{
	if (::soap_read_tt__MetadataConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration_DEFINED
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsConfiguration(struct soap*, const char*, int, const tt__VideoAnalyticsConfiguration *, const char*);
SOAP_FMAC3 tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_in_tt__VideoAnalyticsConfiguration(struct soap*, const char*, tt__VideoAnalyticsConfiguration *, const char*);
SOAP_FMAC1 tt__VideoAnalyticsConfiguration * SOAP_FMAC2 imageing_instantiate_tt__VideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);

inline tt__VideoAnalyticsConfiguration * soap_new_tt__VideoAnalyticsConfiguration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__VideoAnalyticsConfiguration(soap, n, NULL, NULL, NULL);
}

inline tt__VideoAnalyticsConfiguration * soap_new_req_tt__VideoAnalyticsConfiguration(
	struct soap *soap,
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration,
	tt__RuleEngineConfiguration *RuleEngineConfiguration,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1)
{
	tt__VideoAnalyticsConfiguration *_p = ::soap_new_tt__VideoAnalyticsConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration = AnalyticsEngineConfiguration;
		_p->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration = RuleEngineConfiguration;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
	}
	return _p;
}

inline tt__VideoAnalyticsConfiguration * soap_new_set_tt__VideoAnalyticsConfiguration(
	struct soap *soap,
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration,
	tt__RuleEngineConfiguration *RuleEngineConfiguration,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1,
	char *__item__2)
{
	tt__VideoAnalyticsConfiguration *_p = ::soap_new_tt__VideoAnalyticsConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration = AnalyticsEngineConfiguration;
		_p->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration = RuleEngineConfiguration;
		_p->tt__VideoAnalyticsConfiguration::__any = __any;
		_p->tt__VideoAnalyticsConfiguration::__anyAttribute = __anyAttribute;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_tt__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoAnalyticsConfiguration", p->soap_type() == SOAP_TYPE_tt__VideoAnalyticsConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *URL, tt__VideoAnalyticsConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoAnalyticsConfiguration", p->soap_type() == SOAP_TYPE_tt__VideoAnalyticsConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *URL, tt__VideoAnalyticsConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoAnalyticsConfiguration", p->soap_type() == SOAP_TYPE_tt__VideoAnalyticsConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *URL, tt__VideoAnalyticsConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoAnalyticsConfiguration", p->soap_type() == SOAP_TYPE_tt__VideoAnalyticsConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_get_tt__VideoAnalyticsConfiguration(struct soap*, tt__VideoAnalyticsConfiguration *, const char*, const char*);

inline int soap_read_tt__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__VideoAnalyticsConfiguration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *URL, tt__VideoAnalyticsConfiguration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__VideoAnalyticsConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration *p)
{
	if (::soap_read_tt__VideoAnalyticsConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration_DEFINED
#define SOAP_TYPE_tt__AudioEncoderConfiguration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfiguration(struct soap*, const char*, int, const tt__AudioEncoderConfiguration *, const char*);
SOAP_FMAC3 tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioEncoderConfiguration(struct soap*, const char*, tt__AudioEncoderConfiguration *, const char*);
SOAP_FMAC1 tt__AudioEncoderConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);

inline tt__AudioEncoderConfiguration * soap_new_tt__AudioEncoderConfiguration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__AudioEncoderConfiguration(soap, n, NULL, NULL, NULL);
}

inline tt__AudioEncoderConfiguration * soap_new_req_tt__AudioEncoderConfiguration(
	struct soap *soap,
	enum tt__AudioEncoding Encoding,
	int Bitrate,
	int SampleRate,
	tt__MulticastConfiguration *Multicast,
	const std::string& SessionTimeout,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1)
{
	tt__AudioEncoderConfiguration *_p = ::soap_new_tt__AudioEncoderConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AudioEncoderConfiguration::Encoding = Encoding;
		_p->tt__AudioEncoderConfiguration::Bitrate = Bitrate;
		_p->tt__AudioEncoderConfiguration::SampleRate = SampleRate;
		_p->tt__AudioEncoderConfiguration::Multicast = Multicast;
		_p->tt__AudioEncoderConfiguration::SessionTimeout = SessionTimeout;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
	}
	return _p;
}

inline tt__AudioEncoderConfiguration * soap_new_set_tt__AudioEncoderConfiguration(
	struct soap *soap,
	enum tt__AudioEncoding Encoding,
	int Bitrate,
	int SampleRate,
	tt__MulticastConfiguration *Multicast,
	const std::string& SessionTimeout,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1,
	char *__item__2)
{
	tt__AudioEncoderConfiguration *_p = ::soap_new_tt__AudioEncoderConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AudioEncoderConfiguration::Encoding = Encoding;
		_p->tt__AudioEncoderConfiguration::Bitrate = Bitrate;
		_p->tt__AudioEncoderConfiguration::SampleRate = SampleRate;
		_p->tt__AudioEncoderConfiguration::Multicast = Multicast;
		_p->tt__AudioEncoderConfiguration::SessionTimeout = SessionTimeout;
		_p->tt__AudioEncoderConfiguration::__any = __any;
		_p->tt__AudioEncoderConfiguration::__anyAttribute = __anyAttribute;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_tt__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioEncoderConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioEncoderConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__AudioEncoderConfiguration(struct soap *soap, const char *URL, tt__AudioEncoderConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioEncoderConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioEncoderConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__AudioEncoderConfiguration(struct soap *soap, const char *URL, tt__AudioEncoderConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioEncoderConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioEncoderConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__AudioEncoderConfiguration(struct soap *soap, const char *URL, tt__AudioEncoderConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioEncoderConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioEncoderConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioEncoderConfiguration(struct soap*, tt__AudioEncoderConfiguration *, const char*, const char*);

inline int soap_read_tt__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__AudioEncoderConfiguration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__AudioEncoderConfiguration(struct soap *soap, const char *URL, tt__AudioEncoderConfiguration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__AudioEncoderConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration *p)
{
	if (::soap_read_tt__AudioEncoderConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__AudioSourceConfiguration_DEFINED
#define SOAP_TYPE_tt__AudioSourceConfiguration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfiguration(struct soap*, const char*, int, const tt__AudioSourceConfiguration *, const char*);
SOAP_FMAC3 tt__AudioSourceConfiguration * SOAP_FMAC4 soap_in_tt__AudioSourceConfiguration(struct soap*, const char*, tt__AudioSourceConfiguration *, const char*);
SOAP_FMAC1 tt__AudioSourceConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);

inline tt__AudioSourceConfiguration * soap_new_tt__AudioSourceConfiguration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__AudioSourceConfiguration(soap, n, NULL, NULL, NULL);
}

inline tt__AudioSourceConfiguration * soap_new_req_tt__AudioSourceConfiguration(
	struct soap *soap,
	const std::string& SourceToken,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1)
{
	tt__AudioSourceConfiguration *_p = ::soap_new_tt__AudioSourceConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AudioSourceConfiguration::SourceToken = SourceToken;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
	}
	return _p;
}

inline tt__AudioSourceConfiguration * soap_new_set_tt__AudioSourceConfiguration(
	struct soap *soap,
	const std::string& SourceToken,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1,
	char *__item__2)
{
	tt__AudioSourceConfiguration *_p = ::soap_new_tt__AudioSourceConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__AudioSourceConfiguration::SourceToken = SourceToken;
		_p->tt__AudioSourceConfiguration::__any = __any;
		_p->tt__AudioSourceConfiguration::__anyAttribute = __anyAttribute;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_tt__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioSourceConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioSourceConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__AudioSourceConfiguration(struct soap *soap, const char *URL, tt__AudioSourceConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioSourceConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioSourceConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__AudioSourceConfiguration(struct soap *soap, const char *URL, tt__AudioSourceConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioSourceConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioSourceConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__AudioSourceConfiguration(struct soap *soap, const char *URL, tt__AudioSourceConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:AudioSourceConfiguration", p->soap_type() == SOAP_TYPE_tt__AudioSourceConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__AudioSourceConfiguration * SOAP_FMAC4 soap_get_tt__AudioSourceConfiguration(struct soap*, tt__AudioSourceConfiguration *, const char*, const char*);

inline int soap_read_tt__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__AudioSourceConfiguration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__AudioSourceConfiguration(struct soap *soap, const char *URL, tt__AudioSourceConfiguration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__AudioSourceConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration *p)
{
	if (::soap_read_tt__AudioSourceConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__H264Configuration_DEFINED
#define SOAP_TYPE_tt__H264Configuration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Configuration(struct soap*, const char*, int, const tt__H264Configuration *, const char*);
SOAP_FMAC3 tt__H264Configuration * SOAP_FMAC4 soap_in_tt__H264Configuration(struct soap*, const char*, tt__H264Configuration *, const char*);
SOAP_FMAC1 tt__H264Configuration * SOAP_FMAC2 imageing_instantiate_tt__H264Configuration(struct soap*, int, const char*, const char*, size_t*);

inline tt__H264Configuration * soap_new_tt__H264Configuration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__H264Configuration(soap, n, NULL, NULL, NULL);
}

inline tt__H264Configuration * soap_new_req_tt__H264Configuration(
	struct soap *soap,
	int GovLength,
	enum tt__H264Profile H264Profile)
{
	tt__H264Configuration *_p = ::soap_new_tt__H264Configuration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__H264Configuration::GovLength = GovLength;
		_p->tt__H264Configuration::H264Profile = H264Profile;
	}
	return _p;
}

inline tt__H264Configuration * soap_new_set_tt__H264Configuration(
	struct soap *soap,
	int GovLength,
	enum tt__H264Profile H264Profile,
	char *__item__1)
{
	tt__H264Configuration *_p = ::soap_new_tt__H264Configuration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__H264Configuration::GovLength = GovLength;
		_p->tt__H264Configuration::H264Profile = H264Profile;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__H264Configuration(struct soap *soap, tt__H264Configuration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:H264Configuration", p->soap_type() == SOAP_TYPE_tt__H264Configuration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__H264Configuration(struct soap *soap, const char *URL, tt__H264Configuration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:H264Configuration", p->soap_type() == SOAP_TYPE_tt__H264Configuration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__H264Configuration(struct soap *soap, const char *URL, tt__H264Configuration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:H264Configuration", p->soap_type() == SOAP_TYPE_tt__H264Configuration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__H264Configuration(struct soap *soap, const char *URL, tt__H264Configuration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:H264Configuration", p->soap_type() == SOAP_TYPE_tt__H264Configuration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__H264Configuration * SOAP_FMAC4 soap_get_tt__H264Configuration(struct soap*, tt__H264Configuration *, const char*, const char*);

inline int soap_read_tt__H264Configuration(struct soap *soap, tt__H264Configuration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__H264Configuration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__H264Configuration(struct soap *soap, const char *URL, tt__H264Configuration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__H264Configuration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__H264Configuration(struct soap *soap, tt__H264Configuration *p)
{
	if (::soap_read_tt__H264Configuration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Configuration_DEFINED
#define SOAP_TYPE_tt__Mpeg4Configuration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Configuration(struct soap*, const char*, int, const tt__Mpeg4Configuration *, const char*);
SOAP_FMAC3 tt__Mpeg4Configuration * SOAP_FMAC4 soap_in_tt__Mpeg4Configuration(struct soap*, const char*, tt__Mpeg4Configuration *, const char*);
SOAP_FMAC1 tt__Mpeg4Configuration * SOAP_FMAC2 imageing_instantiate_tt__Mpeg4Configuration(struct soap*, int, const char*, const char*, size_t*);

inline tt__Mpeg4Configuration * soap_new_tt__Mpeg4Configuration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Mpeg4Configuration(soap, n, NULL, NULL, NULL);
}

inline tt__Mpeg4Configuration * soap_new_req_tt__Mpeg4Configuration(
	struct soap *soap,
	int GovLength,
	enum tt__Mpeg4Profile Mpeg4Profile)
{
	tt__Mpeg4Configuration *_p = ::soap_new_tt__Mpeg4Configuration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Mpeg4Configuration::GovLength = GovLength;
		_p->tt__Mpeg4Configuration::Mpeg4Profile = Mpeg4Profile;
	}
	return _p;
}

inline tt__Mpeg4Configuration * soap_new_set_tt__Mpeg4Configuration(
	struct soap *soap,
	int GovLength,
	enum tt__Mpeg4Profile Mpeg4Profile,
	char *__item__1)
{
	tt__Mpeg4Configuration *_p = ::soap_new_tt__Mpeg4Configuration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Mpeg4Configuration::GovLength = GovLength;
		_p->tt__Mpeg4Configuration::Mpeg4Profile = Mpeg4Profile;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Mpeg4Configuration", p->soap_type() == SOAP_TYPE_tt__Mpeg4Configuration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Mpeg4Configuration(struct soap *soap, const char *URL, tt__Mpeg4Configuration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Mpeg4Configuration", p->soap_type() == SOAP_TYPE_tt__Mpeg4Configuration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Mpeg4Configuration(struct soap *soap, const char *URL, tt__Mpeg4Configuration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Mpeg4Configuration", p->soap_type() == SOAP_TYPE_tt__Mpeg4Configuration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Mpeg4Configuration(struct soap *soap, const char *URL, tt__Mpeg4Configuration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Mpeg4Configuration", p->soap_type() == SOAP_TYPE_tt__Mpeg4Configuration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Mpeg4Configuration * SOAP_FMAC4 soap_get_tt__Mpeg4Configuration(struct soap*, tt__Mpeg4Configuration *, const char*, const char*);

inline int soap_read_tt__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Mpeg4Configuration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Mpeg4Configuration(struct soap *soap, const char *URL, tt__Mpeg4Configuration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Mpeg4Configuration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *p)
{
	if (::soap_read_tt__Mpeg4Configuration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__VideoRateControl_DEFINED
#define SOAP_TYPE_tt__VideoRateControl_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoRateControl(struct soap*, const char*, int, const tt__VideoRateControl *, const char*);
SOAP_FMAC3 tt__VideoRateControl * SOAP_FMAC4 soap_in_tt__VideoRateControl(struct soap*, const char*, tt__VideoRateControl *, const char*);
SOAP_FMAC1 tt__VideoRateControl * SOAP_FMAC2 imageing_instantiate_tt__VideoRateControl(struct soap*, int, const char*, const char*, size_t*);

inline tt__VideoRateControl * soap_new_tt__VideoRateControl(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__VideoRateControl(soap, n, NULL, NULL, NULL);
}

inline tt__VideoRateControl * soap_new_req_tt__VideoRateControl(
	struct soap *soap,
	int FrameRateLimit,
	int EncodingInterval,
	int BitrateLimit)
{
	tt__VideoRateControl *_p = ::soap_new_tt__VideoRateControl(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoRateControl::FrameRateLimit = FrameRateLimit;
		_p->tt__VideoRateControl::EncodingInterval = EncodingInterval;
		_p->tt__VideoRateControl::BitrateLimit = BitrateLimit;
	}
	return _p;
}

inline tt__VideoRateControl * soap_new_set_tt__VideoRateControl(
	struct soap *soap,
	int FrameRateLimit,
	int EncodingInterval,
	int BitrateLimit,
	char *__item__1)
{
	tt__VideoRateControl *_p = ::soap_new_tt__VideoRateControl(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoRateControl::FrameRateLimit = FrameRateLimit;
		_p->tt__VideoRateControl::EncodingInterval = EncodingInterval;
		_p->tt__VideoRateControl::BitrateLimit = BitrateLimit;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__VideoRateControl(struct soap *soap, tt__VideoRateControl const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoRateControl", p->soap_type() == SOAP_TYPE_tt__VideoRateControl ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__VideoRateControl(struct soap *soap, const char *URL, tt__VideoRateControl const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoRateControl", p->soap_type() == SOAP_TYPE_tt__VideoRateControl ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__VideoRateControl(struct soap *soap, const char *URL, tt__VideoRateControl const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoRateControl", p->soap_type() == SOAP_TYPE_tt__VideoRateControl ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__VideoRateControl(struct soap *soap, const char *URL, tt__VideoRateControl const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoRateControl", p->soap_type() == SOAP_TYPE_tt__VideoRateControl ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__VideoRateControl * SOAP_FMAC4 soap_get_tt__VideoRateControl(struct soap*, tt__VideoRateControl *, const char*, const char*);

inline int soap_read_tt__VideoRateControl(struct soap *soap, tt__VideoRateControl *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__VideoRateControl(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__VideoRateControl(struct soap *soap, const char *URL, tt__VideoRateControl *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__VideoRateControl(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__VideoRateControl(struct soap *soap, tt__VideoRateControl *p)
{
	if (::soap_read_tt__VideoRateControl(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__VideoResolution_DEFINED
#define SOAP_TYPE_tt__VideoResolution_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoResolution(struct soap*, const char*, int, const tt__VideoResolution *, const char*);
SOAP_FMAC3 tt__VideoResolution * SOAP_FMAC4 soap_in_tt__VideoResolution(struct soap*, const char*, tt__VideoResolution *, const char*);
SOAP_FMAC1 tt__VideoResolution * SOAP_FMAC2 imageing_instantiate_tt__VideoResolution(struct soap*, int, const char*, const char*, size_t*);

inline tt__VideoResolution * soap_new_tt__VideoResolution(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__VideoResolution(soap, n, NULL, NULL, NULL);
}

inline tt__VideoResolution * soap_new_req_tt__VideoResolution(
	struct soap *soap,
	int Width,
	int Height)
{
	tt__VideoResolution *_p = ::soap_new_tt__VideoResolution(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoResolution::Width = Width;
		_p->tt__VideoResolution::Height = Height;
	}
	return _p;
}

inline tt__VideoResolution * soap_new_set_tt__VideoResolution(
	struct soap *soap,
	int Width,
	int Height,
	char *__item__1)
{
	tt__VideoResolution *_p = ::soap_new_tt__VideoResolution(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoResolution::Width = Width;
		_p->tt__VideoResolution::Height = Height;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__VideoResolution(struct soap *soap, tt__VideoResolution const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoResolution", p->soap_type() == SOAP_TYPE_tt__VideoResolution ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__VideoResolution(struct soap *soap, const char *URL, tt__VideoResolution const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoResolution", p->soap_type() == SOAP_TYPE_tt__VideoResolution ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__VideoResolution(struct soap *soap, const char *URL, tt__VideoResolution const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoResolution", p->soap_type() == SOAP_TYPE_tt__VideoResolution ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__VideoResolution(struct soap *soap, const char *URL, tt__VideoResolution const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoResolution", p->soap_type() == SOAP_TYPE_tt__VideoResolution ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__VideoResolution * SOAP_FMAC4 soap_get_tt__VideoResolution(struct soap*, tt__VideoResolution *, const char*, const char*);

inline int soap_read_tt__VideoResolution(struct soap *soap, tt__VideoResolution *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__VideoResolution(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__VideoResolution(struct soap *soap, const char *URL, tt__VideoResolution *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__VideoResolution(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__VideoResolution(struct soap *soap, tt__VideoResolution *p)
{
	if (::soap_read_tt__VideoResolution(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration_DEFINED
#define SOAP_TYPE_tt__VideoEncoderConfiguration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfiguration(struct soap*, const char*, int, const tt__VideoEncoderConfiguration *, const char*);
SOAP_FMAC3 tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_in_tt__VideoEncoderConfiguration(struct soap*, const char*, tt__VideoEncoderConfiguration *, const char*);
SOAP_FMAC1 tt__VideoEncoderConfiguration * SOAP_FMAC2 imageing_instantiate_tt__VideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);

inline tt__VideoEncoderConfiguration * soap_new_tt__VideoEncoderConfiguration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__VideoEncoderConfiguration(soap, n, NULL, NULL, NULL);
}

inline tt__VideoEncoderConfiguration * soap_new_req_tt__VideoEncoderConfiguration(
	struct soap *soap,
	enum tt__VideoEncoding Encoding,
	tt__VideoResolution *Resolution,
	float Quality,
	tt__MulticastConfiguration *Multicast,
	const std::string& SessionTimeout,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1)
{
	tt__VideoEncoderConfiguration *_p = ::soap_new_tt__VideoEncoderConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoEncoderConfiguration::Encoding = Encoding;
		_p->tt__VideoEncoderConfiguration::Resolution = Resolution;
		_p->tt__VideoEncoderConfiguration::Quality = Quality;
		_p->tt__VideoEncoderConfiguration::Multicast = Multicast;
		_p->tt__VideoEncoderConfiguration::SessionTimeout = SessionTimeout;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
	}
	return _p;
}

inline tt__VideoEncoderConfiguration * soap_new_set_tt__VideoEncoderConfiguration(
	struct soap *soap,
	enum tt__VideoEncoding Encoding,
	tt__VideoResolution *Resolution,
	float Quality,
	tt__VideoRateControl *RateControl,
	tt__Mpeg4Configuration *MPEG4,
	tt__H264Configuration *H264,
	tt__MulticastConfiguration *Multicast,
	const std::string& SessionTimeout,
	const std::vector<char *> & __any,
	bool *GuaranteedFrameRate,
	char *__anyAttribute,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1,
	char *__item__2)
{
	tt__VideoEncoderConfiguration *_p = ::soap_new_tt__VideoEncoderConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoEncoderConfiguration::Encoding = Encoding;
		_p->tt__VideoEncoderConfiguration::Resolution = Resolution;
		_p->tt__VideoEncoderConfiguration::Quality = Quality;
		_p->tt__VideoEncoderConfiguration::RateControl = RateControl;
		_p->tt__VideoEncoderConfiguration::MPEG4 = MPEG4;
		_p->tt__VideoEncoderConfiguration::H264 = H264;
		_p->tt__VideoEncoderConfiguration::Multicast = Multicast;
		_p->tt__VideoEncoderConfiguration::SessionTimeout = SessionTimeout;
		_p->tt__VideoEncoderConfiguration::__any = __any;
		_p->tt__VideoEncoderConfiguration::GuaranteedFrameRate = GuaranteedFrameRate;
		_p->tt__VideoEncoderConfiguration::__anyAttribute = __anyAttribute;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_tt__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoEncoderConfiguration", p->soap_type() == SOAP_TYPE_tt__VideoEncoderConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__VideoEncoderConfiguration(struct soap *soap, const char *URL, tt__VideoEncoderConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoEncoderConfiguration", p->soap_type() == SOAP_TYPE_tt__VideoEncoderConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__VideoEncoderConfiguration(struct soap *soap, const char *URL, tt__VideoEncoderConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoEncoderConfiguration", p->soap_type() == SOAP_TYPE_tt__VideoEncoderConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__VideoEncoderConfiguration(struct soap *soap, const char *URL, tt__VideoEncoderConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoEncoderConfiguration", p->soap_type() == SOAP_TYPE_tt__VideoEncoderConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_get_tt__VideoEncoderConfiguration(struct soap*, tt__VideoEncoderConfiguration *, const char*, const char*);

inline int soap_read_tt__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__VideoEncoderConfiguration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__VideoEncoderConfiguration(struct soap *soap, const char *URL, tt__VideoEncoderConfiguration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__VideoEncoderConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration *p)
{
	if (::soap_read_tt__VideoEncoderConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__SceneOrientation_DEFINED
#define SOAP_TYPE_tt__SceneOrientation_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientation(struct soap*, const char*, int, const tt__SceneOrientation *, const char*);
SOAP_FMAC3 tt__SceneOrientation * SOAP_FMAC4 soap_in_tt__SceneOrientation(struct soap*, const char*, tt__SceneOrientation *, const char*);
SOAP_FMAC1 tt__SceneOrientation * SOAP_FMAC2 imageing_instantiate_tt__SceneOrientation(struct soap*, int, const char*, const char*, size_t*);

inline tt__SceneOrientation * soap_new_tt__SceneOrientation(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__SceneOrientation(soap, n, NULL, NULL, NULL);
}

inline tt__SceneOrientation * soap_new_req_tt__SceneOrientation(
	struct soap *soap,
	enum tt__SceneOrientationMode Mode)
{
	tt__SceneOrientation *_p = ::soap_new_tt__SceneOrientation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__SceneOrientation::Mode = Mode;
	}
	return _p;
}

inline tt__SceneOrientation * soap_new_set_tt__SceneOrientation(
	struct soap *soap,
	enum tt__SceneOrientationMode Mode,
	std::string *Orientation,
	char *__item__1)
{
	tt__SceneOrientation *_p = ::soap_new_tt__SceneOrientation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__SceneOrientation::Mode = Mode;
		_p->tt__SceneOrientation::Orientation = Orientation;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__SceneOrientation(struct soap *soap, tt__SceneOrientation const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:SceneOrientation", p->soap_type() == SOAP_TYPE_tt__SceneOrientation ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__SceneOrientation(struct soap *soap, const char *URL, tt__SceneOrientation const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:SceneOrientation", p->soap_type() == SOAP_TYPE_tt__SceneOrientation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__SceneOrientation(struct soap *soap, const char *URL, tt__SceneOrientation const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:SceneOrientation", p->soap_type() == SOAP_TYPE_tt__SceneOrientation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__SceneOrientation(struct soap *soap, const char *URL, tt__SceneOrientation const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:SceneOrientation", p->soap_type() == SOAP_TYPE_tt__SceneOrientation ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__SceneOrientation * SOAP_FMAC4 soap_get_tt__SceneOrientation(struct soap*, tt__SceneOrientation *, const char*, const char*);

inline int soap_read_tt__SceneOrientation(struct soap *soap, tt__SceneOrientation *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__SceneOrientation(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__SceneOrientation(struct soap *soap, const char *URL, tt__SceneOrientation *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__SceneOrientation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__SceneOrientation(struct soap *soap, tt__SceneOrientation *p)
{
	if (::soap_read_tt__SceneOrientation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__LensDescription_DEFINED
#define SOAP_TYPE_tt__LensDescription_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensDescription(struct soap*, const char*, int, const tt__LensDescription *, const char*);
SOAP_FMAC3 tt__LensDescription * SOAP_FMAC4 soap_in_tt__LensDescription(struct soap*, const char*, tt__LensDescription *, const char*);
SOAP_FMAC1 tt__LensDescription * SOAP_FMAC2 imageing_instantiate_tt__LensDescription(struct soap*, int, const char*, const char*, size_t*);

inline tt__LensDescription * soap_new_tt__LensDescription(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__LensDescription(soap, n, NULL, NULL, NULL);
}

inline tt__LensDescription * soap_new_req_tt__LensDescription(
	struct soap *soap,
	tt__LensOffset *Offset,
	const std::vector<tt__LensProjection *> & Projection,
	float XFactor)
{
	tt__LensDescription *_p = ::soap_new_tt__LensDescription(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__LensDescription::Offset = Offset;
		_p->tt__LensDescription::Projection = Projection;
		_p->tt__LensDescription::XFactor = XFactor;
	}
	return _p;
}

inline tt__LensDescription * soap_new_set_tt__LensDescription(
	struct soap *soap,
	tt__LensOffset *Offset,
	const std::vector<tt__LensProjection *> & Projection,
	float XFactor,
	const std::vector<char *> & __any,
	float *FocalLength,
	char *__anyAttribute,
	char *__item__1)
{
	tt__LensDescription *_p = ::soap_new_tt__LensDescription(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__LensDescription::Offset = Offset;
		_p->tt__LensDescription::Projection = Projection;
		_p->tt__LensDescription::XFactor = XFactor;
		_p->tt__LensDescription::__any = __any;
		_p->tt__LensDescription::FocalLength = FocalLength;
		_p->tt__LensDescription::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__LensDescription(struct soap *soap, tt__LensDescription const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:LensDescription", p->soap_type() == SOAP_TYPE_tt__LensDescription ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__LensDescription(struct soap *soap, const char *URL, tt__LensDescription const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:LensDescription", p->soap_type() == SOAP_TYPE_tt__LensDescription ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__LensDescription(struct soap *soap, const char *URL, tt__LensDescription const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:LensDescription", p->soap_type() == SOAP_TYPE_tt__LensDescription ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__LensDescription(struct soap *soap, const char *URL, tt__LensDescription const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:LensDescription", p->soap_type() == SOAP_TYPE_tt__LensDescription ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__LensDescription * SOAP_FMAC4 soap_get_tt__LensDescription(struct soap*, tt__LensDescription *, const char*, const char*);

inline int soap_read_tt__LensDescription(struct soap *soap, tt__LensDescription *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__LensDescription(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__LensDescription(struct soap *soap, const char *URL, tt__LensDescription *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__LensDescription(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__LensDescription(struct soap *soap, tt__LensDescription *p)
{
	if (::soap_read_tt__LensDescription(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__LensOffset_DEFINED
#define SOAP_TYPE_tt__LensOffset_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensOffset(struct soap*, const char*, int, const tt__LensOffset *, const char*);
SOAP_FMAC3 tt__LensOffset * SOAP_FMAC4 soap_in_tt__LensOffset(struct soap*, const char*, tt__LensOffset *, const char*);
SOAP_FMAC1 tt__LensOffset * SOAP_FMAC2 imageing_instantiate_tt__LensOffset(struct soap*, int, const char*, const char*, size_t*);

inline tt__LensOffset * soap_new_tt__LensOffset(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__LensOffset(soap, n, NULL, NULL, NULL);
}

inline tt__LensOffset * soap_new_req_tt__LensOffset(
	struct soap *soap)
{
	tt__LensOffset *_p = ::soap_new_tt__LensOffset(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__LensOffset * soap_new_set_tt__LensOffset(
	struct soap *soap,
	float *x,
	float *y,
	char *__anyAttribute,
	char *__item__1)
{
	tt__LensOffset *_p = ::soap_new_tt__LensOffset(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__LensOffset::x = x;
		_p->tt__LensOffset::y = y;
		_p->tt__LensOffset::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__LensOffset(struct soap *soap, tt__LensOffset const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:LensOffset", p->soap_type() == SOAP_TYPE_tt__LensOffset ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__LensOffset(struct soap *soap, const char *URL, tt__LensOffset const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:LensOffset", p->soap_type() == SOAP_TYPE_tt__LensOffset ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__LensOffset(struct soap *soap, const char *URL, tt__LensOffset const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:LensOffset", p->soap_type() == SOAP_TYPE_tt__LensOffset ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__LensOffset(struct soap *soap, const char *URL, tt__LensOffset const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:LensOffset", p->soap_type() == SOAP_TYPE_tt__LensOffset ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__LensOffset * SOAP_FMAC4 soap_get_tt__LensOffset(struct soap*, tt__LensOffset *, const char*, const char*);

inline int soap_read_tt__LensOffset(struct soap *soap, tt__LensOffset *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__LensOffset(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__LensOffset(struct soap *soap, const char *URL, tt__LensOffset *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__LensOffset(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__LensOffset(struct soap *soap, tt__LensOffset *p)
{
	if (::soap_read_tt__LensOffset(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__LensProjection_DEFINED
#define SOAP_TYPE_tt__LensProjection_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensProjection(struct soap*, const char*, int, const tt__LensProjection *, const char*);
SOAP_FMAC3 tt__LensProjection * SOAP_FMAC4 soap_in_tt__LensProjection(struct soap*, const char*, tt__LensProjection *, const char*);
SOAP_FMAC1 tt__LensProjection * SOAP_FMAC2 imageing_instantiate_tt__LensProjection(struct soap*, int, const char*, const char*, size_t*);

inline tt__LensProjection * soap_new_tt__LensProjection(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__LensProjection(soap, n, NULL, NULL, NULL);
}

inline tt__LensProjection * soap_new_req_tt__LensProjection(
	struct soap *soap,
	float Angle,
	float Radius)
{
	tt__LensProjection *_p = ::soap_new_tt__LensProjection(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__LensProjection::Angle = Angle;
		_p->tt__LensProjection::Radius = Radius;
	}
	return _p;
}

inline tt__LensProjection * soap_new_set_tt__LensProjection(
	struct soap *soap,
	float Angle,
	float Radius,
	float *Transmittance,
	const std::vector<char *> & __any,
	char *__anyAttribute,
	char *__item__1)
{
	tt__LensProjection *_p = ::soap_new_tt__LensProjection(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__LensProjection::Angle = Angle;
		_p->tt__LensProjection::Radius = Radius;
		_p->tt__LensProjection::Transmittance = Transmittance;
		_p->tt__LensProjection::__any = __any;
		_p->tt__LensProjection::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__LensProjection(struct soap *soap, tt__LensProjection const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:LensProjection", p->soap_type() == SOAP_TYPE_tt__LensProjection ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__LensProjection(struct soap *soap, const char *URL, tt__LensProjection const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:LensProjection", p->soap_type() == SOAP_TYPE_tt__LensProjection ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__LensProjection(struct soap *soap, const char *URL, tt__LensProjection const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:LensProjection", p->soap_type() == SOAP_TYPE_tt__LensProjection ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__LensProjection(struct soap *soap, const char *URL, tt__LensProjection const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:LensProjection", p->soap_type() == SOAP_TYPE_tt__LensProjection ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__LensProjection * SOAP_FMAC4 soap_get_tt__LensProjection(struct soap*, tt__LensProjection *, const char*, const char*);

inline int soap_read_tt__LensProjection(struct soap *soap, tt__LensProjection *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__LensProjection(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__LensProjection(struct soap *soap, const char *URL, tt__LensProjection *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__LensProjection(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__LensProjection(struct soap *soap, tt__LensProjection *p)
{
	if (::soap_read_tt__LensProjection(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__RotateExtension_DEFINED
#define SOAP_TYPE_tt__RotateExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateExtension(struct soap*, const char*, int, const tt__RotateExtension *, const char*);
SOAP_FMAC3 tt__RotateExtension * SOAP_FMAC4 soap_in_tt__RotateExtension(struct soap*, const char*, tt__RotateExtension *, const char*);
SOAP_FMAC1 tt__RotateExtension * SOAP_FMAC2 imageing_instantiate_tt__RotateExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__RotateExtension * soap_new_tt__RotateExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__RotateExtension(soap, n, NULL, NULL, NULL);
}

inline tt__RotateExtension * soap_new_req_tt__RotateExtension(
	struct soap *soap)
{
	tt__RotateExtension *_p = ::soap_new_tt__RotateExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__RotateExtension * soap_new_set_tt__RotateExtension(
	struct soap *soap,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__RotateExtension *_p = ::soap_new_tt__RotateExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__RotateExtension::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__RotateExtension(struct soap *soap, tt__RotateExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RotateExtension", p->soap_type() == SOAP_TYPE_tt__RotateExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__RotateExtension(struct soap *soap, const char *URL, tt__RotateExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RotateExtension", p->soap_type() == SOAP_TYPE_tt__RotateExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__RotateExtension(struct soap *soap, const char *URL, tt__RotateExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RotateExtension", p->soap_type() == SOAP_TYPE_tt__RotateExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__RotateExtension(struct soap *soap, const char *URL, tt__RotateExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:RotateExtension", p->soap_type() == SOAP_TYPE_tt__RotateExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__RotateExtension * SOAP_FMAC4 soap_get_tt__RotateExtension(struct soap*, tt__RotateExtension *, const char*, const char*);

inline int soap_read_tt__RotateExtension(struct soap *soap, tt__RotateExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__RotateExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__RotateExtension(struct soap *soap, const char *URL, tt__RotateExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__RotateExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__RotateExtension(struct soap *soap, tt__RotateExtension *p)
{
	if (::soap_read_tt__RotateExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__Rotate_DEFINED
#define SOAP_TYPE_tt__Rotate_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rotate(struct soap*, const char*, int, const tt__Rotate *, const char*);
SOAP_FMAC3 tt__Rotate * SOAP_FMAC4 soap_in_tt__Rotate(struct soap*, const char*, tt__Rotate *, const char*);
SOAP_FMAC1 tt__Rotate * SOAP_FMAC2 imageing_instantiate_tt__Rotate(struct soap*, int, const char*, const char*, size_t*);

inline tt__Rotate * soap_new_tt__Rotate(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__Rotate(soap, n, NULL, NULL, NULL);
}

inline tt__Rotate * soap_new_req_tt__Rotate(
	struct soap *soap,
	enum tt__RotateMode Mode)
{
	tt__Rotate *_p = ::soap_new_tt__Rotate(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Rotate::Mode = Mode;
	}
	return _p;
}

inline tt__Rotate * soap_new_set_tt__Rotate(
	struct soap *soap,
	enum tt__RotateMode Mode,
	int *Degree,
	tt__RotateExtension *Extension,
	char *__anyAttribute,
	char *__item__1)
{
	tt__Rotate *_p = ::soap_new_tt__Rotate(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__Rotate::Mode = Mode;
		_p->tt__Rotate::Degree = Degree;
		_p->tt__Rotate::Extension = Extension;
		_p->tt__Rotate::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__Rotate(struct soap *soap, tt__Rotate const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Rotate", p->soap_type() == SOAP_TYPE_tt__Rotate ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__Rotate(struct soap *soap, const char *URL, tt__Rotate const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Rotate", p->soap_type() == SOAP_TYPE_tt__Rotate ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__Rotate(struct soap *soap, const char *URL, tt__Rotate const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Rotate", p->soap_type() == SOAP_TYPE_tt__Rotate ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__Rotate(struct soap *soap, const char *URL, tt__Rotate const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:Rotate", p->soap_type() == SOAP_TYPE_tt__Rotate ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__Rotate * SOAP_FMAC4 soap_get_tt__Rotate(struct soap*, tt__Rotate *, const char*, const char*);

inline int soap_read_tt__Rotate(struct soap *soap, tt__Rotate *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__Rotate(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__Rotate(struct soap *soap, const char *URL, tt__Rotate *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__Rotate(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__Rotate(struct soap *soap, tt__Rotate *p)
{
	if (::soap_read_tt__Rotate(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension2_DEFINED
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension2_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationExtension2(struct soap*, const char*, int, const tt__VideoSourceConfigurationExtension2 *, const char*);
SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationExtension2(struct soap*, const char*, tt__VideoSourceConfigurationExtension2 *, const char*);
SOAP_FMAC1 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC2 imageing_instantiate_tt__VideoSourceConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);

inline tt__VideoSourceConfigurationExtension2 * soap_new_tt__VideoSourceConfigurationExtension2(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__VideoSourceConfigurationExtension2(soap, n, NULL, NULL, NULL);
}

inline tt__VideoSourceConfigurationExtension2 * soap_new_req_tt__VideoSourceConfigurationExtension2(
	struct soap *soap)
{
	tt__VideoSourceConfigurationExtension2 *_p = ::soap_new_tt__VideoSourceConfigurationExtension2(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__VideoSourceConfigurationExtension2 * soap_new_set_tt__VideoSourceConfigurationExtension2(
	struct soap *soap,
	const std::vector<tt__LensDescription *> & LensDescription,
	tt__SceneOrientation *SceneOrientation,
	const std::vector<char *> & __any,
	char *__item__1)
{
	tt__VideoSourceConfigurationExtension2 *_p = ::soap_new_tt__VideoSourceConfigurationExtension2(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoSourceConfigurationExtension2::LensDescription = LensDescription;
		_p->tt__VideoSourceConfigurationExtension2::SceneOrientation = SceneOrientation;
		_p->tt__VideoSourceConfigurationExtension2::__any = __any;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoSourceConfigurationExtension2", p->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationExtension2 ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *URL, tt__VideoSourceConfigurationExtension2 const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoSourceConfigurationExtension2", p->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationExtension2 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *URL, tt__VideoSourceConfigurationExtension2 const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoSourceConfigurationExtension2", p->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationExtension2 ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *URL, tt__VideoSourceConfigurationExtension2 const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoSourceConfigurationExtension2", p->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationExtension2 ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationExtension2(struct soap*, tt__VideoSourceConfigurationExtension2 *, const char*, const char*);

inline int soap_read_tt__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__VideoSourceConfigurationExtension2(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *URL, tt__VideoSourceConfigurationExtension2 *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__VideoSourceConfigurationExtension2(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 *p)
{
	if (::soap_read_tt__VideoSourceConfigurationExtension2(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension_DEFINED
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationExtension(struct soap*, const char*, int, const tt__VideoSourceConfigurationExtension *, const char*);
SOAP_FMAC3 tt__VideoSourceConfigurationExtension * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationExtension(struct soap*, const char*, tt__VideoSourceConfigurationExtension *, const char*);
SOAP_FMAC1 tt__VideoSourceConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__VideoSourceConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);

inline tt__VideoSourceConfigurationExtension * soap_new_tt__VideoSourceConfigurationExtension(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__VideoSourceConfigurationExtension(soap, n, NULL, NULL, NULL);
}

inline tt__VideoSourceConfigurationExtension * soap_new_req_tt__VideoSourceConfigurationExtension(
	struct soap *soap)
{
	tt__VideoSourceConfigurationExtension *_p = ::soap_new_tt__VideoSourceConfigurationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline tt__VideoSourceConfigurationExtension * soap_new_set_tt__VideoSourceConfigurationExtension(
	struct soap *soap,
	tt__Rotate *Rotate,
	tt__VideoSourceConfigurationExtension2 *Extension,
	char *__item__1)
{
	tt__VideoSourceConfigurationExtension *_p = ::soap_new_tt__VideoSourceConfigurationExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoSourceConfigurationExtension::Rotate = Rotate;
		_p->tt__VideoSourceConfigurationExtension::Extension = Extension;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoSourceConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationExtension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *URL, tt__VideoSourceConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoSourceConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *URL, tt__VideoSourceConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoSourceConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationExtension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *URL, tt__VideoSourceConfigurationExtension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoSourceConfigurationExtension", p->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationExtension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__VideoSourceConfigurationExtension * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationExtension(struct soap*, tt__VideoSourceConfigurationExtension *, const char*, const char*);

inline int soap_read_tt__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__VideoSourceConfigurationExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *URL, tt__VideoSourceConfigurationExtension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__VideoSourceConfigurationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *p)
{
	if (::soap_read_tt__VideoSourceConfigurationExtension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfiguration_DEFINED
#define SOAP_TYPE_tt__VideoSourceConfiguration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfiguration(struct soap*, const char*, int, const tt__VideoSourceConfiguration *, const char*);
SOAP_FMAC3 tt__VideoSourceConfiguration * SOAP_FMAC4 soap_in_tt__VideoSourceConfiguration(struct soap*, const char*, tt__VideoSourceConfiguration *, const char*);
SOAP_FMAC1 tt__VideoSourceConfiguration * SOAP_FMAC2 imageing_instantiate_tt__VideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);

inline tt__VideoSourceConfiguration * soap_new_tt__VideoSourceConfiguration(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__VideoSourceConfiguration(soap, n, NULL, NULL, NULL);
}

inline tt__VideoSourceConfiguration * soap_new_req_tt__VideoSourceConfiguration(
	struct soap *soap,
	const std::string& SourceToken,
	tt__IntRectangle *Bounds,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1)
{
	tt__VideoSourceConfiguration *_p = ::soap_new_tt__VideoSourceConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoSourceConfiguration::SourceToken = SourceToken;
		_p->tt__VideoSourceConfiguration::Bounds = Bounds;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
	}
	return _p;
}

inline tt__VideoSourceConfiguration * soap_new_set_tt__VideoSourceConfiguration(
	struct soap *soap,
	const std::string& SourceToken,
	tt__IntRectangle *Bounds,
	const std::vector<char *> & __any,
	tt__VideoSourceConfigurationExtension *Extension,
	std::string *ViewMode,
	char *__anyAttribute,
	const std::string& Name__1,
	int UseCount__1,
	const std::string& token__1,
	char *__item__2)
{
	tt__VideoSourceConfiguration *_p = ::soap_new_tt__VideoSourceConfiguration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__VideoSourceConfiguration::SourceToken = SourceToken;
		_p->tt__VideoSourceConfiguration::Bounds = Bounds;
		_p->tt__VideoSourceConfiguration::__any = __any;
		_p->tt__VideoSourceConfiguration::Extension = Extension;
		_p->tt__VideoSourceConfiguration::ViewMode = ViewMode;
		_p->tt__VideoSourceConfiguration::__anyAttribute = __anyAttribute;
		_p->tt__ConfigurationEntity::Name = Name__1;
		_p->tt__ConfigurationEntity::UseCount = UseCount__1;
		_p->tt__ConfigurationEntity::token = token__1;
		_p->xsd__anyType::__item = __item__2;
	}
	return _p;
}

inline int soap_write_tt__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoSourceConfiguration", p->soap_type() == SOAP_TYPE_tt__VideoSourceConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__VideoSourceConfiguration(struct soap *soap, const char *URL, tt__VideoSourceConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoSourceConfiguration", p->soap_type() == SOAP_TYPE_tt__VideoSourceConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__VideoSourceConfiguration(struct soap *soap, const char *URL, tt__VideoSourceConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoSourceConfiguration", p->soap_type() == SOAP_TYPE_tt__VideoSourceConfiguration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__VideoSourceConfiguration(struct soap *soap, const char *URL, tt__VideoSourceConfiguration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:VideoSourceConfiguration", p->soap_type() == SOAP_TYPE_tt__VideoSourceConfiguration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__VideoSourceConfiguration * SOAP_FMAC4 soap_get_tt__VideoSourceConfiguration(struct soap*, tt__VideoSourceConfiguration *, const char*, const char*);

inline int soap_read_tt__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__VideoSourceConfiguration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__VideoSourceConfiguration(struct soap *soap, const char *URL, tt__VideoSourceConfiguration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__VideoSourceConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration *p)
{
	if (::soap_read_tt__VideoSourceConfiguration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__ConfigurationEntity_DEFINED
#define SOAP_TYPE_tt__ConfigurationEntity_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigurationEntity(struct soap*, const char*, int, const tt__ConfigurationEntity *, const char*);
SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_in_tt__ConfigurationEntity(struct soap*, const char*, tt__ConfigurationEntity *, const char*);
SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 imageing_instantiate_tt__ConfigurationEntity(struct soap*, int, const char*, const char*, size_t*);

inline tt__ConfigurationEntity * soap_new_tt__ConfigurationEntity(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__ConfigurationEntity(soap, n, NULL, NULL, NULL);
}

inline tt__ConfigurationEntity * soap_new_req_tt__ConfigurationEntity(
	struct soap *soap,
	const std::string& Name,
	int UseCount,
	const std::string& token)
{
	tt__ConfigurationEntity *_p = ::soap_new_tt__ConfigurationEntity(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ConfigurationEntity::Name = Name;
		_p->tt__ConfigurationEntity::UseCount = UseCount;
		_p->tt__ConfigurationEntity::token = token;
	}
	return _p;
}

inline tt__ConfigurationEntity * soap_new_set_tt__ConfigurationEntity(
	struct soap *soap,
	const std::string& Name,
	int UseCount,
	const std::string& token,
	char *__item__1)
{
	tt__ConfigurationEntity *_p = ::soap_new_tt__ConfigurationEntity(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__ConfigurationEntity::Name = Name;
		_p->tt__ConfigurationEntity::UseCount = UseCount;
		_p->tt__ConfigurationEntity::token = token;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__ConfigurationEntity(struct soap *soap, tt__ConfigurationEntity const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ConfigurationEntity", p->soap_type() == SOAP_TYPE_tt__ConfigurationEntity ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__ConfigurationEntity(struct soap *soap, const char *URL, tt__ConfigurationEntity const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ConfigurationEntity", p->soap_type() == SOAP_TYPE_tt__ConfigurationEntity ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__ConfigurationEntity(struct soap *soap, const char *URL, tt__ConfigurationEntity const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ConfigurationEntity", p->soap_type() == SOAP_TYPE_tt__ConfigurationEntity ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__ConfigurationEntity(struct soap *soap, const char *URL, tt__ConfigurationEntity const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:ConfigurationEntity", p->soap_type() == SOAP_TYPE_tt__ConfigurationEntity ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_get_tt__ConfigurationEntity(struct soap*, tt__ConfigurationEntity *, const char*, const char*);

inline int soap_read_tt__ConfigurationEntity(struct soap *soap, tt__ConfigurationEntity *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__ConfigurationEntity(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__ConfigurationEntity(struct soap *soap, const char *URL, tt__ConfigurationEntity *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__ConfigurationEntity(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__ConfigurationEntity(struct soap *soap, tt__ConfigurationEntity *p)
{
	if (::soap_read_tt__ConfigurationEntity(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__DurationRange_DEFINED
#define SOAP_TYPE_tt__DurationRange_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DurationRange(struct soap*, const char*, int, const tt__DurationRange *, const char*);
SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_in_tt__DurationRange(struct soap*, const char*, tt__DurationRange *, const char*);
SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 imageing_instantiate_tt__DurationRange(struct soap*, int, const char*, const char*, size_t*);

inline tt__DurationRange * soap_new_tt__DurationRange(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__DurationRange(soap, n, NULL, NULL, NULL);
}

inline tt__DurationRange * soap_new_req_tt__DurationRange(
	struct soap *soap,
	const std::string& Min,
	const std::string& Max)
{
	tt__DurationRange *_p = ::soap_new_tt__DurationRange(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__DurationRange::Min = Min;
		_p->tt__DurationRange::Max = Max;
	}
	return _p;
}

inline tt__DurationRange * soap_new_set_tt__DurationRange(
	struct soap *soap,
	const std::string& Min,
	const std::string& Max,
	char *__item__1)
{
	tt__DurationRange *_p = ::soap_new_tt__DurationRange(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__DurationRange::Min = Min;
		_p->tt__DurationRange::Max = Max;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__DurationRange(struct soap *soap, tt__DurationRange const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:DurationRange", p->soap_type() == SOAP_TYPE_tt__DurationRange ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__DurationRange(struct soap *soap, const char *URL, tt__DurationRange const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:DurationRange", p->soap_type() == SOAP_TYPE_tt__DurationRange ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__DurationRange(struct soap *soap, const char *URL, tt__DurationRange const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:DurationRange", p->soap_type() == SOAP_TYPE_tt__DurationRange ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__DurationRange(struct soap *soap, const char *URL, tt__DurationRange const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:DurationRange", p->soap_type() == SOAP_TYPE_tt__DurationRange ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_get_tt__DurationRange(struct soap*, tt__DurationRange *, const char*, const char*);

inline int soap_read_tt__DurationRange(struct soap *soap, tt__DurationRange *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__DurationRange(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__DurationRange(struct soap *soap, const char *URL, tt__DurationRange *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__DurationRange(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__DurationRange(struct soap *soap, tt__DurationRange *p)
{
	if (::soap_read_tt__DurationRange(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__FloatRange_DEFINED
#define SOAP_TYPE_tt__FloatRange_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatRange(struct soap*, const char*, int, const tt__FloatRange *, const char*);
SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_in_tt__FloatRange(struct soap*, const char*, tt__FloatRange *, const char*);
SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 imageing_instantiate_tt__FloatRange(struct soap*, int, const char*, const char*, size_t*);

inline tt__FloatRange * soap_new_tt__FloatRange(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__FloatRange(soap, n, NULL, NULL, NULL);
}

inline tt__FloatRange * soap_new_req_tt__FloatRange(
	struct soap *soap,
	float Min,
	float Max)
{
	tt__FloatRange *_p = ::soap_new_tt__FloatRange(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__FloatRange::Min = Min;
		_p->tt__FloatRange::Max = Max;
	}
	return _p;
}

inline tt__FloatRange * soap_new_set_tt__FloatRange(
	struct soap *soap,
	float Min,
	float Max,
	char *__item__1)
{
	tt__FloatRange *_p = ::soap_new_tt__FloatRange(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__FloatRange::Min = Min;
		_p->tt__FloatRange::Max = Max;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__FloatRange(struct soap *soap, tt__FloatRange const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FloatRange", p->soap_type() == SOAP_TYPE_tt__FloatRange ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__FloatRange(struct soap *soap, const char *URL, tt__FloatRange const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FloatRange", p->soap_type() == SOAP_TYPE_tt__FloatRange ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__FloatRange(struct soap *soap, const char *URL, tt__FloatRange const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FloatRange", p->soap_type() == SOAP_TYPE_tt__FloatRange ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__FloatRange(struct soap *soap, const char *URL, tt__FloatRange const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:FloatRange", p->soap_type() == SOAP_TYPE_tt__FloatRange ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_get_tt__FloatRange(struct soap*, tt__FloatRange *, const char*, const char*);

inline int soap_read_tt__FloatRange(struct soap *soap, tt__FloatRange *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__FloatRange(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__FloatRange(struct soap *soap, const char *URL, tt__FloatRange *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__FloatRange(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__FloatRange(struct soap *soap, tt__FloatRange *p)
{
	if (::soap_read_tt__FloatRange(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IntRectangleRange_DEFINED
#define SOAP_TYPE_tt__IntRectangleRange_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangleRange(struct soap*, const char*, int, const tt__IntRectangleRange *, const char*);
SOAP_FMAC3 tt__IntRectangleRange * SOAP_FMAC4 soap_in_tt__IntRectangleRange(struct soap*, const char*, tt__IntRectangleRange *, const char*);
SOAP_FMAC1 tt__IntRectangleRange * SOAP_FMAC2 imageing_instantiate_tt__IntRectangleRange(struct soap*, int, const char*, const char*, size_t*);

inline tt__IntRectangleRange * soap_new_tt__IntRectangleRange(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__IntRectangleRange(soap, n, NULL, NULL, NULL);
}

inline tt__IntRectangleRange * soap_new_req_tt__IntRectangleRange(
	struct soap *soap,
	tt__IntRange *XRange,
	tt__IntRange *YRange,
	tt__IntRange *WidthRange,
	tt__IntRange *HeightRange)
{
	tt__IntRectangleRange *_p = ::soap_new_tt__IntRectangleRange(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IntRectangleRange::XRange = XRange;
		_p->tt__IntRectangleRange::YRange = YRange;
		_p->tt__IntRectangleRange::WidthRange = WidthRange;
		_p->tt__IntRectangleRange::HeightRange = HeightRange;
	}
	return _p;
}

inline tt__IntRectangleRange * soap_new_set_tt__IntRectangleRange(
	struct soap *soap,
	tt__IntRange *XRange,
	tt__IntRange *YRange,
	tt__IntRange *WidthRange,
	tt__IntRange *HeightRange,
	char *__item__1)
{
	tt__IntRectangleRange *_p = ::soap_new_tt__IntRectangleRange(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IntRectangleRange::XRange = XRange;
		_p->tt__IntRectangleRange::YRange = YRange;
		_p->tt__IntRectangleRange::WidthRange = WidthRange;
		_p->tt__IntRectangleRange::HeightRange = HeightRange;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__IntRectangleRange(struct soap *soap, tt__IntRectangleRange const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IntRectangleRange", p->soap_type() == SOAP_TYPE_tt__IntRectangleRange ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__IntRectangleRange(struct soap *soap, const char *URL, tt__IntRectangleRange const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IntRectangleRange", p->soap_type() == SOAP_TYPE_tt__IntRectangleRange ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IntRectangleRange(struct soap *soap, const char *URL, tt__IntRectangleRange const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IntRectangleRange", p->soap_type() == SOAP_TYPE_tt__IntRectangleRange ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IntRectangleRange(struct soap *soap, const char *URL, tt__IntRectangleRange const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IntRectangleRange", p->soap_type() == SOAP_TYPE_tt__IntRectangleRange ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__IntRectangleRange * SOAP_FMAC4 soap_get_tt__IntRectangleRange(struct soap*, tt__IntRectangleRange *, const char*, const char*);

inline int soap_read_tt__IntRectangleRange(struct soap *soap, tt__IntRectangleRange *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__IntRectangleRange(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IntRectangleRange(struct soap *soap, const char *URL, tt__IntRectangleRange *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IntRectangleRange(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IntRectangleRange(struct soap *soap, tt__IntRectangleRange *p)
{
	if (::soap_read_tt__IntRectangleRange(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_tt__IntRectangle_DEFINED
#define SOAP_TYPE_tt__IntRectangle_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangle(struct soap*, const char*, int, const tt__IntRectangle *, const char*);
SOAP_FMAC3 tt__IntRectangle * SOAP_FMAC4 soap_in_tt__IntRectangle(struct soap*, const char*, tt__IntRectangle *, const char*);
SOAP_FMAC1 tt__IntRectangle * SOAP_FMAC2 imageing_instantiate_tt__IntRectangle(struct soap*, int, const char*, const char*, size_t*);

inline tt__IntRectangle * soap_new_tt__IntRectangle(struct soap *soap, int n = -1)
{
	return imageing_instantiate_tt__IntRectangle(soap, n, NULL, NULL, NULL);
}

inline tt__IntRectangle * soap_new_req_tt__IntRectangle(
	struct soap *soap,
	int x,
	int y,
	int width,
	int height)
{
	tt__IntRectangle *_p = ::soap_new_tt__IntRectangle(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IntRectangle::x = x;
		_p->tt__IntRectangle::y = y;
		_p->tt__IntRectangle::width = width;
		_p->tt__IntRectangle::height = height;
	}
	return _p;
}

inline tt__IntRectangle * soap_new_set_tt__IntRectangle(
	struct soap *soap,
	int x,
	int y,
	int width,
	int height,
	char *__item__1)
{
	tt__IntRectangle *_p = ::soap_new_tt__IntRectangle(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->tt__IntRectangle::x = x;
		_p->tt__IntRectangle::y = y;
		_p->tt__IntRectangle::width = width;
		_p->tt__IntRectangle::height = height;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_tt__IntRectangle(struct soap *soap, tt__IntRectangle const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IntRectangle", p->soap_type() == SOAP_TYPE_tt__IntRectangle ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_tt__IntRectangle(struct soap *soap, const char *URL, tt__IntRectangle const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IntRectangle", p->soap_type() == SOAP_TYPE_tt__IntRectangle ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_tt__IntRectangle(struct soap *soap, const char *URL, tt__IntRectangle const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IntRectangle", p->soap_type() == SOAP_TYPE_tt__IntRectangle ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_tt__IntRectangle(struct soap *soap, const char *URL, tt__IntRectangle const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "tt:IntRectangle", p->soap_type() == SOAP_TYPE_tt__IntRectangle ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 tt__IntRectangle * SOAP_FMAC4 soap_get_tt__IntRectangle(struct soap*, tt__IntRectangle *, const char*, const char*);

inline int soap_read_tt__IntRectangle(struct soap *soap, tt__IntRectangle *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_tt__IntRectangle(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_tt__IntRectangle(struct soap *soap, const char *URL, tt__IntRectangle *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_tt__IntRectangle(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_tt__IntRectangle(struct soap *soap, tt__IntRectangle *p)
{
	if (::soap_read_tt__IntRectangle(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__SetCurrentPresetResponse_DEFINED
#define SOAP_TYPE__timg__SetCurrentPresetResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetCurrentPresetResponse(struct soap*, const char*, int, const _timg__SetCurrentPresetResponse *, const char*);
SOAP_FMAC3 _timg__SetCurrentPresetResponse * SOAP_FMAC4 soap_in__timg__SetCurrentPresetResponse(struct soap*, const char*, _timg__SetCurrentPresetResponse *, const char*);
SOAP_FMAC1 _timg__SetCurrentPresetResponse * SOAP_FMAC2 imageing_instantiate__timg__SetCurrentPresetResponse(struct soap*, int, const char*, const char*, size_t*);

inline _timg__SetCurrentPresetResponse * soap_new__timg__SetCurrentPresetResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__SetCurrentPresetResponse(soap, n, NULL, NULL, NULL);
}

inline _timg__SetCurrentPresetResponse * soap_new_req__timg__SetCurrentPresetResponse(
	struct soap *soap)
{
	_timg__SetCurrentPresetResponse *_p = ::soap_new__timg__SetCurrentPresetResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _timg__SetCurrentPresetResponse * soap_new_set__timg__SetCurrentPresetResponse(
	struct soap *soap)
{
	_timg__SetCurrentPresetResponse *_p = ::soap_new__timg__SetCurrentPresetResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline int soap_write__timg__SetCurrentPresetResponse(struct soap *soap, _timg__SetCurrentPresetResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetCurrentPresetResponse", p->soap_type() == SOAP_TYPE__timg__SetCurrentPresetResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__SetCurrentPresetResponse(struct soap *soap, const char *URL, _timg__SetCurrentPresetResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetCurrentPresetResponse", p->soap_type() == SOAP_TYPE__timg__SetCurrentPresetResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__SetCurrentPresetResponse(struct soap *soap, const char *URL, _timg__SetCurrentPresetResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetCurrentPresetResponse", p->soap_type() == SOAP_TYPE__timg__SetCurrentPresetResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__SetCurrentPresetResponse(struct soap *soap, const char *URL, _timg__SetCurrentPresetResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetCurrentPresetResponse", p->soap_type() == SOAP_TYPE__timg__SetCurrentPresetResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__SetCurrentPresetResponse * SOAP_FMAC4 soap_get__timg__SetCurrentPresetResponse(struct soap*, _timg__SetCurrentPresetResponse *, const char*, const char*);

inline int soap_read__timg__SetCurrentPresetResponse(struct soap *soap, _timg__SetCurrentPresetResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__SetCurrentPresetResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__SetCurrentPresetResponse(struct soap *soap, const char *URL, _timg__SetCurrentPresetResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__SetCurrentPresetResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__SetCurrentPresetResponse(struct soap *soap, _timg__SetCurrentPresetResponse *p)
{
	if (::soap_read__timg__SetCurrentPresetResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__SetCurrentPreset_DEFINED
#define SOAP_TYPE__timg__SetCurrentPreset_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetCurrentPreset(struct soap*, const char*, int, const _timg__SetCurrentPreset *, const char*);
SOAP_FMAC3 _timg__SetCurrentPreset * SOAP_FMAC4 soap_in__timg__SetCurrentPreset(struct soap*, const char*, _timg__SetCurrentPreset *, const char*);
SOAP_FMAC1 _timg__SetCurrentPreset * SOAP_FMAC2 imageing_instantiate__timg__SetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);

inline _timg__SetCurrentPreset * soap_new__timg__SetCurrentPreset(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__SetCurrentPreset(soap, n, NULL, NULL, NULL);
}

inline _timg__SetCurrentPreset * soap_new_req__timg__SetCurrentPreset(
	struct soap *soap,
	const std::string& VideoSourceToken,
	const std::string& PresetToken)
{
	_timg__SetCurrentPreset *_p = ::soap_new__timg__SetCurrentPreset(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__SetCurrentPreset::VideoSourceToken = VideoSourceToken;
		_p->_timg__SetCurrentPreset::PresetToken = PresetToken;
	}
	return _p;
}

inline _timg__SetCurrentPreset * soap_new_set__timg__SetCurrentPreset(
	struct soap *soap,
	const std::string& VideoSourceToken,
	const std::string& PresetToken)
{
	_timg__SetCurrentPreset *_p = ::soap_new__timg__SetCurrentPreset(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__SetCurrentPreset::VideoSourceToken = VideoSourceToken;
		_p->_timg__SetCurrentPreset::PresetToken = PresetToken;
	}
	return _p;
}

inline int soap_write__timg__SetCurrentPreset(struct soap *soap, _timg__SetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetCurrentPreset", p->soap_type() == SOAP_TYPE__timg__SetCurrentPreset ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__SetCurrentPreset(struct soap *soap, const char *URL, _timg__SetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetCurrentPreset", p->soap_type() == SOAP_TYPE__timg__SetCurrentPreset ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__SetCurrentPreset(struct soap *soap, const char *URL, _timg__SetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetCurrentPreset", p->soap_type() == SOAP_TYPE__timg__SetCurrentPreset ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__SetCurrentPreset(struct soap *soap, const char *URL, _timg__SetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetCurrentPreset", p->soap_type() == SOAP_TYPE__timg__SetCurrentPreset ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__SetCurrentPreset * SOAP_FMAC4 soap_get__timg__SetCurrentPreset(struct soap*, _timg__SetCurrentPreset *, const char*, const char*);

inline int soap_read__timg__SetCurrentPreset(struct soap *soap, _timg__SetCurrentPreset *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__SetCurrentPreset(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__SetCurrentPreset(struct soap *soap, const char *URL, _timg__SetCurrentPreset *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__SetCurrentPreset(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__SetCurrentPreset(struct soap *soap, _timg__SetCurrentPreset *p)
{
	if (::soap_read__timg__SetCurrentPreset(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetCurrentPresetResponse_DEFINED
#define SOAP_TYPE__timg__GetCurrentPresetResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetCurrentPresetResponse(struct soap*, const char*, int, const _timg__GetCurrentPresetResponse *, const char*);
SOAP_FMAC3 _timg__GetCurrentPresetResponse * SOAP_FMAC4 soap_in__timg__GetCurrentPresetResponse(struct soap*, const char*, _timg__GetCurrentPresetResponse *, const char*);
SOAP_FMAC1 _timg__GetCurrentPresetResponse * SOAP_FMAC2 imageing_instantiate__timg__GetCurrentPresetResponse(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetCurrentPresetResponse * soap_new__timg__GetCurrentPresetResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetCurrentPresetResponse(soap, n, NULL, NULL, NULL);
}

inline _timg__GetCurrentPresetResponse * soap_new_req__timg__GetCurrentPresetResponse(
	struct soap *soap)
{
	_timg__GetCurrentPresetResponse *_p = ::soap_new__timg__GetCurrentPresetResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _timg__GetCurrentPresetResponse * soap_new_set__timg__GetCurrentPresetResponse(
	struct soap *soap,
	timg__ImagingPreset *Preset)
{
	_timg__GetCurrentPresetResponse *_p = ::soap_new__timg__GetCurrentPresetResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetCurrentPresetResponse::Preset = Preset;
	}
	return _p;
}

inline int soap_write__timg__GetCurrentPresetResponse(struct soap *soap, _timg__GetCurrentPresetResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetCurrentPresetResponse", p->soap_type() == SOAP_TYPE__timg__GetCurrentPresetResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetCurrentPresetResponse(struct soap *soap, const char *URL, _timg__GetCurrentPresetResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetCurrentPresetResponse", p->soap_type() == SOAP_TYPE__timg__GetCurrentPresetResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetCurrentPresetResponse(struct soap *soap, const char *URL, _timg__GetCurrentPresetResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetCurrentPresetResponse", p->soap_type() == SOAP_TYPE__timg__GetCurrentPresetResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetCurrentPresetResponse(struct soap *soap, const char *URL, _timg__GetCurrentPresetResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetCurrentPresetResponse", p->soap_type() == SOAP_TYPE__timg__GetCurrentPresetResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetCurrentPresetResponse * SOAP_FMAC4 soap_get__timg__GetCurrentPresetResponse(struct soap*, _timg__GetCurrentPresetResponse *, const char*, const char*);

inline int soap_read__timg__GetCurrentPresetResponse(struct soap *soap, _timg__GetCurrentPresetResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetCurrentPresetResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetCurrentPresetResponse(struct soap *soap, const char *URL, _timg__GetCurrentPresetResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetCurrentPresetResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetCurrentPresetResponse(struct soap *soap, _timg__GetCurrentPresetResponse *p)
{
	if (::soap_read__timg__GetCurrentPresetResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetCurrentPreset_DEFINED
#define SOAP_TYPE__timg__GetCurrentPreset_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetCurrentPreset(struct soap*, const char*, int, const _timg__GetCurrentPreset *, const char*);
SOAP_FMAC3 _timg__GetCurrentPreset * SOAP_FMAC4 soap_in__timg__GetCurrentPreset(struct soap*, const char*, _timg__GetCurrentPreset *, const char*);
SOAP_FMAC1 _timg__GetCurrentPreset * SOAP_FMAC2 imageing_instantiate__timg__GetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetCurrentPreset * soap_new__timg__GetCurrentPreset(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetCurrentPreset(soap, n, NULL, NULL, NULL);
}

inline _timg__GetCurrentPreset * soap_new_req__timg__GetCurrentPreset(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__GetCurrentPreset *_p = ::soap_new__timg__GetCurrentPreset(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetCurrentPreset::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline _timg__GetCurrentPreset * soap_new_set__timg__GetCurrentPreset(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__GetCurrentPreset *_p = ::soap_new__timg__GetCurrentPreset(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetCurrentPreset::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline int soap_write__timg__GetCurrentPreset(struct soap *soap, _timg__GetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetCurrentPreset", p->soap_type() == SOAP_TYPE__timg__GetCurrentPreset ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetCurrentPreset(struct soap *soap, const char *URL, _timg__GetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetCurrentPreset", p->soap_type() == SOAP_TYPE__timg__GetCurrentPreset ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetCurrentPreset(struct soap *soap, const char *URL, _timg__GetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetCurrentPreset", p->soap_type() == SOAP_TYPE__timg__GetCurrentPreset ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetCurrentPreset(struct soap *soap, const char *URL, _timg__GetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetCurrentPreset", p->soap_type() == SOAP_TYPE__timg__GetCurrentPreset ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetCurrentPreset * SOAP_FMAC4 soap_get__timg__GetCurrentPreset(struct soap*, _timg__GetCurrentPreset *, const char*, const char*);

inline int soap_read__timg__GetCurrentPreset(struct soap *soap, _timg__GetCurrentPreset *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetCurrentPreset(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetCurrentPreset(struct soap *soap, const char *URL, _timg__GetCurrentPreset *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetCurrentPreset(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetCurrentPreset(struct soap *soap, _timg__GetCurrentPreset *p)
{
	if (::soap_read__timg__GetCurrentPreset(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetPresetsResponse_DEFINED
#define SOAP_TYPE__timg__GetPresetsResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetPresetsResponse(struct soap*, const char*, int, const _timg__GetPresetsResponse *, const char*);
SOAP_FMAC3 _timg__GetPresetsResponse * SOAP_FMAC4 soap_in__timg__GetPresetsResponse(struct soap*, const char*, _timg__GetPresetsResponse *, const char*);
SOAP_FMAC1 _timg__GetPresetsResponse * SOAP_FMAC2 imageing_instantiate__timg__GetPresetsResponse(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetPresetsResponse * soap_new__timg__GetPresetsResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetPresetsResponse(soap, n, NULL, NULL, NULL);
}

inline _timg__GetPresetsResponse * soap_new_req__timg__GetPresetsResponse(
	struct soap *soap,
	const std::vector<timg__ImagingPreset *> & Preset)
{
	_timg__GetPresetsResponse *_p = ::soap_new__timg__GetPresetsResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetPresetsResponse::Preset = Preset;
	}
	return _p;
}

inline _timg__GetPresetsResponse * soap_new_set__timg__GetPresetsResponse(
	struct soap *soap,
	const std::vector<timg__ImagingPreset *> & Preset)
{
	_timg__GetPresetsResponse *_p = ::soap_new__timg__GetPresetsResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetPresetsResponse::Preset = Preset;
	}
	return _p;
}

inline int soap_write__timg__GetPresetsResponse(struct soap *soap, _timg__GetPresetsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetPresetsResponse", p->soap_type() == SOAP_TYPE__timg__GetPresetsResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetPresetsResponse(struct soap *soap, const char *URL, _timg__GetPresetsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetPresetsResponse", p->soap_type() == SOAP_TYPE__timg__GetPresetsResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetPresetsResponse(struct soap *soap, const char *URL, _timg__GetPresetsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetPresetsResponse", p->soap_type() == SOAP_TYPE__timg__GetPresetsResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetPresetsResponse(struct soap *soap, const char *URL, _timg__GetPresetsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetPresetsResponse", p->soap_type() == SOAP_TYPE__timg__GetPresetsResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetPresetsResponse * SOAP_FMAC4 soap_get__timg__GetPresetsResponse(struct soap*, _timg__GetPresetsResponse *, const char*, const char*);

inline int soap_read__timg__GetPresetsResponse(struct soap *soap, _timg__GetPresetsResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetPresetsResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetPresetsResponse(struct soap *soap, const char *URL, _timg__GetPresetsResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetPresetsResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetPresetsResponse(struct soap *soap, _timg__GetPresetsResponse *p)
{
	if (::soap_read__timg__GetPresetsResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetPresets_DEFINED
#define SOAP_TYPE__timg__GetPresets_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetPresets(struct soap*, const char*, int, const _timg__GetPresets *, const char*);
SOAP_FMAC3 _timg__GetPresets * SOAP_FMAC4 soap_in__timg__GetPresets(struct soap*, const char*, _timg__GetPresets *, const char*);
SOAP_FMAC1 _timg__GetPresets * SOAP_FMAC2 imageing_instantiate__timg__GetPresets(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetPresets * soap_new__timg__GetPresets(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetPresets(soap, n, NULL, NULL, NULL);
}

inline _timg__GetPresets * soap_new_req__timg__GetPresets(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__GetPresets *_p = ::soap_new__timg__GetPresets(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetPresets::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline _timg__GetPresets * soap_new_set__timg__GetPresets(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__GetPresets *_p = ::soap_new__timg__GetPresets(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetPresets::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline int soap_write__timg__GetPresets(struct soap *soap, _timg__GetPresets const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetPresets", p->soap_type() == SOAP_TYPE__timg__GetPresets ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetPresets(struct soap *soap, const char *URL, _timg__GetPresets const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetPresets", p->soap_type() == SOAP_TYPE__timg__GetPresets ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetPresets(struct soap *soap, const char *URL, _timg__GetPresets const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetPresets", p->soap_type() == SOAP_TYPE__timg__GetPresets ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetPresets(struct soap *soap, const char *URL, _timg__GetPresets const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetPresets", p->soap_type() == SOAP_TYPE__timg__GetPresets ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetPresets * SOAP_FMAC4 soap_get__timg__GetPresets(struct soap*, _timg__GetPresets *, const char*, const char*);

inline int soap_read__timg__GetPresets(struct soap *soap, _timg__GetPresets *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetPresets(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetPresets(struct soap *soap, const char *URL, _timg__GetPresets *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetPresets(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetPresets(struct soap *soap, _timg__GetPresets *p)
{
	if (::soap_read__timg__GetPresets(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetStatusResponse_DEFINED
#define SOAP_TYPE__timg__GetStatusResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetStatusResponse(struct soap*, const char*, int, const _timg__GetStatusResponse *, const char*);
SOAP_FMAC3 _timg__GetStatusResponse * SOAP_FMAC4 soap_in__timg__GetStatusResponse(struct soap*, const char*, _timg__GetStatusResponse *, const char*);
SOAP_FMAC1 _timg__GetStatusResponse * SOAP_FMAC2 imageing_instantiate__timg__GetStatusResponse(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetStatusResponse * soap_new__timg__GetStatusResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetStatusResponse(soap, n, NULL, NULL, NULL);
}

inline _timg__GetStatusResponse * soap_new_req__timg__GetStatusResponse(
	struct soap *soap,
	tt__ImagingStatus20 *Status)
{
	_timg__GetStatusResponse *_p = ::soap_new__timg__GetStatusResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetStatusResponse::Status = Status;
	}
	return _p;
}

inline _timg__GetStatusResponse * soap_new_set__timg__GetStatusResponse(
	struct soap *soap,
	tt__ImagingStatus20 *Status)
{
	_timg__GetStatusResponse *_p = ::soap_new__timg__GetStatusResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetStatusResponse::Status = Status;
	}
	return _p;
}

inline int soap_write__timg__GetStatusResponse(struct soap *soap, _timg__GetStatusResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetStatusResponse", p->soap_type() == SOAP_TYPE__timg__GetStatusResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetStatusResponse(struct soap *soap, const char *URL, _timg__GetStatusResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetStatusResponse", p->soap_type() == SOAP_TYPE__timg__GetStatusResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetStatusResponse(struct soap *soap, const char *URL, _timg__GetStatusResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetStatusResponse", p->soap_type() == SOAP_TYPE__timg__GetStatusResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetStatusResponse(struct soap *soap, const char *URL, _timg__GetStatusResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetStatusResponse", p->soap_type() == SOAP_TYPE__timg__GetStatusResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetStatusResponse * SOAP_FMAC4 soap_get__timg__GetStatusResponse(struct soap*, _timg__GetStatusResponse *, const char*, const char*);

inline int soap_read__timg__GetStatusResponse(struct soap *soap, _timg__GetStatusResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetStatusResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetStatusResponse(struct soap *soap, const char *URL, _timg__GetStatusResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetStatusResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetStatusResponse(struct soap *soap, _timg__GetStatusResponse *p)
{
	if (::soap_read__timg__GetStatusResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetStatus_DEFINED
#define SOAP_TYPE__timg__GetStatus_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetStatus(struct soap*, const char*, int, const _timg__GetStatus *, const char*);
SOAP_FMAC3 _timg__GetStatus * SOAP_FMAC4 soap_in__timg__GetStatus(struct soap*, const char*, _timg__GetStatus *, const char*);
SOAP_FMAC1 _timg__GetStatus * SOAP_FMAC2 imageing_instantiate__timg__GetStatus(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetStatus * soap_new__timg__GetStatus(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetStatus(soap, n, NULL, NULL, NULL);
}

inline _timg__GetStatus * soap_new_req__timg__GetStatus(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__GetStatus *_p = ::soap_new__timg__GetStatus(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetStatus::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline _timg__GetStatus * soap_new_set__timg__GetStatus(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__GetStatus *_p = ::soap_new__timg__GetStatus(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetStatus::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline int soap_write__timg__GetStatus(struct soap *soap, _timg__GetStatus const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetStatus", p->soap_type() == SOAP_TYPE__timg__GetStatus ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetStatus(struct soap *soap, const char *URL, _timg__GetStatus const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetStatus", p->soap_type() == SOAP_TYPE__timg__GetStatus ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetStatus(struct soap *soap, const char *URL, _timg__GetStatus const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetStatus", p->soap_type() == SOAP_TYPE__timg__GetStatus ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetStatus(struct soap *soap, const char *URL, _timg__GetStatus const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetStatus", p->soap_type() == SOAP_TYPE__timg__GetStatus ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetStatus * SOAP_FMAC4 soap_get__timg__GetStatus(struct soap*, _timg__GetStatus *, const char*, const char*);

inline int soap_read__timg__GetStatus(struct soap *soap, _timg__GetStatus *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetStatus(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetStatus(struct soap *soap, const char *URL, _timg__GetStatus *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetStatus(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetStatus(struct soap *soap, _timg__GetStatus *p)
{
	if (::soap_read__timg__GetStatus(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__StopResponse_DEFINED
#define SOAP_TYPE__timg__StopResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__StopResponse(struct soap*, const char*, int, const _timg__StopResponse *, const char*);
SOAP_FMAC3 _timg__StopResponse * SOAP_FMAC4 soap_in__timg__StopResponse(struct soap*, const char*, _timg__StopResponse *, const char*);
SOAP_FMAC1 _timg__StopResponse * SOAP_FMAC2 imageing_instantiate__timg__StopResponse(struct soap*, int, const char*, const char*, size_t*);

inline _timg__StopResponse * soap_new__timg__StopResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__StopResponse(soap, n, NULL, NULL, NULL);
}

inline _timg__StopResponse * soap_new_req__timg__StopResponse(
	struct soap *soap)
{
	_timg__StopResponse *_p = ::soap_new__timg__StopResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _timg__StopResponse * soap_new_set__timg__StopResponse(
	struct soap *soap)
{
	_timg__StopResponse *_p = ::soap_new__timg__StopResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline int soap_write__timg__StopResponse(struct soap *soap, _timg__StopResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:StopResponse", p->soap_type() == SOAP_TYPE__timg__StopResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__StopResponse(struct soap *soap, const char *URL, _timg__StopResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:StopResponse", p->soap_type() == SOAP_TYPE__timg__StopResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__StopResponse(struct soap *soap, const char *URL, _timg__StopResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:StopResponse", p->soap_type() == SOAP_TYPE__timg__StopResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__StopResponse(struct soap *soap, const char *URL, _timg__StopResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:StopResponse", p->soap_type() == SOAP_TYPE__timg__StopResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__StopResponse * SOAP_FMAC4 soap_get__timg__StopResponse(struct soap*, _timg__StopResponse *, const char*, const char*);

inline int soap_read__timg__StopResponse(struct soap *soap, _timg__StopResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__StopResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__StopResponse(struct soap *soap, const char *URL, _timg__StopResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__StopResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__StopResponse(struct soap *soap, _timg__StopResponse *p)
{
	if (::soap_read__timg__StopResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__Stop_DEFINED
#define SOAP_TYPE__timg__Stop_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__Stop(struct soap*, const char*, int, const _timg__Stop *, const char*);
SOAP_FMAC3 _timg__Stop * SOAP_FMAC4 soap_in__timg__Stop(struct soap*, const char*, _timg__Stop *, const char*);
SOAP_FMAC1 _timg__Stop * SOAP_FMAC2 imageing_instantiate__timg__Stop(struct soap*, int, const char*, const char*, size_t*);

inline _timg__Stop * soap_new__timg__Stop(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__Stop(soap, n, NULL, NULL, NULL);
}

inline _timg__Stop * soap_new_req__timg__Stop(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__Stop *_p = ::soap_new__timg__Stop(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__Stop::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline _timg__Stop * soap_new_set__timg__Stop(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__Stop *_p = ::soap_new__timg__Stop(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__Stop::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline int soap_write__timg__Stop(struct soap *soap, _timg__Stop const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:Stop", p->soap_type() == SOAP_TYPE__timg__Stop ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__Stop(struct soap *soap, const char *URL, _timg__Stop const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:Stop", p->soap_type() == SOAP_TYPE__timg__Stop ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__Stop(struct soap *soap, const char *URL, _timg__Stop const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:Stop", p->soap_type() == SOAP_TYPE__timg__Stop ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__Stop(struct soap *soap, const char *URL, _timg__Stop const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:Stop", p->soap_type() == SOAP_TYPE__timg__Stop ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__Stop * SOAP_FMAC4 soap_get__timg__Stop(struct soap*, _timg__Stop *, const char*, const char*);

inline int soap_read__timg__Stop(struct soap *soap, _timg__Stop *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__Stop(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__Stop(struct soap *soap, const char *URL, _timg__Stop *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__Stop(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__Stop(struct soap *soap, _timg__Stop *p)
{
	if (::soap_read__timg__Stop(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetMoveOptionsResponse_DEFINED
#define SOAP_TYPE__timg__GetMoveOptionsResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetMoveOptionsResponse(struct soap*, const char*, int, const _timg__GetMoveOptionsResponse *, const char*);
SOAP_FMAC3 _timg__GetMoveOptionsResponse * SOAP_FMAC4 soap_in__timg__GetMoveOptionsResponse(struct soap*, const char*, _timg__GetMoveOptionsResponse *, const char*);
SOAP_FMAC1 _timg__GetMoveOptionsResponse * SOAP_FMAC2 imageing_instantiate__timg__GetMoveOptionsResponse(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetMoveOptionsResponse * soap_new__timg__GetMoveOptionsResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetMoveOptionsResponse(soap, n, NULL, NULL, NULL);
}

inline _timg__GetMoveOptionsResponse * soap_new_req__timg__GetMoveOptionsResponse(
	struct soap *soap,
	tt__MoveOptions20 *MoveOptions)
{
	_timg__GetMoveOptionsResponse *_p = ::soap_new__timg__GetMoveOptionsResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetMoveOptionsResponse::MoveOptions = MoveOptions;
	}
	return _p;
}

inline _timg__GetMoveOptionsResponse * soap_new_set__timg__GetMoveOptionsResponse(
	struct soap *soap,
	tt__MoveOptions20 *MoveOptions)
{
	_timg__GetMoveOptionsResponse *_p = ::soap_new__timg__GetMoveOptionsResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetMoveOptionsResponse::MoveOptions = MoveOptions;
	}
	return _p;
}

inline int soap_write__timg__GetMoveOptionsResponse(struct soap *soap, _timg__GetMoveOptionsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetMoveOptionsResponse", p->soap_type() == SOAP_TYPE__timg__GetMoveOptionsResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetMoveOptionsResponse(struct soap *soap, const char *URL, _timg__GetMoveOptionsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetMoveOptionsResponse", p->soap_type() == SOAP_TYPE__timg__GetMoveOptionsResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetMoveOptionsResponse(struct soap *soap, const char *URL, _timg__GetMoveOptionsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetMoveOptionsResponse", p->soap_type() == SOAP_TYPE__timg__GetMoveOptionsResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetMoveOptionsResponse(struct soap *soap, const char *URL, _timg__GetMoveOptionsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetMoveOptionsResponse", p->soap_type() == SOAP_TYPE__timg__GetMoveOptionsResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetMoveOptionsResponse * SOAP_FMAC4 soap_get__timg__GetMoveOptionsResponse(struct soap*, _timg__GetMoveOptionsResponse *, const char*, const char*);

inline int soap_read__timg__GetMoveOptionsResponse(struct soap *soap, _timg__GetMoveOptionsResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetMoveOptionsResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetMoveOptionsResponse(struct soap *soap, const char *URL, _timg__GetMoveOptionsResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetMoveOptionsResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetMoveOptionsResponse(struct soap *soap, _timg__GetMoveOptionsResponse *p)
{
	if (::soap_read__timg__GetMoveOptionsResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetMoveOptions_DEFINED
#define SOAP_TYPE__timg__GetMoveOptions_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetMoveOptions(struct soap*, const char*, int, const _timg__GetMoveOptions *, const char*);
SOAP_FMAC3 _timg__GetMoveOptions * SOAP_FMAC4 soap_in__timg__GetMoveOptions(struct soap*, const char*, _timg__GetMoveOptions *, const char*);
SOAP_FMAC1 _timg__GetMoveOptions * SOAP_FMAC2 imageing_instantiate__timg__GetMoveOptions(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetMoveOptions * soap_new__timg__GetMoveOptions(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetMoveOptions(soap, n, NULL, NULL, NULL);
}

inline _timg__GetMoveOptions * soap_new_req__timg__GetMoveOptions(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__GetMoveOptions *_p = ::soap_new__timg__GetMoveOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetMoveOptions::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline _timg__GetMoveOptions * soap_new_set__timg__GetMoveOptions(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__GetMoveOptions *_p = ::soap_new__timg__GetMoveOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetMoveOptions::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline int soap_write__timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetMoveOptions", p->soap_type() == SOAP_TYPE__timg__GetMoveOptions ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetMoveOptions(struct soap *soap, const char *URL, _timg__GetMoveOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetMoveOptions", p->soap_type() == SOAP_TYPE__timg__GetMoveOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetMoveOptions(struct soap *soap, const char *URL, _timg__GetMoveOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetMoveOptions", p->soap_type() == SOAP_TYPE__timg__GetMoveOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetMoveOptions(struct soap *soap, const char *URL, _timg__GetMoveOptions const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetMoveOptions", p->soap_type() == SOAP_TYPE__timg__GetMoveOptions ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetMoveOptions * SOAP_FMAC4 soap_get__timg__GetMoveOptions(struct soap*, _timg__GetMoveOptions *, const char*, const char*);

inline int soap_read__timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetMoveOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetMoveOptions(struct soap *soap, const char *URL, _timg__GetMoveOptions *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetMoveOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions *p)
{
	if (::soap_read__timg__GetMoveOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__MoveResponse_DEFINED
#define SOAP_TYPE__timg__MoveResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__MoveResponse(struct soap*, const char*, int, const _timg__MoveResponse *, const char*);
SOAP_FMAC3 _timg__MoveResponse * SOAP_FMAC4 soap_in__timg__MoveResponse(struct soap*, const char*, _timg__MoveResponse *, const char*);
SOAP_FMAC1 _timg__MoveResponse * SOAP_FMAC2 imageing_instantiate__timg__MoveResponse(struct soap*, int, const char*, const char*, size_t*);

inline _timg__MoveResponse * soap_new__timg__MoveResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__MoveResponse(soap, n, NULL, NULL, NULL);
}

inline _timg__MoveResponse * soap_new_req__timg__MoveResponse(
	struct soap *soap)
{
	_timg__MoveResponse *_p = ::soap_new__timg__MoveResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _timg__MoveResponse * soap_new_set__timg__MoveResponse(
	struct soap *soap)
{
	_timg__MoveResponse *_p = ::soap_new__timg__MoveResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline int soap_write__timg__MoveResponse(struct soap *soap, _timg__MoveResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:MoveResponse", p->soap_type() == SOAP_TYPE__timg__MoveResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__MoveResponse(struct soap *soap, const char *URL, _timg__MoveResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:MoveResponse", p->soap_type() == SOAP_TYPE__timg__MoveResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__MoveResponse(struct soap *soap, const char *URL, _timg__MoveResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:MoveResponse", p->soap_type() == SOAP_TYPE__timg__MoveResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__MoveResponse(struct soap *soap, const char *URL, _timg__MoveResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:MoveResponse", p->soap_type() == SOAP_TYPE__timg__MoveResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__MoveResponse * SOAP_FMAC4 soap_get__timg__MoveResponse(struct soap*, _timg__MoveResponse *, const char*, const char*);

inline int soap_read__timg__MoveResponse(struct soap *soap, _timg__MoveResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__MoveResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__MoveResponse(struct soap *soap, const char *URL, _timg__MoveResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__MoveResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__MoveResponse(struct soap *soap, _timg__MoveResponse *p)
{
	if (::soap_read__timg__MoveResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__Move_DEFINED
#define SOAP_TYPE__timg__Move_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__Move(struct soap*, const char*, int, const _timg__Move *, const char*);
SOAP_FMAC3 _timg__Move * SOAP_FMAC4 soap_in__timg__Move(struct soap*, const char*, _timg__Move *, const char*);
SOAP_FMAC1 _timg__Move * SOAP_FMAC2 imageing_instantiate__timg__Move(struct soap*, int, const char*, const char*, size_t*);

inline _timg__Move * soap_new__timg__Move(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__Move(soap, n, NULL, NULL, NULL);
}

inline _timg__Move * soap_new_req__timg__Move(
	struct soap *soap,
	const std::string& VideoSourceToken,
	tt__FocusMove *Focus)
{
	_timg__Move *_p = ::soap_new__timg__Move(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__Move::VideoSourceToken = VideoSourceToken;
		_p->_timg__Move::Focus = Focus;
	}
	return _p;
}

inline _timg__Move * soap_new_set__timg__Move(
	struct soap *soap,
	const std::string& VideoSourceToken,
	tt__FocusMove *Focus)
{
	_timg__Move *_p = ::soap_new__timg__Move(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__Move::VideoSourceToken = VideoSourceToken;
		_p->_timg__Move::Focus = Focus;
	}
	return _p;
}

inline int soap_write__timg__Move(struct soap *soap, _timg__Move const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:Move", p->soap_type() == SOAP_TYPE__timg__Move ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__Move(struct soap *soap, const char *URL, _timg__Move const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:Move", p->soap_type() == SOAP_TYPE__timg__Move ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__Move(struct soap *soap, const char *URL, _timg__Move const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:Move", p->soap_type() == SOAP_TYPE__timg__Move ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__Move(struct soap *soap, const char *URL, _timg__Move const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:Move", p->soap_type() == SOAP_TYPE__timg__Move ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__Move * SOAP_FMAC4 soap_get__timg__Move(struct soap*, _timg__Move *, const char*, const char*);

inline int soap_read__timg__Move(struct soap *soap, _timg__Move *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__Move(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__Move(struct soap *soap, const char *URL, _timg__Move *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__Move(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__Move(struct soap *soap, _timg__Move *p)
{
	if (::soap_read__timg__Move(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetOptionsResponse_DEFINED
#define SOAP_TYPE__timg__GetOptionsResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetOptionsResponse(struct soap*, const char*, int, const _timg__GetOptionsResponse *, const char*);
SOAP_FMAC3 _timg__GetOptionsResponse * SOAP_FMAC4 soap_in__timg__GetOptionsResponse(struct soap*, const char*, _timg__GetOptionsResponse *, const char*);
SOAP_FMAC1 _timg__GetOptionsResponse * SOAP_FMAC2 imageing_instantiate__timg__GetOptionsResponse(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetOptionsResponse * soap_new__timg__GetOptionsResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetOptionsResponse(soap, n, NULL, NULL, NULL);
}

inline _timg__GetOptionsResponse * soap_new_req__timg__GetOptionsResponse(
	struct soap *soap,
	tt__ImagingOptions20 *ImagingOptions)
{
	_timg__GetOptionsResponse *_p = ::soap_new__timg__GetOptionsResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetOptionsResponse::ImagingOptions = ImagingOptions;
	}
	return _p;
}

inline _timg__GetOptionsResponse * soap_new_set__timg__GetOptionsResponse(
	struct soap *soap,
	tt__ImagingOptions20 *ImagingOptions)
{
	_timg__GetOptionsResponse *_p = ::soap_new__timg__GetOptionsResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetOptionsResponse::ImagingOptions = ImagingOptions;
	}
	return _p;
}

inline int soap_write__timg__GetOptionsResponse(struct soap *soap, _timg__GetOptionsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetOptionsResponse", p->soap_type() == SOAP_TYPE__timg__GetOptionsResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetOptionsResponse(struct soap *soap, const char *URL, _timg__GetOptionsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetOptionsResponse", p->soap_type() == SOAP_TYPE__timg__GetOptionsResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetOptionsResponse(struct soap *soap, const char *URL, _timg__GetOptionsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetOptionsResponse", p->soap_type() == SOAP_TYPE__timg__GetOptionsResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetOptionsResponse(struct soap *soap, const char *URL, _timg__GetOptionsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetOptionsResponse", p->soap_type() == SOAP_TYPE__timg__GetOptionsResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetOptionsResponse * SOAP_FMAC4 soap_get__timg__GetOptionsResponse(struct soap*, _timg__GetOptionsResponse *, const char*, const char*);

inline int soap_read__timg__GetOptionsResponse(struct soap *soap, _timg__GetOptionsResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetOptionsResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetOptionsResponse(struct soap *soap, const char *URL, _timg__GetOptionsResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetOptionsResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetOptionsResponse(struct soap *soap, _timg__GetOptionsResponse *p)
{
	if (::soap_read__timg__GetOptionsResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetOptions_DEFINED
#define SOAP_TYPE__timg__GetOptions_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetOptions(struct soap*, const char*, int, const _timg__GetOptions *, const char*);
SOAP_FMAC3 _timg__GetOptions * SOAP_FMAC4 soap_in__timg__GetOptions(struct soap*, const char*, _timg__GetOptions *, const char*);
SOAP_FMAC1 _timg__GetOptions * SOAP_FMAC2 imageing_instantiate__timg__GetOptions(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetOptions * soap_new__timg__GetOptions(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetOptions(soap, n, NULL, NULL, NULL);
}

inline _timg__GetOptions * soap_new_req__timg__GetOptions(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__GetOptions *_p = ::soap_new__timg__GetOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetOptions::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline _timg__GetOptions * soap_new_set__timg__GetOptions(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__GetOptions *_p = ::soap_new__timg__GetOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetOptions::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline int soap_write__timg__GetOptions(struct soap *soap, _timg__GetOptions const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetOptions", p->soap_type() == SOAP_TYPE__timg__GetOptions ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetOptions(struct soap *soap, const char *URL, _timg__GetOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetOptions", p->soap_type() == SOAP_TYPE__timg__GetOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetOptions(struct soap *soap, const char *URL, _timg__GetOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetOptions", p->soap_type() == SOAP_TYPE__timg__GetOptions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetOptions(struct soap *soap, const char *URL, _timg__GetOptions const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetOptions", p->soap_type() == SOAP_TYPE__timg__GetOptions ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetOptions * SOAP_FMAC4 soap_get__timg__GetOptions(struct soap*, _timg__GetOptions *, const char*, const char*);

inline int soap_read__timg__GetOptions(struct soap *soap, _timg__GetOptions *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetOptions(struct soap *soap, const char *URL, _timg__GetOptions *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetOptions(struct soap *soap, _timg__GetOptions *p)
{
	if (::soap_read__timg__GetOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__SetImagingSettingsResponse_DEFINED
#define SOAP_TYPE__timg__SetImagingSettingsResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetImagingSettingsResponse(struct soap*, const char*, int, const _timg__SetImagingSettingsResponse *, const char*);
SOAP_FMAC3 _timg__SetImagingSettingsResponse * SOAP_FMAC4 soap_in__timg__SetImagingSettingsResponse(struct soap*, const char*, _timg__SetImagingSettingsResponse *, const char*);
SOAP_FMAC1 _timg__SetImagingSettingsResponse * SOAP_FMAC2 imageing_instantiate__timg__SetImagingSettingsResponse(struct soap*, int, const char*, const char*, size_t*);

inline _timg__SetImagingSettingsResponse * soap_new__timg__SetImagingSettingsResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__SetImagingSettingsResponse(soap, n, NULL, NULL, NULL);
}

inline _timg__SetImagingSettingsResponse * soap_new_req__timg__SetImagingSettingsResponse(
	struct soap *soap)
{
	_timg__SetImagingSettingsResponse *_p = ::soap_new__timg__SetImagingSettingsResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _timg__SetImagingSettingsResponse * soap_new_set__timg__SetImagingSettingsResponse(
	struct soap *soap)
{
	_timg__SetImagingSettingsResponse *_p = ::soap_new__timg__SetImagingSettingsResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline int soap_write__timg__SetImagingSettingsResponse(struct soap *soap, _timg__SetImagingSettingsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetImagingSettingsResponse", p->soap_type() == SOAP_TYPE__timg__SetImagingSettingsResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__SetImagingSettingsResponse(struct soap *soap, const char *URL, _timg__SetImagingSettingsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetImagingSettingsResponse", p->soap_type() == SOAP_TYPE__timg__SetImagingSettingsResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__SetImagingSettingsResponse(struct soap *soap, const char *URL, _timg__SetImagingSettingsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetImagingSettingsResponse", p->soap_type() == SOAP_TYPE__timg__SetImagingSettingsResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__SetImagingSettingsResponse(struct soap *soap, const char *URL, _timg__SetImagingSettingsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetImagingSettingsResponse", p->soap_type() == SOAP_TYPE__timg__SetImagingSettingsResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__SetImagingSettingsResponse * SOAP_FMAC4 soap_get__timg__SetImagingSettingsResponse(struct soap*, _timg__SetImagingSettingsResponse *, const char*, const char*);

inline int soap_read__timg__SetImagingSettingsResponse(struct soap *soap, _timg__SetImagingSettingsResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__SetImagingSettingsResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__SetImagingSettingsResponse(struct soap *soap, const char *URL, _timg__SetImagingSettingsResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__SetImagingSettingsResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__SetImagingSettingsResponse(struct soap *soap, _timg__SetImagingSettingsResponse *p)
{
	if (::soap_read__timg__SetImagingSettingsResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__SetImagingSettings_DEFINED
#define SOAP_TYPE__timg__SetImagingSettings_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetImagingSettings(struct soap*, const char*, int, const _timg__SetImagingSettings *, const char*);
SOAP_FMAC3 _timg__SetImagingSettings * SOAP_FMAC4 soap_in__timg__SetImagingSettings(struct soap*, const char*, _timg__SetImagingSettings *, const char*);
SOAP_FMAC1 _timg__SetImagingSettings * SOAP_FMAC2 imageing_instantiate__timg__SetImagingSettings(struct soap*, int, const char*, const char*, size_t*);

inline _timg__SetImagingSettings * soap_new__timg__SetImagingSettings(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__SetImagingSettings(soap, n, NULL, NULL, NULL);
}

inline _timg__SetImagingSettings * soap_new_req__timg__SetImagingSettings(
	struct soap *soap,
	const std::string& VideoSourceToken,
	tt__ImagingSettings20 *ImagingSettings)
{
	_timg__SetImagingSettings *_p = ::soap_new__timg__SetImagingSettings(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__SetImagingSettings::VideoSourceToken = VideoSourceToken;
		_p->_timg__SetImagingSettings::ImagingSettings = ImagingSettings;
	}
	return _p;
}

inline _timg__SetImagingSettings * soap_new_set__timg__SetImagingSettings(
	struct soap *soap,
	const std::string& VideoSourceToken,
	tt__ImagingSettings20 *ImagingSettings,
	bool *ForcePersistence)
{
	_timg__SetImagingSettings *_p = ::soap_new__timg__SetImagingSettings(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__SetImagingSettings::VideoSourceToken = VideoSourceToken;
		_p->_timg__SetImagingSettings::ImagingSettings = ImagingSettings;
		_p->_timg__SetImagingSettings::ForcePersistence = ForcePersistence;
	}
	return _p;
}

inline int soap_write__timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetImagingSettings", p->soap_type() == SOAP_TYPE__timg__SetImagingSettings ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__SetImagingSettings(struct soap *soap, const char *URL, _timg__SetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetImagingSettings", p->soap_type() == SOAP_TYPE__timg__SetImagingSettings ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__SetImagingSettings(struct soap *soap, const char *URL, _timg__SetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetImagingSettings", p->soap_type() == SOAP_TYPE__timg__SetImagingSettings ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__SetImagingSettings(struct soap *soap, const char *URL, _timg__SetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:SetImagingSettings", p->soap_type() == SOAP_TYPE__timg__SetImagingSettings ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__SetImagingSettings * SOAP_FMAC4 soap_get__timg__SetImagingSettings(struct soap*, _timg__SetImagingSettings *, const char*, const char*);

inline int soap_read__timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__SetImagingSettings(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__SetImagingSettings(struct soap *soap, const char *URL, _timg__SetImagingSettings *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__SetImagingSettings(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings *p)
{
	if (::soap_read__timg__SetImagingSettings(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetImagingSettingsResponse_DEFINED
#define SOAP_TYPE__timg__GetImagingSettingsResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetImagingSettingsResponse(struct soap*, const char*, int, const _timg__GetImagingSettingsResponse *, const char*);
SOAP_FMAC3 _timg__GetImagingSettingsResponse * SOAP_FMAC4 soap_in__timg__GetImagingSettingsResponse(struct soap*, const char*, _timg__GetImagingSettingsResponse *, const char*);
SOAP_FMAC1 _timg__GetImagingSettingsResponse * SOAP_FMAC2 imageing_instantiate__timg__GetImagingSettingsResponse(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetImagingSettingsResponse * soap_new__timg__GetImagingSettingsResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetImagingSettingsResponse(soap, n, NULL, NULL, NULL);
}

inline _timg__GetImagingSettingsResponse * soap_new_req__timg__GetImagingSettingsResponse(
	struct soap *soap,
	tt__ImagingSettings20 *ImagingSettings)
{
	_timg__GetImagingSettingsResponse *_p = ::soap_new__timg__GetImagingSettingsResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetImagingSettingsResponse::ImagingSettings = ImagingSettings;
	}
	return _p;
}

inline _timg__GetImagingSettingsResponse * soap_new_set__timg__GetImagingSettingsResponse(
	struct soap *soap,
	tt__ImagingSettings20 *ImagingSettings)
{
	_timg__GetImagingSettingsResponse *_p = ::soap_new__timg__GetImagingSettingsResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetImagingSettingsResponse::ImagingSettings = ImagingSettings;
	}
	return _p;
}

inline int soap_write__timg__GetImagingSettingsResponse(struct soap *soap, _timg__GetImagingSettingsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetImagingSettingsResponse", p->soap_type() == SOAP_TYPE__timg__GetImagingSettingsResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetImagingSettingsResponse(struct soap *soap, const char *URL, _timg__GetImagingSettingsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetImagingSettingsResponse", p->soap_type() == SOAP_TYPE__timg__GetImagingSettingsResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetImagingSettingsResponse(struct soap *soap, const char *URL, _timg__GetImagingSettingsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetImagingSettingsResponse", p->soap_type() == SOAP_TYPE__timg__GetImagingSettingsResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetImagingSettingsResponse(struct soap *soap, const char *URL, _timg__GetImagingSettingsResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetImagingSettingsResponse", p->soap_type() == SOAP_TYPE__timg__GetImagingSettingsResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetImagingSettingsResponse * SOAP_FMAC4 soap_get__timg__GetImagingSettingsResponse(struct soap*, _timg__GetImagingSettingsResponse *, const char*, const char*);

inline int soap_read__timg__GetImagingSettingsResponse(struct soap *soap, _timg__GetImagingSettingsResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetImagingSettingsResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetImagingSettingsResponse(struct soap *soap, const char *URL, _timg__GetImagingSettingsResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetImagingSettingsResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetImagingSettingsResponse(struct soap *soap, _timg__GetImagingSettingsResponse *p)
{
	if (::soap_read__timg__GetImagingSettingsResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetImagingSettings_DEFINED
#define SOAP_TYPE__timg__GetImagingSettings_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetImagingSettings(struct soap*, const char*, int, const _timg__GetImagingSettings *, const char*);
SOAP_FMAC3 _timg__GetImagingSettings * SOAP_FMAC4 soap_in__timg__GetImagingSettings(struct soap*, const char*, _timg__GetImagingSettings *, const char*);
SOAP_FMAC1 _timg__GetImagingSettings * SOAP_FMAC2 imageing_instantiate__timg__GetImagingSettings(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetImagingSettings * soap_new__timg__GetImagingSettings(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetImagingSettings(soap, n, NULL, NULL, NULL);
}

inline _timg__GetImagingSettings * soap_new_req__timg__GetImagingSettings(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__GetImagingSettings *_p = ::soap_new__timg__GetImagingSettings(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetImagingSettings::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline _timg__GetImagingSettings * soap_new_set__timg__GetImagingSettings(
	struct soap *soap,
	const std::string& VideoSourceToken)
{
	_timg__GetImagingSettings *_p = ::soap_new__timg__GetImagingSettings(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetImagingSettings::VideoSourceToken = VideoSourceToken;
	}
	return _p;
}

inline int soap_write__timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetImagingSettings", p->soap_type() == SOAP_TYPE__timg__GetImagingSettings ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetImagingSettings(struct soap *soap, const char *URL, _timg__GetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetImagingSettings", p->soap_type() == SOAP_TYPE__timg__GetImagingSettings ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetImagingSettings(struct soap *soap, const char *URL, _timg__GetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetImagingSettings", p->soap_type() == SOAP_TYPE__timg__GetImagingSettings ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetImagingSettings(struct soap *soap, const char *URL, _timg__GetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetImagingSettings", p->soap_type() == SOAP_TYPE__timg__GetImagingSettings ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetImagingSettings * SOAP_FMAC4 soap_get__timg__GetImagingSettings(struct soap*, _timg__GetImagingSettings *, const char*, const char*);

inline int soap_read__timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetImagingSettings(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetImagingSettings(struct soap *soap, const char *URL, _timg__GetImagingSettings *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetImagingSettings(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings *p)
{
	if (::soap_read__timg__GetImagingSettings(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetServiceCapabilitiesResponse_DEFINED
#define SOAP_TYPE__timg__GetServiceCapabilitiesResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetServiceCapabilitiesResponse(struct soap*, const char*, int, const _timg__GetServiceCapabilitiesResponse *, const char*);
SOAP_FMAC3 _timg__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__timg__GetServiceCapabilitiesResponse(struct soap*, const char*, _timg__GetServiceCapabilitiesResponse *, const char*);
SOAP_FMAC1 _timg__GetServiceCapabilitiesResponse * SOAP_FMAC2 imageing_instantiate__timg__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetServiceCapabilitiesResponse * soap_new__timg__GetServiceCapabilitiesResponse(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetServiceCapabilitiesResponse(soap, n, NULL, NULL, NULL);
}

inline _timg__GetServiceCapabilitiesResponse * soap_new_req__timg__GetServiceCapabilitiesResponse(
	struct soap *soap,
	timg__Capabilities *Capabilities)
{
	_timg__GetServiceCapabilitiesResponse *_p = ::soap_new__timg__GetServiceCapabilitiesResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetServiceCapabilitiesResponse::Capabilities = Capabilities;
	}
	return _p;
}

inline _timg__GetServiceCapabilitiesResponse * soap_new_set__timg__GetServiceCapabilitiesResponse(
	struct soap *soap,
	timg__Capabilities *Capabilities)
{
	_timg__GetServiceCapabilitiesResponse *_p = ::soap_new__timg__GetServiceCapabilitiesResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_timg__GetServiceCapabilitiesResponse::Capabilities = Capabilities;
	}
	return _p;
}

inline int soap_write__timg__GetServiceCapabilitiesResponse(struct soap *soap, _timg__GetServiceCapabilitiesResponse const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetServiceCapabilitiesResponse", p->soap_type() == SOAP_TYPE__timg__GetServiceCapabilitiesResponse ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *URL, _timg__GetServiceCapabilitiesResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetServiceCapabilitiesResponse", p->soap_type() == SOAP_TYPE__timg__GetServiceCapabilitiesResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *URL, _timg__GetServiceCapabilitiesResponse const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetServiceCapabilitiesResponse", p->soap_type() == SOAP_TYPE__timg__GetServiceCapabilitiesResponse ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *URL, _timg__GetServiceCapabilitiesResponse const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetServiceCapabilitiesResponse", p->soap_type() == SOAP_TYPE__timg__GetServiceCapabilitiesResponse ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__timg__GetServiceCapabilitiesResponse(struct soap*, _timg__GetServiceCapabilitiesResponse *, const char*, const char*);

inline int soap_read__timg__GetServiceCapabilitiesResponse(struct soap *soap, _timg__GetServiceCapabilitiesResponse *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetServiceCapabilitiesResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *URL, _timg__GetServiceCapabilitiesResponse *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetServiceCapabilitiesResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetServiceCapabilitiesResponse(struct soap *soap, _timg__GetServiceCapabilitiesResponse *p)
{
	if (::soap_read__timg__GetServiceCapabilitiesResponse(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__timg__GetServiceCapabilities_DEFINED
#define SOAP_TYPE__timg__GetServiceCapabilities_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetServiceCapabilities(struct soap*, const char*, int, const _timg__GetServiceCapabilities *, const char*);
SOAP_FMAC3 _timg__GetServiceCapabilities * SOAP_FMAC4 soap_in__timg__GetServiceCapabilities(struct soap*, const char*, _timg__GetServiceCapabilities *, const char*);
SOAP_FMAC1 _timg__GetServiceCapabilities * SOAP_FMAC2 imageing_instantiate__timg__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);

inline _timg__GetServiceCapabilities * soap_new__timg__GetServiceCapabilities(struct soap *soap, int n = -1)
{
	return imageing_instantiate__timg__GetServiceCapabilities(soap, n, NULL, NULL, NULL);
}

inline _timg__GetServiceCapabilities * soap_new_req__timg__GetServiceCapabilities(
	struct soap *soap)
{
	_timg__GetServiceCapabilities *_p = ::soap_new__timg__GetServiceCapabilities(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline _timg__GetServiceCapabilities * soap_new_set__timg__GetServiceCapabilities(
	struct soap *soap)
{
	_timg__GetServiceCapabilities *_p = ::soap_new__timg__GetServiceCapabilities(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline int soap_write__timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetServiceCapabilities", p->soap_type() == SOAP_TYPE__timg__GetServiceCapabilities ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__timg__GetServiceCapabilities(struct soap *soap, const char *URL, _timg__GetServiceCapabilities const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetServiceCapabilities", p->soap_type() == SOAP_TYPE__timg__GetServiceCapabilities ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__timg__GetServiceCapabilities(struct soap *soap, const char *URL, _timg__GetServiceCapabilities const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetServiceCapabilities", p->soap_type() == SOAP_TYPE__timg__GetServiceCapabilities ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__timg__GetServiceCapabilities(struct soap *soap, const char *URL, _timg__GetServiceCapabilities const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:GetServiceCapabilities", p->soap_type() == SOAP_TYPE__timg__GetServiceCapabilities ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 _timg__GetServiceCapabilities * SOAP_FMAC4 soap_get__timg__GetServiceCapabilities(struct soap*, _timg__GetServiceCapabilities *, const char*, const char*);

inline int soap_read__timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get__timg__GetServiceCapabilities(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__timg__GetServiceCapabilities(struct soap *soap, const char *URL, _timg__GetServiceCapabilities *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__timg__GetServiceCapabilities(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities *p)
{
	if (::soap_read__timg__GetServiceCapabilities(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_timg__ImagingPreset_DEFINED
#define SOAP_TYPE_timg__ImagingPreset_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_timg__ImagingPreset(struct soap*, const char*, int, const timg__ImagingPreset *, const char*);
SOAP_FMAC3 timg__ImagingPreset * SOAP_FMAC4 soap_in_timg__ImagingPreset(struct soap*, const char*, timg__ImagingPreset *, const char*);
SOAP_FMAC1 timg__ImagingPreset * SOAP_FMAC2 imageing_instantiate_timg__ImagingPreset(struct soap*, int, const char*, const char*, size_t*);

inline timg__ImagingPreset * soap_new_timg__ImagingPreset(struct soap *soap, int n = -1)
{
	return imageing_instantiate_timg__ImagingPreset(soap, n, NULL, NULL, NULL);
}

inline timg__ImagingPreset * soap_new_req_timg__ImagingPreset(
	struct soap *soap,
	const std::string& Name,
	const std::string& token,
	const std::string& type)
{
	timg__ImagingPreset *_p = ::soap_new_timg__ImagingPreset(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->timg__ImagingPreset::Name = Name;
		_p->timg__ImagingPreset::token = token;
		_p->timg__ImagingPreset::type = type;
	}
	return _p;
}

inline timg__ImagingPreset * soap_new_set_timg__ImagingPreset(
	struct soap *soap,
	const std::string& Name,
	const std::string& token,
	const std::string& type,
	char *__anyAttribute,
	char *__item__1)
{
	timg__ImagingPreset *_p = ::soap_new_timg__ImagingPreset(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->timg__ImagingPreset::Name = Name;
		_p->timg__ImagingPreset::token = token;
		_p->timg__ImagingPreset::type = type;
		_p->timg__ImagingPreset::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_timg__ImagingPreset(struct soap *soap, timg__ImagingPreset const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:ImagingPreset", p->soap_type() == SOAP_TYPE_timg__ImagingPreset ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_timg__ImagingPreset(struct soap *soap, const char *URL, timg__ImagingPreset const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:ImagingPreset", p->soap_type() == SOAP_TYPE_timg__ImagingPreset ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_timg__ImagingPreset(struct soap *soap, const char *URL, timg__ImagingPreset const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:ImagingPreset", p->soap_type() == SOAP_TYPE_timg__ImagingPreset ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_timg__ImagingPreset(struct soap *soap, const char *URL, timg__ImagingPreset const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:ImagingPreset", p->soap_type() == SOAP_TYPE_timg__ImagingPreset ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 timg__ImagingPreset * SOAP_FMAC4 soap_get_timg__ImagingPreset(struct soap*, timg__ImagingPreset *, const char*, const char*);

inline int soap_read_timg__ImagingPreset(struct soap *soap, timg__ImagingPreset *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_timg__ImagingPreset(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_timg__ImagingPreset(struct soap *soap, const char *URL, timg__ImagingPreset *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_timg__ImagingPreset(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_timg__ImagingPreset(struct soap *soap, timg__ImagingPreset *p)
{
	if (::soap_read_timg__ImagingPreset(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_timg__Capabilities_DEFINED
#define SOAP_TYPE_timg__Capabilities_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_timg__Capabilities(struct soap*, const char*, int, const timg__Capabilities *, const char*);
SOAP_FMAC3 timg__Capabilities * SOAP_FMAC4 soap_in_timg__Capabilities(struct soap*, const char*, timg__Capabilities *, const char*);
SOAP_FMAC1 timg__Capabilities * SOAP_FMAC2 imageing_instantiate_timg__Capabilities(struct soap*, int, const char*, const char*, size_t*);

inline timg__Capabilities * soap_new_timg__Capabilities(struct soap *soap, int n = -1)
{
	return imageing_instantiate_timg__Capabilities(soap, n, NULL, NULL, NULL);
}

inline timg__Capabilities * soap_new_req_timg__Capabilities(
	struct soap *soap)
{
	timg__Capabilities *_p = ::soap_new_timg__Capabilities(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline timg__Capabilities * soap_new_set_timg__Capabilities(
	struct soap *soap,
	const std::vector<char *> & __any,
	bool *ImageStabilization,
	bool *Presets,
	bool *AdaptablePreset,
	char *__anyAttribute,
	char *__item__1)
{
	timg__Capabilities *_p = ::soap_new_timg__Capabilities(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->timg__Capabilities::__any = __any;
		_p->timg__Capabilities::ImageStabilization = ImageStabilization;
		_p->timg__Capabilities::Presets = Presets;
		_p->timg__Capabilities::AdaptablePreset = AdaptablePreset;
		_p->timg__Capabilities::__anyAttribute = __anyAttribute;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_timg__Capabilities(struct soap *soap, timg__Capabilities const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:Capabilities", p->soap_type() == SOAP_TYPE_timg__Capabilities ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_timg__Capabilities(struct soap *soap, const char *URL, timg__Capabilities const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:Capabilities", p->soap_type() == SOAP_TYPE_timg__Capabilities ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_timg__Capabilities(struct soap *soap, const char *URL, timg__Capabilities const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:Capabilities", p->soap_type() == SOAP_TYPE_timg__Capabilities ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_timg__Capabilities(struct soap *soap, const char *URL, timg__Capabilities const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "timg:Capabilities", p->soap_type() == SOAP_TYPE_timg__Capabilities ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 timg__Capabilities * SOAP_FMAC4 soap_get_timg__Capabilities(struct soap*, timg__Capabilities *, const char*, const char*);

inline int soap_read_timg__Capabilities(struct soap *soap, timg__Capabilities *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_timg__Capabilities(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_timg__Capabilities(struct soap *soap, const char *URL, timg__Capabilities *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_timg__Capabilities(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_timg__Capabilities(struct soap *soap, timg__Capabilities *p)
{
	if (::soap_read_timg__Capabilities(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif
/* _xml__lang is a typedef synonym of std__string */

#ifndef SOAP_TYPE__xml__lang_DEFINED
#define SOAP_TYPE__xml__lang_DEFINED

#define soap_default__xml__lang soap_default_std__string


#define soap_serialize__xml__lang soap_serialize_std__string


#define soap__xml__lang2s(soap, a) ((a).c_str())

#define soap_out__xml__lang soap_out_std__string


#define soap_s2_xml__lang(soap, s, a) soap_s2stdchar((soap), (s), (a), 1, 0, -1, NULL)

#define soap_in__xml__lang soap_in_std__string


#define imageing_instantiate__xml__lang imageing_instantiate_std__string


#define soap_new__xml__lang soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xml__lang(struct soap*, const std::string *, const char*, const char*);

inline int soap_write__xml__lang(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put__xml__lang(soap, p, "xml:lang", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT__xml__lang(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__xml__lang(soap, p, "xml:lang", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__xml__lang(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__xml__lang(soap, p, "xml:lang", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__xml__lang(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__xml__lang(soap, p, "xml:lang", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__xml__lang soap_get_std__string


#define soap_read__xml__lang soap_read_std__string


#define soap_GET__xml__lang soap_GET_std__string


#define soap_POST_recv__xml__lang soap_POST_recv_std__string

#endif

#ifndef SOAP_TYPE_xsd__token___DEFINED
#define SOAP_TYPE_xsd__token___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token__(struct soap*, const char*, int, const xsd__token__ *, const char*);
SOAP_FMAC3 xsd__token__ * SOAP_FMAC4 soap_in_xsd__token__(struct soap*, const char*, xsd__token__ *, const char*);
SOAP_FMAC1 xsd__token__ * SOAP_FMAC2 imageing_instantiate_xsd__token__(struct soap*, int, const char*, const char*, size_t*);

inline xsd__token__ * soap_new_xsd__token__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__token__(soap, n, NULL, NULL, NULL);
}

inline xsd__token__ * soap_new_req_xsd__token__(
	struct soap *soap,
	const std::string& __item)
{
	xsd__token__ *_p = ::soap_new_xsd__token__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__token__::__item = __item;
	}
	return _p;
}

inline xsd__token__ * soap_new_set_xsd__token__(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	xsd__token__ *_p = ::soap_new_xsd__token__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__token__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__token__(struct soap *soap, xsd__token__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:token", p->soap_type() == SOAP_TYPE_xsd__token__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__token__(struct soap *soap, const char *URL, xsd__token__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:token", p->soap_type() == SOAP_TYPE_xsd__token__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__token__(struct soap *soap, const char *URL, xsd__token__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:token", p->soap_type() == SOAP_TYPE_xsd__token__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__token__(struct soap *soap, const char *URL, xsd__token__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:token", p->soap_type() == SOAP_TYPE_xsd__token__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__token__ * SOAP_FMAC4 soap_get_xsd__token__(struct soap*, xsd__token__ *, const char*, const char*);

inline int soap_read_xsd__token__(struct soap *soap, xsd__token__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__token__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__token__(struct soap *soap, const char *URL, xsd__token__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__token__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__token__(struct soap *soap, xsd__token__ *p)
{
	if (::soap_read_xsd__token__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__token_DEFINED
#define SOAP_TYPE_xsd__token_DEFINED

inline void soap_default_xsd__token(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap*, const std::string *);

#define soap_xsd__token2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__token(soap, s, a) soap_s2stdchar((soap), (s), (a), 5, 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__token(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_xsd__token imageing_instantiate_std__string


#define soap_new_xsd__token soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__token(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__token(soap, p, "xsd:token", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__token(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__token(soap, p, "xsd:token", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__token(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__token(soap, p, "xsd:token", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__token(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__token(soap, p, "xsd:token", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__token(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__token(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__token(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__token(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__token(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__token(struct soap *soap, std::string *p)
{
	if (::soap_read_xsd__token(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__string__DEFINED
#define SOAP_TYPE_xsd__string__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string_(struct soap*, const char*, int, const xsd__string_ *, const char*);
SOAP_FMAC3 xsd__string_ * SOAP_FMAC4 soap_in_xsd__string_(struct soap*, const char*, xsd__string_ *, const char*);
SOAP_FMAC1 xsd__string_ * SOAP_FMAC2 imageing_instantiate_xsd__string_(struct soap*, int, const char*, const char*, size_t*);

inline xsd__string_ * soap_new_xsd__string_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__string_(soap, n, NULL, NULL, NULL);
}

inline xsd__string_ * soap_new_req_xsd__string_(
	struct soap *soap,
	const std::string& __item)
{
	xsd__string_ *_p = ::soap_new_xsd__string_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__string_::__item = __item;
	}
	return _p;
}

inline xsd__string_ * soap_new_set_xsd__string_(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	xsd__string_ *_p = ::soap_new_xsd__string_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__string_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__string_(struct soap *soap, xsd__string_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:string", p->soap_type() == SOAP_TYPE_xsd__string_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__string_(struct soap *soap, const char *URL, xsd__string_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:string", p->soap_type() == SOAP_TYPE_xsd__string_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__string_(struct soap *soap, const char *URL, xsd__string_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:string", p->soap_type() == SOAP_TYPE_xsd__string_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__string_(struct soap *soap, const char *URL, xsd__string_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:string", p->soap_type() == SOAP_TYPE_xsd__string_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__string_ * SOAP_FMAC4 soap_get_xsd__string_(struct soap*, xsd__string_ *, const char*, const char*);

inline int soap_read_xsd__string_(struct soap *soap, xsd__string_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__string_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__string_(struct soap *soap, const char *URL, xsd__string_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__string_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__string_(struct soap *soap, xsd__string_ *p)
{
	if (::soap_read_xsd__string_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger___DEFINED
#define SOAP_TYPE_xsd__nonNegativeInteger___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger__(struct soap*, const char*, int, const xsd__nonNegativeInteger__ *, const char*);
SOAP_FMAC3 xsd__nonNegativeInteger__ * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger__(struct soap*, const char*, xsd__nonNegativeInteger__ *, const char*);
SOAP_FMAC1 xsd__nonNegativeInteger__ * SOAP_FMAC2 imageing_instantiate_xsd__nonNegativeInteger__(struct soap*, int, const char*, const char*, size_t*);

inline xsd__nonNegativeInteger__ * soap_new_xsd__nonNegativeInteger__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__nonNegativeInteger__(soap, n, NULL, NULL, NULL);
}

inline xsd__nonNegativeInteger__ * soap_new_req_xsd__nonNegativeInteger__(
	struct soap *soap,
	const std::string& __item)
{
	xsd__nonNegativeInteger__ *_p = ::soap_new_xsd__nonNegativeInteger__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__nonNegativeInteger__::__item = __item;
	}
	return _p;
}

inline xsd__nonNegativeInteger__ * soap_new_set_xsd__nonNegativeInteger__(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	xsd__nonNegativeInteger__ *_p = ::soap_new_xsd__nonNegativeInteger__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__nonNegativeInteger__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__nonNegativeInteger__(struct soap *soap, xsd__nonNegativeInteger__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:nonNegativeInteger", p->soap_type() == SOAP_TYPE_xsd__nonNegativeInteger__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__nonNegativeInteger__(struct soap *soap, const char *URL, xsd__nonNegativeInteger__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:nonNegativeInteger", p->soap_type() == SOAP_TYPE_xsd__nonNegativeInteger__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__nonNegativeInteger__(struct soap *soap, const char *URL, xsd__nonNegativeInteger__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:nonNegativeInteger", p->soap_type() == SOAP_TYPE_xsd__nonNegativeInteger__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__nonNegativeInteger__(struct soap *soap, const char *URL, xsd__nonNegativeInteger__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:nonNegativeInteger", p->soap_type() == SOAP_TYPE_xsd__nonNegativeInteger__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__nonNegativeInteger__ * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger__(struct soap*, xsd__nonNegativeInteger__ *, const char*, const char*);

inline int soap_read_xsd__nonNegativeInteger__(struct soap *soap, xsd__nonNegativeInteger__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__nonNegativeInteger__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__nonNegativeInteger__(struct soap *soap, const char *URL, xsd__nonNegativeInteger__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__nonNegativeInteger__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__nonNegativeInteger__(struct soap *soap, xsd__nonNegativeInteger__ *p)
{
	if (::soap_read_xsd__nonNegativeInteger__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger_DEFINED
#define SOAP_TYPE_xsd__nonNegativeInteger_DEFINED

inline void soap_default_xsd__nonNegativeInteger(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap*, const std::string *);

#define soap_xsd__nonNegativeInteger2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__nonNegativeInteger(soap, s, a) soap_s2stdchar((soap), (s), (a), 5, 0, -1, "\\+?\\d+")
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_xsd__nonNegativeInteger imageing_instantiate_std__string


#define soap_new_xsd__nonNegativeInteger soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__nonNegativeInteger(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__nonNegativeInteger(soap, p, "xsd:nonNegativeInteger", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__nonNegativeInteger(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__nonNegativeInteger(soap, p, "xsd:nonNegativeInteger", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__nonNegativeInteger(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__nonNegativeInteger(soap, p, "xsd:nonNegativeInteger", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__nonNegativeInteger(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__nonNegativeInteger(soap, p, "xsd:nonNegativeInteger", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__nonNegativeInteger(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__nonNegativeInteger(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__nonNegativeInteger(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__nonNegativeInteger(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__nonNegativeInteger(struct soap *soap, std::string *p)
{
	if (::soap_read_xsd__nonNegativeInteger(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__integer___DEFINED
#define SOAP_TYPE_xsd__integer___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer__(struct soap*, const char*, int, const xsd__integer__ *, const char*);
SOAP_FMAC3 xsd__integer__ * SOAP_FMAC4 soap_in_xsd__integer__(struct soap*, const char*, xsd__integer__ *, const char*);
SOAP_FMAC1 xsd__integer__ * SOAP_FMAC2 imageing_instantiate_xsd__integer__(struct soap*, int, const char*, const char*, size_t*);

inline xsd__integer__ * soap_new_xsd__integer__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__integer__(soap, n, NULL, NULL, NULL);
}

inline xsd__integer__ * soap_new_req_xsd__integer__(
	struct soap *soap,
	const std::string& __item)
{
	xsd__integer__ *_p = ::soap_new_xsd__integer__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__integer__::__item = __item;
	}
	return _p;
}

inline xsd__integer__ * soap_new_set_xsd__integer__(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	xsd__integer__ *_p = ::soap_new_xsd__integer__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__integer__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__integer__(struct soap *soap, xsd__integer__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:integer", p->soap_type() == SOAP_TYPE_xsd__integer__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__integer__(struct soap *soap, const char *URL, xsd__integer__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:integer", p->soap_type() == SOAP_TYPE_xsd__integer__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__integer__(struct soap *soap, const char *URL, xsd__integer__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:integer", p->soap_type() == SOAP_TYPE_xsd__integer__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__integer__(struct soap *soap, const char *URL, xsd__integer__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:integer", p->soap_type() == SOAP_TYPE_xsd__integer__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__integer__ * SOAP_FMAC4 soap_get_xsd__integer__(struct soap*, xsd__integer__ *, const char*, const char*);

inline int soap_read_xsd__integer__(struct soap *soap, xsd__integer__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__integer__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__integer__(struct soap *soap, const char *URL, xsd__integer__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__integer__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__integer__(struct soap *soap, xsd__integer__ *p)
{
	if (::soap_read_xsd__integer__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__integer_DEFINED
#define SOAP_TYPE_xsd__integer_DEFINED

inline void soap_default_xsd__integer(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap*, const std::string *);

#define soap_xsd__integer2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__integer(soap, s, a) soap_s2stdchar((soap), (s), (a), 5, 0, -1, "[-+]?\\d+")
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__integer(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_xsd__integer imageing_instantiate_std__string


#define soap_new_xsd__integer soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__integer(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__integer(soap, p, "xsd:integer", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__integer(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__integer(soap, p, "xsd:integer", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__integer(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__integer(soap, p, "xsd:integer", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__integer(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__integer(soap, p, "xsd:integer", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__integer(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__integer(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__integer(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__integer(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__integer(struct soap *soap, std::string *p)
{
	if (::soap_read_xsd__integer(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__int__DEFINED
#define SOAP_TYPE_xsd__int__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int_(struct soap*, const char*, int, const xsd__int_ *, const char*);
SOAP_FMAC3 xsd__int_ * SOAP_FMAC4 soap_in_xsd__int_(struct soap*, const char*, xsd__int_ *, const char*);
SOAP_FMAC1 xsd__int_ * SOAP_FMAC2 imageing_instantiate_xsd__int_(struct soap*, int, const char*, const char*, size_t*);

inline xsd__int_ * soap_new_xsd__int_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__int_(soap, n, NULL, NULL, NULL);
}

inline xsd__int_ * soap_new_req_xsd__int_(
	struct soap *soap,
	int __item)
{
	xsd__int_ *_p = ::soap_new_xsd__int_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__int_::__item = __item;
	}
	return _p;
}

inline xsd__int_ * soap_new_set_xsd__int_(
	struct soap *soap,
	int __item,
	char *__item__1)
{
	xsd__int_ *_p = ::soap_new_xsd__int_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__int_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__int_(struct soap *soap, xsd__int_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:int", p->soap_type() == SOAP_TYPE_xsd__int_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__int_(struct soap *soap, const char *URL, xsd__int_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:int", p->soap_type() == SOAP_TYPE_xsd__int_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__int_(struct soap *soap, const char *URL, xsd__int_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:int", p->soap_type() == SOAP_TYPE_xsd__int_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__int_(struct soap *soap, const char *URL, xsd__int_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:int", p->soap_type() == SOAP_TYPE_xsd__int_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__int_ * SOAP_FMAC4 soap_get_xsd__int_(struct soap*, xsd__int_ *, const char*, const char*);

inline int soap_read_xsd__int_(struct soap *soap, xsd__int_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__int_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__int_(struct soap *soap, const char *URL, xsd__int_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__int_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__int_(struct soap *soap, xsd__int_ *p)
{
	if (::soap_read_xsd__int_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__hexBinary___DEFINED
#define SOAP_TYPE_xsd__hexBinary___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary__(struct soap*, const char*, int, const xsd__hexBinary__ *, const char*);
SOAP_FMAC3 xsd__hexBinary__ * SOAP_FMAC4 soap_in_xsd__hexBinary__(struct soap*, const char*, xsd__hexBinary__ *, const char*);
SOAP_FMAC1 xsd__hexBinary__ * SOAP_FMAC2 imageing_instantiate_xsd__hexBinary__(struct soap*, int, const char*, const char*, size_t*);

inline xsd__hexBinary__ * soap_new_xsd__hexBinary__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__hexBinary__(soap, n, NULL, NULL, NULL);
}

inline xsd__hexBinary__ * soap_new_req_xsd__hexBinary__(
	struct soap *soap,
	const xsd__hexBinary& __item)
{
	xsd__hexBinary__ *_p = ::soap_new_xsd__hexBinary__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__hexBinary__::__item = __item;
	}
	return _p;
}

inline xsd__hexBinary__ * soap_new_set_xsd__hexBinary__(
	struct soap *soap,
	const xsd__hexBinary& __item,
	char *__item__1)
{
	xsd__hexBinary__ *_p = ::soap_new_xsd__hexBinary__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__hexBinary__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__hexBinary__(struct soap *soap, xsd__hexBinary__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:hexBinary", p->soap_type() == SOAP_TYPE_xsd__hexBinary__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__hexBinary__(struct soap *soap, const char *URL, xsd__hexBinary__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:hexBinary", p->soap_type() == SOAP_TYPE_xsd__hexBinary__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__hexBinary__(struct soap *soap, const char *URL, xsd__hexBinary__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:hexBinary", p->soap_type() == SOAP_TYPE_xsd__hexBinary__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__hexBinary__(struct soap *soap, const char *URL, xsd__hexBinary__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:hexBinary", p->soap_type() == SOAP_TYPE_xsd__hexBinary__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__hexBinary__ * SOAP_FMAC4 soap_get_xsd__hexBinary__(struct soap*, xsd__hexBinary__ *, const char*, const char*);

inline int soap_read_xsd__hexBinary__(struct soap *soap, xsd__hexBinary__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__hexBinary__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__hexBinary__(struct soap *soap, const char *URL, xsd__hexBinary__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__hexBinary__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__hexBinary__(struct soap *soap, xsd__hexBinary__ *p)
{
	if (::soap_read_xsd__hexBinary__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__float__DEFINED
#define SOAP_TYPE_xsd__float__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__float_(struct soap*, const char*, int, const xsd__float_ *, const char*);
SOAP_FMAC3 xsd__float_ * SOAP_FMAC4 soap_in_xsd__float_(struct soap*, const char*, xsd__float_ *, const char*);
SOAP_FMAC1 xsd__float_ * SOAP_FMAC2 imageing_instantiate_xsd__float_(struct soap*, int, const char*, const char*, size_t*);

inline xsd__float_ * soap_new_xsd__float_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__float_(soap, n, NULL, NULL, NULL);
}

inline xsd__float_ * soap_new_req_xsd__float_(
	struct soap *soap,
	float __item)
{
	xsd__float_ *_p = ::soap_new_xsd__float_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__float_::__item = __item;
	}
	return _p;
}

inline xsd__float_ * soap_new_set_xsd__float_(
	struct soap *soap,
	float __item,
	char *__item__1)
{
	xsd__float_ *_p = ::soap_new_xsd__float_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__float_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__float_(struct soap *soap, xsd__float_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:float", p->soap_type() == SOAP_TYPE_xsd__float_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__float_(struct soap *soap, const char *URL, xsd__float_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:float", p->soap_type() == SOAP_TYPE_xsd__float_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__float_(struct soap *soap, const char *URL, xsd__float_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:float", p->soap_type() == SOAP_TYPE_xsd__float_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__float_(struct soap *soap, const char *URL, xsd__float_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:float", p->soap_type() == SOAP_TYPE_xsd__float_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__float_ * SOAP_FMAC4 soap_get_xsd__float_(struct soap*, xsd__float_ *, const char*, const char*);

inline int soap_read_xsd__float_(struct soap *soap, xsd__float_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__float_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__float_(struct soap *soap, const char *URL, xsd__float_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__float_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__float_(struct soap *soap, xsd__float_ *p)
{
	if (::soap_read_xsd__float_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__duration___DEFINED
#define SOAP_TYPE_xsd__duration___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration__(struct soap*, const char*, int, const xsd__duration__ *, const char*);
SOAP_FMAC3 xsd__duration__ * SOAP_FMAC4 soap_in_xsd__duration__(struct soap*, const char*, xsd__duration__ *, const char*);
SOAP_FMAC1 xsd__duration__ * SOAP_FMAC2 imageing_instantiate_xsd__duration__(struct soap*, int, const char*, const char*, size_t*);

inline xsd__duration__ * soap_new_xsd__duration__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__duration__(soap, n, NULL, NULL, NULL);
}

inline xsd__duration__ * soap_new_req_xsd__duration__(
	struct soap *soap,
	const std::string& __item)
{
	xsd__duration__ *_p = ::soap_new_xsd__duration__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__duration__::__item = __item;
	}
	return _p;
}

inline xsd__duration__ * soap_new_set_xsd__duration__(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	xsd__duration__ *_p = ::soap_new_xsd__duration__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__duration__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__duration__(struct soap *soap, xsd__duration__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:duration", p->soap_type() == SOAP_TYPE_xsd__duration__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__duration__(struct soap *soap, const char *URL, xsd__duration__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:duration", p->soap_type() == SOAP_TYPE_xsd__duration__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__duration__(struct soap *soap, const char *URL, xsd__duration__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:duration", p->soap_type() == SOAP_TYPE_xsd__duration__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__duration__(struct soap *soap, const char *URL, xsd__duration__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:duration", p->soap_type() == SOAP_TYPE_xsd__duration__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__duration__ * SOAP_FMAC4 soap_get_xsd__duration__(struct soap*, xsd__duration__ *, const char*, const char*);

inline int soap_read_xsd__duration__(struct soap *soap, xsd__duration__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__duration__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__duration__(struct soap *soap, const char *URL, xsd__duration__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__duration__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__duration__(struct soap *soap, xsd__duration__ *p)
{
	if (::soap_read_xsd__duration__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__duration_DEFINED
#define SOAP_TYPE_xsd__duration_DEFINED

inline void soap_default_xsd__duration(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap*, const std::string *);

#define soap_xsd__duration2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__duration(soap, s, a) soap_s2stdchar((soap), (s), (a), 5, 0, -1, "[-+]?P(\\d+Y)?(\\d+M)?(\\d+D)?(T(\\d+H)?(\\d+M)?(\\d+(\\.\\d*)?S)?)?")
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__duration(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_xsd__duration imageing_instantiate_std__string


#define soap_new_xsd__duration soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__duration(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__duration(soap, p, "xsd:duration", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__duration(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__duration(soap, p, "xsd:duration", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__duration(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__duration(soap, p, "xsd:duration", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__duration(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__duration(soap, p, "xsd:duration", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__duration(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__duration(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__duration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__duration(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__duration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__duration(struct soap *soap, std::string *p)
{
	if (::soap_read_xsd__duration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__double__DEFINED
#define SOAP_TYPE_xsd__double__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double_(struct soap*, const char*, int, const xsd__double_ *, const char*);
SOAP_FMAC3 xsd__double_ * SOAP_FMAC4 soap_in_xsd__double_(struct soap*, const char*, xsd__double_ *, const char*);
SOAP_FMAC1 xsd__double_ * SOAP_FMAC2 imageing_instantiate_xsd__double_(struct soap*, int, const char*, const char*, size_t*);

inline xsd__double_ * soap_new_xsd__double_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__double_(soap, n, NULL, NULL, NULL);
}

inline xsd__double_ * soap_new_req_xsd__double_(
	struct soap *soap,
	double __item)
{
	xsd__double_ *_p = ::soap_new_xsd__double_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__double_::__item = __item;
	}
	return _p;
}

inline xsd__double_ * soap_new_set_xsd__double_(
	struct soap *soap,
	double __item,
	char *__item__1)
{
	xsd__double_ *_p = ::soap_new_xsd__double_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__double_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__double_(struct soap *soap, xsd__double_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:double", p->soap_type() == SOAP_TYPE_xsd__double_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__double_(struct soap *soap, const char *URL, xsd__double_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:double", p->soap_type() == SOAP_TYPE_xsd__double_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__double_(struct soap *soap, const char *URL, xsd__double_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:double", p->soap_type() == SOAP_TYPE_xsd__double_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__double_(struct soap *soap, const char *URL, xsd__double_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:double", p->soap_type() == SOAP_TYPE_xsd__double_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__double_ * SOAP_FMAC4 soap_get_xsd__double_(struct soap*, xsd__double_ *, const char*, const char*);

inline int soap_read_xsd__double_(struct soap *soap, xsd__double_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__double_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__double_(struct soap *soap, const char *URL, xsd__double_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__double_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__double_(struct soap *soap, xsd__double_ *p)
{
	if (::soap_read_xsd__double_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__dateTime__DEFINED
#define SOAP_TYPE_xsd__dateTime__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime_(struct soap*, const char*, int, const xsd__dateTime_ *, const char*);
SOAP_FMAC3 xsd__dateTime_ * SOAP_FMAC4 soap_in_xsd__dateTime_(struct soap*, const char*, xsd__dateTime_ *, const char*);
SOAP_FMAC1 xsd__dateTime_ * SOAP_FMAC2 imageing_instantiate_xsd__dateTime_(struct soap*, int, const char*, const char*, size_t*);

inline xsd__dateTime_ * soap_new_xsd__dateTime_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__dateTime_(soap, n, NULL, NULL, NULL);
}

inline xsd__dateTime_ * soap_new_req_xsd__dateTime_(
	struct soap *soap,
	time_t __item)
{
	xsd__dateTime_ *_p = ::soap_new_xsd__dateTime_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__dateTime_::__item = __item;
	}
	return _p;
}

inline xsd__dateTime_ * soap_new_set_xsd__dateTime_(
	struct soap *soap,
	time_t __item,
	char *__item__1)
{
	xsd__dateTime_ *_p = ::soap_new_xsd__dateTime_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__dateTime_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__dateTime_(struct soap *soap, xsd__dateTime_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:dateTime", p->soap_type() == SOAP_TYPE_xsd__dateTime_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__dateTime_(struct soap *soap, const char *URL, xsd__dateTime_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:dateTime", p->soap_type() == SOAP_TYPE_xsd__dateTime_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__dateTime_(struct soap *soap, const char *URL, xsd__dateTime_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:dateTime", p->soap_type() == SOAP_TYPE_xsd__dateTime_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__dateTime_(struct soap *soap, const char *URL, xsd__dateTime_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:dateTime", p->soap_type() == SOAP_TYPE_xsd__dateTime_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__dateTime_ * SOAP_FMAC4 soap_get_xsd__dateTime_(struct soap*, xsd__dateTime_ *, const char*, const char*);

inline int soap_read_xsd__dateTime_(struct soap *soap, xsd__dateTime_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__dateTime_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__dateTime_(struct soap *soap, const char *URL, xsd__dateTime_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__dateTime_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__dateTime_(struct soap *soap, xsd__dateTime_ *p)
{
	if (::soap_read_xsd__dateTime_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__boolean__DEFINED
#define SOAP_TYPE_xsd__boolean__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean_(struct soap*, const char*, int, const xsd__boolean_ *, const char*);
SOAP_FMAC3 xsd__boolean_ * SOAP_FMAC4 soap_in_xsd__boolean_(struct soap*, const char*, xsd__boolean_ *, const char*);
SOAP_FMAC1 xsd__boolean_ * SOAP_FMAC2 imageing_instantiate_xsd__boolean_(struct soap*, int, const char*, const char*, size_t*);

inline xsd__boolean_ * soap_new_xsd__boolean_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__boolean_(soap, n, NULL, NULL, NULL);
}

inline xsd__boolean_ * soap_new_req_xsd__boolean_(
	struct soap *soap,
	bool __item)
{
	xsd__boolean_ *_p = ::soap_new_xsd__boolean_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__boolean_::__item = __item;
	}
	return _p;
}

inline xsd__boolean_ * soap_new_set_xsd__boolean_(
	struct soap *soap,
	bool __item,
	char *__item__1)
{
	xsd__boolean_ *_p = ::soap_new_xsd__boolean_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__boolean_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__boolean_(struct soap *soap, xsd__boolean_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:boolean", p->soap_type() == SOAP_TYPE_xsd__boolean_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__boolean_(struct soap *soap, const char *URL, xsd__boolean_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:boolean", p->soap_type() == SOAP_TYPE_xsd__boolean_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__boolean_(struct soap *soap, const char *URL, xsd__boolean_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:boolean", p->soap_type() == SOAP_TYPE_xsd__boolean_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__boolean_(struct soap *soap, const char *URL, xsd__boolean_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:boolean", p->soap_type() == SOAP_TYPE_xsd__boolean_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__boolean_ * SOAP_FMAC4 soap_get_xsd__boolean_(struct soap*, xsd__boolean_ *, const char*, const char*);

inline int soap_read_xsd__boolean_(struct soap *soap, xsd__boolean_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__boolean_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__boolean_(struct soap *soap, const char *URL, xsd__boolean_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__boolean_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__boolean_(struct soap *soap, xsd__boolean_ *p)
{
	if (::soap_read_xsd__boolean_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__base64Binary___DEFINED
#define SOAP_TYPE_xsd__base64Binary___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary__(struct soap*, const char*, int, const xsd__base64Binary__ *, const char*);
SOAP_FMAC3 xsd__base64Binary__ * SOAP_FMAC4 soap_in_xsd__base64Binary__(struct soap*, const char*, xsd__base64Binary__ *, const char*);
SOAP_FMAC1 xsd__base64Binary__ * SOAP_FMAC2 imageing_instantiate_xsd__base64Binary__(struct soap*, int, const char*, const char*, size_t*);

inline xsd__base64Binary__ * soap_new_xsd__base64Binary__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__base64Binary__(soap, n, NULL, NULL, NULL);
}

inline xsd__base64Binary__ * soap_new_req_xsd__base64Binary__(
	struct soap *soap,
	const xsd__base64Binary& __item)
{
	xsd__base64Binary__ *_p = ::soap_new_xsd__base64Binary__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__base64Binary__::__item = __item;
	}
	return _p;
}

inline xsd__base64Binary__ * soap_new_set_xsd__base64Binary__(
	struct soap *soap,
	const xsd__base64Binary& __item,
	char *__item__1)
{
	xsd__base64Binary__ *_p = ::soap_new_xsd__base64Binary__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__base64Binary__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__base64Binary__(struct soap *soap, xsd__base64Binary__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:base64Binary", p->soap_type() == SOAP_TYPE_xsd__base64Binary__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__base64Binary__(struct soap *soap, const char *URL, xsd__base64Binary__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:base64Binary", p->soap_type() == SOAP_TYPE_xsd__base64Binary__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__base64Binary__(struct soap *soap, const char *URL, xsd__base64Binary__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:base64Binary", p->soap_type() == SOAP_TYPE_xsd__base64Binary__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__base64Binary__(struct soap *soap, const char *URL, xsd__base64Binary__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:base64Binary", p->soap_type() == SOAP_TYPE_xsd__base64Binary__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__base64Binary__ * SOAP_FMAC4 soap_get_xsd__base64Binary__(struct soap*, xsd__base64Binary__ *, const char*, const char*);

inline int soap_read_xsd__base64Binary__(struct soap *soap, xsd__base64Binary__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__base64Binary__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__base64Binary__(struct soap *soap, const char *URL, xsd__base64Binary__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__base64Binary__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__base64Binary__(struct soap *soap, xsd__base64Binary__ *p)
{
	if (::soap_read_xsd__base64Binary__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__anyURI___DEFINED
#define SOAP_TYPE_xsd__anyURI___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI__(struct soap*, const char*, int, const xsd__anyURI__ *, const char*);
SOAP_FMAC3 xsd__anyURI__ * SOAP_FMAC4 soap_in_xsd__anyURI__(struct soap*, const char*, xsd__anyURI__ *, const char*);
SOAP_FMAC1 xsd__anyURI__ * SOAP_FMAC2 imageing_instantiate_xsd__anyURI__(struct soap*, int, const char*, const char*, size_t*);

inline xsd__anyURI__ * soap_new_xsd__anyURI__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__anyURI__(soap, n, NULL, NULL, NULL);
}

inline xsd__anyURI__ * soap_new_req_xsd__anyURI__(
	struct soap *soap,
	const std::string& __item)
{
	xsd__anyURI__ *_p = ::soap_new_xsd__anyURI__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__anyURI__::__item = __item;
	}
	return _p;
}

inline xsd__anyURI__ * soap_new_set_xsd__anyURI__(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	xsd__anyURI__ *_p = ::soap_new_xsd__anyURI__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__anyURI__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__anyURI__(struct soap *soap, xsd__anyURI__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:anyURI", p->soap_type() == SOAP_TYPE_xsd__anyURI__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__anyURI__(struct soap *soap, const char *URL, xsd__anyURI__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:anyURI", p->soap_type() == SOAP_TYPE_xsd__anyURI__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__anyURI__(struct soap *soap, const char *URL, xsd__anyURI__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:anyURI", p->soap_type() == SOAP_TYPE_xsd__anyURI__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__anyURI__(struct soap *soap, const char *URL, xsd__anyURI__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:anyURI", p->soap_type() == SOAP_TYPE_xsd__anyURI__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__anyURI__ * SOAP_FMAC4 soap_get_xsd__anyURI__(struct soap*, xsd__anyURI__ *, const char*, const char*);

inline int soap_read_xsd__anyURI__(struct soap *soap, xsd__anyURI__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__anyURI__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__anyURI__(struct soap *soap, const char *URL, xsd__anyURI__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__anyURI__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__anyURI__(struct soap *soap, xsd__anyURI__ *p)
{
	if (::soap_read_xsd__anyURI__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__anyURI_DEFINED
#define SOAP_TYPE_xsd__anyURI_DEFINED

inline void soap_default_xsd__anyURI(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap*, const std::string *);

#define soap_xsd__anyURI2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__anyURI(soap, s, a) soap_s2stdchar((soap), (s), (a), 4, 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_xsd__anyURI imageing_instantiate_std__string


#define soap_new_xsd__anyURI soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__anyURI(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__anyURI(soap, p, "xsd:anyURI", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__anyURI(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__anyURI(soap, p, "xsd:anyURI", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__anyURI(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__anyURI(soap, p, "xsd:anyURI", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__anyURI(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__anyURI(soap, p, "xsd:anyURI", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__anyURI(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__anyURI(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__anyURI(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__anyURI(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__anyURI(struct soap *soap, std::string *p)
{
	if (::soap_read_xsd__anyURI(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__anySimpleType___DEFINED
#define SOAP_TYPE_xsd__anySimpleType___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType__(struct soap*, const char*, int, const xsd__anySimpleType__ *, const char*);
SOAP_FMAC3 xsd__anySimpleType__ * SOAP_FMAC4 soap_in_xsd__anySimpleType__(struct soap*, const char*, xsd__anySimpleType__ *, const char*);
SOAP_FMAC1 xsd__anySimpleType__ * SOAP_FMAC2 imageing_instantiate_xsd__anySimpleType__(struct soap*, int, const char*, const char*, size_t*);

inline xsd__anySimpleType__ * soap_new_xsd__anySimpleType__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__anySimpleType__(soap, n, NULL, NULL, NULL);
}

inline xsd__anySimpleType__ * soap_new_req_xsd__anySimpleType__(
	struct soap *soap,
	const std::string& __item)
{
	xsd__anySimpleType__ *_p = ::soap_new_xsd__anySimpleType__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__anySimpleType__::__item = __item;
	}
	return _p;
}

inline xsd__anySimpleType__ * soap_new_set_xsd__anySimpleType__(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	xsd__anySimpleType__ *_p = ::soap_new_xsd__anySimpleType__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__anySimpleType__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__anySimpleType__(struct soap *soap, xsd__anySimpleType__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:anySimpleType", p->soap_type() == SOAP_TYPE_xsd__anySimpleType__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__anySimpleType__(struct soap *soap, const char *URL, xsd__anySimpleType__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:anySimpleType", p->soap_type() == SOAP_TYPE_xsd__anySimpleType__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__anySimpleType__(struct soap *soap, const char *URL, xsd__anySimpleType__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:anySimpleType", p->soap_type() == SOAP_TYPE_xsd__anySimpleType__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__anySimpleType__(struct soap *soap, const char *URL, xsd__anySimpleType__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:anySimpleType", p->soap_type() == SOAP_TYPE_xsd__anySimpleType__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__anySimpleType__ * SOAP_FMAC4 soap_get_xsd__anySimpleType__(struct soap*, xsd__anySimpleType__ *, const char*, const char*);

inline int soap_read_xsd__anySimpleType__(struct soap *soap, xsd__anySimpleType__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__anySimpleType__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__anySimpleType__(struct soap *soap, const char *URL, xsd__anySimpleType__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__anySimpleType__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__anySimpleType__(struct soap *soap, xsd__anySimpleType__ *p)
{
	if (::soap_read_xsd__anySimpleType__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__anySimpleType_DEFINED
#define SOAP_TYPE_xsd__anySimpleType_DEFINED

inline void soap_default_xsd__anySimpleType(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anySimpleType(struct soap*, const std::string *);

#define soap_xsd__anySimpleType2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__anySimpleType(soap, s, a) soap_s2stdchar((soap), (s), (a), 1, 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_xsd__anySimpleType imageing_instantiate_std__string


#define soap_new_xsd__anySimpleType soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anySimpleType(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__anySimpleType(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__anySimpleType(soap, p, "xsd:anySimpleType", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__anySimpleType(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__anySimpleType(soap, p, "xsd:anySimpleType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__anySimpleType(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__anySimpleType(soap, p, "xsd:anySimpleType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__anySimpleType(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__anySimpleType(soap, p, "xsd:anySimpleType", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__anySimpleType(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__anySimpleType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__anySimpleType(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__anySimpleType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__anySimpleType(struct soap *soap, std::string *p)
{
	if (::soap_read_xsd__anySimpleType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__QName___DEFINED
#define SOAP_TYPE_xsd__QName___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName__(struct soap*, const char*, int, const xsd__QName__ *, const char*);
SOAP_FMAC3 xsd__QName__ * SOAP_FMAC4 soap_in_xsd__QName__(struct soap*, const char*, xsd__QName__ *, const char*);
SOAP_FMAC1 xsd__QName__ * SOAP_FMAC2 imageing_instantiate_xsd__QName__(struct soap*, int, const char*, const char*, size_t*);

inline xsd__QName__ * soap_new_xsd__QName__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__QName__(soap, n, NULL, NULL, NULL);
}

inline xsd__QName__ * soap_new_req_xsd__QName__(
	struct soap *soap,
	const std::string& __item)
{
	xsd__QName__ *_p = ::soap_new_xsd__QName__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__QName__::__item = __item;
	}
	return _p;
}

inline xsd__QName__ * soap_new_set_xsd__QName__(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	xsd__QName__ *_p = ::soap_new_xsd__QName__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__QName__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__QName__(struct soap *soap, xsd__QName__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:QName", p->soap_type() == SOAP_TYPE_xsd__QName__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__QName__(struct soap *soap, const char *URL, xsd__QName__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:QName", p->soap_type() == SOAP_TYPE_xsd__QName__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__QName__(struct soap *soap, const char *URL, xsd__QName__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:QName", p->soap_type() == SOAP_TYPE_xsd__QName__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__QName__(struct soap *soap, const char *URL, xsd__QName__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:QName", p->soap_type() == SOAP_TYPE_xsd__QName__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__QName__ * SOAP_FMAC4 soap_get_xsd__QName__(struct soap*, xsd__QName__ *, const char*, const char*);

inline int soap_read_xsd__QName__(struct soap *soap, xsd__QName__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__QName__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__QName__(struct soap *soap, const char *URL, xsd__QName__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__QName__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__QName__(struct soap *soap, xsd__QName__ *p)
{
	if (::soap_read_xsd__QName__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__NCName___DEFINED
#define SOAP_TYPE_xsd__NCName___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName__(struct soap*, const char*, int, const xsd__NCName__ *, const char*);
SOAP_FMAC3 xsd__NCName__ * SOAP_FMAC4 soap_in_xsd__NCName__(struct soap*, const char*, xsd__NCName__ *, const char*);
SOAP_FMAC1 xsd__NCName__ * SOAP_FMAC2 imageing_instantiate_xsd__NCName__(struct soap*, int, const char*, const char*, size_t*);

inline xsd__NCName__ * soap_new_xsd__NCName__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__NCName__(soap, n, NULL, NULL, NULL);
}

inline xsd__NCName__ * soap_new_req_xsd__NCName__(
	struct soap *soap,
	const std::string& __item)
{
	xsd__NCName__ *_p = ::soap_new_xsd__NCName__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__NCName__::__item = __item;
	}
	return _p;
}

inline xsd__NCName__ * soap_new_set_xsd__NCName__(
	struct soap *soap,
	const std::string& __item,
	char *__item__1)
{
	xsd__NCName__ *_p = ::soap_new_xsd__NCName__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__NCName__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_xsd__NCName__(struct soap *soap, xsd__NCName__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:NCName", p->soap_type() == SOAP_TYPE_xsd__NCName__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__NCName__(struct soap *soap, const char *URL, xsd__NCName__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:NCName", p->soap_type() == SOAP_TYPE_xsd__NCName__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__NCName__(struct soap *soap, const char *URL, xsd__NCName__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:NCName", p->soap_type() == SOAP_TYPE_xsd__NCName__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__NCName__(struct soap *soap, const char *URL, xsd__NCName__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:NCName", p->soap_type() == SOAP_TYPE_xsd__NCName__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__NCName__ * SOAP_FMAC4 soap_get_xsd__NCName__(struct soap*, xsd__NCName__ *, const char*, const char*);

inline int soap_read_xsd__NCName__(struct soap *soap, xsd__NCName__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__NCName__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__NCName__(struct soap *soap, const char *URL, xsd__NCName__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__NCName__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__NCName__(struct soap *soap, xsd__NCName__ *p)
{
	if (::soap_read_xsd__NCName__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__NCName_DEFINED
#define SOAP_TYPE_xsd__NCName_DEFINED

inline void soap_default_xsd__NCName(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap*, const std::string *);

#define soap_xsd__NCName2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__NCName(soap, s, a) soap_s2stdchar((soap), (s), (a), 5, 0, -1, "[\\i-[:]][\\c-[:]]*")
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__NCName(struct soap*, const char*, std::string*, const char*);

#define imageing_instantiate_xsd__NCName imageing_instantiate_std__string


#define soap_new_xsd__NCName soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__NCName(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__NCName(soap, p, "xsd:NCName", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__NCName(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__NCName(soap, p, "xsd:NCName", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__NCName(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__NCName(soap, p, "xsd:NCName", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__NCName(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__NCName(soap, p, "xsd:NCName", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NCName(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__NCName(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__NCName(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__NCName(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__NCName(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__NCName(struct soap *soap, std::string *p)
{
	if (::soap_read_xsd__NCName(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault__DEFINED
#define SOAP_TYPE_SOAP_ENV__Fault__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault_(struct soap*, const char*, int, const SOAP_ENV__Fault_ *, const char*);
SOAP_FMAC3 SOAP_ENV__Fault_ * SOAP_FMAC4 soap_in_SOAP_ENV__Fault_(struct soap*, const char*, SOAP_ENV__Fault_ *, const char*);
SOAP_FMAC1 SOAP_ENV__Fault_ * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Fault_(struct soap*, int, const char*, const char*, size_t*);

inline SOAP_ENV__Fault_ * soap_new_SOAP_ENV__Fault_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_SOAP_ENV__Fault_(soap, n, NULL, NULL, NULL);
}

inline SOAP_ENV__Fault_ * soap_new_req_SOAP_ENV__Fault_(
	struct soap *soap,
	const struct SOAP_ENV__Fault& __item)
{
	SOAP_ENV__Fault_ *_p = ::soap_new_SOAP_ENV__Fault_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->SOAP_ENV__Fault_::__item = __item;
	}
	return _p;
}

inline SOAP_ENV__Fault_ * soap_new_set_SOAP_ENV__Fault_(
	struct soap *soap,
	const struct SOAP_ENV__Fault& __item,
	char *__item__1)
{
	SOAP_ENV__Fault_ *_p = ::soap_new_SOAP_ENV__Fault_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->SOAP_ENV__Fault_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_SOAP_ENV__Fault_(struct soap *soap, SOAP_ENV__Fault_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "SOAP-ENV:Fault", p->soap_type() == SOAP_TYPE_SOAP_ENV__Fault_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Fault_(struct soap *soap, const char *URL, SOAP_ENV__Fault_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "SOAP-ENV:Fault", p->soap_type() == SOAP_TYPE_SOAP_ENV__Fault_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_SOAP_ENV__Fault_(struct soap *soap, const char *URL, SOAP_ENV__Fault_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "SOAP-ENV:Fault", p->soap_type() == SOAP_TYPE_SOAP_ENV__Fault_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Fault_(struct soap *soap, const char *URL, SOAP_ENV__Fault_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "SOAP-ENV:Fault", p->soap_type() == SOAP_TYPE_SOAP_ENV__Fault_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 SOAP_ENV__Fault_ * SOAP_FMAC4 soap_get_SOAP_ENV__Fault_(struct soap*, SOAP_ENV__Fault_ *, const char*, const char*);

inline int soap_read_SOAP_ENV__Fault_(struct soap *soap, SOAP_ENV__Fault_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_SOAP_ENV__Fault_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Fault_(struct soap *soap, const char *URL, SOAP_ENV__Fault_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_SOAP_ENV__Fault_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_SOAP_ENV__Fault_(struct soap *soap, SOAP_ENV__Fault_ *p)
{
	if (::soap_read_SOAP_ENV__Fault_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Envelope__DEFINED
#define SOAP_TYPE_SOAP_ENV__Envelope__DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Envelope_(struct soap*, const char*, int, const SOAP_ENV__Envelope_ *, const char*);
SOAP_FMAC3 SOAP_ENV__Envelope_ * SOAP_FMAC4 soap_in_SOAP_ENV__Envelope_(struct soap*, const char*, SOAP_ENV__Envelope_ *, const char*);
SOAP_FMAC1 SOAP_ENV__Envelope_ * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Envelope_(struct soap*, int, const char*, const char*, size_t*);

inline SOAP_ENV__Envelope_ * soap_new_SOAP_ENV__Envelope_(struct soap *soap, int n = -1)
{
	return imageing_instantiate_SOAP_ENV__Envelope_(soap, n, NULL, NULL, NULL);
}

inline SOAP_ENV__Envelope_ * soap_new_req_SOAP_ENV__Envelope_(
	struct soap *soap,
	const struct SOAP_ENV__Envelope& __item)
{
	SOAP_ENV__Envelope_ *_p = ::soap_new_SOAP_ENV__Envelope_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->SOAP_ENV__Envelope_::__item = __item;
	}
	return _p;
}

inline SOAP_ENV__Envelope_ * soap_new_set_SOAP_ENV__Envelope_(
	struct soap *soap,
	const struct SOAP_ENV__Envelope& __item,
	char *__item__1)
{
	SOAP_ENV__Envelope_ *_p = ::soap_new_SOAP_ENV__Envelope_(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->SOAP_ENV__Envelope_::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_SOAP_ENV__Envelope_(struct soap *soap, SOAP_ENV__Envelope_ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "SOAP-ENV:Envelope", p->soap_type() == SOAP_TYPE_SOAP_ENV__Envelope_ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Envelope_(struct soap *soap, const char *URL, SOAP_ENV__Envelope_ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "SOAP-ENV:Envelope", p->soap_type() == SOAP_TYPE_SOAP_ENV__Envelope_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_SOAP_ENV__Envelope_(struct soap *soap, const char *URL, SOAP_ENV__Envelope_ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "SOAP-ENV:Envelope", p->soap_type() == SOAP_TYPE_SOAP_ENV__Envelope_ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Envelope_(struct soap *soap, const char *URL, SOAP_ENV__Envelope_ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "SOAP-ENV:Envelope", p->soap_type() == SOAP_TYPE_SOAP_ENV__Envelope_ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 SOAP_ENV__Envelope_ * SOAP_FMAC4 soap_get_SOAP_ENV__Envelope_(struct soap*, SOAP_ENV__Envelope_ *, const char*, const char*);

inline int soap_read_SOAP_ENV__Envelope_(struct soap *soap, SOAP_ENV__Envelope_ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_SOAP_ENV__Envelope_(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Envelope_(struct soap *soap, const char *URL, SOAP_ENV__Envelope_ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_SOAP_ENV__Envelope_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_SOAP_ENV__Envelope_(struct soap *soap, SOAP_ENV__Envelope_ *p)
{
	if (::soap_read_SOAP_ENV__Envelope_(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsa5__EndpointReferenceType___DEFINED
#define SOAP_TYPE_wsa5__EndpointReferenceType___DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType__(struct soap*, const char*, int, const wsa5__EndpointReferenceType__ *, const char*);
SOAP_FMAC3 wsa5__EndpointReferenceType__ * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType__(struct soap*, const char*, wsa5__EndpointReferenceType__ *, const char*);
SOAP_FMAC1 wsa5__EndpointReferenceType__ * SOAP_FMAC2 imageing_instantiate_wsa5__EndpointReferenceType__(struct soap*, int, const char*, const char*, size_t*);

inline wsa5__EndpointReferenceType__ * soap_new_wsa5__EndpointReferenceType__(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsa5__EndpointReferenceType__(soap, n, NULL, NULL, NULL);
}

inline wsa5__EndpointReferenceType__ * soap_new_req_wsa5__EndpointReferenceType__(
	struct soap *soap,
	const struct wsa5__EndpointReferenceType& __item)
{
	wsa5__EndpointReferenceType__ *_p = ::soap_new_wsa5__EndpointReferenceType__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsa5__EndpointReferenceType__::__item = __item;
	}
	return _p;
}

inline wsa5__EndpointReferenceType__ * soap_new_set_wsa5__EndpointReferenceType__(
	struct soap *soap,
	const struct wsa5__EndpointReferenceType& __item,
	char *__item__1)
{
	wsa5__EndpointReferenceType__ *_p = ::soap_new_wsa5__EndpointReferenceType__(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsa5__EndpointReferenceType__::__item = __item;
		_p->xsd__anyType::__item = __item__1;
	}
	return _p;
}

inline int soap_write_wsa5__EndpointReferenceType__(struct soap *soap, wsa5__EndpointReferenceType__ const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsa5:EndpointReferenceType", p->soap_type() == SOAP_TYPE_wsa5__EndpointReferenceType__ ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsa5__EndpointReferenceType__(struct soap *soap, const char *URL, wsa5__EndpointReferenceType__ const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsa5:EndpointReferenceType", p->soap_type() == SOAP_TYPE_wsa5__EndpointReferenceType__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsa5__EndpointReferenceType__(struct soap *soap, const char *URL, wsa5__EndpointReferenceType__ const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsa5:EndpointReferenceType", p->soap_type() == SOAP_TYPE_wsa5__EndpointReferenceType__ ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsa5__EndpointReferenceType__(struct soap *soap, const char *URL, wsa5__EndpointReferenceType__ const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsa5:EndpointReferenceType", p->soap_type() == SOAP_TYPE_wsa5__EndpointReferenceType__ ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsa5__EndpointReferenceType__ * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType__(struct soap*, wsa5__EndpointReferenceType__ *, const char*, const char*);

inline int soap_read_wsa5__EndpointReferenceType__(struct soap *soap, wsa5__EndpointReferenceType__ *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsa5__EndpointReferenceType__(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsa5__EndpointReferenceType__(struct soap *soap, const char *URL, wsa5__EndpointReferenceType__ *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsa5__EndpointReferenceType__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsa5__EndpointReferenceType__(struct soap *soap, wsa5__EndpointReferenceType__ *p)
{
	if (::soap_read_wsa5__EndpointReferenceType__(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__hexBinary_DEFINED
#define SOAP_TYPE_xsd__hexBinary_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap*, const char*, int, const xsd__hexBinary *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__hexBinary2s(struct soap*, xsd__hexBinary);
SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap*, const char*, xsd__hexBinary *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__hexBinary(struct soap*, const char*, xsd__hexBinary *);
SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 imageing_instantiate_xsd__hexBinary(struct soap*, int, const char*, const char*, size_t*);

inline xsd__hexBinary * soap_new_xsd__hexBinary(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__hexBinary(soap, n, NULL, NULL, NULL);
}

inline xsd__hexBinary * soap_new_req_xsd__hexBinary(
	struct soap *soap)
{
	xsd__hexBinary *_p = ::soap_new_xsd__hexBinary(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xsd__hexBinary * soap_new_set_xsd__hexBinary(
	struct soap *soap,
	unsigned char *__ptr,
	int __size)
{
	xsd__hexBinary *_p = ::soap_new_xsd__hexBinary(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__hexBinary::__ptr = __ptr;
		_p->xsd__hexBinary::__size = __size;
	}
	return _p;
}

inline int soap_write_xsd__hexBinary(struct soap *soap, xsd__hexBinary const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:hexBinary", p->soap_type() == SOAP_TYPE_xsd__hexBinary ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__hexBinary(struct soap *soap, const char *URL, xsd__hexBinary const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:hexBinary", p->soap_type() == SOAP_TYPE_xsd__hexBinary ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__hexBinary(struct soap *soap, const char *URL, xsd__hexBinary const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:hexBinary", p->soap_type() == SOAP_TYPE_xsd__hexBinary ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__hexBinary(struct soap *soap, const char *URL, xsd__hexBinary const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:hexBinary", p->soap_type() == SOAP_TYPE_xsd__hexBinary ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap*, xsd__hexBinary *, const char*, const char*);

inline int soap_read_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__hexBinary(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__hexBinary(struct soap *soap, const char *URL, xsd__hexBinary *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__hexBinary(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p)
{
	if (::soap_read_xsd__hexBinary(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__base64Binary_DEFINED
#define SOAP_TYPE_xsd__base64Binary_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap*, const char*, int, const xsd__base64Binary *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap*, xsd__base64Binary);
SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap*, const char*, xsd__base64Binary *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap*, const char*, xsd__base64Binary *);
SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 imageing_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);

inline xsd__base64Binary * soap_new_xsd__base64Binary(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__base64Binary(soap, n, NULL, NULL, NULL);
}

inline xsd__base64Binary * soap_new_req_xsd__base64Binary(
	struct soap *soap)
{
	xsd__base64Binary *_p = ::soap_new_xsd__base64Binary(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xsd__base64Binary * soap_new_set_xsd__base64Binary(
	struct soap *soap,
	unsigned char *__ptr,
	int __size,
	char *id,
	char *type,
	char *options)
{
	xsd__base64Binary *_p = ::soap_new_xsd__base64Binary(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__base64Binary::__ptr = __ptr;
		_p->xsd__base64Binary::__size = __size;
		_p->xsd__base64Binary::id = id;
		_p->xsd__base64Binary::type = type;
		_p->xsd__base64Binary::options = options;
	}
	return _p;
}

inline int soap_write_xsd__base64Binary(struct soap *soap, xsd__base64Binary const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:base64Binary", p->soap_type() == SOAP_TYPE_xsd__base64Binary ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__base64Binary(struct soap *soap, const char *URL, xsd__base64Binary const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:base64Binary", p->soap_type() == SOAP_TYPE_xsd__base64Binary ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__base64Binary(struct soap *soap, const char *URL, xsd__base64Binary const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:base64Binary", p->soap_type() == SOAP_TYPE_xsd__base64Binary ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__base64Binary(struct soap *soap, const char *URL, xsd__base64Binary const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:base64Binary", p->soap_type() == SOAP_TYPE_xsd__base64Binary ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap*, xsd__base64Binary *, const char*, const char*);

inline int soap_read_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__base64Binary(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__base64Binary(struct soap *soap, const char *URL, xsd__base64Binary *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__base64Binary(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p)
{
	if (::soap_read_xsd__base64Binary(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__QName_DEFINED
#define SOAP_TYPE_xsd__QName_DEFINED

inline void soap_default_xsd__QName(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap*, const std::string *);

#define soap_xsd__QName2s(soap, a) soap_QName2s((soap), (a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__QName(soap, s, a) soap_s2stdQName((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__QName(struct soap*, const char*, std::string*, const char*);
SOAP_FMAC1 std::string * SOAP_FMAC2 imageing_instantiate_xsd__QName(struct soap*, int, const char*, const char*, size_t*);

inline std::string * soap_new_xsd__QName(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__QName(soap, n, NULL, NULL, NULL);
}

inline std::string * soap_new_req_xsd__QName(
	struct soap *soap)
{
	std::string *_p = ::soap_new_xsd__QName(soap);
	if (_p)
	{	::soap_default_xsd__QName(soap, _p);
	}
	return _p;
}

inline std::string * soap_new_set_xsd__QName(
	struct soap *soap)
{
	std::string *_p = ::soap_new_xsd__QName(soap);
	if (_p)
	{	::soap_default_xsd__QName(soap, _p);
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__QName(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__QName(soap, p, "xsd:QName", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__QName(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__QName(soap, p, "xsd:QName", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__QName(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__QName(soap, p, "xsd:QName", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__QName(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__QName(soap, p, "xsd:QName", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__QName(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__QName(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__QName(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__QName(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__QName(struct soap *soap, std::string *p)
{
	if (::soap_read_xsd__QName(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_std__string_DEFINED
#define SOAP_TYPE_std__string_DEFINED

inline void soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap*, const std::string *);

#define soap_std__string2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2std__string(soap, s, a) soap_s2stdchar((soap), (s), (a), 1, 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap*, const char*, std::string*, const char*);
SOAP_FMAC1 std::string * SOAP_FMAC2 imageing_instantiate_std__string(struct soap*, int, const char*, const char*, size_t*);

inline std::string * soap_new_std__string(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

inline std::string * soap_new_req_std__string(
	struct soap *soap)
{
	std::string *_p = ::soap_new_std__string(soap);
	if (_p)
	{	::soap_default_std__string(soap, _p);
	}
	return _p;
}

inline std::string * soap_new_set_std__string(
	struct soap *soap)
{
	std::string *_p = ::soap_new_std__string(soap);
	if (_p)
	{	::soap_default_std__string(soap, _p);
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_std__string(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_std__string(soap, p, "string", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_std__string(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_std__string(soap, p, "string", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_std__string(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_std__string(soap, p, "string", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_std__string(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_std__string(soap, p, "string", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap*, std::string *, const char*, const char*);

inline int soap_read_std__string(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_std__string(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_std__string(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_std__string(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_std__string(struct soap *soap, std::string *p)
{
	if (::soap_read_std__string(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__anyType_DEFINED
#define SOAP_TYPE_xsd__anyType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap*, const char*, int, const xsd__anyType *, const char*);
SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap*, const char*, xsd__anyType *, const char*);
SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 imageing_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);

inline xsd__anyType * soap_new_xsd__anyType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_xsd__anyType(soap, n, NULL, NULL, NULL);
}

inline xsd__anyType * soap_new_req_xsd__anyType(
	struct soap *soap)
{
	xsd__anyType *_p = ::soap_new_xsd__anyType(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xsd__anyType * soap_new_set_xsd__anyType(
	struct soap *soap,
	char *__item)
{
	xsd__anyType *_p = ::soap_new_xsd__anyType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__anyType::__item = __item;
	}
	return _p;
}

inline int soap_write_xsd__anyType(struct soap *soap, xsd__anyType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:anyType", p->soap_type() == SOAP_TYPE_xsd__anyType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xsd__anyType(struct soap *soap, const char *URL, xsd__anyType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:anyType", p->soap_type() == SOAP_TYPE_xsd__anyType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__anyType(struct soap *soap, const char *URL, xsd__anyType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:anyType", p->soap_type() == SOAP_TYPE_xsd__anyType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__anyType(struct soap *soap, const char *URL, xsd__anyType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xsd:anyType", p->soap_type() == SOAP_TYPE_xsd__anyType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap*, xsd__anyType *, const char*, const char*);

inline int soap_read_xsd__anyType(struct soap *soap, xsd__anyType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xsd__anyType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__anyType(struct soap *soap, const char *URL, xsd__anyType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__anyType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__anyType(struct soap *soap, xsd__anyType *p)
{
	if (::soap_read_xsd__anyType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE___timg__SetCurrentPreset_DEFINED
#define SOAP_TYPE___timg__SetCurrentPreset_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__SetCurrentPreset(struct soap*, struct __timg__SetCurrentPreset *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__SetCurrentPreset(struct soap*, const struct __timg__SetCurrentPreset *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__SetCurrentPreset(struct soap*, const char*, int, const struct __timg__SetCurrentPreset *, const char*);
SOAP_FMAC3 struct __timg__SetCurrentPreset * SOAP_FMAC4 soap_in___timg__SetCurrentPreset(struct soap*, const char*, struct __timg__SetCurrentPreset *, const char*);
SOAP_FMAC1 struct __timg__SetCurrentPreset * SOAP_FMAC2 imageing_instantiate___timg__SetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);

inline struct __timg__SetCurrentPreset * soap_new___timg__SetCurrentPreset(struct soap *soap, int n = -1)
{
	return imageing_instantiate___timg__SetCurrentPreset(soap, n, NULL, NULL, NULL);
}

inline struct __timg__SetCurrentPreset * soap_new_req___timg__SetCurrentPreset(
	struct soap *soap)
{
	struct __timg__SetCurrentPreset *_p = ::soap_new___timg__SetCurrentPreset(soap);
	if (_p)
	{	::soap_default___timg__SetCurrentPreset(soap, _p);
	}
	return _p;
}

inline struct __timg__SetCurrentPreset * soap_new_set___timg__SetCurrentPreset(
	struct soap *soap,
	_timg__SetCurrentPreset *timg__SetCurrentPreset)
{
	struct __timg__SetCurrentPreset *_p = ::soap_new___timg__SetCurrentPreset(soap);
	if (_p)
	{	::soap_default___timg__SetCurrentPreset(soap, _p);
		_p->timg__SetCurrentPreset = timg__SetCurrentPreset;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__SetCurrentPreset(struct soap*, const struct __timg__SetCurrentPreset *, const char*, const char*);

inline int soap_write___timg__SetCurrentPreset(struct soap *soap, struct __timg__SetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize___timg__SetCurrentPreset(soap, p), 0) || ::soap_put___timg__SetCurrentPreset(soap, p, "-timg:SetCurrentPreset", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT___timg__SetCurrentPreset(struct soap *soap, const char *URL, struct __timg__SetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__SetCurrentPreset(soap, p), 0) || ::soap_put___timg__SetCurrentPreset(soap, p, "-timg:SetCurrentPreset", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH___timg__SetCurrentPreset(struct soap *soap, const char *URL, struct __timg__SetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__SetCurrentPreset(soap, p), 0) || ::soap_put___timg__SetCurrentPreset(soap, p, "-timg:SetCurrentPreset", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send___timg__SetCurrentPreset(struct soap *soap, const char *URL, struct __timg__SetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__SetCurrentPreset(soap, p), 0) || ::soap_put___timg__SetCurrentPreset(soap, p, "-timg:SetCurrentPreset", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct __timg__SetCurrentPreset * SOAP_FMAC4 soap_get___timg__SetCurrentPreset(struct soap*, struct __timg__SetCurrentPreset *, const char*, const char*);

inline int soap_read___timg__SetCurrentPreset(struct soap *soap, struct __timg__SetCurrentPreset *p)
{
	if (p)
	{	::soap_default___timg__SetCurrentPreset(soap, p);
		if (soap_begin_recv(soap) || ::soap_get___timg__SetCurrentPreset(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET___timg__SetCurrentPreset(struct soap *soap, const char *URL, struct __timg__SetCurrentPreset *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read___timg__SetCurrentPreset(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv___timg__SetCurrentPreset(struct soap *soap, struct __timg__SetCurrentPreset *p)
{
	if (::soap_read___timg__SetCurrentPreset(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE___timg__GetCurrentPreset_DEFINED
#define SOAP_TYPE___timg__GetCurrentPreset_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetCurrentPreset(struct soap*, struct __timg__GetCurrentPreset *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetCurrentPreset(struct soap*, const struct __timg__GetCurrentPreset *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetCurrentPreset(struct soap*, const char*, int, const struct __timg__GetCurrentPreset *, const char*);
SOAP_FMAC3 struct __timg__GetCurrentPreset * SOAP_FMAC4 soap_in___timg__GetCurrentPreset(struct soap*, const char*, struct __timg__GetCurrentPreset *, const char*);
SOAP_FMAC1 struct __timg__GetCurrentPreset * SOAP_FMAC2 imageing_instantiate___timg__GetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);

inline struct __timg__GetCurrentPreset * soap_new___timg__GetCurrentPreset(struct soap *soap, int n = -1)
{
	return imageing_instantiate___timg__GetCurrentPreset(soap, n, NULL, NULL, NULL);
}

inline struct __timg__GetCurrentPreset * soap_new_req___timg__GetCurrentPreset(
	struct soap *soap)
{
	struct __timg__GetCurrentPreset *_p = ::soap_new___timg__GetCurrentPreset(soap);
	if (_p)
	{	::soap_default___timg__GetCurrentPreset(soap, _p);
	}
	return _p;
}

inline struct __timg__GetCurrentPreset * soap_new_set___timg__GetCurrentPreset(
	struct soap *soap,
	_timg__GetCurrentPreset *timg__GetCurrentPreset)
{
	struct __timg__GetCurrentPreset *_p = ::soap_new___timg__GetCurrentPreset(soap);
	if (_p)
	{	::soap_default___timg__GetCurrentPreset(soap, _p);
		_p->timg__GetCurrentPreset = timg__GetCurrentPreset;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetCurrentPreset(struct soap*, const struct __timg__GetCurrentPreset *, const char*, const char*);

inline int soap_write___timg__GetCurrentPreset(struct soap *soap, struct __timg__GetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize___timg__GetCurrentPreset(soap, p), 0) || ::soap_put___timg__GetCurrentPreset(soap, p, "-timg:GetCurrentPreset", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT___timg__GetCurrentPreset(struct soap *soap, const char *URL, struct __timg__GetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetCurrentPreset(soap, p), 0) || ::soap_put___timg__GetCurrentPreset(soap, p, "-timg:GetCurrentPreset", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH___timg__GetCurrentPreset(struct soap *soap, const char *URL, struct __timg__GetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetCurrentPreset(soap, p), 0) || ::soap_put___timg__GetCurrentPreset(soap, p, "-timg:GetCurrentPreset", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send___timg__GetCurrentPreset(struct soap *soap, const char *URL, struct __timg__GetCurrentPreset const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetCurrentPreset(soap, p), 0) || ::soap_put___timg__GetCurrentPreset(soap, p, "-timg:GetCurrentPreset", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct __timg__GetCurrentPreset * SOAP_FMAC4 soap_get___timg__GetCurrentPreset(struct soap*, struct __timg__GetCurrentPreset *, const char*, const char*);

inline int soap_read___timg__GetCurrentPreset(struct soap *soap, struct __timg__GetCurrentPreset *p)
{
	if (p)
	{	::soap_default___timg__GetCurrentPreset(soap, p);
		if (soap_begin_recv(soap) || ::soap_get___timg__GetCurrentPreset(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET___timg__GetCurrentPreset(struct soap *soap, const char *URL, struct __timg__GetCurrentPreset *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read___timg__GetCurrentPreset(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv___timg__GetCurrentPreset(struct soap *soap, struct __timg__GetCurrentPreset *p)
{
	if (::soap_read___timg__GetCurrentPreset(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE___timg__GetPresets_DEFINED
#define SOAP_TYPE___timg__GetPresets_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetPresets(struct soap*, struct __timg__GetPresets *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetPresets(struct soap*, const struct __timg__GetPresets *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetPresets(struct soap*, const char*, int, const struct __timg__GetPresets *, const char*);
SOAP_FMAC3 struct __timg__GetPresets * SOAP_FMAC4 soap_in___timg__GetPresets(struct soap*, const char*, struct __timg__GetPresets *, const char*);
SOAP_FMAC1 struct __timg__GetPresets * SOAP_FMAC2 imageing_instantiate___timg__GetPresets(struct soap*, int, const char*, const char*, size_t*);

inline struct __timg__GetPresets * soap_new___timg__GetPresets(struct soap *soap, int n = -1)
{
	return imageing_instantiate___timg__GetPresets(soap, n, NULL, NULL, NULL);
}

inline struct __timg__GetPresets * soap_new_req___timg__GetPresets(
	struct soap *soap)
{
	struct __timg__GetPresets *_p = ::soap_new___timg__GetPresets(soap);
	if (_p)
	{	::soap_default___timg__GetPresets(soap, _p);
	}
	return _p;
}

inline struct __timg__GetPresets * soap_new_set___timg__GetPresets(
	struct soap *soap,
	_timg__GetPresets *timg__GetPresets)
{
	struct __timg__GetPresets *_p = ::soap_new___timg__GetPresets(soap);
	if (_p)
	{	::soap_default___timg__GetPresets(soap, _p);
		_p->timg__GetPresets = timg__GetPresets;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetPresets(struct soap*, const struct __timg__GetPresets *, const char*, const char*);

inline int soap_write___timg__GetPresets(struct soap *soap, struct __timg__GetPresets const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize___timg__GetPresets(soap, p), 0) || ::soap_put___timg__GetPresets(soap, p, "-timg:GetPresets", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT___timg__GetPresets(struct soap *soap, const char *URL, struct __timg__GetPresets const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetPresets(soap, p), 0) || ::soap_put___timg__GetPresets(soap, p, "-timg:GetPresets", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH___timg__GetPresets(struct soap *soap, const char *URL, struct __timg__GetPresets const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetPresets(soap, p), 0) || ::soap_put___timg__GetPresets(soap, p, "-timg:GetPresets", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send___timg__GetPresets(struct soap *soap, const char *URL, struct __timg__GetPresets const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetPresets(soap, p), 0) || ::soap_put___timg__GetPresets(soap, p, "-timg:GetPresets", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct __timg__GetPresets * SOAP_FMAC4 soap_get___timg__GetPresets(struct soap*, struct __timg__GetPresets *, const char*, const char*);

inline int soap_read___timg__GetPresets(struct soap *soap, struct __timg__GetPresets *p)
{
	if (p)
	{	::soap_default___timg__GetPresets(soap, p);
		if (soap_begin_recv(soap) || ::soap_get___timg__GetPresets(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET___timg__GetPresets(struct soap *soap, const char *URL, struct __timg__GetPresets *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read___timg__GetPresets(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv___timg__GetPresets(struct soap *soap, struct __timg__GetPresets *p)
{
	if (::soap_read___timg__GetPresets(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE___timg__GetMoveOptions_DEFINED
#define SOAP_TYPE___timg__GetMoveOptions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetMoveOptions(struct soap*, struct __timg__GetMoveOptions *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetMoveOptions(struct soap*, const struct __timg__GetMoveOptions *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetMoveOptions(struct soap*, const char*, int, const struct __timg__GetMoveOptions *, const char*);
SOAP_FMAC3 struct __timg__GetMoveOptions * SOAP_FMAC4 soap_in___timg__GetMoveOptions(struct soap*, const char*, struct __timg__GetMoveOptions *, const char*);
SOAP_FMAC1 struct __timg__GetMoveOptions * SOAP_FMAC2 imageing_instantiate___timg__GetMoveOptions(struct soap*, int, const char*, const char*, size_t*);

inline struct __timg__GetMoveOptions * soap_new___timg__GetMoveOptions(struct soap *soap, int n = -1)
{
	return imageing_instantiate___timg__GetMoveOptions(soap, n, NULL, NULL, NULL);
}

inline struct __timg__GetMoveOptions * soap_new_req___timg__GetMoveOptions(
	struct soap *soap)
{
	struct __timg__GetMoveOptions *_p = ::soap_new___timg__GetMoveOptions(soap);
	if (_p)
	{	::soap_default___timg__GetMoveOptions(soap, _p);
	}
	return _p;
}

inline struct __timg__GetMoveOptions * soap_new_set___timg__GetMoveOptions(
	struct soap *soap,
	_timg__GetMoveOptions *timg__GetMoveOptions)
{
	struct __timg__GetMoveOptions *_p = ::soap_new___timg__GetMoveOptions(soap);
	if (_p)
	{	::soap_default___timg__GetMoveOptions(soap, _p);
		_p->timg__GetMoveOptions = timg__GetMoveOptions;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetMoveOptions(struct soap*, const struct __timg__GetMoveOptions *, const char*, const char*);

inline int soap_write___timg__GetMoveOptions(struct soap *soap, struct __timg__GetMoveOptions const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize___timg__GetMoveOptions(soap, p), 0) || ::soap_put___timg__GetMoveOptions(soap, p, "-timg:GetMoveOptions", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT___timg__GetMoveOptions(struct soap *soap, const char *URL, struct __timg__GetMoveOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetMoveOptions(soap, p), 0) || ::soap_put___timg__GetMoveOptions(soap, p, "-timg:GetMoveOptions", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH___timg__GetMoveOptions(struct soap *soap, const char *URL, struct __timg__GetMoveOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetMoveOptions(soap, p), 0) || ::soap_put___timg__GetMoveOptions(soap, p, "-timg:GetMoveOptions", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send___timg__GetMoveOptions(struct soap *soap, const char *URL, struct __timg__GetMoveOptions const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetMoveOptions(soap, p), 0) || ::soap_put___timg__GetMoveOptions(soap, p, "-timg:GetMoveOptions", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct __timg__GetMoveOptions * SOAP_FMAC4 soap_get___timg__GetMoveOptions(struct soap*, struct __timg__GetMoveOptions *, const char*, const char*);

inline int soap_read___timg__GetMoveOptions(struct soap *soap, struct __timg__GetMoveOptions *p)
{
	if (p)
	{	::soap_default___timg__GetMoveOptions(soap, p);
		if (soap_begin_recv(soap) || ::soap_get___timg__GetMoveOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET___timg__GetMoveOptions(struct soap *soap, const char *URL, struct __timg__GetMoveOptions *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read___timg__GetMoveOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv___timg__GetMoveOptions(struct soap *soap, struct __timg__GetMoveOptions *p)
{
	if (::soap_read___timg__GetMoveOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE___timg__GetStatus_DEFINED
#define SOAP_TYPE___timg__GetStatus_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetStatus(struct soap*, struct __timg__GetStatus *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetStatus(struct soap*, const struct __timg__GetStatus *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetStatus(struct soap*, const char*, int, const struct __timg__GetStatus *, const char*);
SOAP_FMAC3 struct __timg__GetStatus * SOAP_FMAC4 soap_in___timg__GetStatus(struct soap*, const char*, struct __timg__GetStatus *, const char*);
SOAP_FMAC1 struct __timg__GetStatus * SOAP_FMAC2 imageing_instantiate___timg__GetStatus(struct soap*, int, const char*, const char*, size_t*);

inline struct __timg__GetStatus * soap_new___timg__GetStatus(struct soap *soap, int n = -1)
{
	return imageing_instantiate___timg__GetStatus(soap, n, NULL, NULL, NULL);
}

inline struct __timg__GetStatus * soap_new_req___timg__GetStatus(
	struct soap *soap)
{
	struct __timg__GetStatus *_p = ::soap_new___timg__GetStatus(soap);
	if (_p)
	{	::soap_default___timg__GetStatus(soap, _p);
	}
	return _p;
}

inline struct __timg__GetStatus * soap_new_set___timg__GetStatus(
	struct soap *soap,
	_timg__GetStatus *timg__GetStatus)
{
	struct __timg__GetStatus *_p = ::soap_new___timg__GetStatus(soap);
	if (_p)
	{	::soap_default___timg__GetStatus(soap, _p);
		_p->timg__GetStatus = timg__GetStatus;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetStatus(struct soap*, const struct __timg__GetStatus *, const char*, const char*);

inline int soap_write___timg__GetStatus(struct soap *soap, struct __timg__GetStatus const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize___timg__GetStatus(soap, p), 0) || ::soap_put___timg__GetStatus(soap, p, "-timg:GetStatus", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT___timg__GetStatus(struct soap *soap, const char *URL, struct __timg__GetStatus const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetStatus(soap, p), 0) || ::soap_put___timg__GetStatus(soap, p, "-timg:GetStatus", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH___timg__GetStatus(struct soap *soap, const char *URL, struct __timg__GetStatus const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetStatus(soap, p), 0) || ::soap_put___timg__GetStatus(soap, p, "-timg:GetStatus", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send___timg__GetStatus(struct soap *soap, const char *URL, struct __timg__GetStatus const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetStatus(soap, p), 0) || ::soap_put___timg__GetStatus(soap, p, "-timg:GetStatus", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct __timg__GetStatus * SOAP_FMAC4 soap_get___timg__GetStatus(struct soap*, struct __timg__GetStatus *, const char*, const char*);

inline int soap_read___timg__GetStatus(struct soap *soap, struct __timg__GetStatus *p)
{
	if (p)
	{	::soap_default___timg__GetStatus(soap, p);
		if (soap_begin_recv(soap) || ::soap_get___timg__GetStatus(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET___timg__GetStatus(struct soap *soap, const char *URL, struct __timg__GetStatus *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read___timg__GetStatus(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv___timg__GetStatus(struct soap *soap, struct __timg__GetStatus *p)
{
	if (::soap_read___timg__GetStatus(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE___timg__Stop_DEFINED
#define SOAP_TYPE___timg__Stop_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__Stop(struct soap*, struct __timg__Stop *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__Stop(struct soap*, const struct __timg__Stop *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__Stop(struct soap*, const char*, int, const struct __timg__Stop *, const char*);
SOAP_FMAC3 struct __timg__Stop * SOAP_FMAC4 soap_in___timg__Stop(struct soap*, const char*, struct __timg__Stop *, const char*);
SOAP_FMAC1 struct __timg__Stop * SOAP_FMAC2 imageing_instantiate___timg__Stop(struct soap*, int, const char*, const char*, size_t*);

inline struct __timg__Stop * soap_new___timg__Stop(struct soap *soap, int n = -1)
{
	return imageing_instantiate___timg__Stop(soap, n, NULL, NULL, NULL);
}

inline struct __timg__Stop * soap_new_req___timg__Stop(
	struct soap *soap)
{
	struct __timg__Stop *_p = ::soap_new___timg__Stop(soap);
	if (_p)
	{	::soap_default___timg__Stop(soap, _p);
	}
	return _p;
}

inline struct __timg__Stop * soap_new_set___timg__Stop(
	struct soap *soap,
	_timg__Stop *timg__Stop)
{
	struct __timg__Stop *_p = ::soap_new___timg__Stop(soap);
	if (_p)
	{	::soap_default___timg__Stop(soap, _p);
		_p->timg__Stop = timg__Stop;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__Stop(struct soap*, const struct __timg__Stop *, const char*, const char*);

inline int soap_write___timg__Stop(struct soap *soap, struct __timg__Stop const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize___timg__Stop(soap, p), 0) || ::soap_put___timg__Stop(soap, p, "-timg:Stop", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT___timg__Stop(struct soap *soap, const char *URL, struct __timg__Stop const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__Stop(soap, p), 0) || ::soap_put___timg__Stop(soap, p, "-timg:Stop", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH___timg__Stop(struct soap *soap, const char *URL, struct __timg__Stop const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__Stop(soap, p), 0) || ::soap_put___timg__Stop(soap, p, "-timg:Stop", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send___timg__Stop(struct soap *soap, const char *URL, struct __timg__Stop const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__Stop(soap, p), 0) || ::soap_put___timg__Stop(soap, p, "-timg:Stop", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct __timg__Stop * SOAP_FMAC4 soap_get___timg__Stop(struct soap*, struct __timg__Stop *, const char*, const char*);

inline int soap_read___timg__Stop(struct soap *soap, struct __timg__Stop *p)
{
	if (p)
	{	::soap_default___timg__Stop(soap, p);
		if (soap_begin_recv(soap) || ::soap_get___timg__Stop(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET___timg__Stop(struct soap *soap, const char *URL, struct __timg__Stop *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read___timg__Stop(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv___timg__Stop(struct soap *soap, struct __timg__Stop *p)
{
	if (::soap_read___timg__Stop(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE___timg__Move_DEFINED
#define SOAP_TYPE___timg__Move_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__Move(struct soap*, struct __timg__Move *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__Move(struct soap*, const struct __timg__Move *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__Move(struct soap*, const char*, int, const struct __timg__Move *, const char*);
SOAP_FMAC3 struct __timg__Move * SOAP_FMAC4 soap_in___timg__Move(struct soap*, const char*, struct __timg__Move *, const char*);
SOAP_FMAC1 struct __timg__Move * SOAP_FMAC2 imageing_instantiate___timg__Move(struct soap*, int, const char*, const char*, size_t*);

inline struct __timg__Move * soap_new___timg__Move(struct soap *soap, int n = -1)
{
	return imageing_instantiate___timg__Move(soap, n, NULL, NULL, NULL);
}

inline struct __timg__Move * soap_new_req___timg__Move(
	struct soap *soap)
{
	struct __timg__Move *_p = ::soap_new___timg__Move(soap);
	if (_p)
	{	::soap_default___timg__Move(soap, _p);
	}
	return _p;
}

inline struct __timg__Move * soap_new_set___timg__Move(
	struct soap *soap,
	_timg__Move *timg__Move)
{
	struct __timg__Move *_p = ::soap_new___timg__Move(soap);
	if (_p)
	{	::soap_default___timg__Move(soap, _p);
		_p->timg__Move = timg__Move;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__Move(struct soap*, const struct __timg__Move *, const char*, const char*);

inline int soap_write___timg__Move(struct soap *soap, struct __timg__Move const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize___timg__Move(soap, p), 0) || ::soap_put___timg__Move(soap, p, "-timg:Move", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT___timg__Move(struct soap *soap, const char *URL, struct __timg__Move const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__Move(soap, p), 0) || ::soap_put___timg__Move(soap, p, "-timg:Move", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH___timg__Move(struct soap *soap, const char *URL, struct __timg__Move const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__Move(soap, p), 0) || ::soap_put___timg__Move(soap, p, "-timg:Move", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send___timg__Move(struct soap *soap, const char *URL, struct __timg__Move const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__Move(soap, p), 0) || ::soap_put___timg__Move(soap, p, "-timg:Move", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct __timg__Move * SOAP_FMAC4 soap_get___timg__Move(struct soap*, struct __timg__Move *, const char*, const char*);

inline int soap_read___timg__Move(struct soap *soap, struct __timg__Move *p)
{
	if (p)
	{	::soap_default___timg__Move(soap, p);
		if (soap_begin_recv(soap) || ::soap_get___timg__Move(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET___timg__Move(struct soap *soap, const char *URL, struct __timg__Move *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read___timg__Move(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv___timg__Move(struct soap *soap, struct __timg__Move *p)
{
	if (::soap_read___timg__Move(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE___timg__GetOptions_DEFINED
#define SOAP_TYPE___timg__GetOptions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetOptions(struct soap*, struct __timg__GetOptions *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetOptions(struct soap*, const struct __timg__GetOptions *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetOptions(struct soap*, const char*, int, const struct __timg__GetOptions *, const char*);
SOAP_FMAC3 struct __timg__GetOptions * SOAP_FMAC4 soap_in___timg__GetOptions(struct soap*, const char*, struct __timg__GetOptions *, const char*);
SOAP_FMAC1 struct __timg__GetOptions * SOAP_FMAC2 imageing_instantiate___timg__GetOptions(struct soap*, int, const char*, const char*, size_t*);

inline struct __timg__GetOptions * soap_new___timg__GetOptions(struct soap *soap, int n = -1)
{
	return imageing_instantiate___timg__GetOptions(soap, n, NULL, NULL, NULL);
}

inline struct __timg__GetOptions * soap_new_req___timg__GetOptions(
	struct soap *soap)
{
	struct __timg__GetOptions *_p = ::soap_new___timg__GetOptions(soap);
	if (_p)
	{	::soap_default___timg__GetOptions(soap, _p);
	}
	return _p;
}

inline struct __timg__GetOptions * soap_new_set___timg__GetOptions(
	struct soap *soap,
	_timg__GetOptions *timg__GetOptions)
{
	struct __timg__GetOptions *_p = ::soap_new___timg__GetOptions(soap);
	if (_p)
	{	::soap_default___timg__GetOptions(soap, _p);
		_p->timg__GetOptions = timg__GetOptions;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetOptions(struct soap*, const struct __timg__GetOptions *, const char*, const char*);

inline int soap_write___timg__GetOptions(struct soap *soap, struct __timg__GetOptions const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize___timg__GetOptions(soap, p), 0) || ::soap_put___timg__GetOptions(soap, p, "-timg:GetOptions", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT___timg__GetOptions(struct soap *soap, const char *URL, struct __timg__GetOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetOptions(soap, p), 0) || ::soap_put___timg__GetOptions(soap, p, "-timg:GetOptions", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH___timg__GetOptions(struct soap *soap, const char *URL, struct __timg__GetOptions const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetOptions(soap, p), 0) || ::soap_put___timg__GetOptions(soap, p, "-timg:GetOptions", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send___timg__GetOptions(struct soap *soap, const char *URL, struct __timg__GetOptions const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetOptions(soap, p), 0) || ::soap_put___timg__GetOptions(soap, p, "-timg:GetOptions", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct __timg__GetOptions * SOAP_FMAC4 soap_get___timg__GetOptions(struct soap*, struct __timg__GetOptions *, const char*, const char*);

inline int soap_read___timg__GetOptions(struct soap *soap, struct __timg__GetOptions *p)
{
	if (p)
	{	::soap_default___timg__GetOptions(soap, p);
		if (soap_begin_recv(soap) || ::soap_get___timg__GetOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET___timg__GetOptions(struct soap *soap, const char *URL, struct __timg__GetOptions *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read___timg__GetOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv___timg__GetOptions(struct soap *soap, struct __timg__GetOptions *p)
{
	if (::soap_read___timg__GetOptions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE___timg__SetImagingSettings_DEFINED
#define SOAP_TYPE___timg__SetImagingSettings_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__SetImagingSettings(struct soap*, struct __timg__SetImagingSettings *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__SetImagingSettings(struct soap*, const struct __timg__SetImagingSettings *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__SetImagingSettings(struct soap*, const char*, int, const struct __timg__SetImagingSettings *, const char*);
SOAP_FMAC3 struct __timg__SetImagingSettings * SOAP_FMAC4 soap_in___timg__SetImagingSettings(struct soap*, const char*, struct __timg__SetImagingSettings *, const char*);
SOAP_FMAC1 struct __timg__SetImagingSettings * SOAP_FMAC2 imageing_instantiate___timg__SetImagingSettings(struct soap*, int, const char*, const char*, size_t*);

inline struct __timg__SetImagingSettings * soap_new___timg__SetImagingSettings(struct soap *soap, int n = -1)
{
	return imageing_instantiate___timg__SetImagingSettings(soap, n, NULL, NULL, NULL);
}

inline struct __timg__SetImagingSettings * soap_new_req___timg__SetImagingSettings(
	struct soap *soap)
{
	struct __timg__SetImagingSettings *_p = ::soap_new___timg__SetImagingSettings(soap);
	if (_p)
	{	::soap_default___timg__SetImagingSettings(soap, _p);
	}
	return _p;
}

inline struct __timg__SetImagingSettings * soap_new_set___timg__SetImagingSettings(
	struct soap *soap,
	_timg__SetImagingSettings *timg__SetImagingSettings)
{
	struct __timg__SetImagingSettings *_p = ::soap_new___timg__SetImagingSettings(soap);
	if (_p)
	{	::soap_default___timg__SetImagingSettings(soap, _p);
		_p->timg__SetImagingSettings = timg__SetImagingSettings;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__SetImagingSettings(struct soap*, const struct __timg__SetImagingSettings *, const char*, const char*);

inline int soap_write___timg__SetImagingSettings(struct soap *soap, struct __timg__SetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize___timg__SetImagingSettings(soap, p), 0) || ::soap_put___timg__SetImagingSettings(soap, p, "-timg:SetImagingSettings", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT___timg__SetImagingSettings(struct soap *soap, const char *URL, struct __timg__SetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__SetImagingSettings(soap, p), 0) || ::soap_put___timg__SetImagingSettings(soap, p, "-timg:SetImagingSettings", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH___timg__SetImagingSettings(struct soap *soap, const char *URL, struct __timg__SetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__SetImagingSettings(soap, p), 0) || ::soap_put___timg__SetImagingSettings(soap, p, "-timg:SetImagingSettings", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send___timg__SetImagingSettings(struct soap *soap, const char *URL, struct __timg__SetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__SetImagingSettings(soap, p), 0) || ::soap_put___timg__SetImagingSettings(soap, p, "-timg:SetImagingSettings", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct __timg__SetImagingSettings * SOAP_FMAC4 soap_get___timg__SetImagingSettings(struct soap*, struct __timg__SetImagingSettings *, const char*, const char*);

inline int soap_read___timg__SetImagingSettings(struct soap *soap, struct __timg__SetImagingSettings *p)
{
	if (p)
	{	::soap_default___timg__SetImagingSettings(soap, p);
		if (soap_begin_recv(soap) || ::soap_get___timg__SetImagingSettings(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET___timg__SetImagingSettings(struct soap *soap, const char *URL, struct __timg__SetImagingSettings *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read___timg__SetImagingSettings(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv___timg__SetImagingSettings(struct soap *soap, struct __timg__SetImagingSettings *p)
{
	if (::soap_read___timg__SetImagingSettings(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE___timg__GetImagingSettings_DEFINED
#define SOAP_TYPE___timg__GetImagingSettings_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetImagingSettings(struct soap*, struct __timg__GetImagingSettings *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetImagingSettings(struct soap*, const struct __timg__GetImagingSettings *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetImagingSettings(struct soap*, const char*, int, const struct __timg__GetImagingSettings *, const char*);
SOAP_FMAC3 struct __timg__GetImagingSettings * SOAP_FMAC4 soap_in___timg__GetImagingSettings(struct soap*, const char*, struct __timg__GetImagingSettings *, const char*);
SOAP_FMAC1 struct __timg__GetImagingSettings * SOAP_FMAC2 imageing_instantiate___timg__GetImagingSettings(struct soap*, int, const char*, const char*, size_t*);

inline struct __timg__GetImagingSettings * soap_new___timg__GetImagingSettings(struct soap *soap, int n = -1)
{
	return imageing_instantiate___timg__GetImagingSettings(soap, n, NULL, NULL, NULL);
}

inline struct __timg__GetImagingSettings * soap_new_req___timg__GetImagingSettings(
	struct soap *soap)
{
	struct __timg__GetImagingSettings *_p = ::soap_new___timg__GetImagingSettings(soap);
	if (_p)
	{	::soap_default___timg__GetImagingSettings(soap, _p);
	}
	return _p;
}

inline struct __timg__GetImagingSettings * soap_new_set___timg__GetImagingSettings(
	struct soap *soap,
	_timg__GetImagingSettings *timg__GetImagingSettings)
{
	struct __timg__GetImagingSettings *_p = ::soap_new___timg__GetImagingSettings(soap);
	if (_p)
	{	::soap_default___timg__GetImagingSettings(soap, _p);
		_p->timg__GetImagingSettings = timg__GetImagingSettings;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetImagingSettings(struct soap*, const struct __timg__GetImagingSettings *, const char*, const char*);

inline int soap_write___timg__GetImagingSettings(struct soap *soap, struct __timg__GetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize___timg__GetImagingSettings(soap, p), 0) || ::soap_put___timg__GetImagingSettings(soap, p, "-timg:GetImagingSettings", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT___timg__GetImagingSettings(struct soap *soap, const char *URL, struct __timg__GetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetImagingSettings(soap, p), 0) || ::soap_put___timg__GetImagingSettings(soap, p, "-timg:GetImagingSettings", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH___timg__GetImagingSettings(struct soap *soap, const char *URL, struct __timg__GetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetImagingSettings(soap, p), 0) || ::soap_put___timg__GetImagingSettings(soap, p, "-timg:GetImagingSettings", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send___timg__GetImagingSettings(struct soap *soap, const char *URL, struct __timg__GetImagingSettings const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetImagingSettings(soap, p), 0) || ::soap_put___timg__GetImagingSettings(soap, p, "-timg:GetImagingSettings", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct __timg__GetImagingSettings * SOAP_FMAC4 soap_get___timg__GetImagingSettings(struct soap*, struct __timg__GetImagingSettings *, const char*, const char*);

inline int soap_read___timg__GetImagingSettings(struct soap *soap, struct __timg__GetImagingSettings *p)
{
	if (p)
	{	::soap_default___timg__GetImagingSettings(soap, p);
		if (soap_begin_recv(soap) || ::soap_get___timg__GetImagingSettings(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET___timg__GetImagingSettings(struct soap *soap, const char *URL, struct __timg__GetImagingSettings *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read___timg__GetImagingSettings(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv___timg__GetImagingSettings(struct soap *soap, struct __timg__GetImagingSettings *p)
{
	if (::soap_read___timg__GetImagingSettings(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE___timg__GetServiceCapabilities_DEFINED
#define SOAP_TYPE___timg__GetServiceCapabilities_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetServiceCapabilities(struct soap*, struct __timg__GetServiceCapabilities *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetServiceCapabilities(struct soap*, const struct __timg__GetServiceCapabilities *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetServiceCapabilities(struct soap*, const char*, int, const struct __timg__GetServiceCapabilities *, const char*);
SOAP_FMAC3 struct __timg__GetServiceCapabilities * SOAP_FMAC4 soap_in___timg__GetServiceCapabilities(struct soap*, const char*, struct __timg__GetServiceCapabilities *, const char*);
SOAP_FMAC1 struct __timg__GetServiceCapabilities * SOAP_FMAC2 imageing_instantiate___timg__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);

inline struct __timg__GetServiceCapabilities * soap_new___timg__GetServiceCapabilities(struct soap *soap, int n = -1)
{
	return imageing_instantiate___timg__GetServiceCapabilities(soap, n, NULL, NULL, NULL);
}

inline struct __timg__GetServiceCapabilities * soap_new_req___timg__GetServiceCapabilities(
	struct soap *soap)
{
	struct __timg__GetServiceCapabilities *_p = ::soap_new___timg__GetServiceCapabilities(soap);
	if (_p)
	{	::soap_default___timg__GetServiceCapabilities(soap, _p);
	}
	return _p;
}

inline struct __timg__GetServiceCapabilities * soap_new_set___timg__GetServiceCapabilities(
	struct soap *soap,
	_timg__GetServiceCapabilities *timg__GetServiceCapabilities)
{
	struct __timg__GetServiceCapabilities *_p = ::soap_new___timg__GetServiceCapabilities(soap);
	if (_p)
	{	::soap_default___timg__GetServiceCapabilities(soap, _p);
		_p->timg__GetServiceCapabilities = timg__GetServiceCapabilities;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetServiceCapabilities(struct soap*, const struct __timg__GetServiceCapabilities *, const char*, const char*);

inline int soap_write___timg__GetServiceCapabilities(struct soap *soap, struct __timg__GetServiceCapabilities const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize___timg__GetServiceCapabilities(soap, p), 0) || ::soap_put___timg__GetServiceCapabilities(soap, p, "-timg:GetServiceCapabilities", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT___timg__GetServiceCapabilities(struct soap *soap, const char *URL, struct __timg__GetServiceCapabilities const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetServiceCapabilities(soap, p), 0) || ::soap_put___timg__GetServiceCapabilities(soap, p, "-timg:GetServiceCapabilities", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH___timg__GetServiceCapabilities(struct soap *soap, const char *URL, struct __timg__GetServiceCapabilities const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetServiceCapabilities(soap, p), 0) || ::soap_put___timg__GetServiceCapabilities(soap, p, "-timg:GetServiceCapabilities", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send___timg__GetServiceCapabilities(struct soap *soap, const char *URL, struct __timg__GetServiceCapabilities const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize___timg__GetServiceCapabilities(soap, p), 0) || ::soap_put___timg__GetServiceCapabilities(soap, p, "-timg:GetServiceCapabilities", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct __timg__GetServiceCapabilities * SOAP_FMAC4 soap_get___timg__GetServiceCapabilities(struct soap*, struct __timg__GetServiceCapabilities *, const char*, const char*);

inline int soap_read___timg__GetServiceCapabilities(struct soap *soap, struct __timg__GetServiceCapabilities *p)
{
	if (p)
	{	::soap_default___timg__GetServiceCapabilities(soap, p);
		if (soap_begin_recv(soap) || ::soap_get___timg__GetServiceCapabilities(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET___timg__GetServiceCapabilities(struct soap *soap, const char *URL, struct __timg__GetServiceCapabilities *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read___timg__GetServiceCapabilities(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv___timg__GetServiceCapabilities(struct soap *soap, struct __timg__GetServiceCapabilities *p)
{
	if (::soap_read___timg__GetServiceCapabilities(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Envelope_DEFINED
#define SOAP_TYPE_SOAP_ENV__Envelope_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Envelope(struct soap*, struct SOAP_ENV__Envelope *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Envelope(struct soap*, const struct SOAP_ENV__Envelope *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Envelope(struct soap*, const char*, int, const struct SOAP_ENV__Envelope *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_in_SOAP_ENV__Envelope(struct soap*, const char*, struct SOAP_ENV__Envelope *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Envelope * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Envelope(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Envelope * soap_new_SOAP_ENV__Envelope(struct soap *soap, int n = -1)
{
	return imageing_instantiate_SOAP_ENV__Envelope(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Envelope * soap_new_req_SOAP_ENV__Envelope(
	struct soap *soap)
{
	struct SOAP_ENV__Envelope *_p = ::soap_new_SOAP_ENV__Envelope(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Envelope(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Envelope * soap_new_set_SOAP_ENV__Envelope(
	struct soap *soap,
	struct SOAP_ENV__Header *SOAP_ENV__Header,
	char *SOAP_ENV__Body)
{
	struct SOAP_ENV__Envelope *_p = ::soap_new_SOAP_ENV__Envelope(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Envelope(soap, _p);
		_p->SOAP_ENV__Header = SOAP_ENV__Header;
		_p->SOAP_ENV__Body = SOAP_ENV__Body;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Envelope(struct soap*, const struct SOAP_ENV__Envelope *, const char*, const char*);

inline int soap_write_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_SOAP_ENV__Envelope(soap, p), 0) || ::soap_put_SOAP_ENV__Envelope(soap, p, "SOAP-ENV:Envelope", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Envelope(struct soap *soap, const char *URL, struct SOAP_ENV__Envelope const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Envelope(soap, p), 0) || ::soap_put_SOAP_ENV__Envelope(soap, p, "SOAP-ENV:Envelope", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_SOAP_ENV__Envelope(struct soap *soap, const char *URL, struct SOAP_ENV__Envelope const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Envelope(soap, p), 0) || ::soap_put_SOAP_ENV__Envelope(soap, p, "SOAP-ENV:Envelope", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Envelope(struct soap *soap, const char *URL, struct SOAP_ENV__Envelope const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Envelope(soap, p), 0) || ::soap_put_SOAP_ENV__Envelope(soap, p, "SOAP-ENV:Envelope", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_get_SOAP_ENV__Envelope(struct soap*, struct SOAP_ENV__Envelope *, const char*, const char*);

inline int soap_read_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *p)
{
	if (p)
	{	::soap_default_SOAP_ENV__Envelope(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_SOAP_ENV__Envelope(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Envelope(struct soap *soap, const char *URL, struct SOAP_ENV__Envelope *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_SOAP_ENV__Envelope(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *p)
{
	if (::soap_read_SOAP_ENV__Envelope(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault_DEFINED
#define SOAP_TYPE_SOAP_ENV__Fault_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap*, const char*, int, const struct SOAP_ENV__Fault *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap*, const char*, struct SOAP_ENV__Fault *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Fault * soap_new_SOAP_ENV__Fault(struct soap *soap, int n = -1)
{
	return imageing_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Fault * soap_new_req_SOAP_ENV__Fault(
	struct soap *soap)
{
	struct SOAP_ENV__Fault *_p = ::soap_new_SOAP_ENV__Fault(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Fault(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Fault * soap_new_set_SOAP_ENV__Fault(
	struct soap *soap,
	char *faultcode,
	char *faultstring,
	char *faultactor,
	struct SOAP_ENV__Detail *detail,
	struct SOAP_ENV__Code *SOAP_ENV__Code,
	struct SOAP_ENV__Reason *SOAP_ENV__Reason,
	char *SOAP_ENV__Node,
	char *SOAP_ENV__Role,
	struct SOAP_ENV__Detail *SOAP_ENV__Detail)
{
	struct SOAP_ENV__Fault *_p = ::soap_new_SOAP_ENV__Fault(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Fault(soap, _p);
		_p->faultcode = faultcode;
		_p->faultstring = faultstring;
		_p->faultactor = faultactor;
		_p->detail = detail;
		_p->SOAP_ENV__Code = SOAP_ENV__Code;
		_p->SOAP_ENV__Reason = SOAP_ENV__Reason;
		_p->SOAP_ENV__Node = SOAP_ENV__Node;
		_p->SOAP_ENV__Role = SOAP_ENV__Role;
		_p->SOAP_ENV__Detail = SOAP_ENV__Detail;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *, const char*, const char*);

inline int soap_write_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_SOAP_ENV__Fault(soap, p), 0) || ::soap_put_SOAP_ENV__Fault(soap, p, "SOAP-ENV:Fault", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Fault(struct soap *soap, const char *URL, struct SOAP_ENV__Fault const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Fault(soap, p), 0) || ::soap_put_SOAP_ENV__Fault(soap, p, "SOAP-ENV:Fault", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_SOAP_ENV__Fault(struct soap *soap, const char *URL, struct SOAP_ENV__Fault const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Fault(soap, p), 0) || ::soap_put_SOAP_ENV__Fault(soap, p, "SOAP-ENV:Fault", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Fault(struct soap *soap, const char *URL, struct SOAP_ENV__Fault const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Fault(soap, p), 0) || ::soap_put_SOAP_ENV__Fault(soap, p, "SOAP-ENV:Fault", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *, const char*, const char*);

inline int soap_read_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{
	if (p)
	{	::soap_default_SOAP_ENV__Fault(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_SOAP_ENV__Fault(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Fault(struct soap *soap, const char *URL, struct SOAP_ENV__Fault *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_SOAP_ENV__Fault(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{
	if (::soap_read_SOAP_ENV__Fault(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason_DEFINED
#define SOAP_TYPE_SOAP_ENV__Reason_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap*, const char*, int, const struct SOAP_ENV__Reason *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Reason * soap_new_SOAP_ENV__Reason(struct soap *soap, int n = -1)
{
	return imageing_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Reason * soap_new_req_SOAP_ENV__Reason(
	struct soap *soap)
{
	struct SOAP_ENV__Reason *_p = ::soap_new_SOAP_ENV__Reason(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Reason(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Reason * soap_new_set_SOAP_ENV__Reason(
	struct soap *soap,
	char *SOAP_ENV__Text)
{
	struct SOAP_ENV__Reason *_p = ::soap_new_SOAP_ENV__Reason(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Reason(soap, _p);
		_p->SOAP_ENV__Text = SOAP_ENV__Text;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *, const char*, const char*);

inline int soap_write_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_SOAP_ENV__Reason(soap, p), 0) || ::soap_put_SOAP_ENV__Reason(soap, p, "SOAP-ENV:Reason", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Reason(struct soap *soap, const char *URL, struct SOAP_ENV__Reason const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Reason(soap, p), 0) || ::soap_put_SOAP_ENV__Reason(soap, p, "SOAP-ENV:Reason", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_SOAP_ENV__Reason(struct soap *soap, const char *URL, struct SOAP_ENV__Reason const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Reason(soap, p), 0) || ::soap_put_SOAP_ENV__Reason(soap, p, "SOAP-ENV:Reason", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Reason(struct soap *soap, const char *URL, struct SOAP_ENV__Reason const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Reason(soap, p), 0) || ::soap_put_SOAP_ENV__Reason(soap, p, "SOAP-ENV:Reason", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *, const char*, const char*);

inline int soap_read_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{
	if (p)
	{	::soap_default_SOAP_ENV__Reason(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_SOAP_ENV__Reason(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Reason(struct soap *soap, const char *URL, struct SOAP_ENV__Reason *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_SOAP_ENV__Reason(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{
	if (::soap_read_SOAP_ENV__Reason(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code_DEFINED
#define SOAP_TYPE_SOAP_ENV__Code_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap*, const char*, int, const struct SOAP_ENV__Code *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Code * soap_new_SOAP_ENV__Code(struct soap *soap, int n = -1)
{
	return imageing_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Code * soap_new_req_SOAP_ENV__Code(
	struct soap *soap)
{
	struct SOAP_ENV__Code *_p = ::soap_new_SOAP_ENV__Code(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Code(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Code * soap_new_set_SOAP_ENV__Code(
	struct soap *soap,
	char *SOAP_ENV__Value,
	struct SOAP_ENV__Code *SOAP_ENV__Subcode)
{
	struct SOAP_ENV__Code *_p = ::soap_new_SOAP_ENV__Code(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Code(soap, _p);
		_p->SOAP_ENV__Value = SOAP_ENV__Value;
		_p->SOAP_ENV__Subcode = SOAP_ENV__Subcode;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *, const char*, const char*);

inline int soap_write_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_SOAP_ENV__Code(soap, p), 0) || ::soap_put_SOAP_ENV__Code(soap, p, "SOAP-ENV:Code", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Code(struct soap *soap, const char *URL, struct SOAP_ENV__Code const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Code(soap, p), 0) || ::soap_put_SOAP_ENV__Code(soap, p, "SOAP-ENV:Code", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_SOAP_ENV__Code(struct soap *soap, const char *URL, struct SOAP_ENV__Code const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Code(soap, p), 0) || ::soap_put_SOAP_ENV__Code(soap, p, "SOAP-ENV:Code", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Code(struct soap *soap, const char *URL, struct SOAP_ENV__Code const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Code(soap, p), 0) || ::soap_put_SOAP_ENV__Code(soap, p, "SOAP-ENV:Code", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *, const char*, const char*);

inline int soap_read_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{
	if (p)
	{	::soap_default_SOAP_ENV__Code(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_SOAP_ENV__Code(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Code(struct soap *soap, const char *URL, struct SOAP_ENV__Code *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_SOAP_ENV__Code(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{
	if (::soap_read_SOAP_ENV__Code(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail_DEFINED
#define SOAP_TYPE_SOAP_ENV__Detail_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap*, const char*, int, const struct SOAP_ENV__Detail *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Detail * soap_new_SOAP_ENV__Detail(struct soap *soap, int n = -1)
{
	return imageing_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Detail * soap_new_req_SOAP_ENV__Detail(
	struct soap *soap,
	int __type,
	void *fault)
{
	struct SOAP_ENV__Detail *_p = ::soap_new_SOAP_ENV__Detail(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Detail(soap, _p);
		_p->__type = __type;
		_p->fault = fault;
	}
	return _p;
}

inline struct SOAP_ENV__Detail * soap_new_set_SOAP_ENV__Detail(
	struct soap *soap,
	char *__any,
	int __type,
	void *fault)
{
	struct SOAP_ENV__Detail *_p = ::soap_new_SOAP_ENV__Detail(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Detail(soap, _p);
		_p->__any = __any;
		_p->__type = __type;
		_p->fault = fault;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *, const char*, const char*);

inline int soap_write_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_SOAP_ENV__Detail(soap, p), 0) || ::soap_put_SOAP_ENV__Detail(soap, p, "SOAP-ENV:Detail", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Detail(struct soap *soap, const char *URL, struct SOAP_ENV__Detail const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Detail(soap, p), 0) || ::soap_put_SOAP_ENV__Detail(soap, p, "SOAP-ENV:Detail", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_SOAP_ENV__Detail(struct soap *soap, const char *URL, struct SOAP_ENV__Detail const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Detail(soap, p), 0) || ::soap_put_SOAP_ENV__Detail(soap, p, "SOAP-ENV:Detail", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Detail(struct soap *soap, const char *URL, struct SOAP_ENV__Detail const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Detail(soap, p), 0) || ::soap_put_SOAP_ENV__Detail(soap, p, "SOAP-ENV:Detail", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *, const char*, const char*);

inline int soap_read_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{
	if (p)
	{	::soap_default_SOAP_ENV__Detail(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_SOAP_ENV__Detail(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Detail(struct soap *soap, const char *URL, struct SOAP_ENV__Detail *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_SOAP_ENV__Detail(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{
	if (::soap_read_SOAP_ENV__Detail(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header_DEFINED
#define SOAP_TYPE_SOAP_ENV__Header_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap*, const char*, int, const struct SOAP_ENV__Header *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap*, const char*, struct SOAP_ENV__Header *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Header * soap_new_SOAP_ENV__Header(struct soap *soap, int n = -1)
{
	return imageing_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Header * soap_new_req_SOAP_ENV__Header(
	struct soap *soap)
{
	struct SOAP_ENV__Header *_p = ::soap_new_SOAP_ENV__Header(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Header(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Header * soap_new_set_SOAP_ENV__Header(
	struct soap *soap,
	char *wsa5__MessageID,
	struct wsa5__RelatesToType *wsa5__RelatesTo,
	struct wsa5__EndpointReferenceType *wsa5__From,
	struct wsa5__EndpointReferenceType *wsa5__ReplyTo,
	struct wsa5__EndpointReferenceType *wsa5__FaultTo,
	char *wsa5__To,
	char *wsa5__Action,
	struct chan__ChannelInstanceType *chan__ChannelInstance)
{
	struct SOAP_ENV__Header *_p = ::soap_new_SOAP_ENV__Header(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Header(soap, _p);
		_p->wsa5__MessageID = wsa5__MessageID;
		_p->wsa5__RelatesTo = wsa5__RelatesTo;
		_p->wsa5__From = wsa5__From;
		_p->wsa5__ReplyTo = wsa5__ReplyTo;
		_p->wsa5__FaultTo = wsa5__FaultTo;
		_p->wsa5__To = wsa5__To;
		_p->wsa5__Action = wsa5__Action;
		_p->chan__ChannelInstance = chan__ChannelInstance;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *, const char*, const char*);

inline int soap_write_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_SOAP_ENV__Header(soap, p), 0) || ::soap_put_SOAP_ENV__Header(soap, p, "SOAP-ENV:Header", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Header(struct soap *soap, const char *URL, struct SOAP_ENV__Header const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Header(soap, p), 0) || ::soap_put_SOAP_ENV__Header(soap, p, "SOAP-ENV:Header", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_SOAP_ENV__Header(struct soap *soap, const char *URL, struct SOAP_ENV__Header const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Header(soap, p), 0) || ::soap_put_SOAP_ENV__Header(soap, p, "SOAP-ENV:Header", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Header(struct soap *soap, const char *URL, struct SOAP_ENV__Header const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Header(soap, p), 0) || ::soap_put_SOAP_ENV__Header(soap, p, "SOAP-ENV:Header", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *, const char*, const char*);

inline int soap_read_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{
	if (p)
	{	::soap_default_SOAP_ENV__Header(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_SOAP_ENV__Header(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Header(struct soap *soap, const char *URL, struct SOAP_ENV__Header *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_SOAP_ENV__Header(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{
	if (::soap_read_SOAP_ENV__Header(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#endif

#ifndef SOAP_TYPE_chan__ChannelInstanceType_DEFINED
#define SOAP_TYPE_chan__ChannelInstanceType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_chan__ChannelInstanceType(struct soap*, struct chan__ChannelInstanceType *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_chan__ChannelInstanceType(struct soap*, const struct chan__ChannelInstanceType *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_chan__ChannelInstanceType(struct soap*, const char*, int, const struct chan__ChannelInstanceType *, const char*);
SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_in_chan__ChannelInstanceType(struct soap*, const char*, struct chan__ChannelInstanceType *, const char*);
SOAP_FMAC1 struct chan__ChannelInstanceType * SOAP_FMAC2 imageing_instantiate_chan__ChannelInstanceType(struct soap*, int, const char*, const char*, size_t*);

inline struct chan__ChannelInstanceType * soap_new_chan__ChannelInstanceType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_chan__ChannelInstanceType(soap, n, NULL, NULL, NULL);
}

inline struct chan__ChannelInstanceType * soap_new_req_chan__ChannelInstanceType(
	struct soap *soap,
	int __item)
{
	struct chan__ChannelInstanceType *_p = ::soap_new_chan__ChannelInstanceType(soap);
	if (_p)
	{	::soap_default_chan__ChannelInstanceType(soap, _p);
		_p->__item = __item;
	}
	return _p;
}

inline struct chan__ChannelInstanceType * soap_new_set_chan__ChannelInstanceType(
	struct soap *soap,
	int __item,
	enum _wsa5__IsReferenceParameter wsa5__IsReferenceParameter)
{
	struct chan__ChannelInstanceType *_p = ::soap_new_chan__ChannelInstanceType(soap);
	if (_p)
	{	::soap_default_chan__ChannelInstanceType(soap, _p);
		_p->__item = __item;
		_p->wsa5__IsReferenceParameter = wsa5__IsReferenceParameter;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_chan__ChannelInstanceType(struct soap*, const struct chan__ChannelInstanceType *, const char*, const char*);

inline int soap_write_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_chan__ChannelInstanceType(soap, p), 0) || ::soap_put_chan__ChannelInstanceType(soap, p, "chan:ChannelInstanceType", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_chan__ChannelInstanceType(struct soap *soap, const char *URL, struct chan__ChannelInstanceType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_chan__ChannelInstanceType(soap, p), 0) || ::soap_put_chan__ChannelInstanceType(soap, p, "chan:ChannelInstanceType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_chan__ChannelInstanceType(struct soap *soap, const char *URL, struct chan__ChannelInstanceType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_chan__ChannelInstanceType(soap, p), 0) || ::soap_put_chan__ChannelInstanceType(soap, p, "chan:ChannelInstanceType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_chan__ChannelInstanceType(struct soap *soap, const char *URL, struct chan__ChannelInstanceType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_chan__ChannelInstanceType(soap, p), 0) || ::soap_put_chan__ChannelInstanceType(soap, p, "chan:ChannelInstanceType", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_get_chan__ChannelInstanceType(struct soap*, struct chan__ChannelInstanceType *, const char*, const char*);

inline int soap_read_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p)
{
	if (p)
	{	::soap_default_chan__ChannelInstanceType(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_chan__ChannelInstanceType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_chan__ChannelInstanceType(struct soap *soap, const char *URL, struct chan__ChannelInstanceType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_chan__ChannelInstanceType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p)
{
	if (::soap_read_chan__ChannelInstanceType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif
/* _wsa5__ProblemAction is a typedef synonym of wsa5__ProblemActionType */

#ifndef SOAP_TYPE__wsa5__ProblemAction_DEFINED
#define SOAP_TYPE__wsa5__ProblemAction_DEFINED

#define soap_default__wsa5__ProblemAction soap_default_wsa5__ProblemActionType

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap*, const struct wsa5__ProblemActionType *);

#define soap_serialize__wsa5__ProblemAction soap_serialize_wsa5__ProblemActionType


#define soap__wsa5__ProblemAction2s soap_wsa5__ProblemActionType2s


#define soap_out__wsa5__ProblemAction soap_out_wsa5__ProblemActionType


#define soap_s2_wsa5__ProblemAction soap_s2wsa5__ProblemActionType


#define soap_in__wsa5__ProblemAction soap_in_wsa5__ProblemActionType


#define imageing_instantiate__wsa5__ProblemAction imageing_instantiate_wsa5__ProblemActionType


#define soap_new__wsa5__ProblemAction soap_new_wsa5__ProblemActionType


#define soap_new_req__wsa5__ProblemAction soap_new_req_wsa5__ProblemActionType


#define soap_new_set__wsa5__ProblemAction soap_new_set_wsa5__ProblemActionType

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemAction(struct soap*, const struct wsa5__ProblemActionType *, const char*, const char*);

inline int soap_write__wsa5__ProblemAction(struct soap *soap, struct wsa5__ProblemActionType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize__wsa5__ProblemAction(soap, p), 0) || ::soap_put__wsa5__ProblemAction(soap, p, "wsa5:ProblemAction", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsa5__ProblemAction(struct soap *soap, const char *URL, struct wsa5__ProblemActionType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__ProblemAction(soap, p), 0) || ::soap_put__wsa5__ProblemAction(soap, p, "wsa5:ProblemAction", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__ProblemAction(struct soap *soap, const char *URL, struct wsa5__ProblemActionType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__ProblemAction(soap, p), 0) || ::soap_put__wsa5__ProblemAction(soap, p, "wsa5:ProblemAction", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__ProblemAction(struct soap *soap, const char *URL, struct wsa5__ProblemActionType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__ProblemAction(soap, p), 0) || ::soap_put__wsa5__ProblemAction(soap, p, "wsa5:ProblemAction", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__wsa5__ProblemAction soap_get_wsa5__ProblemActionType


#define soap_read__wsa5__ProblemAction soap_read_wsa5__ProblemActionType


#define soap_GET__wsa5__ProblemAction soap_GET_wsa5__ProblemActionType


#define soap_POST_recv__wsa5__ProblemAction soap_POST_recv_wsa5__ProblemActionType

#endif
/* _wsa5__FaultTo is a typedef synonym of wsa5__EndpointReferenceType */

#ifndef SOAP_TYPE__wsa5__FaultTo_DEFINED
#define SOAP_TYPE__wsa5__FaultTo_DEFINED

#define soap_default__wsa5__FaultTo soap_default_wsa5__EndpointReferenceType

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap*, const struct wsa5__EndpointReferenceType *);

#define soap_serialize__wsa5__FaultTo soap_serialize_wsa5__EndpointReferenceType


#define soap__wsa5__FaultTo2s soap_wsa5__EndpointReferenceType2s


#define soap_out__wsa5__FaultTo soap_out_wsa5__EndpointReferenceType


#define soap_s2_wsa5__FaultTo soap_s2wsa5__EndpointReferenceType


#define soap_in__wsa5__FaultTo soap_in_wsa5__EndpointReferenceType


#define imageing_instantiate__wsa5__FaultTo imageing_instantiate_wsa5__EndpointReferenceType


#define soap_new__wsa5__FaultTo soap_new_wsa5__EndpointReferenceType


#define soap_new_req__wsa5__FaultTo soap_new_req_wsa5__EndpointReferenceType


#define soap_new_set__wsa5__FaultTo soap_new_set_wsa5__EndpointReferenceType

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__FaultTo(struct soap*, const struct wsa5__EndpointReferenceType *, const char*, const char*);

inline int soap_write__wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize__wsa5__FaultTo(soap, p), 0) || ::soap_put__wsa5__FaultTo(soap, p, "wsa5:FaultTo", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsa5__FaultTo(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__FaultTo(soap, p), 0) || ::soap_put__wsa5__FaultTo(soap, p, "wsa5:FaultTo", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__FaultTo(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__FaultTo(soap, p), 0) || ::soap_put__wsa5__FaultTo(soap, p, "wsa5:FaultTo", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__FaultTo(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__FaultTo(soap, p), 0) || ::soap_put__wsa5__FaultTo(soap, p, "wsa5:FaultTo", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__wsa5__FaultTo soap_get_wsa5__EndpointReferenceType


#define soap_read__wsa5__FaultTo soap_read_wsa5__EndpointReferenceType


#define soap_GET__wsa5__FaultTo soap_GET_wsa5__EndpointReferenceType


#define soap_POST_recv__wsa5__FaultTo soap_POST_recv_wsa5__EndpointReferenceType

#endif
/* _wsa5__From is a typedef synonym of wsa5__EndpointReferenceType */

#ifndef SOAP_TYPE__wsa5__From_DEFINED
#define SOAP_TYPE__wsa5__From_DEFINED

#define soap_default__wsa5__From soap_default_wsa5__EndpointReferenceType

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap*, const struct wsa5__EndpointReferenceType *);

#define soap_serialize__wsa5__From soap_serialize_wsa5__EndpointReferenceType


#define soap__wsa5__From2s soap_wsa5__EndpointReferenceType2s


#define soap_out__wsa5__From soap_out_wsa5__EndpointReferenceType


#define soap_s2_wsa5__From soap_s2wsa5__EndpointReferenceType


#define soap_in__wsa5__From soap_in_wsa5__EndpointReferenceType


#define imageing_instantiate__wsa5__From imageing_instantiate_wsa5__EndpointReferenceType


#define soap_new__wsa5__From soap_new_wsa5__EndpointReferenceType


#define soap_new_req__wsa5__From soap_new_req_wsa5__EndpointReferenceType


#define soap_new_set__wsa5__From soap_new_set_wsa5__EndpointReferenceType

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__From(struct soap*, const struct wsa5__EndpointReferenceType *, const char*, const char*);

inline int soap_write__wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize__wsa5__From(soap, p), 0) || ::soap_put__wsa5__From(soap, p, "wsa5:From", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsa5__From(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__From(soap, p), 0) || ::soap_put__wsa5__From(soap, p, "wsa5:From", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__From(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__From(soap, p), 0) || ::soap_put__wsa5__From(soap, p, "wsa5:From", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__From(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__From(soap, p), 0) || ::soap_put__wsa5__From(soap, p, "wsa5:From", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__wsa5__From soap_get_wsa5__EndpointReferenceType


#define soap_read__wsa5__From soap_read_wsa5__EndpointReferenceType


#define soap_GET__wsa5__From soap_GET_wsa5__EndpointReferenceType


#define soap_POST_recv__wsa5__From soap_POST_recv_wsa5__EndpointReferenceType

#endif
/* _wsa5__ReplyTo is a typedef synonym of wsa5__EndpointReferenceType */

#ifndef SOAP_TYPE__wsa5__ReplyTo_DEFINED
#define SOAP_TYPE__wsa5__ReplyTo_DEFINED

#define soap_default__wsa5__ReplyTo soap_default_wsa5__EndpointReferenceType

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap*, const struct wsa5__EndpointReferenceType *);

#define soap_serialize__wsa5__ReplyTo soap_serialize_wsa5__EndpointReferenceType


#define soap__wsa5__ReplyTo2s soap_wsa5__EndpointReferenceType2s


#define soap_out__wsa5__ReplyTo soap_out_wsa5__EndpointReferenceType


#define soap_s2_wsa5__ReplyTo soap_s2wsa5__EndpointReferenceType


#define soap_in__wsa5__ReplyTo soap_in_wsa5__EndpointReferenceType


#define imageing_instantiate__wsa5__ReplyTo imageing_instantiate_wsa5__EndpointReferenceType


#define soap_new__wsa5__ReplyTo soap_new_wsa5__EndpointReferenceType


#define soap_new_req__wsa5__ReplyTo soap_new_req_wsa5__EndpointReferenceType


#define soap_new_set__wsa5__ReplyTo soap_new_set_wsa5__EndpointReferenceType

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReplyTo(struct soap*, const struct wsa5__EndpointReferenceType *, const char*, const char*);

inline int soap_write__wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize__wsa5__ReplyTo(soap, p), 0) || ::soap_put__wsa5__ReplyTo(soap, p, "wsa5:ReplyTo", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsa5__ReplyTo(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__ReplyTo(soap, p), 0) || ::soap_put__wsa5__ReplyTo(soap, p, "wsa5:ReplyTo", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__ReplyTo(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__ReplyTo(soap, p), 0) || ::soap_put__wsa5__ReplyTo(soap, p, "wsa5:ReplyTo", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__ReplyTo(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__ReplyTo(soap, p), 0) || ::soap_put__wsa5__ReplyTo(soap, p, "wsa5:ReplyTo", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__wsa5__ReplyTo soap_get_wsa5__EndpointReferenceType


#define soap_read__wsa5__ReplyTo soap_read_wsa5__EndpointReferenceType


#define soap_GET__wsa5__ReplyTo soap_GET_wsa5__EndpointReferenceType


#define soap_POST_recv__wsa5__ReplyTo soap_POST_recv_wsa5__EndpointReferenceType

#endif
/* _wsa5__RelatesTo is a typedef synonym of wsa5__RelatesToType */

#ifndef SOAP_TYPE__wsa5__RelatesTo_DEFINED
#define SOAP_TYPE__wsa5__RelatesTo_DEFINED

#define soap_default__wsa5__RelatesTo soap_default_wsa5__RelatesToType

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap*, const struct wsa5__RelatesToType *);

#define soap_serialize__wsa5__RelatesTo soap_serialize_wsa5__RelatesToType


#define soap__wsa5__RelatesTo2s soap_wsa5__RelatesToType2s


#define soap_out__wsa5__RelatesTo soap_out_wsa5__RelatesToType


#define soap_s2_wsa5__RelatesTo soap_s2wsa5__RelatesToType


#define soap_in__wsa5__RelatesTo soap_in_wsa5__RelatesToType


#define imageing_instantiate__wsa5__RelatesTo imageing_instantiate_wsa5__RelatesToType


#define soap_new__wsa5__RelatesTo soap_new_wsa5__RelatesToType


#define soap_new_req__wsa5__RelatesTo soap_new_req_wsa5__RelatesToType


#define soap_new_set__wsa5__RelatesTo soap_new_set_wsa5__RelatesToType

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RelatesTo(struct soap*, const struct wsa5__RelatesToType *, const char*, const char*);

inline int soap_write__wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize__wsa5__RelatesTo(soap, p), 0) || ::soap_put__wsa5__RelatesTo(soap, p, "wsa5:RelatesTo", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsa5__RelatesTo(struct soap *soap, const char *URL, struct wsa5__RelatesToType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__RelatesTo(soap, p), 0) || ::soap_put__wsa5__RelatesTo(soap, p, "wsa5:RelatesTo", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__RelatesTo(struct soap *soap, const char *URL, struct wsa5__RelatesToType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__RelatesTo(soap, p), 0) || ::soap_put__wsa5__RelatesTo(soap, p, "wsa5:RelatesTo", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__RelatesTo(struct soap *soap, const char *URL, struct wsa5__RelatesToType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__RelatesTo(soap, p), 0) || ::soap_put__wsa5__RelatesTo(soap, p, "wsa5:RelatesTo", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__wsa5__RelatesTo soap_get_wsa5__RelatesToType


#define soap_read__wsa5__RelatesTo soap_read_wsa5__RelatesToType


#define soap_GET__wsa5__RelatesTo soap_GET_wsa5__RelatesToType


#define soap_POST_recv__wsa5__RelatesTo soap_POST_recv_wsa5__RelatesToType

#endif
/* _wsa5__Metadata is a typedef synonym of wsa5__MetadataType */

#ifndef SOAP_TYPE__wsa5__Metadata_DEFINED
#define SOAP_TYPE__wsa5__Metadata_DEFINED

#define soap_default__wsa5__Metadata soap_default_wsa5__MetadataType

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap*, const struct wsa5__MetadataType *);

#define soap_serialize__wsa5__Metadata soap_serialize_wsa5__MetadataType


#define soap__wsa5__Metadata2s soap_wsa5__MetadataType2s


#define soap_out__wsa5__Metadata soap_out_wsa5__MetadataType


#define soap_s2_wsa5__Metadata soap_s2wsa5__MetadataType


#define soap_in__wsa5__Metadata soap_in_wsa5__MetadataType


#define imageing_instantiate__wsa5__Metadata imageing_instantiate_wsa5__MetadataType


#define soap_new__wsa5__Metadata soap_new_wsa5__MetadataType


#define soap_new_req__wsa5__Metadata soap_new_req_wsa5__MetadataType


#define soap_new_set__wsa5__Metadata soap_new_set_wsa5__MetadataType

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Metadata(struct soap*, const struct wsa5__MetadataType *, const char*, const char*);

inline int soap_write__wsa5__Metadata(struct soap *soap, struct wsa5__MetadataType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize__wsa5__Metadata(soap, p), 0) || ::soap_put__wsa5__Metadata(soap, p, "wsa5:Metadata", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsa5__Metadata(struct soap *soap, const char *URL, struct wsa5__MetadataType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__Metadata(soap, p), 0) || ::soap_put__wsa5__Metadata(soap, p, "wsa5:Metadata", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__Metadata(struct soap *soap, const char *URL, struct wsa5__MetadataType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__Metadata(soap, p), 0) || ::soap_put__wsa5__Metadata(soap, p, "wsa5:Metadata", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__Metadata(struct soap *soap, const char *URL, struct wsa5__MetadataType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__Metadata(soap, p), 0) || ::soap_put__wsa5__Metadata(soap, p, "wsa5:Metadata", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__wsa5__Metadata soap_get_wsa5__MetadataType


#define soap_read__wsa5__Metadata soap_read_wsa5__MetadataType


#define soap_GET__wsa5__Metadata soap_GET_wsa5__MetadataType


#define soap_POST_recv__wsa5__Metadata soap_POST_recv_wsa5__MetadataType

#endif
/* _wsa5__ReferenceParameters is a typedef synonym of wsa5__ReferenceParametersType */

#ifndef SOAP_TYPE__wsa5__ReferenceParameters_DEFINED
#define SOAP_TYPE__wsa5__ReferenceParameters_DEFINED

#define soap_default__wsa5__ReferenceParameters soap_default_wsa5__ReferenceParametersType

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap*, const struct wsa5__ReferenceParametersType *);

#define soap_serialize__wsa5__ReferenceParameters soap_serialize_wsa5__ReferenceParametersType


#define soap__wsa5__ReferenceParameters2s soap_wsa5__ReferenceParametersType2s


#define soap_out__wsa5__ReferenceParameters soap_out_wsa5__ReferenceParametersType


#define soap_s2_wsa5__ReferenceParameters soap_s2wsa5__ReferenceParametersType


#define soap_in__wsa5__ReferenceParameters soap_in_wsa5__ReferenceParametersType


#define imageing_instantiate__wsa5__ReferenceParameters imageing_instantiate_wsa5__ReferenceParametersType


#define soap_new__wsa5__ReferenceParameters soap_new_wsa5__ReferenceParametersType


#define soap_new_req__wsa5__ReferenceParameters soap_new_req_wsa5__ReferenceParametersType


#define soap_new_set__wsa5__ReferenceParameters soap_new_set_wsa5__ReferenceParametersType

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReferenceParameters(struct soap*, const struct wsa5__ReferenceParametersType *, const char*, const char*);

inline int soap_write__wsa5__ReferenceParameters(struct soap *soap, struct wsa5__ReferenceParametersType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize__wsa5__ReferenceParameters(soap, p), 0) || ::soap_put__wsa5__ReferenceParameters(soap, p, "wsa5:ReferenceParameters", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsa5__ReferenceParameters(struct soap *soap, const char *URL, struct wsa5__ReferenceParametersType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__ReferenceParameters(soap, p), 0) || ::soap_put__wsa5__ReferenceParameters(soap, p, "wsa5:ReferenceParameters", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__ReferenceParameters(struct soap *soap, const char *URL, struct wsa5__ReferenceParametersType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__ReferenceParameters(soap, p), 0) || ::soap_put__wsa5__ReferenceParameters(soap, p, "wsa5:ReferenceParameters", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__ReferenceParameters(struct soap *soap, const char *URL, struct wsa5__ReferenceParametersType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__ReferenceParameters(soap, p), 0) || ::soap_put__wsa5__ReferenceParameters(soap, p, "wsa5:ReferenceParameters", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__wsa5__ReferenceParameters soap_get_wsa5__ReferenceParametersType


#define soap_read__wsa5__ReferenceParameters soap_read_wsa5__ReferenceParametersType


#define soap_GET__wsa5__ReferenceParameters soap_GET_wsa5__ReferenceParametersType


#define soap_POST_recv__wsa5__ReferenceParameters soap_POST_recv_wsa5__ReferenceParametersType

#endif
/* _wsa5__EndpointReference is a typedef synonym of wsa5__EndpointReferenceType */

#ifndef SOAP_TYPE__wsa5__EndpointReference_DEFINED
#define SOAP_TYPE__wsa5__EndpointReference_DEFINED

#define soap_default__wsa5__EndpointReference soap_default_wsa5__EndpointReferenceType

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap*, const struct wsa5__EndpointReferenceType *);

#define soap_serialize__wsa5__EndpointReference soap_serialize_wsa5__EndpointReferenceType


#define soap__wsa5__EndpointReference2s soap_wsa5__EndpointReferenceType2s


#define soap_out__wsa5__EndpointReference soap_out_wsa5__EndpointReferenceType


#define soap_s2_wsa5__EndpointReference soap_s2wsa5__EndpointReferenceType


#define soap_in__wsa5__EndpointReference soap_in_wsa5__EndpointReferenceType


#define imageing_instantiate__wsa5__EndpointReference imageing_instantiate_wsa5__EndpointReferenceType


#define soap_new__wsa5__EndpointReference soap_new_wsa5__EndpointReferenceType


#define soap_new_req__wsa5__EndpointReference soap_new_req_wsa5__EndpointReferenceType


#define soap_new_set__wsa5__EndpointReference soap_new_set_wsa5__EndpointReferenceType

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__EndpointReference(struct soap*, const struct wsa5__EndpointReferenceType *, const char*, const char*);

inline int soap_write__wsa5__EndpointReference(struct soap *soap, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize__wsa5__EndpointReference(soap, p), 0) || ::soap_put__wsa5__EndpointReference(soap, p, "wsa5:EndpointReference", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__wsa5__EndpointReference(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__EndpointReference(soap, p), 0) || ::soap_put__wsa5__EndpointReference(soap, p, "wsa5:EndpointReference", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__EndpointReference(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__EndpointReference(soap, p), 0) || ::soap_put__wsa5__EndpointReference(soap, p, "wsa5:EndpointReference", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__EndpointReference(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__wsa5__EndpointReference(soap, p), 0) || ::soap_put__wsa5__EndpointReference(soap, p, "wsa5:EndpointReference", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__wsa5__EndpointReference soap_get_wsa5__EndpointReferenceType


#define soap_read__wsa5__EndpointReference soap_read_wsa5__EndpointReferenceType


#define soap_GET__wsa5__EndpointReference soap_GET_wsa5__EndpointReferenceType


#define soap_POST_recv__wsa5__EndpointReference soap_POST_recv_wsa5__EndpointReferenceType

#endif

#ifndef SOAP_TYPE_wsa5__ProblemActionType_DEFINED
#define SOAP_TYPE_wsa5__ProblemActionType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap*, struct wsa5__ProblemActionType *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap*, const struct wsa5__ProblemActionType *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap*, const char*, int, const struct wsa5__ProblemActionType *, const char*);
SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap*, const char*, struct wsa5__ProblemActionType *, const char*);
SOAP_FMAC1 struct wsa5__ProblemActionType * SOAP_FMAC2 imageing_instantiate_wsa5__ProblemActionType(struct soap*, int, const char*, const char*, size_t*);

inline struct wsa5__ProblemActionType * soap_new_wsa5__ProblemActionType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsa5__ProblemActionType(soap, n, NULL, NULL, NULL);
}

inline struct wsa5__ProblemActionType * soap_new_req_wsa5__ProblemActionType(
	struct soap *soap)
{
	struct wsa5__ProblemActionType *_p = ::soap_new_wsa5__ProblemActionType(soap);
	if (_p)
	{	::soap_default_wsa5__ProblemActionType(soap, _p);
	}
	return _p;
}

inline struct wsa5__ProblemActionType * soap_new_set_wsa5__ProblemActionType(
	struct soap *soap,
	char *Action,
	char *SoapAction,
	char *__anyAttribute)
{
	struct wsa5__ProblemActionType *_p = ::soap_new_wsa5__ProblemActionType(soap);
	if (_p)
	{	::soap_default_wsa5__ProblemActionType(soap, _p);
		_p->Action = Action;
		_p->SoapAction = SoapAction;
		_p->__anyAttribute = __anyAttribute;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap*, const struct wsa5__ProblemActionType *, const char*, const char*);

inline int soap_write_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_wsa5__ProblemActionType(soap, p), 0) || ::soap_put_wsa5__ProblemActionType(soap, p, "wsa5:ProblemActionType", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsa5__ProblemActionType(struct soap *soap, const char *URL, struct wsa5__ProblemActionType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__ProblemActionType(soap, p), 0) || ::soap_put_wsa5__ProblemActionType(soap, p, "wsa5:ProblemActionType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsa5__ProblemActionType(struct soap *soap, const char *URL, struct wsa5__ProblemActionType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__ProblemActionType(soap, p), 0) || ::soap_put_wsa5__ProblemActionType(soap, p, "wsa5:ProblemActionType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsa5__ProblemActionType(struct soap *soap, const char *URL, struct wsa5__ProblemActionType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__ProblemActionType(soap, p), 0) || ::soap_put_wsa5__ProblemActionType(soap, p, "wsa5:ProblemActionType", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap*, struct wsa5__ProblemActionType *, const char*, const char*);

inline int soap_read_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p)
{
	if (p)
	{	::soap_default_wsa5__ProblemActionType(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_wsa5__ProblemActionType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsa5__ProblemActionType(struct soap *soap, const char *URL, struct wsa5__ProblemActionType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsa5__ProblemActionType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p)
{
	if (::soap_read_wsa5__ProblemActionType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsa5__RelatesToType_DEFINED
#define SOAP_TYPE_wsa5__RelatesToType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap*, struct wsa5__RelatesToType *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap*, const struct wsa5__RelatesToType *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap*, const char*, int, const struct wsa5__RelatesToType *, const char*);
SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap*, const char*, struct wsa5__RelatesToType *, const char*);
SOAP_FMAC1 struct wsa5__RelatesToType * SOAP_FMAC2 imageing_instantiate_wsa5__RelatesToType(struct soap*, int, const char*, const char*, size_t*);

inline struct wsa5__RelatesToType * soap_new_wsa5__RelatesToType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsa5__RelatesToType(soap, n, NULL, NULL, NULL);
}

inline struct wsa5__RelatesToType * soap_new_req_wsa5__RelatesToType(
	struct soap *soap)
{
	struct wsa5__RelatesToType *_p = ::soap_new_wsa5__RelatesToType(soap);
	if (_p)
	{	::soap_default_wsa5__RelatesToType(soap, _p);
	}
	return _p;
}

inline struct wsa5__RelatesToType * soap_new_set_wsa5__RelatesToType(
	struct soap *soap,
	char *__item,
	char *RelationshipType,
	char *__anyAttribute)
{
	struct wsa5__RelatesToType *_p = ::soap_new_wsa5__RelatesToType(soap);
	if (_p)
	{	::soap_default_wsa5__RelatesToType(soap, _p);
		_p->__item = __item;
		_p->RelationshipType = RelationshipType;
		_p->__anyAttribute = __anyAttribute;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap*, const struct wsa5__RelatesToType *, const char*, const char*);

inline int soap_write_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_wsa5__RelatesToType(soap, p), 0) || ::soap_put_wsa5__RelatesToType(soap, p, "wsa5:RelatesToType", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsa5__RelatesToType(struct soap *soap, const char *URL, struct wsa5__RelatesToType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__RelatesToType(soap, p), 0) || ::soap_put_wsa5__RelatesToType(soap, p, "wsa5:RelatesToType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsa5__RelatesToType(struct soap *soap, const char *URL, struct wsa5__RelatesToType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__RelatesToType(soap, p), 0) || ::soap_put_wsa5__RelatesToType(soap, p, "wsa5:RelatesToType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsa5__RelatesToType(struct soap *soap, const char *URL, struct wsa5__RelatesToType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__RelatesToType(soap, p), 0) || ::soap_put_wsa5__RelatesToType(soap, p, "wsa5:RelatesToType", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap*, struct wsa5__RelatesToType *, const char*, const char*);

inline int soap_read_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p)
{
	if (p)
	{	::soap_default_wsa5__RelatesToType(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_wsa5__RelatesToType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsa5__RelatesToType(struct soap *soap, const char *URL, struct wsa5__RelatesToType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsa5__RelatesToType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p)
{
	if (::soap_read_wsa5__RelatesToType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsa5__MetadataType_DEFINED
#define SOAP_TYPE_wsa5__MetadataType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap*, struct wsa5__MetadataType *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap*, const struct wsa5__MetadataType *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap*, const char*, int, const struct wsa5__MetadataType *, const char*);
SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap*, const char*, struct wsa5__MetadataType *, const char*);
SOAP_FMAC1 struct wsa5__MetadataType * SOAP_FMAC2 imageing_instantiate_wsa5__MetadataType(struct soap*, int, const char*, const char*, size_t*);

inline struct wsa5__MetadataType * soap_new_wsa5__MetadataType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsa5__MetadataType(soap, n, NULL, NULL, NULL);
}

inline struct wsa5__MetadataType * soap_new_req_wsa5__MetadataType(
	struct soap *soap,
	int __size,
	char **__any)
{
	struct wsa5__MetadataType *_p = ::soap_new_wsa5__MetadataType(soap);
	if (_p)
	{	::soap_default_wsa5__MetadataType(soap, _p);
		_p->__size = __size;
		_p->__any = __any;
	}
	return _p;
}

inline struct wsa5__MetadataType * soap_new_set_wsa5__MetadataType(
	struct soap *soap,
	int __size,
	char **__any,
	char *__anyAttribute)
{
	struct wsa5__MetadataType *_p = ::soap_new_wsa5__MetadataType(soap);
	if (_p)
	{	::soap_default_wsa5__MetadataType(soap, _p);
		_p->__size = __size;
		_p->__any = __any;
		_p->__anyAttribute = __anyAttribute;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap*, const struct wsa5__MetadataType *, const char*, const char*);

inline int soap_write_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_wsa5__MetadataType(soap, p), 0) || ::soap_put_wsa5__MetadataType(soap, p, "wsa5:MetadataType", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsa5__MetadataType(struct soap *soap, const char *URL, struct wsa5__MetadataType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__MetadataType(soap, p), 0) || ::soap_put_wsa5__MetadataType(soap, p, "wsa5:MetadataType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsa5__MetadataType(struct soap *soap, const char *URL, struct wsa5__MetadataType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__MetadataType(soap, p), 0) || ::soap_put_wsa5__MetadataType(soap, p, "wsa5:MetadataType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsa5__MetadataType(struct soap *soap, const char *URL, struct wsa5__MetadataType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__MetadataType(soap, p), 0) || ::soap_put_wsa5__MetadataType(soap, p, "wsa5:MetadataType", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap*, struct wsa5__MetadataType *, const char*, const char*);

inline int soap_read_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p)
{
	if (p)
	{	::soap_default_wsa5__MetadataType(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_wsa5__MetadataType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsa5__MetadataType(struct soap *soap, const char *URL, struct wsa5__MetadataType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsa5__MetadataType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p)
{
	if (::soap_read_wsa5__MetadataType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsa5__ReferenceParametersType_DEFINED
#define SOAP_TYPE_wsa5__ReferenceParametersType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap*, struct wsa5__ReferenceParametersType *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap*, const struct wsa5__ReferenceParametersType *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap*, const char*, int, const struct wsa5__ReferenceParametersType *, const char*);
SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap*, const char*, struct wsa5__ReferenceParametersType *, const char*);
SOAP_FMAC1 struct wsa5__ReferenceParametersType * SOAP_FMAC2 imageing_instantiate_wsa5__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);

inline struct wsa5__ReferenceParametersType * soap_new_wsa5__ReferenceParametersType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsa5__ReferenceParametersType(soap, n, NULL, NULL, NULL);
}

inline struct wsa5__ReferenceParametersType * soap_new_req_wsa5__ReferenceParametersType(
	struct soap *soap,
	int __size,
	char **__any)
{
	struct wsa5__ReferenceParametersType *_p = ::soap_new_wsa5__ReferenceParametersType(soap);
	if (_p)
	{	::soap_default_wsa5__ReferenceParametersType(soap, _p);
		_p->__size = __size;
		_p->__any = __any;
	}
	return _p;
}

inline struct wsa5__ReferenceParametersType * soap_new_set_wsa5__ReferenceParametersType(
	struct soap *soap,
	int *chan__ChannelInstance,
	int __size,
	char **__any,
	char *__anyAttribute)
{
	struct wsa5__ReferenceParametersType *_p = ::soap_new_wsa5__ReferenceParametersType(soap);
	if (_p)
	{	::soap_default_wsa5__ReferenceParametersType(soap, _p);
		_p->chan__ChannelInstance = chan__ChannelInstance;
		_p->__size = __size;
		_p->__any = __any;
		_p->__anyAttribute = __anyAttribute;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap*, const struct wsa5__ReferenceParametersType *, const char*, const char*);

inline int soap_write_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_wsa5__ReferenceParametersType(soap, p), 0) || ::soap_put_wsa5__ReferenceParametersType(soap, p, "wsa5:ReferenceParametersType", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsa5__ReferenceParametersType(struct soap *soap, const char *URL, struct wsa5__ReferenceParametersType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__ReferenceParametersType(soap, p), 0) || ::soap_put_wsa5__ReferenceParametersType(soap, p, "wsa5:ReferenceParametersType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsa5__ReferenceParametersType(struct soap *soap, const char *URL, struct wsa5__ReferenceParametersType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__ReferenceParametersType(soap, p), 0) || ::soap_put_wsa5__ReferenceParametersType(soap, p, "wsa5:ReferenceParametersType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsa5__ReferenceParametersType(struct soap *soap, const char *URL, struct wsa5__ReferenceParametersType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__ReferenceParametersType(soap, p), 0) || ::soap_put_wsa5__ReferenceParametersType(soap, p, "wsa5:ReferenceParametersType", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap*, struct wsa5__ReferenceParametersType *, const char*, const char*);

inline int soap_read_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p)
{
	if (p)
	{	::soap_default_wsa5__ReferenceParametersType(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_wsa5__ReferenceParametersType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsa5__ReferenceParametersType(struct soap *soap, const char *URL, struct wsa5__ReferenceParametersType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsa5__ReferenceParametersType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p)
{
	if (::soap_read_wsa5__ReferenceParametersType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsa5__EndpointReferenceType_DEFINED
#define SOAP_TYPE_wsa5__EndpointReferenceType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap*, struct wsa5__EndpointReferenceType *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap*, const struct wsa5__EndpointReferenceType *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap*, const char*, int, const struct wsa5__EndpointReferenceType *, const char*);
SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap*, const char*, struct wsa5__EndpointReferenceType *, const char*);
SOAP_FMAC1 struct wsa5__EndpointReferenceType * SOAP_FMAC2 imageing_instantiate_wsa5__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);

inline struct wsa5__EndpointReferenceType * soap_new_wsa5__EndpointReferenceType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_wsa5__EndpointReferenceType(soap, n, NULL, NULL, NULL);
}

inline struct wsa5__EndpointReferenceType * soap_new_req_wsa5__EndpointReferenceType(
	struct soap *soap,
	char *Address,
	int __size,
	char **__any)
{
	struct wsa5__EndpointReferenceType *_p = ::soap_new_wsa5__EndpointReferenceType(soap);
	if (_p)
	{	::soap_default_wsa5__EndpointReferenceType(soap, _p);
		_p->Address = Address;
		_p->__size = __size;
		_p->__any = __any;
	}
	return _p;
}

inline struct wsa5__EndpointReferenceType * soap_new_set_wsa5__EndpointReferenceType(
	struct soap *soap,
	char *Address,
	struct wsa5__ReferenceParametersType *ReferenceParameters,
	struct wsa5__MetadataType *Metadata,
	int __size,
	char **__any,
	char *__anyAttribute)
{
	struct wsa5__EndpointReferenceType *_p = ::soap_new_wsa5__EndpointReferenceType(soap);
	if (_p)
	{	::soap_default_wsa5__EndpointReferenceType(soap, _p);
		_p->Address = Address;
		_p->ReferenceParameters = ReferenceParameters;
		_p->Metadata = Metadata;
		_p->__size = __size;
		_p->__any = __any;
		_p->__anyAttribute = __anyAttribute;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap*, const struct wsa5__EndpointReferenceType *, const char*, const char*);

inline int soap_write_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_wsa5__EndpointReferenceType(soap, p), 0) || ::soap_put_wsa5__EndpointReferenceType(soap, p, "wsa5:EndpointReferenceType", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsa5__EndpointReferenceType(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__EndpointReferenceType(soap, p), 0) || ::soap_put_wsa5__EndpointReferenceType(soap, p, "wsa5:EndpointReferenceType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsa5__EndpointReferenceType(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__EndpointReferenceType(soap, p), 0) || ::soap_put_wsa5__EndpointReferenceType(soap, p, "wsa5:EndpointReferenceType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsa5__EndpointReferenceType(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_wsa5__EndpointReferenceType(soap, p), 0) || ::soap_put_wsa5__EndpointReferenceType(soap, p, "wsa5:EndpointReferenceType", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap*, struct wsa5__EndpointReferenceType *, const char*, const char*);

inline int soap_read_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p)
{
	if (p)
	{	::soap_default_wsa5__EndpointReferenceType(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_wsa5__EndpointReferenceType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsa5__EndpointReferenceType(struct soap *soap, const char *URL, struct wsa5__EndpointReferenceType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsa5__EndpointReferenceType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p)
{
	if (::soap_read_wsa5__EndpointReferenceType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__xop__Include_DEFINED
#define SOAP_TYPE__xop__Include_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default__xop__Include(struct soap*, struct _xop__Include *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xop__Include(struct soap*, const struct _xop__Include *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out__xop__Include(struct soap*, const char*, int, const struct _xop__Include *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap__xop__Include2s(struct soap*, struct _xop__Include);
SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_in__xop__Include(struct soap*, const char*, struct _xop__Include *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2_xop__Include(struct soap*, const char*, struct _xop__Include *);
SOAP_FMAC1 struct _xop__Include * SOAP_FMAC2 imageing_instantiate__xop__Include(struct soap*, int, const char*, const char*, size_t*);

inline struct _xop__Include * soap_new__xop__Include(struct soap *soap, int n = -1)
{
	return imageing_instantiate__xop__Include(soap, n, NULL, NULL, NULL);
}

inline struct _xop__Include * soap_new_req__xop__Include(
	struct soap *soap)
{
	struct _xop__Include *_p = ::soap_new__xop__Include(soap);
	if (_p)
	{	::soap_default__xop__Include(soap, _p);
	}
	return _p;
}

inline struct _xop__Include * soap_new_set__xop__Include(
	struct soap *soap,
	unsigned char *__ptr,
	int __size,
	char *id,
	char *type,
	char *options)
{
	struct _xop__Include *_p = ::soap_new__xop__Include(soap);
	if (_p)
	{	::soap_default__xop__Include(soap, _p);
		_p->__ptr = __ptr;
		_p->__size = __size;
		_p->id = id;
		_p->type = type;
		_p->options = options;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put__xop__Include(struct soap*, const struct _xop__Include *, const char*, const char*);

inline int soap_write__xop__Include(struct soap *soap, struct _xop__Include const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize__xop__Include(soap, p), 0) || ::soap_put__xop__Include(soap, p, "xop:Include", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT__xop__Include(struct soap *soap, const char *URL, struct _xop__Include const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__xop__Include(soap, p), 0) || ::soap_put__xop__Include(soap, p, "xop:Include", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__xop__Include(struct soap *soap, const char *URL, struct _xop__Include const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__xop__Include(soap, p), 0) || ::soap_put__xop__Include(soap, p, "xop:Include", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__xop__Include(struct soap *soap, const char *URL, struct _xop__Include const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize__xop__Include(soap, p), 0) || ::soap_put__xop__Include(soap, p, "xop:Include", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_get__xop__Include(struct soap*, struct _xop__Include *, const char*, const char*);

inline int soap_read__xop__Include(struct soap *soap, struct _xop__Include *p)
{
	if (p)
	{	::soap_default__xop__Include(soap, p);
		if (soap_begin_recv(soap) || ::soap_get__xop__Include(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__xop__Include(struct soap *soap, const char *URL, struct _xop__Include *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__xop__Include(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__xop__Include(struct soap *soap, struct _xop__Include *p)
{
	if (::soap_read__xop__Include(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_PointerTo_timg__SetCurrentPreset_DEFINED
#define SOAP_TYPE_PointerTo_timg__SetCurrentPreset_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__SetCurrentPreset(struct soap*, _timg__SetCurrentPreset *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__SetCurrentPreset(struct soap*, const char *, int, _timg__SetCurrentPreset *const*, const char *);
SOAP_FMAC3 _timg__SetCurrentPreset ** SOAP_FMAC4 soap_in_PointerTo_timg__SetCurrentPreset(struct soap*, const char*, _timg__SetCurrentPreset **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__SetCurrentPreset(struct soap*, _timg__SetCurrentPreset *const*, const char*, const char*);
SOAP_FMAC3 _timg__SetCurrentPreset ** SOAP_FMAC4 soap_get_PointerTo_timg__SetCurrentPreset(struct soap*, _timg__SetCurrentPreset **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_timg__GetCurrentPreset_DEFINED
#define SOAP_TYPE_PointerTo_timg__GetCurrentPreset_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetCurrentPreset(struct soap*, _timg__GetCurrentPreset *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetCurrentPreset(struct soap*, const char *, int, _timg__GetCurrentPreset *const*, const char *);
SOAP_FMAC3 _timg__GetCurrentPreset ** SOAP_FMAC4 soap_in_PointerTo_timg__GetCurrentPreset(struct soap*, const char*, _timg__GetCurrentPreset **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetCurrentPreset(struct soap*, _timg__GetCurrentPreset *const*, const char*, const char*);
SOAP_FMAC3 _timg__GetCurrentPreset ** SOAP_FMAC4 soap_get_PointerTo_timg__GetCurrentPreset(struct soap*, _timg__GetCurrentPreset **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_timg__GetPresets_DEFINED
#define SOAP_TYPE_PointerTo_timg__GetPresets_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetPresets(struct soap*, _timg__GetPresets *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetPresets(struct soap*, const char *, int, _timg__GetPresets *const*, const char *);
SOAP_FMAC3 _timg__GetPresets ** SOAP_FMAC4 soap_in_PointerTo_timg__GetPresets(struct soap*, const char*, _timg__GetPresets **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetPresets(struct soap*, _timg__GetPresets *const*, const char*, const char*);
SOAP_FMAC3 _timg__GetPresets ** SOAP_FMAC4 soap_get_PointerTo_timg__GetPresets(struct soap*, _timg__GetPresets **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_timg__GetMoveOptions_DEFINED
#define SOAP_TYPE_PointerTo_timg__GetMoveOptions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetMoveOptions(struct soap*, _timg__GetMoveOptions *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetMoveOptions(struct soap*, const char *, int, _timg__GetMoveOptions *const*, const char *);
SOAP_FMAC3 _timg__GetMoveOptions ** SOAP_FMAC4 soap_in_PointerTo_timg__GetMoveOptions(struct soap*, const char*, _timg__GetMoveOptions **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetMoveOptions(struct soap*, _timg__GetMoveOptions *const*, const char*, const char*);
SOAP_FMAC3 _timg__GetMoveOptions ** SOAP_FMAC4 soap_get_PointerTo_timg__GetMoveOptions(struct soap*, _timg__GetMoveOptions **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_timg__GetStatus_DEFINED
#define SOAP_TYPE_PointerTo_timg__GetStatus_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetStatus(struct soap*, _timg__GetStatus *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetStatus(struct soap*, const char *, int, _timg__GetStatus *const*, const char *);
SOAP_FMAC3 _timg__GetStatus ** SOAP_FMAC4 soap_in_PointerTo_timg__GetStatus(struct soap*, const char*, _timg__GetStatus **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetStatus(struct soap*, _timg__GetStatus *const*, const char*, const char*);
SOAP_FMAC3 _timg__GetStatus ** SOAP_FMAC4 soap_get_PointerTo_timg__GetStatus(struct soap*, _timg__GetStatus **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_timg__Stop_DEFINED
#define SOAP_TYPE_PointerTo_timg__Stop_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__Stop(struct soap*, _timg__Stop *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__Stop(struct soap*, const char *, int, _timg__Stop *const*, const char *);
SOAP_FMAC3 _timg__Stop ** SOAP_FMAC4 soap_in_PointerTo_timg__Stop(struct soap*, const char*, _timg__Stop **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__Stop(struct soap*, _timg__Stop *const*, const char*, const char*);
SOAP_FMAC3 _timg__Stop ** SOAP_FMAC4 soap_get_PointerTo_timg__Stop(struct soap*, _timg__Stop **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_timg__Move_DEFINED
#define SOAP_TYPE_PointerTo_timg__Move_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__Move(struct soap*, _timg__Move *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__Move(struct soap*, const char *, int, _timg__Move *const*, const char *);
SOAP_FMAC3 _timg__Move ** SOAP_FMAC4 soap_in_PointerTo_timg__Move(struct soap*, const char*, _timg__Move **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__Move(struct soap*, _timg__Move *const*, const char*, const char*);
SOAP_FMAC3 _timg__Move ** SOAP_FMAC4 soap_get_PointerTo_timg__Move(struct soap*, _timg__Move **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_timg__GetOptions_DEFINED
#define SOAP_TYPE_PointerTo_timg__GetOptions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetOptions(struct soap*, _timg__GetOptions *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetOptions(struct soap*, const char *, int, _timg__GetOptions *const*, const char *);
SOAP_FMAC3 _timg__GetOptions ** SOAP_FMAC4 soap_in_PointerTo_timg__GetOptions(struct soap*, const char*, _timg__GetOptions **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetOptions(struct soap*, _timg__GetOptions *const*, const char*, const char*);
SOAP_FMAC3 _timg__GetOptions ** SOAP_FMAC4 soap_get_PointerTo_timg__GetOptions(struct soap*, _timg__GetOptions **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_timg__SetImagingSettings_DEFINED
#define SOAP_TYPE_PointerTo_timg__SetImagingSettings_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__SetImagingSettings(struct soap*, _timg__SetImagingSettings *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__SetImagingSettings(struct soap*, const char *, int, _timg__SetImagingSettings *const*, const char *);
SOAP_FMAC3 _timg__SetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__SetImagingSettings(struct soap*, const char*, _timg__SetImagingSettings **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__SetImagingSettings(struct soap*, _timg__SetImagingSettings *const*, const char*, const char*);
SOAP_FMAC3 _timg__SetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__SetImagingSettings(struct soap*, _timg__SetImagingSettings **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_timg__GetImagingSettings_DEFINED
#define SOAP_TYPE_PointerTo_timg__GetImagingSettings_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetImagingSettings(struct soap*, _timg__GetImagingSettings *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetImagingSettings(struct soap*, const char *, int, _timg__GetImagingSettings *const*, const char *);
SOAP_FMAC3 _timg__GetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__GetImagingSettings(struct soap*, const char*, _timg__GetImagingSettings **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetImagingSettings(struct soap*, _timg__GetImagingSettings *const*, const char*, const char*);
SOAP_FMAC3 _timg__GetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__GetImagingSettings(struct soap*, _timg__GetImagingSettings **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_timg__GetServiceCapabilities_DEFINED
#define SOAP_TYPE_PointerTo_timg__GetServiceCapabilities_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetServiceCapabilities(struct soap*, _timg__GetServiceCapabilities *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetServiceCapabilities(struct soap*, const char *, int, _timg__GetServiceCapabilities *const*, const char *);
SOAP_FMAC3 _timg__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_timg__GetServiceCapabilities(struct soap*, const char*, _timg__GetServiceCapabilities **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetServiceCapabilities(struct soap*, _timg__GetServiceCapabilities *const*, const char*, const char*);
SOAP_FMAC3 _timg__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_timg__GetServiceCapabilities(struct soap*, _timg__GetServiceCapabilities **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxsd__NCName_DEFINED
#define SOAP_TYPE_PointerToxsd__NCName_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NCName(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NCName(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__NCName(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NCName(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__NCName(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowstop__ConcreteTopicExpression_DEFINED
#define SOAP_TYPE_PointerTowstop__ConcreteTopicExpression_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__ConcreteTopicExpression(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__ConcreteTopicExpression(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowstop__ConcreteTopicExpression(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__ConcreteTopicExpression(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowstop__ConcreteTopicExpression(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxsd__QName_DEFINED
#define SOAP_TYPE_PointerToxsd__QName_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__QName(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__QName(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__QName(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__QName(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__QName(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowstop__TopicType_DEFINED
#define SOAP_TYPE_PointerTowstop__TopicType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicType(struct soap*, wstop__TopicType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicType(struct soap*, const char *, int, wstop__TopicType *const*, const char *);
SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicType(struct soap*, const char*, wstop__TopicType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicType(struct soap*, wstop__TopicType *const*, const char*, const char*);
SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicType(struct soap*, wstop__TopicType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowstop__QueryExpressionType_DEFINED
#define SOAP_TYPE_PointerTowstop__QueryExpressionType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__QueryExpressionType(struct soap*, wstop__QueryExpressionType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__QueryExpressionType(struct soap*, const char *, int, wstop__QueryExpressionType *const*, const char *);
SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTowstop__QueryExpressionType(struct soap*, const char*, wstop__QueryExpressionType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__QueryExpressionType(struct soap*, wstop__QueryExpressionType *const*, const char*, const char*);
SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTowstop__QueryExpressionType(struct soap*, wstop__QueryExpressionType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__PTZConfigurationExtension_DEFINED
#define SOAP_TYPE_PointerTott__PTZConfigurationExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension(struct soap*, tt__PTZConfigurationExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension(struct soap*, const char *, int, tt__PTZConfigurationExtension *const*, const char *);
SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension(struct soap*, const char*, tt__PTZConfigurationExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension(struct soap*, tt__PTZConfigurationExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension(struct soap*, tt__PTZConfigurationExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ZoomLimits_DEFINED
#define SOAP_TYPE_PointerTott__ZoomLimits_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ZoomLimits(struct soap*, tt__ZoomLimits *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ZoomLimits(struct soap*, const char *, int, tt__ZoomLimits *const*, const char *);
SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_in_PointerTott__ZoomLimits(struct soap*, const char*, tt__ZoomLimits **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ZoomLimits(struct soap*, tt__ZoomLimits *const*, const char*, const char*);
SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_get_PointerTott__ZoomLimits(struct soap*, tt__ZoomLimits **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__PanTiltLimits_DEFINED
#define SOAP_TYPE_PointerTott__PanTiltLimits_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PanTiltLimits(struct soap*, tt__PanTiltLimits *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PanTiltLimits(struct soap*, const char *, int, tt__PanTiltLimits *const*, const char *);
SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_in_PointerTott__PanTiltLimits(struct soap*, const char*, tt__PanTiltLimits **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PanTiltLimits(struct soap*, tt__PanTiltLimits *const*, const char*, const char*);
SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_get_PointerTott__PanTiltLimits(struct soap*, tt__PanTiltLimits **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__PTZSpeed_DEFINED
#define SOAP_TYPE_PointerTott__PTZSpeed_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpeed(struct soap*, tt__PTZSpeed *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpeed(struct soap*, const char *, int, tt__PTZSpeed *const*, const char *);
SOAP_FMAC3 tt__PTZSpeed ** SOAP_FMAC4 soap_in_PointerTott__PTZSpeed(struct soap*, const char*, tt__PTZSpeed **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpeed(struct soap*, tt__PTZSpeed *const*, const char*, const char*);
SOAP_FMAC3 tt__PTZSpeed ** SOAP_FMAC4 soap_get_PointerTott__PTZSpeed(struct soap*, tt__PTZSpeed **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__MetadataConfigurationExtension_DEFINED
#define SOAP_TYPE_PointerTott__MetadataConfigurationExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationExtension(struct soap*, tt__MetadataConfigurationExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationExtension(struct soap*, const char *, int, tt__MetadataConfigurationExtension *const*, const char *);
SOAP_FMAC3 tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationExtension(struct soap*, const char*, tt__MetadataConfigurationExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationExtension(struct soap*, tt__MetadataConfigurationExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationExtension(struct soap*, tt__MetadataConfigurationExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__EventSubscription_DEFINED
#define SOAP_TYPE_PointerTott__EventSubscription_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventSubscription(struct soap*, tt__EventSubscription *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventSubscription(struct soap*, const char *, int, tt__EventSubscription *const*, const char *);
SOAP_FMAC3 tt__EventSubscription ** SOAP_FMAC4 soap_in_PointerTott__EventSubscription(struct soap*, const char*, tt__EventSubscription **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventSubscription(struct soap*, tt__EventSubscription *const*, const char*, const char*);
SOAP_FMAC3 tt__EventSubscription ** SOAP_FMAC4 soap_get_PointerTott__EventSubscription(struct soap*, tt__EventSubscription **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__PTZFilter_DEFINED
#define SOAP_TYPE_PointerTott__PTZFilter_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZFilter(struct soap*, tt__PTZFilter *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZFilter(struct soap*, const char *, int, tt__PTZFilter *const*, const char *);
SOAP_FMAC3 tt__PTZFilter ** SOAP_FMAC4 soap_in_PointerTott__PTZFilter(struct soap*, const char*, tt__PTZFilter **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZFilter(struct soap*, tt__PTZFilter *const*, const char*, const char*);
SOAP_FMAC3 tt__PTZFilter ** SOAP_FMAC4 soap_get_PointerTott__PTZFilter(struct soap*, tt__PTZFilter **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__RuleEngineConfiguration_DEFINED
#define SOAP_TYPE_PointerTott__RuleEngineConfiguration_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfiguration(struct soap*, tt__RuleEngineConfiguration *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfiguration(struct soap*, const char *, int, tt__RuleEngineConfiguration *const*, const char *);
SOAP_FMAC3 tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfiguration(struct soap*, const char*, tt__RuleEngineConfiguration **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfiguration(struct soap*, tt__RuleEngineConfiguration *const*, const char*, const char*);
SOAP_FMAC3 tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfiguration(struct soap*, tt__RuleEngineConfiguration **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration_DEFINED
#define SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfiguration(struct soap*, tt__AnalyticsEngineConfiguration *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfiguration(struct soap*, const char *, int, tt__AnalyticsEngineConfiguration *const*, const char *);
SOAP_FMAC3 tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfiguration(struct soap*, const char*, tt__AnalyticsEngineConfiguration **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfiguration(struct soap*, tt__AnalyticsEngineConfiguration *const*, const char*, const char*);
SOAP_FMAC3 tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfiguration(struct soap*, tt__AnalyticsEngineConfiguration **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__MulticastConfiguration_DEFINED
#define SOAP_TYPE_PointerTott__MulticastConfiguration_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MulticastConfiguration(struct soap*, tt__MulticastConfiguration *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MulticastConfiguration(struct soap*, const char *, int, tt__MulticastConfiguration *const*, const char *);
SOAP_FMAC3 tt__MulticastConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MulticastConfiguration(struct soap*, const char*, tt__MulticastConfiguration **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MulticastConfiguration(struct soap*, tt__MulticastConfiguration *const*, const char*, const char*);
SOAP_FMAC3 tt__MulticastConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MulticastConfiguration(struct soap*, tt__MulticastConfiguration **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__H264Configuration_DEFINED
#define SOAP_TYPE_PointerTott__H264Configuration_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Configuration(struct soap*, tt__H264Configuration *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Configuration(struct soap*, const char *, int, tt__H264Configuration *const*, const char *);
SOAP_FMAC3 tt__H264Configuration ** SOAP_FMAC4 soap_in_PointerTott__H264Configuration(struct soap*, const char*, tt__H264Configuration **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Configuration(struct soap*, tt__H264Configuration *const*, const char*, const char*);
SOAP_FMAC3 tt__H264Configuration ** SOAP_FMAC4 soap_get_PointerTott__H264Configuration(struct soap*, tt__H264Configuration **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__Mpeg4Configuration_DEFINED
#define SOAP_TYPE_PointerTott__Mpeg4Configuration_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Configuration(struct soap*, tt__Mpeg4Configuration *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Configuration(struct soap*, const char *, int, tt__Mpeg4Configuration *const*, const char *);
SOAP_FMAC3 tt__Mpeg4Configuration ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Configuration(struct soap*, const char*, tt__Mpeg4Configuration **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Configuration(struct soap*, tt__Mpeg4Configuration *const*, const char*, const char*);
SOAP_FMAC3 tt__Mpeg4Configuration ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Configuration(struct soap*, tt__Mpeg4Configuration **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__VideoRateControl_DEFINED
#define SOAP_TYPE_PointerTott__VideoRateControl_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl(struct soap*, tt__VideoRateControl *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl(struct soap*, const char *, int, tt__VideoRateControl *const*, const char *);
SOAP_FMAC3 tt__VideoRateControl ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl(struct soap*, const char*, tt__VideoRateControl **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl(struct soap*, tt__VideoRateControl *const*, const char*, const char*);
SOAP_FMAC3 tt__VideoRateControl ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl(struct soap*, tt__VideoRateControl **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__VideoResolution_DEFINED
#define SOAP_TYPE_PointerTott__VideoResolution_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoResolution(struct soap*, tt__VideoResolution *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoResolution(struct soap*, const char *, int, tt__VideoResolution *const*, const char *);
SOAP_FMAC3 tt__VideoResolution ** SOAP_FMAC4 soap_in_PointerTott__VideoResolution(struct soap*, const char*, tt__VideoResolution **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoResolution(struct soap*, tt__VideoResolution *const*, const char*, const char*);
SOAP_FMAC3 tt__VideoResolution ** SOAP_FMAC4 soap_get_PointerTott__VideoResolution(struct soap*, tt__VideoResolution **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension_DEFINED
#define SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension(struct soap*, tt__VideoSourceConfigurationExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension(struct soap*, const char *, int, tt__VideoSourceConfigurationExtension *const*, const char *);
SOAP_FMAC3 tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension(struct soap*, const char*, tt__VideoSourceConfigurationExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension(struct soap*, tt__VideoSourceConfigurationExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension(struct soap*, tt__VideoSourceConfigurationExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__IntRectangle_DEFINED
#define SOAP_TYPE_PointerTott__IntRectangle_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangle(struct soap*, tt__IntRectangle *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangle(struct soap*, const char *, int, tt__IntRectangle *const*, const char *);
SOAP_FMAC3 tt__IntRectangle ** SOAP_FMAC4 soap_in_PointerTott__IntRectangle(struct soap*, const char*, tt__IntRectangle **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangle(struct soap*, tt__IntRectangle *const*, const char*, const char*);
SOAP_FMAC3 tt__IntRectangle ** SOAP_FMAC4 soap_get_PointerTott__IntRectangle(struct soap*, tt__IntRectangle **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowstop__Documentation_DEFINED
#define SOAP_TYPE_PointerTowstop__Documentation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__Documentation(struct soap*, wstop__Documentation *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__Documentation(struct soap*, const char *, int, wstop__Documentation *const*, const char *);
SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_in_PointerTowstop__Documentation(struct soap*, const char*, wstop__Documentation **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__Documentation(struct soap*, wstop__Documentation *const*, const char*, const char*);
SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_get_PointerTowstop__Documentation(struct soap*, wstop__Documentation **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause_DEFINED
#define SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap*, _wsrfbf__BaseFaultType_FaultCause *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap*, const char *, int, _wsrfbf__BaseFaultType_FaultCause *const*, const char *);
SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap*, const char*, _wsrfbf__BaseFaultType_FaultCause **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap*, _wsrfbf__BaseFaultType_FaultCause *const*, const char*, const char*);
SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap*, _wsrfbf__BaseFaultType_FaultCause **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_xml__lang_DEFINED
#define SOAP_TYPE_PointerTo_xml__lang_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xml__lang(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xml__lang(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTo_xml__lang(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xml__lang(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTo_xml__lang(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode_DEFINED
#define SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap*, _wsrfbf__BaseFaultType_ErrorCode *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap*, const char *, int, _wsrfbf__BaseFaultType_ErrorCode *const*, const char *);
SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap*, const char*, _wsrfbf__BaseFaultType_ErrorCode **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap*, _wsrfbf__BaseFaultType_ErrorCode *const*, const char*, const char*);
SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap*, _wsrfbf__BaseFaultType_ErrorCode **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxsd__nonNegativeInteger_DEFINED
#define SOAP_TYPE_PointerToxsd__nonNegativeInteger_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__nonNegativeInteger(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__nonNegativeInteger(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__nonNegativeInteger(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__nonNegativeInteger(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__nonNegativeInteger(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy_DEFINED
#define SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap*, _wsnt__Subscribe_SubscriptionPolicy *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap*, const char *, int, _wsnt__Subscribe_SubscriptionPolicy *const*, const char *);
SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap*, const char*, _wsnt__Subscribe_SubscriptionPolicy **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap*, _wsnt__Subscribe_SubscriptionPolicy *const*, const char*, const char*);
SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap*, _wsnt__Subscribe_SubscriptionPolicy **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType_DEFINED
#define SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType_DEFINED
#define SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotificationMessageHolderType(struct soap*, wsnt__NotificationMessageHolderType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotificationMessageHolderType(struct soap*, const char *, int, wsnt__NotificationMessageHolderType *const*, const char *);
SOAP_FMAC3 wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotificationMessageHolderType(struct soap*, const char*, wsnt__NotificationMessageHolderType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotificationMessageHolderType(struct soap*, wsnt__NotificationMessageHolderType *const*, const char*, const char*);
SOAP_FMAC3 wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotificationMessageHolderType(struct soap*, wsnt__NotificationMessageHolderType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTodateTime_DEFINED
#define SOAP_TYPE_PointerTodateTime_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap*, time_t *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap*, const char *, int, time_t *const*, const char *);
SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap*, const char*, time_t **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap*, time_t *const*, const char*, const char*);
SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap*, time_t **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType_DEFINED
#define SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscriptionPolicyType(struct soap*, wsnt__SubscriptionPolicyType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscriptionPolicyType(struct soap*, const char *, int, wsnt__SubscriptionPolicyType *const*, const char *);
SOAP_FMAC3 wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscriptionPolicyType(struct soap*, const char*, wsnt__SubscriptionPolicyType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscriptionPolicyType(struct soap*, wsnt__SubscriptionPolicyType *const*, const char*, const char*);
SOAP_FMAC3 wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscriptionPolicyType(struct soap*, wsnt__SubscriptionPolicyType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowstop__TopicSetType_DEFINED
#define SOAP_TYPE_PointerTowstop__TopicSetType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicSetType(struct soap*, wstop__TopicSetType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicSetType(struct soap*, const char *, int, wstop__TopicSetType *const*, const char *);
SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicSetType(struct soap*, const char*, wstop__TopicSetType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicSetType(struct soap*, wstop__TopicSetType *const*, const char*, const char*);
SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicSetType(struct soap*, wstop__TopicSetType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsnt__TopicExpressionType_DEFINED
#define SOAP_TYPE_PointerTowsnt__TopicExpressionType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionType(struct soap*, wsnt__TopicExpressionType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionType(struct soap*, const char *, int, wsnt__TopicExpressionType *const*, const char *);
SOAP_FMAC3 wsnt__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionType(struct soap*, const char*, wsnt__TopicExpressionType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionType(struct soap*, wsnt__TopicExpressionType *const*, const char*, const char*);
SOAP_FMAC3 wsnt__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionType(struct soap*, wsnt__TopicExpressionType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsa5__EndpointReferenceType_DEFINED
#define SOAP_TYPE_PointerTowsa5__EndpointReferenceType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap*, struct wsa5__EndpointReferenceType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap*, const char *, int, struct wsa5__EndpointReferenceType *const*, const char *);
SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap*, const char*, struct wsa5__EndpointReferenceType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap*, struct wsa5__EndpointReferenceType *const*, const char*, const char*);
SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap*, struct wsa5__EndpointReferenceType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__PropertyOperation_DEFINED
#define SOAP_TYPE_PointerTott__PropertyOperation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PropertyOperation(struct soap*, enum tt__PropertyOperation *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PropertyOperation(struct soap*, const char *, int, enum tt__PropertyOperation *const*, const char *);
SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_in_PointerTott__PropertyOperation(struct soap*, const char*, enum tt__PropertyOperation **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PropertyOperation(struct soap*, enum tt__PropertyOperation *const*, const char*, const char*);
SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_get_PointerTott__PropertyOperation(struct soap*, enum tt__PropertyOperation **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__MessageExtension_DEFINED
#define SOAP_TYPE_PointerTott__MessageExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageExtension(struct soap*, tt__MessageExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageExtension(struct soap*, const char *, int, tt__MessageExtension *const*, const char *);
SOAP_FMAC3 tt__MessageExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageExtension(struct soap*, const char*, tt__MessageExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageExtension(struct soap*, tt__MessageExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__MessageExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageExtension(struct soap*, tt__MessageExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxsd__anyURI_DEFINED
#define SOAP_TYPE_PointerToxsd__anyURI_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ItemList_DEFINED
#define SOAP_TYPE_PointerTott__ItemList_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemList(struct soap*, tt__ItemList *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemList(struct soap*, const char *, int, tt__ItemList *const*, const char *);
SOAP_FMAC3 tt__ItemList ** SOAP_FMAC4 soap_in_PointerTott__ItemList(struct soap*, const char*, tt__ItemList **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemList(struct soap*, tt__ItemList *const*, const char*, const char*);
SOAP_FMAC3 tt__ItemList ** SOAP_FMAC4 soap_get_PointerTott__ItemList(struct soap*, tt__ItemList **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension_DEFINED
#define SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfigurationExtension(struct soap*, tt__RuleEngineConfigurationExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfigurationExtension(struct soap*, const char *, int, tt__RuleEngineConfigurationExtension *const*, const char *);
SOAP_FMAC3 tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfigurationExtension(struct soap*, const char*, tt__RuleEngineConfigurationExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfigurationExtension(struct soap*, tt__RuleEngineConfigurationExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfigurationExtension(struct soap*, tt__RuleEngineConfigurationExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension_DEFINED
#define SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(struct soap*, tt__AnalyticsEngineConfigurationExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfigurationExtension(struct soap*, const char *, int, tt__AnalyticsEngineConfigurationExtension *const*, const char *);
SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfigurationExtension(struct soap*, const char*, tt__AnalyticsEngineConfigurationExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfigurationExtension(struct soap*, tt__AnalyticsEngineConfigurationExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfigurationExtension(struct soap*, tt__AnalyticsEngineConfigurationExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__Config_DEFINED
#define SOAP_TYPE_PointerTott__Config_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Config(struct soap*, tt__Config *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Config(struct soap*, const char *, int, tt__Config *const*, const char *);
SOAP_FMAC3 tt__Config ** SOAP_FMAC4 soap_in_PointerTott__Config(struct soap*, const char*, tt__Config **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Config(struct soap*, tt__Config *const*, const char*, const char*);
SOAP_FMAC3 tt__Config ** SOAP_FMAC4 soap_get_PointerTott__Config(struct soap*, tt__Config **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__Vector_DEFINED
#define SOAP_TYPE_PointerTott__Vector_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector(struct soap*, tt__Vector *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector(struct soap*, const char *, int, tt__Vector *const*, const char *);
SOAP_FMAC3 tt__Vector ** SOAP_FMAC4 soap_in_PointerTott__Vector(struct soap*, const char*, tt__Vector **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector(struct soap*, tt__Vector *const*, const char*, const char*);
SOAP_FMAC3 tt__Vector ** SOAP_FMAC4 soap_get_PointerTott__Vector(struct soap*, tt__Vector **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ItemListExtension_DEFINED
#define SOAP_TYPE_PointerTott__ItemListExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListExtension(struct soap*, tt__ItemListExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListExtension(struct soap*, const char *, int, tt__ItemListExtension *const*, const char *);
SOAP_FMAC3 tt__ItemListExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListExtension(struct soap*, const char*, tt__ItemListExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListExtension(struct soap*, tt__ItemListExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__ItemListExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListExtension(struct soap*, tt__ItemListExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__FocusOptions20Extension_DEFINED
#define SOAP_TYPE_PointerTott__FocusOptions20Extension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20Extension(struct soap*, tt__FocusOptions20Extension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20Extension(struct soap*, const char *, int, tt__FocusOptions20Extension *const*, const char *);
SOAP_FMAC3 tt__FocusOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20Extension(struct soap*, const char*, tt__FocusOptions20Extension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20Extension(struct soap*, tt__FocusOptions20Extension *const*, const char*, const char*);
SOAP_FMAC3 tt__FocusOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20Extension(struct soap*, tt__FocusOptions20Extension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension_DEFINED
#define SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20Extension(struct soap*, tt__WhiteBalanceOptions20Extension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20Extension(struct soap*, const char *, int, tt__WhiteBalanceOptions20Extension *const*, const char *);
SOAP_FMAC3 tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20Extension(struct soap*, const char*, tt__WhiteBalanceOptions20Extension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20Extension(struct soap*, tt__WhiteBalanceOptions20Extension *const*, const char*, const char*);
SOAP_FMAC3 tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20Extension(struct soap*, tt__WhiteBalanceOptions20Extension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__StringAttrList_DEFINED
#define SOAP_TYPE_PointerTott__StringAttrList_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StringAttrList(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StringAttrList(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__StringAttrList(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StringAttrList(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__StringAttrList(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__FocusConfiguration20Extension_DEFINED
#define SOAP_TYPE_PointerTott__FocusConfiguration20Extension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20Extension(struct soap*, tt__FocusConfiguration20Extension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20Extension(struct soap*, const char *, int, tt__FocusConfiguration20Extension *const*, const char *);
SOAP_FMAC3 tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20Extension(struct soap*, const char*, tt__FocusConfiguration20Extension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20Extension(struct soap*, tt__FocusConfiguration20Extension *const*, const char*, const char*);
SOAP_FMAC3 tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20Extension(struct soap*, tt__FocusConfiguration20Extension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__WhiteBalance20Extension_DEFINED
#define SOAP_TYPE_PointerTott__WhiteBalance20Extension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20Extension(struct soap*, tt__WhiteBalance20Extension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20Extension(struct soap*, const char *, int, tt__WhiteBalance20Extension *const*, const char *);
SOAP_FMAC3 tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20Extension(struct soap*, const char*, tt__WhiteBalance20Extension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20Extension(struct soap*, tt__WhiteBalance20Extension *const*, const char*, const char*);
SOAP_FMAC3 tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20Extension(struct soap*, tt__WhiteBalance20Extension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ContinuousFocusOptions_DEFINED
#define SOAP_TYPE_PointerTott__ContinuousFocusOptions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ContinuousFocusOptions(struct soap*, tt__ContinuousFocusOptions *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ContinuousFocusOptions(struct soap*, const char *, int, tt__ContinuousFocusOptions *const*, const char *);
SOAP_FMAC3 tt__ContinuousFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__ContinuousFocusOptions(struct soap*, const char*, tt__ContinuousFocusOptions **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ContinuousFocusOptions(struct soap*, tt__ContinuousFocusOptions *const*, const char*, const char*);
SOAP_FMAC3 tt__ContinuousFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__ContinuousFocusOptions(struct soap*, tt__ContinuousFocusOptions **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__RelativeFocusOptions20_DEFINED
#define SOAP_TYPE_PointerTott__RelativeFocusOptions20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocusOptions20(struct soap*, tt__RelativeFocusOptions20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocusOptions20(struct soap*, const char *, int, tt__RelativeFocusOptions20 *const*, const char *);
SOAP_FMAC3 tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocusOptions20(struct soap*, const char*, tt__RelativeFocusOptions20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocusOptions20(struct soap*, tt__RelativeFocusOptions20 *const*, const char*, const char*);
SOAP_FMAC3 tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocusOptions20(struct soap*, tt__RelativeFocusOptions20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__AbsoluteFocusOptions_DEFINED
#define SOAP_TYPE_PointerTott__AbsoluteFocusOptions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AbsoluteFocusOptions(struct soap*, tt__AbsoluteFocusOptions *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AbsoluteFocusOptions(struct soap*, const char *, int, tt__AbsoluteFocusOptions *const*, const char *);
SOAP_FMAC3 tt__AbsoluteFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__AbsoluteFocusOptions(struct soap*, const char*, tt__AbsoluteFocusOptions **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AbsoluteFocusOptions(struct soap*, tt__AbsoluteFocusOptions *const*, const char*, const char*);
SOAP_FMAC3 tt__AbsoluteFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__AbsoluteFocusOptions(struct soap*, tt__AbsoluteFocusOptions **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension_DEFINED
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, tt__IrCutFilterAutoAdjustmentOptionsExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, const char *, int, tt__IrCutFilterAutoAdjustmentOptionsExtension *const*, const char *);
SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, const char*, tt__IrCutFilterAutoAdjustmentOptionsExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, tt__IrCutFilterAutoAdjustmentOptionsExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, tt__IrCutFilterAutoAdjustmentOptionsExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__DurationRange_DEFINED
#define SOAP_TYPE_PointerTott__DurationRange_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DurationRange(struct soap*, tt__DurationRange *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DurationRange(struct soap*, const char *, int, tt__DurationRange *const*, const char *);
SOAP_FMAC3 tt__DurationRange ** SOAP_FMAC4 soap_in_PointerTott__DurationRange(struct soap*, const char*, tt__DurationRange **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DurationRange(struct soap*, tt__DurationRange *const*, const char*, const char*);
SOAP_FMAC3 tt__DurationRange ** SOAP_FMAC4 soap_get_PointerTott__DurationRange(struct soap*, tt__DurationRange **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImageStabilizationOptionsExtension_DEFINED
#define SOAP_TYPE_PointerTott__ImageStabilizationOptionsExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationOptionsExtension(struct soap*, tt__ImageStabilizationOptionsExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationOptionsExtension(struct soap*, const char *, int, tt__ImageStabilizationOptionsExtension *const*, const char *);
SOAP_FMAC3 tt__ImageStabilizationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationOptionsExtension(struct soap*, const char*, tt__ImageStabilizationOptionsExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationOptionsExtension(struct soap*, tt__ImageStabilizationOptionsExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__ImageStabilizationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationOptionsExtension(struct soap*, tt__ImageStabilizationOptionsExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension4_DEFINED
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension4_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension4(struct soap*, tt__ImagingOptions20Extension4 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension4(struct soap*, const char *, int, tt__ImagingOptions20Extension4 *const*, const char *);
SOAP_FMAC3 tt__ImagingOptions20Extension4 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension4(struct soap*, const char*, tt__ImagingOptions20Extension4 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension4(struct soap*, tt__ImagingOptions20Extension4 *const*, const char*, const char*);
SOAP_FMAC3 tt__ImagingOptions20Extension4 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension4(struct soap*, tt__ImagingOptions20Extension4 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__NoiseReductionOptions_DEFINED
#define SOAP_TYPE_PointerTott__NoiseReductionOptions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NoiseReductionOptions(struct soap*, tt__NoiseReductionOptions *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NoiseReductionOptions(struct soap*, const char *, int, tt__NoiseReductionOptions *const*, const char *);
SOAP_FMAC3 tt__NoiseReductionOptions ** SOAP_FMAC4 soap_in_PointerTott__NoiseReductionOptions(struct soap*, const char*, tt__NoiseReductionOptions **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NoiseReductionOptions(struct soap*, tt__NoiseReductionOptions *const*, const char*, const char*);
SOAP_FMAC3 tt__NoiseReductionOptions ** SOAP_FMAC4 soap_get_PointerTott__NoiseReductionOptions(struct soap*, tt__NoiseReductionOptions **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__DefoggingOptions_DEFINED
#define SOAP_TYPE_PointerTott__DefoggingOptions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DefoggingOptions(struct soap*, tt__DefoggingOptions *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DefoggingOptions(struct soap*, const char *, int, tt__DefoggingOptions *const*, const char *);
SOAP_FMAC3 tt__DefoggingOptions ** SOAP_FMAC4 soap_in_PointerTott__DefoggingOptions(struct soap*, const char*, tt__DefoggingOptions **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DefoggingOptions(struct soap*, tt__DefoggingOptions *const*, const char*, const char*);
SOAP_FMAC3 tt__DefoggingOptions ** SOAP_FMAC4 soap_get_PointerTott__DefoggingOptions(struct soap*, tt__DefoggingOptions **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ToneCompensationOptions_DEFINED
#define SOAP_TYPE_PointerTott__ToneCompensationOptions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ToneCompensationOptions(struct soap*, tt__ToneCompensationOptions *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ToneCompensationOptions(struct soap*, const char *, int, tt__ToneCompensationOptions *const*, const char *);
SOAP_FMAC3 tt__ToneCompensationOptions ** SOAP_FMAC4 soap_in_PointerTott__ToneCompensationOptions(struct soap*, const char*, tt__ToneCompensationOptions **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ToneCompensationOptions(struct soap*, tt__ToneCompensationOptions *const*, const char*, const char*);
SOAP_FMAC3 tt__ToneCompensationOptions ** SOAP_FMAC4 soap_get_PointerTott__ToneCompensationOptions(struct soap*, tt__ToneCompensationOptions **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension3_DEFINED
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension3_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension3(struct soap*, tt__ImagingOptions20Extension3 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension3(struct soap*, const char *, int, tt__ImagingOptions20Extension3 *const*, const char *);
SOAP_FMAC3 tt__ImagingOptions20Extension3 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension3(struct soap*, const char*, tt__ImagingOptions20Extension3 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension3(struct soap*, tt__ImagingOptions20Extension3 *const*, const char*, const char*);
SOAP_FMAC3 tt__ImagingOptions20Extension3 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension3(struct soap*, tt__ImagingOptions20Extension3 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptions_DEFINED
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap*, tt__IrCutFilterAutoAdjustmentOptions *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap*, const char *, int, tt__IrCutFilterAutoAdjustmentOptions *const*, const char *);
SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap*, const char*, tt__IrCutFilterAutoAdjustmentOptions **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap*, tt__IrCutFilterAutoAdjustmentOptions *const*, const char*, const char*);
SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap*, tt__IrCutFilterAutoAdjustmentOptions **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension2_DEFINED
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension2_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension2(struct soap*, tt__ImagingOptions20Extension2 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension2(struct soap*, const char *, int, tt__ImagingOptions20Extension2 *const*, const char *);
SOAP_FMAC3 tt__ImagingOptions20Extension2 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension2(struct soap*, const char*, tt__ImagingOptions20Extension2 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension2(struct soap*, tt__ImagingOptions20Extension2 *const*, const char*, const char*);
SOAP_FMAC3 tt__ImagingOptions20Extension2 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension2(struct soap*, tt__ImagingOptions20Extension2 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImageStabilizationOptions_DEFINED
#define SOAP_TYPE_PointerTott__ImageStabilizationOptions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationOptions(struct soap*, tt__ImageStabilizationOptions *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationOptions(struct soap*, const char *, int, tt__ImageStabilizationOptions *const*, const char *);
SOAP_FMAC3 tt__ImageStabilizationOptions ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationOptions(struct soap*, const char*, tt__ImageStabilizationOptions **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationOptions(struct soap*, tt__ImageStabilizationOptions *const*, const char*, const char*);
SOAP_FMAC3 tt__ImageStabilizationOptions ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationOptions(struct soap*, tt__ImageStabilizationOptions **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension_DEFINED
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension(struct soap*, tt__ImagingOptions20Extension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension(struct soap*, const char *, int, tt__ImagingOptions20Extension *const*, const char *);
SOAP_FMAC3 tt__ImagingOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension(struct soap*, const char*, tt__ImagingOptions20Extension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension(struct soap*, tt__ImagingOptions20Extension *const*, const char*, const char*);
SOAP_FMAC3 tt__ImagingOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension(struct soap*, tt__ImagingOptions20Extension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__WhiteBalanceOptions20_DEFINED
#define SOAP_TYPE_PointerTott__WhiteBalanceOptions20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20(struct soap*, tt__WhiteBalanceOptions20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20(struct soap*, const char *, int, tt__WhiteBalanceOptions20 *const*, const char *);
SOAP_FMAC3 tt__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20(struct soap*, const char*, tt__WhiteBalanceOptions20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20(struct soap*, tt__WhiteBalanceOptions20 *const*, const char*, const char*);
SOAP_FMAC3 tt__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20(struct soap*, tt__WhiteBalanceOptions20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__WideDynamicRangeOptions20_DEFINED
#define SOAP_TYPE_PointerTott__WideDynamicRangeOptions20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRangeOptions20(struct soap*, tt__WideDynamicRangeOptions20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRangeOptions20(struct soap*, const char *, int, tt__WideDynamicRangeOptions20 *const*, const char *);
SOAP_FMAC3 tt__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRangeOptions20(struct soap*, const char*, tt__WideDynamicRangeOptions20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRangeOptions20(struct soap*, tt__WideDynamicRangeOptions20 *const*, const char*, const char*);
SOAP_FMAC3 tt__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRangeOptions20(struct soap*, tt__WideDynamicRangeOptions20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__FocusOptions20_DEFINED
#define SOAP_TYPE_PointerTott__FocusOptions20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20(struct soap*, tt__FocusOptions20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20(struct soap*, const char *, int, tt__FocusOptions20 *const*, const char *);
SOAP_FMAC3 tt__FocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20(struct soap*, const char*, tt__FocusOptions20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20(struct soap*, tt__FocusOptions20 *const*, const char*, const char*);
SOAP_FMAC3 tt__FocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20(struct soap*, tt__FocusOptions20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ExposureOptions20_DEFINED
#define SOAP_TYPE_PointerTott__ExposureOptions20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposureOptions20(struct soap*, tt__ExposureOptions20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposureOptions20(struct soap*, const char *, int, tt__ExposureOptions20 *const*, const char *);
SOAP_FMAC3 tt__ExposureOptions20 ** SOAP_FMAC4 soap_in_PointerTott__ExposureOptions20(struct soap*, const char*, tt__ExposureOptions20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposureOptions20(struct soap*, tt__ExposureOptions20 *const*, const char*, const char*);
SOAP_FMAC3 tt__ExposureOptions20 ** SOAP_FMAC4 soap_get_PointerTott__ExposureOptions20(struct soap*, tt__ExposureOptions20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__BacklightCompensationOptions20_DEFINED
#define SOAP_TYPE_PointerTott__BacklightCompensationOptions20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensationOptions20(struct soap*, tt__BacklightCompensationOptions20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensationOptions20(struct soap*, const char *, int, tt__BacklightCompensationOptions20 *const*, const char *);
SOAP_FMAC3 tt__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensationOptions20(struct soap*, const char*, tt__BacklightCompensationOptions20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensationOptions20(struct soap*, tt__BacklightCompensationOptions20 *const*, const char*, const char*);
SOAP_FMAC3 tt__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensationOptions20(struct soap*, tt__BacklightCompensationOptions20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__DefoggingExtension_DEFINED
#define SOAP_TYPE_PointerTott__DefoggingExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DefoggingExtension(struct soap*, tt__DefoggingExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DefoggingExtension(struct soap*, const char *, int, tt__DefoggingExtension *const*, const char *);
SOAP_FMAC3 tt__DefoggingExtension ** SOAP_FMAC4 soap_in_PointerTott__DefoggingExtension(struct soap*, const char*, tt__DefoggingExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DefoggingExtension(struct soap*, tt__DefoggingExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__DefoggingExtension ** SOAP_FMAC4 soap_get_PointerTott__DefoggingExtension(struct soap*, tt__DefoggingExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ToneCompensationExtension_DEFINED
#define SOAP_TYPE_PointerTott__ToneCompensationExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ToneCompensationExtension(struct soap*, tt__ToneCompensationExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ToneCompensationExtension(struct soap*, const char *, int, tt__ToneCompensationExtension *const*, const char *);
SOAP_FMAC3 tt__ToneCompensationExtension ** SOAP_FMAC4 soap_in_PointerTott__ToneCompensationExtension(struct soap*, const char*, tt__ToneCompensationExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ToneCompensationExtension(struct soap*, tt__ToneCompensationExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__ToneCompensationExtension ** SOAP_FMAC4 soap_get_PointerTott__ToneCompensationExtension(struct soap*, tt__ToneCompensationExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__Rectangle_DEFINED
#define SOAP_TYPE_PointerTott__Rectangle_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rectangle(struct soap*, tt__Rectangle *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rectangle(struct soap*, const char *, int, tt__Rectangle *const*, const char *);
SOAP_FMAC3 tt__Rectangle ** SOAP_FMAC4 soap_in_PointerTott__Rectangle(struct soap*, const char*, tt__Rectangle **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rectangle(struct soap*, tt__Rectangle *const*, const char*, const char*);
SOAP_FMAC3 tt__Rectangle ** SOAP_FMAC4 soap_get_PointerTott__Rectangle(struct soap*, tt__Rectangle **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ExposurePriority_DEFINED
#define SOAP_TYPE_PointerTott__ExposurePriority_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposurePriority(struct soap*, enum tt__ExposurePriority *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposurePriority(struct soap*, const char *, int, enum tt__ExposurePriority *const*, const char *);
SOAP_FMAC3 enum tt__ExposurePriority ** SOAP_FMAC4 soap_in_PointerTott__ExposurePriority(struct soap*, const char*, enum tt__ExposurePriority **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposurePriority(struct soap*, enum tt__ExposurePriority *const*, const char*, const char*);
SOAP_FMAC3 enum tt__ExposurePriority ** SOAP_FMAC4 soap_get_PointerTott__ExposurePriority(struct soap*, enum tt__ExposurePriority **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentExtension_DEFINED
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap*, tt__IrCutFilterAutoAdjustmentExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap*, const char *, int, tt__IrCutFilterAutoAdjustmentExtension *const*, const char *);
SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap*, const char*, tt__IrCutFilterAutoAdjustmentExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap*, tt__IrCutFilterAutoAdjustmentExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap*, tt__IrCutFilterAutoAdjustmentExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxsd__duration_DEFINED
#define SOAP_TYPE_PointerToxsd__duration_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImageStabilizationExtension_DEFINED
#define SOAP_TYPE_PointerTott__ImageStabilizationExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationExtension(struct soap*, tt__ImageStabilizationExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationExtension(struct soap*, const char *, int, tt__ImageStabilizationExtension *const*, const char *);
SOAP_FMAC3 tt__ImageStabilizationExtension ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationExtension(struct soap*, const char*, tt__ImageStabilizationExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationExtension(struct soap*, tt__ImageStabilizationExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__ImageStabilizationExtension ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationExtension(struct soap*, tt__ImageStabilizationExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension204_DEFINED
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension204_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension204(struct soap*, tt__ImagingSettingsExtension204 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension204(struct soap*, const char *, int, tt__ImagingSettingsExtension204 *const*, const char *);
SOAP_FMAC3 tt__ImagingSettingsExtension204 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension204(struct soap*, const char*, tt__ImagingSettingsExtension204 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension204(struct soap*, tt__ImagingSettingsExtension204 *const*, const char*, const char*);
SOAP_FMAC3 tt__ImagingSettingsExtension204 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension204(struct soap*, tt__ImagingSettingsExtension204 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__NoiseReduction_DEFINED
#define SOAP_TYPE_PointerTott__NoiseReduction_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NoiseReduction(struct soap*, tt__NoiseReduction *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NoiseReduction(struct soap*, const char *, int, tt__NoiseReduction *const*, const char *);
SOAP_FMAC3 tt__NoiseReduction ** SOAP_FMAC4 soap_in_PointerTott__NoiseReduction(struct soap*, const char*, tt__NoiseReduction **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NoiseReduction(struct soap*, tt__NoiseReduction *const*, const char*, const char*);
SOAP_FMAC3 tt__NoiseReduction ** SOAP_FMAC4 soap_get_PointerTott__NoiseReduction(struct soap*, tt__NoiseReduction **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__Defogging_DEFINED
#define SOAP_TYPE_PointerTott__Defogging_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Defogging(struct soap*, tt__Defogging *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Defogging(struct soap*, const char *, int, tt__Defogging *const*, const char *);
SOAP_FMAC3 tt__Defogging ** SOAP_FMAC4 soap_in_PointerTott__Defogging(struct soap*, const char*, tt__Defogging **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Defogging(struct soap*, tt__Defogging *const*, const char*, const char*);
SOAP_FMAC3 tt__Defogging ** SOAP_FMAC4 soap_get_PointerTott__Defogging(struct soap*, tt__Defogging **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ToneCompensation_DEFINED
#define SOAP_TYPE_PointerTott__ToneCompensation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ToneCompensation(struct soap*, tt__ToneCompensation *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ToneCompensation(struct soap*, const char *, int, tt__ToneCompensation *const*, const char *);
SOAP_FMAC3 tt__ToneCompensation ** SOAP_FMAC4 soap_in_PointerTott__ToneCompensation(struct soap*, const char*, tt__ToneCompensation **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ToneCompensation(struct soap*, tt__ToneCompensation *const*, const char*, const char*);
SOAP_FMAC3 tt__ToneCompensation ** SOAP_FMAC4 soap_get_PointerTott__ToneCompensation(struct soap*, tt__ToneCompensation **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension203_DEFINED
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension203_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension203(struct soap*, tt__ImagingSettingsExtension203 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension203(struct soap*, const char *, int, tt__ImagingSettingsExtension203 *const*, const char *);
SOAP_FMAC3 tt__ImagingSettingsExtension203 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension203(struct soap*, const char*, tt__ImagingSettingsExtension203 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension203(struct soap*, tt__ImagingSettingsExtension203 *const*, const char*, const char*);
SOAP_FMAC3 tt__ImagingSettingsExtension203 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension203(struct soap*, tt__ImagingSettingsExtension203 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustment_DEFINED
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustment_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustment(struct soap*, tt__IrCutFilterAutoAdjustment *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustment(struct soap*, const char *, int, tt__IrCutFilterAutoAdjustment *const*, const char *);
SOAP_FMAC3 tt__IrCutFilterAutoAdjustment ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustment(struct soap*, const char*, tt__IrCutFilterAutoAdjustment **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustment(struct soap*, tt__IrCutFilterAutoAdjustment *const*, const char*, const char*);
SOAP_FMAC3 tt__IrCutFilterAutoAdjustment ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustment(struct soap*, tt__IrCutFilterAutoAdjustment **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension202_DEFINED
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension202_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension202(struct soap*, tt__ImagingSettingsExtension202 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension202(struct soap*, const char *, int, tt__ImagingSettingsExtension202 *const*, const char *);
SOAP_FMAC3 tt__ImagingSettingsExtension202 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension202(struct soap*, const char*, tt__ImagingSettingsExtension202 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension202(struct soap*, tt__ImagingSettingsExtension202 *const*, const char*, const char*);
SOAP_FMAC3 tt__ImagingSettingsExtension202 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension202(struct soap*, tt__ImagingSettingsExtension202 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImageStabilization_DEFINED
#define SOAP_TYPE_PointerTott__ImageStabilization_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilization(struct soap*, tt__ImageStabilization *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilization(struct soap*, const char *, int, tt__ImageStabilization *const*, const char *);
SOAP_FMAC3 tt__ImageStabilization ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilization(struct soap*, const char*, tt__ImageStabilization **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilization(struct soap*, tt__ImageStabilization *const*, const char*, const char*);
SOAP_FMAC3 tt__ImageStabilization ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilization(struct soap*, tt__ImageStabilization **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension20_DEFINED
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension20(struct soap*, tt__ImagingSettingsExtension20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension20(struct soap*, const char *, int, tt__ImagingSettingsExtension20 *const*, const char *);
SOAP_FMAC3 tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension20(struct soap*, const char*, tt__ImagingSettingsExtension20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension20(struct soap*, tt__ImagingSettingsExtension20 *const*, const char*, const char*);
SOAP_FMAC3 tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension20(struct soap*, tt__ImagingSettingsExtension20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__WhiteBalance20_DEFINED
#define SOAP_TYPE_PointerTott__WhiteBalance20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20(struct soap*, tt__WhiteBalance20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20(struct soap*, const char *, int, tt__WhiteBalance20 *const*, const char *);
SOAP_FMAC3 tt__WhiteBalance20 ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20(struct soap*, const char*, tt__WhiteBalance20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20(struct soap*, tt__WhiteBalance20 *const*, const char*, const char*);
SOAP_FMAC3 tt__WhiteBalance20 ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20(struct soap*, tt__WhiteBalance20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__WideDynamicRange20_DEFINED
#define SOAP_TYPE_PointerTott__WideDynamicRange20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRange20(struct soap*, tt__WideDynamicRange20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRange20(struct soap*, const char *, int, tt__WideDynamicRange20 *const*, const char *);
SOAP_FMAC3 tt__WideDynamicRange20 ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRange20(struct soap*, const char*, tt__WideDynamicRange20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRange20(struct soap*, tt__WideDynamicRange20 *const*, const char*, const char*);
SOAP_FMAC3 tt__WideDynamicRange20 ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRange20(struct soap*, tt__WideDynamicRange20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__IrCutFilterMode_DEFINED
#define SOAP_TYPE_PointerTott__IrCutFilterMode_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterMode(struct soap*, enum tt__IrCutFilterMode *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterMode(struct soap*, const char *, int, enum tt__IrCutFilterMode *const*, const char *);
SOAP_FMAC3 enum tt__IrCutFilterMode ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterMode(struct soap*, const char*, enum tt__IrCutFilterMode **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterMode(struct soap*, enum tt__IrCutFilterMode *const*, const char*, const char*);
SOAP_FMAC3 enum tt__IrCutFilterMode ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterMode(struct soap*, enum tt__IrCutFilterMode **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__FocusConfiguration20_DEFINED
#define SOAP_TYPE_PointerTott__FocusConfiguration20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20(struct soap*, tt__FocusConfiguration20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20(struct soap*, const char *, int, tt__FocusConfiguration20 *const*, const char *);
SOAP_FMAC3 tt__FocusConfiguration20 ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20(struct soap*, const char*, tt__FocusConfiguration20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20(struct soap*, tt__FocusConfiguration20 *const*, const char*, const char*);
SOAP_FMAC3 tt__FocusConfiguration20 ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20(struct soap*, tt__FocusConfiguration20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__Exposure20_DEFINED
#define SOAP_TYPE_PointerTott__Exposure20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Exposure20(struct soap*, tt__Exposure20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Exposure20(struct soap*, const char *, int, tt__Exposure20 *const*, const char *);
SOAP_FMAC3 tt__Exposure20 ** SOAP_FMAC4 soap_in_PointerTott__Exposure20(struct soap*, const char*, tt__Exposure20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Exposure20(struct soap*, tt__Exposure20 *const*, const char*, const char*);
SOAP_FMAC3 tt__Exposure20 ** SOAP_FMAC4 soap_get_PointerTott__Exposure20(struct soap*, tt__Exposure20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__BacklightCompensation20_DEFINED
#define SOAP_TYPE_PointerTott__BacklightCompensation20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensation20(struct soap*, tt__BacklightCompensation20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensation20(struct soap*, const char *, int, tt__BacklightCompensation20 *const*, const char *);
SOAP_FMAC3 tt__BacklightCompensation20 ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensation20(struct soap*, const char*, tt__BacklightCompensation20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensation20(struct soap*, tt__BacklightCompensation20 *const*, const char*, const char*);
SOAP_FMAC3 tt__BacklightCompensation20 ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensation20(struct soap*, tt__BacklightCompensation20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__FocusStatus20Extension_DEFINED
#define SOAP_TYPE_PointerTott__FocusStatus20Extension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus20Extension(struct soap*, tt__FocusStatus20Extension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus20Extension(struct soap*, const char *, int, tt__FocusStatus20Extension *const*, const char *);
SOAP_FMAC3 tt__FocusStatus20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus20Extension(struct soap*, const char*, tt__FocusStatus20Extension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus20Extension(struct soap*, tt__FocusStatus20Extension *const*, const char*, const char*);
SOAP_FMAC3 tt__FocusStatus20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus20Extension(struct soap*, tt__FocusStatus20Extension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImagingStatus20Extension_DEFINED
#define SOAP_TYPE_PointerTott__ImagingStatus20Extension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingStatus20Extension(struct soap*, tt__ImagingStatus20Extension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingStatus20Extension(struct soap*, const char *, int, tt__ImagingStatus20Extension *const*, const char *);
SOAP_FMAC3 tt__ImagingStatus20Extension ** SOAP_FMAC4 soap_in_PointerTott__ImagingStatus20Extension(struct soap*, const char*, tt__ImagingStatus20Extension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingStatus20Extension(struct soap*, tt__ImagingStatus20Extension *const*, const char*, const char*);
SOAP_FMAC3 tt__ImagingStatus20Extension ** SOAP_FMAC4 soap_get_PointerTott__ImagingStatus20Extension(struct soap*, tt__ImagingStatus20Extension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__FocusStatus20_DEFINED
#define SOAP_TYPE_PointerTott__FocusStatus20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus20(struct soap*, tt__FocusStatus20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus20(struct soap*, const char *, int, tt__FocusStatus20 *const*, const char *);
SOAP_FMAC3 tt__FocusStatus20 ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus20(struct soap*, const char*, tt__FocusStatus20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus20(struct soap*, tt__FocusStatus20 *const*, const char*, const char*);
SOAP_FMAC3 tt__FocusStatus20 ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus20(struct soap*, tt__FocusStatus20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ContinuousFocus_DEFINED
#define SOAP_TYPE_PointerTott__ContinuousFocus_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ContinuousFocus(struct soap*, tt__ContinuousFocus *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ContinuousFocus(struct soap*, const char *, int, tt__ContinuousFocus *const*, const char *);
SOAP_FMAC3 tt__ContinuousFocus ** SOAP_FMAC4 soap_in_PointerTott__ContinuousFocus(struct soap*, const char*, tt__ContinuousFocus **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ContinuousFocus(struct soap*, tt__ContinuousFocus *const*, const char*, const char*);
SOAP_FMAC3 tt__ContinuousFocus ** SOAP_FMAC4 soap_get_PointerTott__ContinuousFocus(struct soap*, tt__ContinuousFocus **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__RelativeFocus_DEFINED
#define SOAP_TYPE_PointerTott__RelativeFocus_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocus(struct soap*, tt__RelativeFocus *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocus(struct soap*, const char *, int, tt__RelativeFocus *const*, const char *);
SOAP_FMAC3 tt__RelativeFocus ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocus(struct soap*, const char*, tt__RelativeFocus **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocus(struct soap*, tt__RelativeFocus *const*, const char*, const char*);
SOAP_FMAC3 tt__RelativeFocus ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocus(struct soap*, tt__RelativeFocus **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__AbsoluteFocus_DEFINED
#define SOAP_TYPE_PointerTott__AbsoluteFocus_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AbsoluteFocus(struct soap*, tt__AbsoluteFocus *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AbsoluteFocus(struct soap*, const char *, int, tt__AbsoluteFocus *const*, const char *);
SOAP_FMAC3 tt__AbsoluteFocus ** SOAP_FMAC4 soap_in_PointerTott__AbsoluteFocus(struct soap*, const char*, tt__AbsoluteFocus **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AbsoluteFocus(struct soap*, tt__AbsoluteFocus *const*, const char*, const char*);
SOAP_FMAC3 tt__AbsoluteFocus ** SOAP_FMAC4 soap_get_PointerTott__AbsoluteFocus(struct soap*, tt__AbsoluteFocus **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__Vector1D_DEFINED
#define SOAP_TYPE_PointerTott__Vector1D_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector1D(struct soap*, tt__Vector1D *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector1D(struct soap*, const char *, int, tt__Vector1D *const*, const char *);
SOAP_FMAC3 tt__Vector1D ** SOAP_FMAC4 soap_in_PointerTott__Vector1D(struct soap*, const char*, tt__Vector1D **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector1D(struct soap*, tt__Vector1D *const*, const char*, const char*);
SOAP_FMAC3 tt__Vector1D ** SOAP_FMAC4 soap_get_PointerTott__Vector1D(struct soap*, tt__Vector1D **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__Vector2D_DEFINED
#define SOAP_TYPE_PointerTott__Vector2D_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector2D(struct soap*, tt__Vector2D *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector2D(struct soap*, const char *, int, tt__Vector2D *const*, const char *);
SOAP_FMAC3 tt__Vector2D ** SOAP_FMAC4 soap_in_PointerTott__Vector2D(struct soap*, const char*, tt__Vector2D **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector2D(struct soap*, tt__Vector2D *const*, const char*, const char*);
SOAP_FMAC3 tt__Vector2D ** SOAP_FMAC4 soap_get_PointerTott__Vector2D(struct soap*, tt__Vector2D **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__FloatRange_DEFINED
#define SOAP_TYPE_PointerTott__FloatRange_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FloatRange(struct soap*, tt__FloatRange *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FloatRange(struct soap*, const char *, int, tt__FloatRange *const*, const char *);
SOAP_FMAC3 tt__FloatRange ** SOAP_FMAC4 soap_in_PointerTott__FloatRange(struct soap*, const char*, tt__FloatRange **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FloatRange(struct soap*, tt__FloatRange *const*, const char*, const char*);
SOAP_FMAC3 tt__FloatRange ** SOAP_FMAC4 soap_get_PointerTott__FloatRange(struct soap*, tt__FloatRange **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__Space1DDescription_DEFINED
#define SOAP_TYPE_PointerTott__Space1DDescription_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space1DDescription(struct soap*, tt__Space1DDescription *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space1DDescription(struct soap*, const char *, int, tt__Space1DDescription *const*, const char *);
SOAP_FMAC3 tt__Space1DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space1DDescription(struct soap*, const char*, tt__Space1DDescription **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space1DDescription(struct soap*, tt__Space1DDescription *const*, const char*, const char*);
SOAP_FMAC3 tt__Space1DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space1DDescription(struct soap*, tt__Space1DDescription **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__Space2DDescription_DEFINED
#define SOAP_TYPE_PointerTott__Space2DDescription_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space2DDescription(struct soap*, tt__Space2DDescription *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space2DDescription(struct soap*, const char *, int, tt__Space2DDescription *const*, const char *);
SOAP_FMAC3 tt__Space2DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space2DDescription(struct soap*, const char*, tt__Space2DDescription **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space2DDescription(struct soap*, tt__Space2DDescription *const*, const char*, const char*);
SOAP_FMAC3 tt__Space2DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space2DDescription(struct soap*, tt__Space2DDescription **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__PTControlDirectionExtension_DEFINED
#define SOAP_TYPE_PointerTott__PTControlDirectionExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirectionExtension(struct soap*, tt__PTControlDirectionExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirectionExtension(struct soap*, const char *, int, tt__PTControlDirectionExtension *const*, const char *);
SOAP_FMAC3 tt__PTControlDirectionExtension ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirectionExtension(struct soap*, const char*, tt__PTControlDirectionExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirectionExtension(struct soap*, tt__PTControlDirectionExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__PTControlDirectionExtension ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirectionExtension(struct soap*, tt__PTControlDirectionExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__Reverse_DEFINED
#define SOAP_TYPE_PointerTott__Reverse_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Reverse(struct soap*, tt__Reverse *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Reverse(struct soap*, const char *, int, tt__Reverse *const*, const char *);
SOAP_FMAC3 tt__Reverse ** SOAP_FMAC4 soap_in_PointerTott__Reverse(struct soap*, const char*, tt__Reverse **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Reverse(struct soap*, tt__Reverse *const*, const char*, const char*);
SOAP_FMAC3 tt__Reverse ** SOAP_FMAC4 soap_get_PointerTott__Reverse(struct soap*, tt__Reverse **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__EFlip_DEFINED
#define SOAP_TYPE_PointerTott__EFlip_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlip(struct soap*, tt__EFlip *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlip(struct soap*, const char *, int, tt__EFlip *const*, const char *);
SOAP_FMAC3 tt__EFlip ** SOAP_FMAC4 soap_in_PointerTott__EFlip(struct soap*, const char*, tt__EFlip **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlip(struct soap*, tt__EFlip *const*, const char*, const char*);
SOAP_FMAC3 tt__EFlip ** SOAP_FMAC4 soap_get_PointerTott__EFlip(struct soap*, tt__EFlip **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__PTZConfigurationExtension2_DEFINED
#define SOAP_TYPE_PointerTott__PTZConfigurationExtension2_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension2(struct soap*, tt__PTZConfigurationExtension2 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension2(struct soap*, const char *, int, tt__PTZConfigurationExtension2 *const*, const char *);
SOAP_FMAC3 tt__PTZConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension2(struct soap*, const char*, tt__PTZConfigurationExtension2 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension2(struct soap*, tt__PTZConfigurationExtension2 *const*, const char*, const char*);
SOAP_FMAC3 tt__PTZConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension2(struct soap*, tt__PTZConfigurationExtension2 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__PTControlDirection_DEFINED
#define SOAP_TYPE_PointerTott__PTControlDirection_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirection(struct soap*, tt__PTControlDirection *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirection(struct soap*, const char *, int, tt__PTControlDirection *const*, const char *);
SOAP_FMAC3 tt__PTControlDirection ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirection(struct soap*, const char*, tt__PTControlDirection **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirection(struct soap*, tt__PTControlDirection *const*, const char*, const char*);
SOAP_FMAC3 tt__PTControlDirection ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirection(struct soap*, tt__PTControlDirection **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__IPv6Address_DEFINED
#define SOAP_TYPE_PointerTott__IPv6Address_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Address(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Address(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__IPv6Address(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Address(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__IPv6Address(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__IPv4Address_DEFINED
#define SOAP_TYPE_PointerTott__IPv4Address_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Address(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Address(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__IPv4Address(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Address(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__IPv4Address(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__IPAddress_DEFINED
#define SOAP_TYPE_PointerTott__IPAddress_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddress(struct soap*, tt__IPAddress *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddress(struct soap*, const char *, int, tt__IPAddress *const*, const char *);
SOAP_FMAC3 tt__IPAddress ** SOAP_FMAC4 soap_in_PointerTott__IPAddress(struct soap*, const char*, tt__IPAddress **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddress(struct soap*, tt__IPAddress *const*, const char*, const char*);
SOAP_FMAC3 tt__IPAddress ** SOAP_FMAC4 soap_get_PointerTott__IPAddress(struct soap*, tt__IPAddress **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy_DEFINED
#define SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap*, _tt__EventSubscription_SubscriptionPolicy *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap*, const char *, int, _tt__EventSubscription_SubscriptionPolicy *const*, const char *);
SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap*, const char*, _tt__EventSubscription_SubscriptionPolicy **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap*, _tt__EventSubscription_SubscriptionPolicy *const*, const char*, const char*);
SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap*, _tt__EventSubscription_SubscriptionPolicy **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsnt__FilterType_DEFINED
#define SOAP_TYPE_PointerTowsnt__FilterType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__FilterType(struct soap*, wsnt__FilterType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__FilterType(struct soap*, const char *, int, wsnt__FilterType *const*, const char *);
SOAP_FMAC3 wsnt__FilterType ** SOAP_FMAC4 soap_in_PointerTowsnt__FilterType(struct soap*, const char*, wsnt__FilterType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__FilterType(struct soap*, wsnt__FilterType *const*, const char*, const char*);
SOAP_FMAC3 wsnt__FilterType ** SOAP_FMAC4 soap_get_PointerTowsnt__FilterType(struct soap*, wsnt__FilterType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTostd__string_DEFINED
#define SOAP_TYPE_PointerTostd__string_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__LensProjection_DEFINED
#define SOAP_TYPE_PointerTott__LensProjection_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensProjection(struct soap*, tt__LensProjection *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensProjection(struct soap*, const char *, int, tt__LensProjection *const*, const char *);
SOAP_FMAC3 tt__LensProjection ** SOAP_FMAC4 soap_in_PointerTott__LensProjection(struct soap*, const char*, tt__LensProjection **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensProjection(struct soap*, tt__LensProjection *const*, const char*, const char*);
SOAP_FMAC3 tt__LensProjection ** SOAP_FMAC4 soap_get_PointerTott__LensProjection(struct soap*, tt__LensProjection **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__LensOffset_DEFINED
#define SOAP_TYPE_PointerTott__LensOffset_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensOffset(struct soap*, tt__LensOffset *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensOffset(struct soap*, const char *, int, tt__LensOffset *const*, const char *);
SOAP_FMAC3 tt__LensOffset ** SOAP_FMAC4 soap_in_PointerTott__LensOffset(struct soap*, const char*, tt__LensOffset **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensOffset(struct soap*, tt__LensOffset *const*, const char*, const char*);
SOAP_FMAC3 tt__LensOffset ** SOAP_FMAC4 soap_get_PointerTott__LensOffset(struct soap*, tt__LensOffset **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTofloat_DEFINED
#define SOAP_TYPE_PointerTofloat_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap*, float *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap*, const char *, int, float *const*, const char *);
SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap*, const char*, float **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap*, float *const*, const char*, const char*);
SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap*, float **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__RotateExtension_DEFINED
#define SOAP_TYPE_PointerTott__RotateExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateExtension(struct soap*, tt__RotateExtension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateExtension(struct soap*, const char *, int, tt__RotateExtension *const*, const char *);
SOAP_FMAC3 tt__RotateExtension ** SOAP_FMAC4 soap_in_PointerTott__RotateExtension(struct soap*, const char*, tt__RotateExtension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateExtension(struct soap*, tt__RotateExtension *const*, const char*, const char*);
SOAP_FMAC3 tt__RotateExtension ** SOAP_FMAC4 soap_get_PointerTott__RotateExtension(struct soap*, tt__RotateExtension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__SceneOrientation_DEFINED
#define SOAP_TYPE_PointerTott__SceneOrientation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SceneOrientation(struct soap*, tt__SceneOrientation *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SceneOrientation(struct soap*, const char *, int, tt__SceneOrientation *const*, const char *);
SOAP_FMAC3 tt__SceneOrientation ** SOAP_FMAC4 soap_in_PointerTott__SceneOrientation(struct soap*, const char*, tt__SceneOrientation **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SceneOrientation(struct soap*, tt__SceneOrientation *const*, const char*, const char*);
SOAP_FMAC3 tt__SceneOrientation ** SOAP_FMAC4 soap_get_PointerTott__SceneOrientation(struct soap*, tt__SceneOrientation **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__LensDescription_DEFINED
#define SOAP_TYPE_PointerTott__LensDescription_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensDescription(struct soap*, tt__LensDescription *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensDescription(struct soap*, const char *, int, tt__LensDescription *const*, const char *);
SOAP_FMAC3 tt__LensDescription ** SOAP_FMAC4 soap_in_PointerTott__LensDescription(struct soap*, const char*, tt__LensDescription **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensDescription(struct soap*, tt__LensDescription *const*, const char*, const char*);
SOAP_FMAC3 tt__LensDescription ** SOAP_FMAC4 soap_get_PointerTott__LensDescription(struct soap*, tt__LensDescription **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension2_DEFINED
#define SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension2_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension2(struct soap*, tt__VideoSourceConfigurationExtension2 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension2(struct soap*, const char *, int, tt__VideoSourceConfigurationExtension2 *const*, const char *);
SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension2(struct soap*, const char*, tt__VideoSourceConfigurationExtension2 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension2(struct soap*, tt__VideoSourceConfigurationExtension2 *const*, const char*, const char*);
SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension2(struct soap*, tt__VideoSourceConfigurationExtension2 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__Rotate_DEFINED
#define SOAP_TYPE_PointerTott__Rotate_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rotate(struct soap*, tt__Rotate *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rotate(struct soap*, const char *, int, tt__Rotate *const*, const char *);
SOAP_FMAC3 tt__Rotate ** SOAP_FMAC4 soap_in_PointerTott__Rotate(struct soap*, const char*, tt__Rotate **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rotate(struct soap*, tt__Rotate *const*, const char*, const char*);
SOAP_FMAC3 tt__Rotate ** SOAP_FMAC4 soap_get_PointerTott__Rotate(struct soap*, tt__Rotate **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__IntRange_DEFINED
#define SOAP_TYPE_PointerTott__IntRange_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRange(struct soap*, tt__IntRange *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRange(struct soap*, const char *, int, tt__IntRange *const*, const char *);
SOAP_FMAC3 tt__IntRange ** SOAP_FMAC4 soap_in_PointerTott__IntRange(struct soap*, const char*, tt__IntRange **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRange(struct soap*, tt__IntRange *const*, const char*, const char*);
SOAP_FMAC3 tt__IntRange ** SOAP_FMAC4 soap_get_PointerTott__IntRange(struct soap*, tt__IntRange **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTotimg__ImagingPreset_DEFINED
#define SOAP_TYPE_PointerTotimg__ImagingPreset_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotimg__ImagingPreset(struct soap*, timg__ImagingPreset *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotimg__ImagingPreset(struct soap*, const char *, int, timg__ImagingPreset *const*, const char *);
SOAP_FMAC3 timg__ImagingPreset ** SOAP_FMAC4 soap_in_PointerTotimg__ImagingPreset(struct soap*, const char*, timg__ImagingPreset **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotimg__ImagingPreset(struct soap*, timg__ImagingPreset *const*, const char*, const char*);
SOAP_FMAC3 timg__ImagingPreset ** SOAP_FMAC4 soap_get_PointerTotimg__ImagingPreset(struct soap*, timg__ImagingPreset **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImagingStatus20_DEFINED
#define SOAP_TYPE_PointerTott__ImagingStatus20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingStatus20(struct soap*, tt__ImagingStatus20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingStatus20(struct soap*, const char *, int, tt__ImagingStatus20 *const*, const char *);
SOAP_FMAC3 tt__ImagingStatus20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingStatus20(struct soap*, const char*, tt__ImagingStatus20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingStatus20(struct soap*, tt__ImagingStatus20 *const*, const char*, const char*);
SOAP_FMAC3 tt__ImagingStatus20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingStatus20(struct soap*, tt__ImagingStatus20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__MoveOptions20_DEFINED
#define SOAP_TYPE_PointerTott__MoveOptions20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MoveOptions20(struct soap*, tt__MoveOptions20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MoveOptions20(struct soap*, const char *, int, tt__MoveOptions20 *const*, const char *);
SOAP_FMAC3 tt__MoveOptions20 ** SOAP_FMAC4 soap_in_PointerTott__MoveOptions20(struct soap*, const char*, tt__MoveOptions20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MoveOptions20(struct soap*, tt__MoveOptions20 *const*, const char*, const char*);
SOAP_FMAC3 tt__MoveOptions20 ** SOAP_FMAC4 soap_get_PointerTott__MoveOptions20(struct soap*, tt__MoveOptions20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__FocusMove_DEFINED
#define SOAP_TYPE_PointerTott__FocusMove_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusMove(struct soap*, tt__FocusMove *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusMove(struct soap*, const char *, int, tt__FocusMove *const*, const char *);
SOAP_FMAC3 tt__FocusMove ** SOAP_FMAC4 soap_in_PointerTott__FocusMove(struct soap*, const char*, tt__FocusMove **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusMove(struct soap*, tt__FocusMove *const*, const char*, const char*);
SOAP_FMAC3 tt__FocusMove ** SOAP_FMAC4 soap_get_PointerTott__FocusMove(struct soap*, tt__FocusMove **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImagingOptions20_DEFINED
#define SOAP_TYPE_PointerTott__ImagingOptions20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20(struct soap*, tt__ImagingOptions20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20(struct soap*, const char *, int, tt__ImagingOptions20 *const*, const char *);
SOAP_FMAC3 tt__ImagingOptions20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20(struct soap*, const char*, tt__ImagingOptions20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20(struct soap*, tt__ImagingOptions20 *const*, const char*, const char*);
SOAP_FMAC3 tt__ImagingOptions20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20(struct soap*, tt__ImagingOptions20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTott__ImagingSettings20_DEFINED
#define SOAP_TYPE_PointerTott__ImagingSettings20_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings20(struct soap*, tt__ImagingSettings20 *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings20(struct soap*, const char *, int, tt__ImagingSettings20 *const*, const char *);
SOAP_FMAC3 tt__ImagingSettings20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings20(struct soap*, const char*, tt__ImagingSettings20 **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings20(struct soap*, tt__ImagingSettings20 *const*, const char*, const char*);
SOAP_FMAC3 tt__ImagingSettings20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings20(struct soap*, tt__ImagingSettings20 **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTotimg__Capabilities_DEFINED
#define SOAP_TYPE_PointerTotimg__Capabilities_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotimg__Capabilities(struct soap*, timg__Capabilities *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotimg__Capabilities(struct soap*, const char *, int, timg__Capabilities *const*, const char *);
SOAP_FMAC3 timg__Capabilities ** SOAP_FMAC4 soap_in_PointerTotimg__Capabilities(struct soap*, const char*, timg__Capabilities **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotimg__Capabilities(struct soap*, timg__Capabilities *const*, const char*, const char*);
SOAP_FMAC3 timg__Capabilities ** SOAP_FMAC4 soap_get_PointerTotimg__Capabilities(struct soap*, timg__Capabilities **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTobool_DEFINED
#define SOAP_TYPE_PointerTobool_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap*, bool *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap*, const char *, int, bool *const*, const char *);
SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap*, const char*, bool **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap*, bool *const*, const char*, const char*);
SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap*, bool **, const char*, const char*);
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Header_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Header_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Header(struct soap*, const char *, int, struct SOAP_ENV__Header *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Header(struct soap*, const char*, struct SOAP_ENV__Header **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header **, const char*, const char*);
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Reason_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap*, const char *, int, struct SOAP_ENV__Reason *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason **, const char*, const char*);
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Code_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap*, const char *, int, struct SOAP_ENV__Code *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code **, const char*, const char*);
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Detail_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap*, const char *, int, struct SOAP_ENV__Detail *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail **, const char*, const char*);
#endif

#endif

#ifndef SOAP_TYPE_PointerTochan__ChannelInstanceType_DEFINED
#define SOAP_TYPE_PointerTochan__ChannelInstanceType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap*, struct chan__ChannelInstanceType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap*, const char *, int, struct chan__ChannelInstanceType *const*, const char *);
SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap*, const char*, struct chan__ChannelInstanceType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap*, struct chan__ChannelInstanceType *const*, const char*, const char*);
SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap*, struct chan__ChannelInstanceType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_wsa5__FaultTo_DEFINED
#define SOAP_TYPE_PointerTo_wsa5__FaultTo_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap*, struct wsa5__EndpointReferenceType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap*, const char *, int, struct wsa5__EndpointReferenceType *const*, const char *);
SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap*, const char*, struct wsa5__EndpointReferenceType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap*, struct wsa5__EndpointReferenceType *const*, const char*, const char*);
SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap*, struct wsa5__EndpointReferenceType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_wsa5__ReplyTo_DEFINED
#define SOAP_TYPE_PointerTo_wsa5__ReplyTo_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap*, struct wsa5__EndpointReferenceType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap*, const char *, int, struct wsa5__EndpointReferenceType *const*, const char *);
SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap*, const char*, struct wsa5__EndpointReferenceType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap*, struct wsa5__EndpointReferenceType *const*, const char*, const char*);
SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap*, struct wsa5__EndpointReferenceType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_wsa5__From_DEFINED
#define SOAP_TYPE_PointerTo_wsa5__From_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap*, struct wsa5__EndpointReferenceType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap*, const char *, int, struct wsa5__EndpointReferenceType *const*, const char *);
SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap*, const char*, struct wsa5__EndpointReferenceType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap*, struct wsa5__EndpointReferenceType *const*, const char*, const char*);
SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap*, struct wsa5__EndpointReferenceType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_wsa5__RelatesTo_DEFINED
#define SOAP_TYPE_PointerTo_wsa5__RelatesTo_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap*, struct wsa5__RelatesToType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap*, const char *, int, struct wsa5__RelatesToType *const*, const char *);
SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap*, const char*, struct wsa5__RelatesToType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap*, struct wsa5__RelatesToType *const*, const char*, const char*);
SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap*, struct wsa5__RelatesToType **, const char*, const char*);
#endif
/* _wsa5__ProblemIRI is a typedef synonym of string */

#ifndef SOAP_TYPE__wsa5__ProblemIRI_DEFINED
#define SOAP_TYPE__wsa5__ProblemIRI_DEFINED

#define soap_default__wsa5__ProblemIRI soap_default_string


#define soap_serialize__wsa5__ProblemIRI soap_serialize_string


#define soap__wsa5__ProblemIRI2s(soap, a) (a)

#define soap_out__wsa5__ProblemIRI soap_out_string


#define soap_s2_wsa5__ProblemIRI(soap, s, a) soap_s2char((soap), (s), (char**)(a), 1, 0, -1, NULL)

#define soap_in__wsa5__ProblemIRI soap_in_string


#define imageing_instantiate__wsa5__ProblemIRI imageing_instantiate_string


#define soap_new__wsa5__ProblemIRI soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemIRI(struct soap*, char *const*, const char*, const char*);

inline int soap_write__wsa5__ProblemIRI(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put__wsa5__ProblemIRI(soap, p, "wsa5:ProblemIRI", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT__wsa5__ProblemIRI(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__ProblemIRI(soap, p, "wsa5:ProblemIRI", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__ProblemIRI(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__ProblemIRI(soap, p, "wsa5:ProblemIRI", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__ProblemIRI(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__ProblemIRI(soap, p, "wsa5:ProblemIRI", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__wsa5__ProblemIRI soap_get_string


#define soap_read__wsa5__ProblemIRI soap_read_string


#define soap_GET__wsa5__ProblemIRI soap_GET_string


#define soap_POST_recv__wsa5__ProblemIRI soap_POST_recv_string

#endif
/* _wsa5__ProblemHeaderQName is a typedef synonym of _QName */

#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName_DEFINED
#define SOAP_TYPE__wsa5__ProblemHeaderQName_DEFINED

#define soap_default__wsa5__ProblemHeaderQName soap_default__QName


#define soap_serialize__wsa5__ProblemHeaderQName soap_serialize__QName


#define soap__wsa5__ProblemHeaderQName2s(soap, a) soap_QName2s(soap, (a))

#define soap_out__wsa5__ProblemHeaderQName soap_out__QName


#define soap_s2_wsa5__ProblemHeaderQName(soap, s, a) soap_s2QName((soap), (s), (char**)(a), 0, -1, NULL)

#define soap_in__wsa5__ProblemHeaderQName soap_in__QName


#define imageing_instantiate__wsa5__ProblemHeaderQName imageing_instantiate__QName


#define soap_new__wsa5__ProblemHeaderQName soap_new__QName


#define soap_put__wsa5__ProblemHeaderQName soap_put__QName


#define soap_write__wsa5__ProblemHeaderQName soap_write__QName


#define soap_PUT__wsa5__ProblemHeaderQName soap_PUT__QName


#define soap_PATCH__wsa5__ProblemHeaderQName soap_PATCH__QName


#define soap_POST_send__wsa5__ProblemHeaderQName soap_POST_send__QName


#define soap_get__wsa5__ProblemHeaderQName soap_get__QName


#define soap_read__wsa5__ProblemHeaderQName soap_read__QName


#define soap_GET__wsa5__ProblemHeaderQName soap_GET__QName


#define soap_POST_recv__wsa5__ProblemHeaderQName soap_POST_recv__QName

#endif
/* _wsa5__Action is a typedef synonym of string */

#ifndef SOAP_TYPE__wsa5__Action_DEFINED
#define SOAP_TYPE__wsa5__Action_DEFINED

#define soap_default__wsa5__Action soap_default_string


#define soap_serialize__wsa5__Action soap_serialize_string


#define soap__wsa5__Action2s(soap, a) (a)

#define soap_out__wsa5__Action soap_out_string


#define soap_s2_wsa5__Action(soap, s, a) soap_s2char((soap), (s), (char**)(a), 1, 0, -1, NULL)

#define soap_in__wsa5__Action soap_in_string


#define imageing_instantiate__wsa5__Action imageing_instantiate_string


#define soap_new__wsa5__Action soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Action(struct soap*, char *const*, const char*, const char*);

inline int soap_write__wsa5__Action(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put__wsa5__Action(soap, p, "wsa5:Action", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT__wsa5__Action(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__Action(soap, p, "wsa5:Action", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__Action(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__Action(soap, p, "wsa5:Action", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__Action(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__Action(soap, p, "wsa5:Action", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__wsa5__Action soap_get_string


#define soap_read__wsa5__Action soap_read_string


#define soap_GET__wsa5__Action soap_GET_string


#define soap_POST_recv__wsa5__Action soap_POST_recv_string

#endif
/* _wsa5__To is a typedef synonym of string */

#ifndef SOAP_TYPE__wsa5__To_DEFINED
#define SOAP_TYPE__wsa5__To_DEFINED

#define soap_default__wsa5__To soap_default_string


#define soap_serialize__wsa5__To soap_serialize_string


#define soap__wsa5__To2s(soap, a) (a)

#define soap_out__wsa5__To soap_out_string


#define soap_s2_wsa5__To(soap, s, a) soap_s2char((soap), (s), (char**)(a), 1, 0, -1, NULL)

#define soap_in__wsa5__To soap_in_string


#define imageing_instantiate__wsa5__To imageing_instantiate_string


#define soap_new__wsa5__To soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__To(struct soap*, char *const*, const char*, const char*);

inline int soap_write__wsa5__To(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put__wsa5__To(soap, p, "wsa5:To", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT__wsa5__To(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__To(soap, p, "wsa5:To", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__To(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__To(soap, p, "wsa5:To", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__To(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__To(soap, p, "wsa5:To", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__wsa5__To soap_get_string


#define soap_read__wsa5__To soap_read_string


#define soap_GET__wsa5__To soap_GET_string


#define soap_POST_recv__wsa5__To soap_POST_recv_string

#endif
/* _wsa5__MessageID is a typedef synonym of string */

#ifndef SOAP_TYPE__wsa5__MessageID_DEFINED
#define SOAP_TYPE__wsa5__MessageID_DEFINED

#define soap_default__wsa5__MessageID soap_default_string


#define soap_serialize__wsa5__MessageID soap_serialize_string


#define soap__wsa5__MessageID2s(soap, a) (a)

#define soap_out__wsa5__MessageID soap_out_string


#define soap_s2_wsa5__MessageID(soap, s, a) soap_s2char((soap), (s), (char**)(a), 1, 0, -1, NULL)

#define soap_in__wsa5__MessageID soap_in_string


#define imageing_instantiate__wsa5__MessageID imageing_instantiate_string


#define soap_new__wsa5__MessageID soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__MessageID(struct soap*, char *const*, const char*, const char*);

inline int soap_write__wsa5__MessageID(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put__wsa5__MessageID(soap, p, "wsa5:MessageID", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT__wsa5__MessageID(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__MessageID(soap, p, "wsa5:MessageID", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__wsa5__MessageID(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__MessageID(soap, p, "wsa5:MessageID", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__wsa5__MessageID(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__wsa5__MessageID(soap, p, "wsa5:MessageID", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

#define soap_get__wsa5__MessageID soap_get_string


#define soap_read__wsa5__MessageID soap_read_string


#define soap_GET__wsa5__MessageID soap_GET_string


#define soap_POST_recv__wsa5__MessageID soap_POST_recv_string

#endif

#ifndef SOAP_TYPE_PointerToint_DEFINED
#define SOAP_TYPE_PointerToint_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap*, int *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap*, const char *, int, int *const*, const char *);
SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap*, const char*, int **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap*, int *const*, const char*, const char*);
SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap*, int **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_XML_DEFINED
#define SOAP_TYPE_PointerTo_XML_DEFINED
#endif

#ifndef SOAP_TYPE_PointerTowsa5__MetadataType_DEFINED
#define SOAP_TYPE_PointerTowsa5__MetadataType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap*, struct wsa5__MetadataType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap*, const char *, int, struct wsa5__MetadataType *const*, const char *);
SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap*, const char*, struct wsa5__MetadataType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap*, struct wsa5__MetadataType *const*, const char*, const char*);
SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap*, struct wsa5__MetadataType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsa5__ReferenceParametersType_DEFINED
#define SOAP_TYPE_PointerTowsa5__ReferenceParametersType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap*, struct wsa5__ReferenceParametersType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap*, const char *, int, struct wsa5__ReferenceParametersType *const*, const char *);
SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap*, const char*, struct wsa5__ReferenceParametersType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap*, struct wsa5__ReferenceParametersType *const*, const char*, const char*);
SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap*, struct wsa5__ReferenceParametersType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType_DEFINED
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType_DEFINED

inline void soap_default_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__FaultCodesOpenEnumType
	*a = SOAP_DEFAULT_wsa5__FaultCodesOpenEnumType;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap*, char *const*);

#define soap_wsa5__FaultCodesOpenEnumType2s(soap, a) (a)
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2wsa5__FaultCodesOpenEnumType(soap, s, a) soap_s2char((soap), (s), (char**)(a), 1, 0, -1, NULL)
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap*, const char*, char **, const char*);

#define imageing_instantiate_wsa5__FaultCodesOpenEnumType imageing_instantiate_string


#define soap_new_wsa5__FaultCodesOpenEnumType soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap*, char *const*, const char*, const char*);

inline int soap_write_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_wsa5__FaultCodesOpenEnumType(soap, p, "wsa5:FaultCodesOpenEnumType", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsa5__FaultCodesOpenEnumType(soap, p, "wsa5:FaultCodesOpenEnumType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsa5__FaultCodesOpenEnumType(soap, p, "wsa5:FaultCodesOpenEnumType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsa5__FaultCodesOpenEnumType(soap, p, "wsa5:FaultCodesOpenEnumType", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap*, char **, const char*, const char*);

inline int soap_read_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_wsa5__FaultCodesOpenEnumType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsa5__FaultCodesOpenEnumType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p)
{
	if (::soap_read_wsa5__FaultCodesOpenEnumType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum_DEFINED
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum_DEFINED

inline void soap_default_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__RelationshipTypeOpenEnum
	*a = SOAP_DEFAULT_wsa5__RelationshipTypeOpenEnum;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap*, char *const*);

#define soap_wsa5__RelationshipTypeOpenEnum2s(soap, a) (a)
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2wsa5__RelationshipTypeOpenEnum(soap, s, a) soap_s2char((soap), (s), (char**)(a), 1, 0, -1, NULL)
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap*, const char*, char **, const char*);

#define imageing_instantiate_wsa5__RelationshipTypeOpenEnum imageing_instantiate_string


#define soap_new_wsa5__RelationshipTypeOpenEnum soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap*, char *const*, const char*, const char*);

inline int soap_write_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_wsa5__RelationshipTypeOpenEnum(soap, p, "wsa5:RelationshipTypeOpenEnum", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsa5__RelationshipTypeOpenEnum(soap, p, "wsa5:RelationshipTypeOpenEnum", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsa5__RelationshipTypeOpenEnum(soap, p, "wsa5:RelationshipTypeOpenEnum", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wsa5__RelationshipTypeOpenEnum(soap, p, "wsa5:RelationshipTypeOpenEnum", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap*, char **, const char*, const char*);

inline int soap_read_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_wsa5__RelationshipTypeOpenEnum(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsa5__RelationshipTypeOpenEnum(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p)
{
	if (::soap_read_wsa5__RelationshipTypeOpenEnum(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_PointerTounsignedByte_DEFINED
#define SOAP_TYPE_PointerTounsignedByte_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap*, unsigned char *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap*, const char *, int, unsigned char *const*, const char *);
SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap*, const char*, unsigned char **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap*, unsigned char *const*, const char*, const char*);
SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap*, unsigned char **, const char*, const char*);
#endif

#ifndef SOAP_TYPE__QName_DEFINED
#define SOAP_TYPE__QName_DEFINED

inline void soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap*, char *const*);

#define soap__QName2s(soap, a) soap_QName2s(soap, (a))
SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2_QName(soap, s, a) soap_s2QName((soap), (s), (char**)(a), 0, -1, NULL)
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap*, const char*, char **, const char*);

#define imageing_instantiate__QName imageing_instantiate_string


#define soap_new__QName soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap*, char *const*, const char*, const char*);

inline int soap_write__QName(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put__QName(soap, p, "QName", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT__QName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__QName(soap, p, "QName", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__QName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__QName(soap, p, "QName", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__QName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__QName(soap, p, "QName", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap*, char **, const char*, const char*);

inline int soap_read__QName(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get__QName(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__QName(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__QName(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__QName(struct soap *soap, char **p)
{
	if (::soap_read__QName(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__XML_DEFINED
#define SOAP_TYPE__XML_DEFINED
#endif

#ifndef SOAP_TYPE_string_DEFINED
#define SOAP_TYPE_string_DEFINED

inline void soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap*, char *const*);

#define soap_string2s(soap, a) (a)
SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2string(soap, s, a) soap_s2char((soap), (s), (char**)(a), 1, 0, -1, NULL)
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap*, const char*, char **, const char*);

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap*, char *const*, const char*, const char*);

inline int soap_write_string(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_string(soap, p, "string", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_string(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_string(soap, p, "string", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_string(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_string(soap, p, "string", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_string(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_string(soap, p, "string", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap*, char **, const char*, const char*);

inline int soap_read_string(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_string(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_string(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_string(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_string(struct soap *soap, char **p)
{
	if (::soap_read_string(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic_DEFINED
#define SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap*, std::vector<_wstop__TopicNamespaceType_Topic> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap*, const std::vector<_wstop__TopicNamespaceType_Topic> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap*, const char*, int, const std::vector<_wstop__TopicNamespaceType_Topic> *, const char*);
SOAP_FMAC3 std::vector<_wstop__TopicNamespaceType_Topic> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap*, const char*, std::vector<_wstop__TopicNamespaceType_Topic> *, const char*);
SOAP_FMAC1 std::vector<_wstop__TopicNamespaceType_Topic>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<_wstop__TopicNamespaceType_Topic>  * soap_new_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowstop__TopicType(struct soap*, std::vector<wstop__TopicType *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(struct soap*, const std::vector<wstop__TopicType *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowstop__TopicType(struct soap*, const char*, int, const std::vector<wstop__TopicType *> *, const char*);
SOAP_FMAC3 std::vector<wstop__TopicType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowstop__TopicType(struct soap*, const char*, std::vector<wstop__TopicType *> *, const char*);
SOAP_FMAC1 std::vector<wstop__TopicType *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wstop__TopicType *>  * soap_new_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__QName_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxsd__QName_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap*, std::vector<std::string> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap*, const std::vector<std::string> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap*, const char*, int, const std::vector<std::string> *, const char*);
SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap*, const char*, std::vector<std::string> *, const char*);
SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfxsd__QName(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<std::string>  * soap_new_std__vectorTemplateOfxsd__QName(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOfxsd__QName(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description_DEFINED
#define SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap*, std::vector<_wsrfbf__BaseFaultType_Description> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap*, const std::vector<_wsrfbf__BaseFaultType_Description> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap*, const char*, int, const std::vector<_wsrfbf__BaseFaultType_Description> *, const char*);
SOAP_FMAC3 std::vector<_wsrfbf__BaseFaultType_Description> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap*, const char*, std::vector<_wsrfbf__BaseFaultType_Description> *, const char*);
SOAP_FMAC1 std::vector<_wsrfbf__BaseFaultType_Description>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<_wsrfbf__BaseFaultType_Description>  * soap_new_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap*, std::vector<wsnt__NotificationMessageHolderType *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap*, const std::vector<wsnt__NotificationMessageHolderType *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap*, const char*, int, const std::vector<wsnt__NotificationMessageHolderType *> *, const char*);
SOAP_FMAC3 std::vector<wsnt__NotificationMessageHolderType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap*, const char*, std::vector<wsnt__NotificationMessageHolderType *> *, const char*);
SOAP_FMAC1 std::vector<wsnt__NotificationMessageHolderType *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsnt__NotificationMessageHolderType *>  * soap_new_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__anyURI_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxsd__anyURI_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyURI(struct soap*, std::vector<std::string> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyURI(struct soap*, const std::vector<std::string> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyURI(struct soap*, const char*, int, const std::vector<std::string> *, const char*);
SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyURI(struct soap*, const char*, std::vector<std::string> *, const char*);
SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfxsd__anyURI(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<std::string>  * soap_new_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOfxsd__anyURI(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap*, std::vector<wsnt__TopicExpressionType *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap*, const std::vector<wsnt__TopicExpressionType *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap*, const char*, int, const std::vector<wsnt__TopicExpressionType *> *, const char*);
SOAP_FMAC3 std::vector<wsnt__TopicExpressionType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap*, const char*, std::vector<wsnt__TopicExpressionType *> *, const char*);
SOAP_FMAC1 std::vector<wsnt__TopicExpressionType *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsnt__TopicExpressionType *>  * soap_new_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Config_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Config_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Config(struct soap*, std::vector<tt__Config *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Config(struct soap*, const std::vector<tt__Config *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Config(struct soap*, const char*, int, const std::vector<tt__Config *> *, const char*);
SOAP_FMAC3 std::vector<tt__Config *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Config(struct soap*, const char*, std::vector<tt__Config *> *, const char*);
SOAP_FMAC1 std::vector<tt__Config *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTott__Config(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<tt__Config *>  * soap_new_std__vectorTemplateOfPointerTott__Config(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOfPointerTott__Config(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Vector(struct soap*, std::vector<tt__Vector *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Vector(struct soap*, const std::vector<tt__Vector *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Vector(struct soap*, const char*, int, const std::vector<tt__Vector *> *, const char*);
SOAP_FMAC3 std::vector<tt__Vector *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Vector(struct soap*, const char*, std::vector<tt__Vector *> *, const char*);
SOAP_FMAC1 std::vector<tt__Vector *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTott__Vector(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<tt__Vector *>  * soap_new_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOfPointerTott__Vector(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem_DEFINED
#define SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap*, std::vector<_tt__ItemList_ElementItem> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap*, const std::vector<_tt__ItemList_ElementItem> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap*, const char*, int, const std::vector<_tt__ItemList_ElementItem> *, const char*);
SOAP_FMAC3 std::vector<_tt__ItemList_ElementItem> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap*, const char*, std::vector<_tt__ItemList_ElementItem> *, const char*);
SOAP_FMAC1 std::vector<_tt__ItemList_ElementItem>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<_tt__ItemList_ElementItem>  * soap_new_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem_DEFINED
#define SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap*, std::vector<_tt__ItemList_SimpleItem> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap*, const std::vector<_tt__ItemList_SimpleItem> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap*, const char*, int, const std::vector<_tt__ItemList_SimpleItem> *, const char*);
SOAP_FMAC3 std::vector<_tt__ItemList_SimpleItem> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap*, const char*, std::vector<_tt__ItemList_SimpleItem> *, const char*);
SOAP_FMAC1 std::vector<_tt__ItemList_SimpleItem>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<_tt__ItemList_SimpleItem>  * soap_new_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode_DEFINED
#define SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__AutoFocusMode(struct soap*, std::vector<enum tt__AutoFocusMode> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__AutoFocusMode(struct soap*, const std::vector<enum tt__AutoFocusMode> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__AutoFocusMode(struct soap*, const char*, int, const std::vector<enum tt__AutoFocusMode> *, const char*);
SOAP_FMAC3 std::vector<enum tt__AutoFocusMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__AutoFocusMode(struct soap*, const char*, std::vector<enum tt__AutoFocusMode> *, const char*);
SOAP_FMAC1 std::vector<enum tt__AutoFocusMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__AutoFocusMode(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<enum tt__AutoFocusMode>  * soap_new_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOftt__AutoFocusMode(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode_DEFINED
#define SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__WhiteBalanceMode(struct soap*, std::vector<enum tt__WhiteBalanceMode> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__WhiteBalanceMode(struct soap*, const std::vector<enum tt__WhiteBalanceMode> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__WhiteBalanceMode(struct soap*, const char*, int, const std::vector<enum tt__WhiteBalanceMode> *, const char*);
SOAP_FMAC3 std::vector<enum tt__WhiteBalanceMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__WhiteBalanceMode(struct soap*, const char*, std::vector<enum tt__WhiteBalanceMode> *, const char*);
SOAP_FMAC1 std::vector<enum tt__WhiteBalanceMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<enum tt__WhiteBalanceMode>  * soap_new_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority_DEFINED
#define SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ExposurePriority(struct soap*, std::vector<enum tt__ExposurePriority> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ExposurePriority(struct soap*, const std::vector<enum tt__ExposurePriority> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ExposurePriority(struct soap*, const char*, int, const std::vector<enum tt__ExposurePriority> *, const char*);
SOAP_FMAC3 std::vector<enum tt__ExposurePriority> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ExposurePriority(struct soap*, const char*, std::vector<enum tt__ExposurePriority> *, const char*);
SOAP_FMAC1 std::vector<enum tt__ExposurePriority>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__ExposurePriority(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<enum tt__ExposurePriority>  * soap_new_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOftt__ExposurePriority(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOftt__ExposureMode_DEFINED
#define SOAP_TYPE_std__vectorTemplateOftt__ExposureMode_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ExposureMode(struct soap*, std::vector<enum tt__ExposureMode> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ExposureMode(struct soap*, const std::vector<enum tt__ExposureMode> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ExposureMode(struct soap*, const char*, int, const std::vector<enum tt__ExposureMode> *, const char*);
SOAP_FMAC3 std::vector<enum tt__ExposureMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ExposureMode(struct soap*, const char*, std::vector<enum tt__ExposureMode> *, const char*);
SOAP_FMAC1 std::vector<enum tt__ExposureMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__ExposureMode(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<enum tt__ExposureMode>  * soap_new_std__vectorTemplateOftt__ExposureMode(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOftt__ExposureMode(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode_DEFINED
#define SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__BacklightCompensationMode(struct soap*, std::vector<enum tt__BacklightCompensationMode> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__BacklightCompensationMode(struct soap*, const std::vector<enum tt__BacklightCompensationMode> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__BacklightCompensationMode(struct soap*, const char*, int, const std::vector<enum tt__BacklightCompensationMode> *, const char*);
SOAP_FMAC3 std::vector<enum tt__BacklightCompensationMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__BacklightCompensationMode(struct soap*, const char*, std::vector<enum tt__BacklightCompensationMode> *, const char*);
SOAP_FMAC1 std::vector<enum tt__BacklightCompensationMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<enum tt__BacklightCompensationMode>  * soap_new_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode_DEFINED
#define SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__WideDynamicMode(struct soap*, std::vector<enum tt__WideDynamicMode> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__WideDynamicMode(struct soap*, const std::vector<enum tt__WideDynamicMode> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__WideDynamicMode(struct soap*, const char*, int, const std::vector<enum tt__WideDynamicMode> *, const char*);
SOAP_FMAC3 std::vector<enum tt__WideDynamicMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__WideDynamicMode(struct soap*, const char*, std::vector<enum tt__WideDynamicMode> *, const char*);
SOAP_FMAC1 std::vector<enum tt__WideDynamicMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__WideDynamicMode(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<enum tt__WideDynamicMode>  * soap_new_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOftt__WideDynamicMode(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfstd__string_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap*, std::vector<std::string> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap*, const std::vector<std::string> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap*, const char*, int, const std::vector<std::string> *, const char*);
SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap*, const char*, std::vector<std::string> *, const char*);
SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfstd__string(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<std::string>  * soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode_DEFINED
#define SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ImageStabilizationMode(struct soap*, std::vector<enum tt__ImageStabilizationMode> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ImageStabilizationMode(struct soap*, const std::vector<enum tt__ImageStabilizationMode> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ImageStabilizationMode(struct soap*, const char*, int, const std::vector<enum tt__ImageStabilizationMode> *, const char*);
SOAP_FMAC3 std::vector<enum tt__ImageStabilizationMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ImageStabilizationMode(struct soap*, const char*, std::vector<enum tt__ImageStabilizationMode> *, const char*);
SOAP_FMAC1 std::vector<enum tt__ImageStabilizationMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__ImageStabilizationMode(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<enum tt__ImageStabilizationMode>  * soap_new_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOftt__ImageStabilizationMode(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode_DEFINED
#define SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IrCutFilterMode(struct soap*, std::vector<enum tt__IrCutFilterMode> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IrCutFilterMode(struct soap*, const std::vector<enum tt__IrCutFilterMode> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IrCutFilterMode(struct soap*, const char*, int, const std::vector<enum tt__IrCutFilterMode> *, const char*);
SOAP_FMAC3 std::vector<enum tt__IrCutFilterMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IrCutFilterMode(struct soap*, const char*, std::vector<enum tt__IrCutFilterMode> *, const char*);
SOAP_FMAC1 std::vector<enum tt__IrCutFilterMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__IrCutFilterMode(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<enum tt__IrCutFilterMode>  * soap_new_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOftt__IrCutFilterMode(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap*, std::vector<tt__IrCutFilterAutoAdjustment *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap*, const std::vector<tt__IrCutFilterAutoAdjustment *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap*, const char*, int, const std::vector<tt__IrCutFilterAutoAdjustment *> *, const char*);
SOAP_FMAC3 std::vector<tt__IrCutFilterAutoAdjustment *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap*, const char*, std::vector<tt__IrCutFilterAutoAdjustment *> *, const char*);
SOAP_FMAC1 std::vector<tt__IrCutFilterAutoAdjustment *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<tt__IrCutFilterAutoAdjustment *>  * soap_new_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LensProjection(struct soap*, std::vector<tt__LensProjection *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LensProjection(struct soap*, const std::vector<tt__LensProjection *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LensProjection(struct soap*, const char*, int, const std::vector<tt__LensProjection *> *, const char*);
SOAP_FMAC3 std::vector<tt__LensProjection *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LensProjection(struct soap*, const char*, std::vector<tt__LensProjection *> *, const char*);
SOAP_FMAC1 std::vector<tt__LensProjection *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTott__LensProjection(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<tt__LensProjection *>  * soap_new_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOfPointerTott__LensProjection(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LensDescription(struct soap*, std::vector<tt__LensDescription *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LensDescription(struct soap*, const std::vector<tt__LensDescription *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LensDescription(struct soap*, const char*, int, const std::vector<tt__LensDescription *> *, const char*);
SOAP_FMAC3 std::vector<tt__LensDescription *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LensDescription(struct soap*, const char*, std::vector<tt__LensDescription *> *, const char*);
SOAP_FMAC1 std::vector<tt__LensDescription *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTott__LensDescription(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<tt__LensDescription *>  * soap_new_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOfPointerTott__LensDescription(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap*, std::vector<timg__ImagingPreset *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap*, const std::vector<timg__ImagingPreset *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap*, const char*, int, const std::vector<timg__ImagingPreset *> *, const char*);
SOAP_FMAC3 std::vector<timg__ImagingPreset *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap*, const char*, std::vector<timg__ImagingPreset *> *, const char*);
SOAP_FMAC1 std::vector<timg__ImagingPreset *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<timg__ImagingPreset *>  * soap_new_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOfPointerTotimg__ImagingPreset(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOf_XML_DEFINED
#define SOAP_TYPE_std__vectorTemplateOf_XML_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap*, std::vector<char *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap*, const std::vector<char *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap*, const char*, int, const std::vector<char *> *, const char*);
SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap*, const char*, std::vector<char *> *, const char*);
SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOf_XML(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<char *>  * soap_new_std__vectorTemplateOf_XML(struct soap *soap, int n = -1)
{
	return imageing_instantiate_std__vectorTemplateOf_XML(soap, n, NULL, NULL, NULL);
}
#endif

#endif

/* End of imageingH.h */
