/* imageingC.cpp
   Generated by gSOAP 2.8.117 for out/onvif_imaging.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "imageingH.h"

SOAP_SOURCE_STAMP("@(#) imageingC.cpp ver 2.8.117 2021-12-08 15:16:43 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ULONG64:
		return soap_in_ULONG64(soap, tag, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_tt__MoveStatus:
		return soap_in_tt__MoveStatus(soap, tag, NULL, "tt:MoveStatus");
	case SOAP_TYPE_tt__PropertyOperation:
		return soap_in_tt__PropertyOperation(soap, tag, NULL, "tt:PropertyOperation");
	case SOAP_TYPE_tt__ImageStabilizationMode:
		return soap_in_tt__ImageStabilizationMode(soap, tag, NULL, "tt:ImageStabilizationMode");
	case SOAP_TYPE_tt__IrCutFilterMode:
		return soap_in_tt__IrCutFilterMode(soap, tag, NULL, "tt:IrCutFilterMode");
	case SOAP_TYPE_tt__WhiteBalanceMode:
		return soap_in_tt__WhiteBalanceMode(soap, tag, NULL, "tt:WhiteBalanceMode");
	case SOAP_TYPE_tt__ExposureMode:
		return soap_in_tt__ExposureMode(soap, tag, NULL, "tt:ExposureMode");
	case SOAP_TYPE_tt__ExposurePriority:
		return soap_in_tt__ExposurePriority(soap, tag, NULL, "tt:ExposurePriority");
	case SOAP_TYPE_tt__BacklightCompensationMode:
		return soap_in_tt__BacklightCompensationMode(soap, tag, NULL, "tt:BacklightCompensationMode");
	case SOAP_TYPE_tt__WideDynamicMode:
		return soap_in_tt__WideDynamicMode(soap, tag, NULL, "tt:WideDynamicMode");
	case SOAP_TYPE_tt__AutoFocusMode:
		return soap_in_tt__AutoFocusMode(soap, tag, NULL, "tt:AutoFocusMode");
	case SOAP_TYPE_tt__ReverseMode:
		return soap_in_tt__ReverseMode(soap, tag, NULL, "tt:ReverseMode");
	case SOAP_TYPE_tt__EFlipMode:
		return soap_in_tt__EFlipMode(soap, tag, NULL, "tt:EFlipMode");
	case SOAP_TYPE_tt__IPType:
		return soap_in_tt__IPType(soap, tag, NULL, "tt:IPType");
	case SOAP_TYPE_tt__AudioEncoding:
		return soap_in_tt__AudioEncoding(soap, tag, NULL, "tt:AudioEncoding");
	case SOAP_TYPE_tt__H264Profile:
		return soap_in_tt__H264Profile(soap, tag, NULL, "tt:H264Profile");
	case SOAP_TYPE_tt__Mpeg4Profile:
		return soap_in_tt__Mpeg4Profile(soap, tag, NULL, "tt:Mpeg4Profile");
	case SOAP_TYPE_tt__VideoEncoding:
		return soap_in_tt__VideoEncoding(soap, tag, NULL, "tt:VideoEncoding");
	case SOAP_TYPE_tt__SceneOrientationMode:
		return soap_in_tt__SceneOrientationMode(soap, tag, NULL, "tt:SceneOrientationMode");
	case SOAP_TYPE_tt__RotateMode:
		return soap_in_tt__RotateMode(soap, tag, NULL, "tt:RotateMode");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_in_wsa5__FaultCodesType(soap, tag, NULL, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_in_wsa5__RelationshipType(soap, tag, NULL, "wsa5:RelationshipType");
	case SOAP_TYPE_wstop__ConcreteTopicExpression__:
		return soap_in_wstop__ConcreteTopicExpression__(soap, tag, NULL, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		return soap_in_wstop__ConcreteTopicExpression(soap, tag, NULL, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_tt__MoveStatus_:
		return soap_in_tt__MoveStatus_(soap, tag, NULL, "tt:MoveStatus");
	case SOAP_TYPE_tt__ReferenceToken__:
		return soap_in_tt__ReferenceToken__(soap, tag, NULL, "tt:ReferenceToken");
	case SOAP_TYPE_tt__ReferenceToken:
		return soap_in_tt__ReferenceToken(soap, tag, NULL, "tt:ReferenceToken");
	case SOAP_TYPE_tt__PropertyOperation_:
		return soap_in_tt__PropertyOperation_(soap, tag, NULL, "tt:PropertyOperation");
	case SOAP_TYPE_tt__ImageStabilizationMode_:
		return soap_in_tt__ImageStabilizationMode_(soap, tag, NULL, "tt:ImageStabilizationMode");
	case SOAP_TYPE_tt__IrCutFilterMode_:
		return soap_in_tt__IrCutFilterMode_(soap, tag, NULL, "tt:IrCutFilterMode");
	case SOAP_TYPE_tt__WhiteBalanceMode_:
		return soap_in_tt__WhiteBalanceMode_(soap, tag, NULL, "tt:WhiteBalanceMode");
	case SOAP_TYPE_tt__ExposureMode_:
		return soap_in_tt__ExposureMode_(soap, tag, NULL, "tt:ExposureMode");
	case SOAP_TYPE_tt__ExposurePriority_:
		return soap_in_tt__ExposurePriority_(soap, tag, NULL, "tt:ExposurePriority");
	case SOAP_TYPE_tt__BacklightCompensationMode_:
		return soap_in_tt__BacklightCompensationMode_(soap, tag, NULL, "tt:BacklightCompensationMode");
	case SOAP_TYPE_tt__WideDynamicMode_:
		return soap_in_tt__WideDynamicMode_(soap, tag, NULL, "tt:WideDynamicMode");
	case SOAP_TYPE_tt__AutoFocusMode_:
		return soap_in_tt__AutoFocusMode_(soap, tag, NULL, "tt:AutoFocusMode");
	case SOAP_TYPE_tt__ReverseMode_:
		return soap_in_tt__ReverseMode_(soap, tag, NULL, "tt:ReverseMode");
	case SOAP_TYPE_tt__EFlipMode_:
		return soap_in_tt__EFlipMode_(soap, tag, NULL, "tt:EFlipMode");
	case SOAP_TYPE_tt__IPType_:
		return soap_in_tt__IPType_(soap, tag, NULL, "tt:IPType");
	case SOAP_TYPE_tt__IPv6Address__:
		return soap_in_tt__IPv6Address__(soap, tag, NULL, "tt:IPv6Address");
	case SOAP_TYPE_tt__IPv6Address:
		return soap_in_tt__IPv6Address(soap, tag, NULL, "tt:IPv6Address");
	case SOAP_TYPE_tt__IPv4Address__:
		return soap_in_tt__IPv4Address__(soap, tag, NULL, "tt:IPv4Address");
	case SOAP_TYPE_tt__IPv4Address:
		return soap_in_tt__IPv4Address(soap, tag, NULL, "tt:IPv4Address");
	case SOAP_TYPE_tt__AudioEncoding_:
		return soap_in_tt__AudioEncoding_(soap, tag, NULL, "tt:AudioEncoding");
	case SOAP_TYPE_tt__H264Profile_:
		return soap_in_tt__H264Profile_(soap, tag, NULL, "tt:H264Profile");
	case SOAP_TYPE_tt__Mpeg4Profile_:
		return soap_in_tt__Mpeg4Profile_(soap, tag, NULL, "tt:Mpeg4Profile");
	case SOAP_TYPE_tt__VideoEncoding_:
		return soap_in_tt__VideoEncoding_(soap, tag, NULL, "tt:VideoEncoding");
	case SOAP_TYPE_tt__SceneOrientationMode_:
		return soap_in_tt__SceneOrientationMode_(soap, tag, NULL, "tt:SceneOrientationMode");
	case SOAP_TYPE_tt__RotateMode_:
		return soap_in_tt__RotateMode_(soap, tag, NULL, "tt:RotateMode");
	case SOAP_TYPE_tt__Name__:
		return soap_in_tt__Name__(soap, tag, NULL, "tt:Name");
	case SOAP_TYPE_tt__Name:
		return soap_in_tt__Name(soap, tag, NULL, "tt:Name");
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		return soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, NULL, "wsnt:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_tt__StringList:
		return soap_in_tt__StringList(soap, tag, NULL, "tt:StringList");
	case SOAP_TYPE_tt__StringAttrList:
		return soap_in_tt__StringAttrList(soap, tag, NULL, "tt:StringAttrList");
	case SOAP_TYPE_tt__FloatList:
		return soap_in_tt__FloatList(soap, tag, NULL, "tt:FloatList");
	case SOAP_TYPE_tt__IntList:
		return soap_in_tt__IntList(soap, tag, NULL, "tt:IntList");
	case SOAP_TYPE_wstop__TopicSetType:
		return soap_in_wstop__TopicSetType(soap, tag, NULL, "wstop:TopicSetType");
	case SOAP_TYPE_wstop__TopicType:
		return soap_in_wstop__TopicType(soap, tag, NULL, "wstop:TopicType");
	case SOAP_TYPE_wstop__TopicNamespaceType:
		return soap_in_wstop__TopicNamespaceType(soap, tag, NULL, "wstop:TopicNamespaceType");
	case SOAP_TYPE_wstop__QueryExpressionType:
		return soap_in_wstop__QueryExpressionType(soap, tag, NULL, "wstop:QueryExpressionType");
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		return soap_in_wstop__ExtensibleDocumented(soap, tag, NULL, "wstop:ExtensibleDocumented");
	case SOAP_TYPE_wstop__Documentation:
		return soap_in_wstop__Documentation(soap, tag, NULL, "wstop:Documentation");
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		return soap_in_wsrfbf__BaseFaultType(soap, tag, NULL, "wsrfbf:BaseFaultType");
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		return soap_in_wsnt__ResumeFailedFaultType(soap, tag, NULL, "wsnt:ResumeFailedFaultType");
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		return soap_in_wsnt__PauseFailedFaultType(soap, tag, NULL, "wsnt:PauseFailedFaultType");
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		return soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, NULL, "wsnt:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		return soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, NULL, "wsnt:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		return soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, NULL, "wsnt:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		return soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, NULL, "wsnt:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		return soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, NULL, "wsnt:UnableToGetMessagesFaultType");
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		return soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, NULL, "wsnt:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		return soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, NULL, "wsnt:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		return soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, NULL, "wsnt:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		return soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, NULL, "wsnt:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		return soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, NULL, "wsnt:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		return soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, NULL, "wsnt:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		return soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, NULL, "wsnt:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		return soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, NULL, "wsnt:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		return soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, NULL, "wsnt:TopicNotSupportedFaultType");
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		return soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, NULL, "wsnt:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		return soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, NULL, "wsnt:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		return soap_in_wsnt__InvalidFilterFaultType(soap, tag, NULL, "wsnt:InvalidFilterFaultType");
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		return soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, NULL, "wsnt:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		return soap_in_wsnt__NotificationMessageHolderType(soap, tag, NULL, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		return soap_in_wsnt__SubscriptionPolicyType(soap, tag, NULL, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_wsnt__FilterType:
		return soap_in_wsnt__FilterType(soap, tag, NULL, "wsnt:FilterType");
	case SOAP_TYPE_wsnt__TopicExpressionType:
		return soap_in_wsnt__TopicExpressionType(soap, tag, NULL, "wsnt:TopicExpressionType");
	case SOAP_TYPE_wsnt__QueryExpressionType:
		return soap_in_wsnt__QueryExpressionType(soap, tag, NULL, "wsnt:QueryExpressionType");
	case SOAP_TYPE_tt__Polygon:
		return soap_in_tt__Polygon(soap, tag, NULL, "tt:Polygon");
	case SOAP_TYPE_tt__Rectangle:
		return soap_in_tt__Rectangle(soap, tag, NULL, "tt:Rectangle");
	case SOAP_TYPE_tt__Vector:
		return soap_in_tt__Vector(soap, tag, NULL, "tt:Vector");
	case SOAP_TYPE_tt__Vector1D:
		return soap_in_tt__Vector1D(soap, tag, NULL, "tt:Vector1D");
	case SOAP_TYPE_tt__Vector2D:
		return soap_in_tt__Vector2D(soap, tag, NULL, "tt:Vector2D");
	case SOAP_TYPE_tt__IntRange:
		return soap_in_tt__IntRange(soap, tag, NULL, "tt:IntRange");
	case SOAP_TYPE_tt__PolygonOptions:
		return soap_in_tt__PolygonOptions(soap, tag, NULL, "tt:PolygonOptions");
	case SOAP_TYPE_tt__Config:
		return soap_in_tt__Config(soap, tag, NULL, "tt:Config");
	case SOAP_TYPE_tt__RuleEngineConfigurationExtension:
		return soap_in_tt__RuleEngineConfigurationExtension(soap, tag, NULL, "tt:RuleEngineConfigurationExtension");
	case SOAP_TYPE_tt__RuleEngineConfiguration:
		return soap_in_tt__RuleEngineConfiguration(soap, tag, NULL, "tt:RuleEngineConfiguration");
	case SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension:
		return soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, NULL, "tt:AnalyticsEngineConfigurationExtension");
	case SOAP_TYPE_tt__AnalyticsEngineConfiguration:
		return soap_in_tt__AnalyticsEngineConfiguration(soap, tag, NULL, "tt:AnalyticsEngineConfiguration");
	case SOAP_TYPE_tt__Polyline:
		return soap_in_tt__Polyline(soap, tag, NULL, "tt:Polyline");
	case SOAP_TYPE_tt__ItemListExtension:
		return soap_in_tt__ItemListExtension(soap, tag, NULL, "tt:ItemListExtension");
	case SOAP_TYPE_tt__ItemList:
		return soap_in_tt__ItemList(soap, tag, NULL, "tt:ItemList");
	case SOAP_TYPE_tt__MessageExtension:
		return soap_in_tt__MessageExtension(soap, tag, NULL, "tt:MessageExtension");
	case SOAP_TYPE_tt__NoiseReductionOptions:
		return soap_in_tt__NoiseReductionOptions(soap, tag, NULL, "tt:NoiseReductionOptions");
	case SOAP_TYPE_tt__DefoggingOptions:
		return soap_in_tt__DefoggingOptions(soap, tag, NULL, "tt:DefoggingOptions");
	case SOAP_TYPE_tt__ToneCompensationOptions:
		return soap_in_tt__ToneCompensationOptions(soap, tag, NULL, "tt:ToneCompensationOptions");
	case SOAP_TYPE_tt__FocusOptions20Extension:
		return soap_in_tt__FocusOptions20Extension(soap, tag, NULL, "tt:FocusOptions20Extension");
	case SOAP_TYPE_tt__FocusOptions20:
		return soap_in_tt__FocusOptions20(soap, tag, NULL, "tt:FocusOptions20");
	case SOAP_TYPE_tt__WhiteBalanceOptions20Extension:
		return soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, NULL, "tt:WhiteBalanceOptions20Extension");
	case SOAP_TYPE_tt__WhiteBalanceOptions20:
		return soap_in_tt__WhiteBalanceOptions20(soap, tag, NULL, "tt:WhiteBalanceOptions20");
	case SOAP_TYPE_tt__FocusConfiguration20Extension:
		return soap_in_tt__FocusConfiguration20Extension(soap, tag, NULL, "tt:FocusConfiguration20Extension");
	case SOAP_TYPE_tt__FocusConfiguration20:
		return soap_in_tt__FocusConfiguration20(soap, tag, NULL, "tt:FocusConfiguration20");
	case SOAP_TYPE_tt__WhiteBalance20Extension:
		return soap_in_tt__WhiteBalance20Extension(soap, tag, NULL, "tt:WhiteBalance20Extension");
	case SOAP_TYPE_tt__WhiteBalance20:
		return soap_in_tt__WhiteBalance20(soap, tag, NULL, "tt:WhiteBalance20");
	case SOAP_TYPE_tt__RelativeFocusOptions20:
		return soap_in_tt__RelativeFocusOptions20(soap, tag, NULL, "tt:RelativeFocusOptions20");
	case SOAP_TYPE_tt__MoveOptions20:
		return soap_in_tt__MoveOptions20(soap, tag, NULL, "tt:MoveOptions20");
	case SOAP_TYPE_tt__ExposureOptions20:
		return soap_in_tt__ExposureOptions20(soap, tag, NULL, "tt:ExposureOptions20");
	case SOAP_TYPE_tt__BacklightCompensationOptions20:
		return soap_in_tt__BacklightCompensationOptions20(soap, tag, NULL, "tt:BacklightCompensationOptions20");
	case SOAP_TYPE_tt__WideDynamicRangeOptions20:
		return soap_in_tt__WideDynamicRangeOptions20(soap, tag, NULL, "tt:WideDynamicRangeOptions20");
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension:
		return soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, NULL, "tt:IrCutFilterAutoAdjustmentOptionsExtension");
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions:
		return soap_in_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, NULL, "tt:IrCutFilterAutoAdjustmentOptions");
	case SOAP_TYPE_tt__ImageStabilizationOptionsExtension:
		return soap_in_tt__ImageStabilizationOptionsExtension(soap, tag, NULL, "tt:ImageStabilizationOptionsExtension");
	case SOAP_TYPE_tt__ImageStabilizationOptions:
		return soap_in_tt__ImageStabilizationOptions(soap, tag, NULL, "tt:ImageStabilizationOptions");
	case SOAP_TYPE_tt__ImagingOptions20Extension4:
		return soap_in_tt__ImagingOptions20Extension4(soap, tag, NULL, "tt:ImagingOptions20Extension4");
	case SOAP_TYPE_tt__ImagingOptions20Extension3:
		return soap_in_tt__ImagingOptions20Extension3(soap, tag, NULL, "tt:ImagingOptions20Extension3");
	case SOAP_TYPE_tt__ImagingOptions20Extension2:
		return soap_in_tt__ImagingOptions20Extension2(soap, tag, NULL, "tt:ImagingOptions20Extension2");
	case SOAP_TYPE_tt__ImagingOptions20Extension:
		return soap_in_tt__ImagingOptions20Extension(soap, tag, NULL, "tt:ImagingOptions20Extension");
	case SOAP_TYPE_tt__ImagingOptions20:
		return soap_in_tt__ImagingOptions20(soap, tag, NULL, "tt:ImagingOptions20");
	case SOAP_TYPE_tt__NoiseReduction:
		return soap_in_tt__NoiseReduction(soap, tag, NULL, "tt:NoiseReduction");
	case SOAP_TYPE_tt__DefoggingExtension:
		return soap_in_tt__DefoggingExtension(soap, tag, NULL, "tt:DefoggingExtension");
	case SOAP_TYPE_tt__Defogging:
		return soap_in_tt__Defogging(soap, tag, NULL, "tt:Defogging");
	case SOAP_TYPE_tt__ToneCompensationExtension:
		return soap_in_tt__ToneCompensationExtension(soap, tag, NULL, "tt:ToneCompensationExtension");
	case SOAP_TYPE_tt__ToneCompensation:
		return soap_in_tt__ToneCompensation(soap, tag, NULL, "tt:ToneCompensation");
	case SOAP_TYPE_tt__Exposure20:
		return soap_in_tt__Exposure20(soap, tag, NULL, "tt:Exposure20");
	case SOAP_TYPE_tt__BacklightCompensation20:
		return soap_in_tt__BacklightCompensation20(soap, tag, NULL, "tt:BacklightCompensation20");
	case SOAP_TYPE_tt__WideDynamicRange20:
		return soap_in_tt__WideDynamicRange20(soap, tag, NULL, "tt:WideDynamicRange20");
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension:
		return soap_in_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, NULL, "tt:IrCutFilterAutoAdjustmentExtension");
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustment:
		return soap_in_tt__IrCutFilterAutoAdjustment(soap, tag, NULL, "tt:IrCutFilterAutoAdjustment");
	case SOAP_TYPE_tt__ImageStabilizationExtension:
		return soap_in_tt__ImageStabilizationExtension(soap, tag, NULL, "tt:ImageStabilizationExtension");
	case SOAP_TYPE_tt__ImageStabilization:
		return soap_in_tt__ImageStabilization(soap, tag, NULL, "tt:ImageStabilization");
	case SOAP_TYPE_tt__ImagingSettingsExtension204:
		return soap_in_tt__ImagingSettingsExtension204(soap, tag, NULL, "tt:ImagingSettingsExtension204");
	case SOAP_TYPE_tt__ImagingSettingsExtension203:
		return soap_in_tt__ImagingSettingsExtension203(soap, tag, NULL, "tt:ImagingSettingsExtension203");
	case SOAP_TYPE_tt__ImagingSettingsExtension202:
		return soap_in_tt__ImagingSettingsExtension202(soap, tag, NULL, "tt:ImagingSettingsExtension202");
	case SOAP_TYPE_tt__ImagingSettingsExtension20:
		return soap_in_tt__ImagingSettingsExtension20(soap, tag, NULL, "tt:ImagingSettingsExtension20");
	case SOAP_TYPE_tt__ImagingSettings20:
		return soap_in_tt__ImagingSettings20(soap, tag, NULL, "tt:ImagingSettings20");
	case SOAP_TYPE_tt__FocusStatus20Extension:
		return soap_in_tt__FocusStatus20Extension(soap, tag, NULL, "tt:FocusStatus20Extension");
	case SOAP_TYPE_tt__FocusStatus20:
		return soap_in_tt__FocusStatus20(soap, tag, NULL, "tt:FocusStatus20");
	case SOAP_TYPE_tt__ImagingStatus20Extension:
		return soap_in_tt__ImagingStatus20Extension(soap, tag, NULL, "tt:ImagingStatus20Extension");
	case SOAP_TYPE_tt__ImagingStatus20:
		return soap_in_tt__ImagingStatus20(soap, tag, NULL, "tt:ImagingStatus20");
	case SOAP_TYPE_tt__ContinuousFocusOptions:
		return soap_in_tt__ContinuousFocusOptions(soap, tag, NULL, "tt:ContinuousFocusOptions");
	case SOAP_TYPE_tt__AbsoluteFocusOptions:
		return soap_in_tt__AbsoluteFocusOptions(soap, tag, NULL, "tt:AbsoluteFocusOptions");
	case SOAP_TYPE_tt__ContinuousFocus:
		return soap_in_tt__ContinuousFocus(soap, tag, NULL, "tt:ContinuousFocus");
	case SOAP_TYPE_tt__RelativeFocus:
		return soap_in_tt__RelativeFocus(soap, tag, NULL, "tt:RelativeFocus");
	case SOAP_TYPE_tt__AbsoluteFocus:
		return soap_in_tt__AbsoluteFocus(soap, tag, NULL, "tt:AbsoluteFocus");
	case SOAP_TYPE_tt__FocusMove:
		return soap_in_tt__FocusMove(soap, tag, NULL, "tt:FocusMove");
	case SOAP_TYPE_tt__PTZSpeed:
		return soap_in_tt__PTZSpeed(soap, tag, NULL, "tt:PTZSpeed");
	case SOAP_TYPE_tt__Space1DDescription:
		return soap_in_tt__Space1DDescription(soap, tag, NULL, "tt:Space1DDescription");
	case SOAP_TYPE_tt__Space2DDescription:
		return soap_in_tt__Space2DDescription(soap, tag, NULL, "tt:Space2DDescription");
	case SOAP_TYPE_tt__ZoomLimits:
		return soap_in_tt__ZoomLimits(soap, tag, NULL, "tt:ZoomLimits");
	case SOAP_TYPE_tt__PanTiltLimits:
		return soap_in_tt__PanTiltLimits(soap, tag, NULL, "tt:PanTiltLimits");
	case SOAP_TYPE_tt__Reverse:
		return soap_in_tt__Reverse(soap, tag, NULL, "tt:Reverse");
	case SOAP_TYPE_tt__EFlip:
		return soap_in_tt__EFlip(soap, tag, NULL, "tt:EFlip");
	case SOAP_TYPE_tt__PTControlDirectionExtension:
		return soap_in_tt__PTControlDirectionExtension(soap, tag, NULL, "tt:PTControlDirectionExtension");
	case SOAP_TYPE_tt__PTControlDirection:
		return soap_in_tt__PTControlDirection(soap, tag, NULL, "tt:PTControlDirection");
	case SOAP_TYPE_tt__PTZConfigurationExtension2:
		return soap_in_tt__PTZConfigurationExtension2(soap, tag, NULL, "tt:PTZConfigurationExtension2");
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		return soap_in_tt__PTZConfigurationExtension(soap, tag, NULL, "tt:PTZConfigurationExtension");
	case SOAP_TYPE_tt__PTZConfiguration:
		return soap_in_tt__PTZConfiguration(soap, tag, NULL, "tt:PTZConfiguration");
	case SOAP_TYPE_tt__IPAddress:
		return soap_in_tt__IPAddress(soap, tag, NULL, "tt:IPAddress");
	case SOAP_TYPE_tt__MulticastConfiguration:
		return soap_in_tt__MulticastConfiguration(soap, tag, NULL, "tt:MulticastConfiguration");
	case SOAP_TYPE_tt__AudioDecoderConfiguration:
		return soap_in_tt__AudioDecoderConfiguration(soap, tag, NULL, "tt:AudioDecoderConfiguration");
	case SOAP_TYPE_tt__AudioOutputConfiguration:
		return soap_in_tt__AudioOutputConfiguration(soap, tag, NULL, "tt:AudioOutputConfiguration");
	case SOAP_TYPE_tt__EventSubscription:
		return soap_in_tt__EventSubscription(soap, tag, NULL, "tt:EventSubscription");
	case SOAP_TYPE_tt__PTZFilter:
		return soap_in_tt__PTZFilter(soap, tag, NULL, "tt:PTZFilter");
	case SOAP_TYPE_tt__MetadataConfigurationExtension:
		return soap_in_tt__MetadataConfigurationExtension(soap, tag, NULL, "tt:MetadataConfigurationExtension");
	case SOAP_TYPE_tt__MetadataConfiguration:
		return soap_in_tt__MetadataConfiguration(soap, tag, NULL, "tt:MetadataConfiguration");
	case SOAP_TYPE_tt__VideoAnalyticsConfiguration:
		return soap_in_tt__VideoAnalyticsConfiguration(soap, tag, NULL, "tt:VideoAnalyticsConfiguration");
	case SOAP_TYPE_tt__AudioEncoderConfiguration:
		return soap_in_tt__AudioEncoderConfiguration(soap, tag, NULL, "tt:AudioEncoderConfiguration");
	case SOAP_TYPE_tt__AudioSourceConfiguration:
		return soap_in_tt__AudioSourceConfiguration(soap, tag, NULL, "tt:AudioSourceConfiguration");
	case SOAP_TYPE_tt__H264Configuration:
		return soap_in_tt__H264Configuration(soap, tag, NULL, "tt:H264Configuration");
	case SOAP_TYPE_tt__Mpeg4Configuration:
		return soap_in_tt__Mpeg4Configuration(soap, tag, NULL, "tt:Mpeg4Configuration");
	case SOAP_TYPE_tt__VideoRateControl:
		return soap_in_tt__VideoRateControl(soap, tag, NULL, "tt:VideoRateControl");
	case SOAP_TYPE_tt__VideoResolution:
		return soap_in_tt__VideoResolution(soap, tag, NULL, "tt:VideoResolution");
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		return soap_in_tt__VideoEncoderConfiguration(soap, tag, NULL, "tt:VideoEncoderConfiguration");
	case SOAP_TYPE_tt__SceneOrientation:
		return soap_in_tt__SceneOrientation(soap, tag, NULL, "tt:SceneOrientation");
	case SOAP_TYPE_tt__LensDescription:
		return soap_in_tt__LensDescription(soap, tag, NULL, "tt:LensDescription");
	case SOAP_TYPE_tt__LensOffset:
		return soap_in_tt__LensOffset(soap, tag, NULL, "tt:LensOffset");
	case SOAP_TYPE_tt__LensProjection:
		return soap_in_tt__LensProjection(soap, tag, NULL, "tt:LensProjection");
	case SOAP_TYPE_tt__RotateExtension:
		return soap_in_tt__RotateExtension(soap, tag, NULL, "tt:RotateExtension");
	case SOAP_TYPE_tt__Rotate:
		return soap_in_tt__Rotate(soap, tag, NULL, "tt:Rotate");
	case SOAP_TYPE_tt__VideoSourceConfigurationExtension2:
		return soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, NULL, "tt:VideoSourceConfigurationExtension2");
	case SOAP_TYPE_tt__VideoSourceConfigurationExtension:
		return soap_in_tt__VideoSourceConfigurationExtension(soap, tag, NULL, "tt:VideoSourceConfigurationExtension");
	case SOAP_TYPE_tt__VideoSourceConfiguration:
		return soap_in_tt__VideoSourceConfiguration(soap, tag, NULL, "tt:VideoSourceConfiguration");
	case SOAP_TYPE_tt__ConfigurationEntity:
		return soap_in_tt__ConfigurationEntity(soap, tag, NULL, "tt:ConfigurationEntity");
	case SOAP_TYPE_tt__DurationRange:
		return soap_in_tt__DurationRange(soap, tag, NULL, "tt:DurationRange");
	case SOAP_TYPE_tt__FloatRange:
		return soap_in_tt__FloatRange(soap, tag, NULL, "tt:FloatRange");
	case SOAP_TYPE_tt__IntRectangleRange:
		return soap_in_tt__IntRectangleRange(soap, tag, NULL, "tt:IntRectangleRange");
	case SOAP_TYPE_tt__IntRectangle:
		return soap_in_tt__IntRectangle(soap, tag, NULL, "tt:IntRectangle");
	case SOAP_TYPE_timg__ImagingPreset:
		return soap_in_timg__ImagingPreset(soap, tag, NULL, "timg:ImagingPreset");
	case SOAP_TYPE_timg__Capabilities:
		return soap_in_timg__Capabilities(soap, tag, NULL, "timg:Capabilities");
	case SOAP_TYPE_xsd__token__:
		return soap_in_xsd__token__(soap, tag, NULL, "xsd:token");
	case SOAP_TYPE_xsd__token:
		return soap_in_xsd__token(soap, tag, NULL, "xsd:token");
	case SOAP_TYPE_xsd__string_:
		return soap_in_xsd__string_(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_xsd__nonNegativeInteger__:
		return soap_in_xsd__nonNegativeInteger__(soap, tag, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, tag, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer__:
		return soap_in_xsd__integer__(soap, tag, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, tag, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__int_:
		return soap_in_xsd__int_(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_xsd__hexBinary__:
		return soap_in_xsd__hexBinary__(soap, tag, NULL, "xsd:hexBinary");
	case SOAP_TYPE_xsd__float_:
		return soap_in_xsd__float_(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_xsd__duration__:
		return soap_in_xsd__duration__(soap, tag, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, tag, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__double_:
		return soap_in_xsd__double_(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_xsd__dateTime_:
		return soap_in_xsd__dateTime_(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean_:
		return soap_in_xsd__boolean_(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary__:
		return soap_in_xsd__base64Binary__(soap, tag, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI__:
		return soap_in_xsd__anyURI__(soap, tag, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType__:
		return soap_in_xsd__anySimpleType__(soap, tag, NULL, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__anySimpleType:
		return soap_in_xsd__anySimpleType(soap, tag, NULL, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__QName__:
		return soap_in_xsd__QName__(soap, tag, NULL, "xsd:QName");
	case SOAP_TYPE_xsd__NCName__:
		return soap_in_xsd__NCName__(soap, tag, NULL, "xsd:NCName");
	case SOAP_TYPE_xsd__NCName:
		return soap_in_xsd__NCName(soap, tag, NULL, "xsd:NCName");
	case SOAP_TYPE_SOAP_ENV__Fault_:
		return soap_in_SOAP_ENV__Fault_(soap, tag, NULL, "SOAP-ENV:Fault");
	case SOAP_TYPE_SOAP_ENV__Envelope_:
		return soap_in_SOAP_ENV__Envelope_(soap, tag, NULL, "SOAP-ENV:Envelope");
	case SOAP_TYPE_wsa5__EndpointReferenceType__:
		return soap_in_wsa5__EndpointReferenceType__(soap, tag, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_xsd__hexBinary:
		return soap_in_xsd__hexBinary(soap, tag, NULL, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, tag, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, tag, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, tag, NULL, "xsd:anyType");
	case SOAP_TYPE_SOAP_ENV__Envelope:
		return soap_in_SOAP_ENV__Envelope(soap, tag, NULL, "SOAP-ENV:Envelope");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_in_chan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_in_wsa5__ProblemActionType(soap, tag, NULL, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_in_wsa5__RelatesToType(soap, tag, NULL, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_in_wsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTo_timg__SetCurrentPreset:
		return soap_in_PointerTo_timg__SetCurrentPreset(soap, tag, NULL, "timg:SetCurrentPreset");
	case SOAP_TYPE_PointerTo_timg__GetCurrentPreset:
		return soap_in_PointerTo_timg__GetCurrentPreset(soap, tag, NULL, "timg:GetCurrentPreset");
	case SOAP_TYPE_PointerTo_timg__GetPresets:
		return soap_in_PointerTo_timg__GetPresets(soap, tag, NULL, "timg:GetPresets");
	case SOAP_TYPE_PointerTo_timg__GetMoveOptions:
		return soap_in_PointerTo_timg__GetMoveOptions(soap, tag, NULL, "timg:GetMoveOptions");
	case SOAP_TYPE_PointerTo_timg__GetStatus:
		return soap_in_PointerTo_timg__GetStatus(soap, tag, NULL, "timg:GetStatus");
	case SOAP_TYPE_PointerTo_timg__Stop:
		return soap_in_PointerTo_timg__Stop(soap, tag, NULL, "timg:Stop");
	case SOAP_TYPE_PointerTo_timg__Move:
		return soap_in_PointerTo_timg__Move(soap, tag, NULL, "timg:Move");
	case SOAP_TYPE_PointerTo_timg__GetOptions:
		return soap_in_PointerTo_timg__GetOptions(soap, tag, NULL, "timg:GetOptions");
	case SOAP_TYPE_PointerTo_timg__SetImagingSettings:
		return soap_in_PointerTo_timg__SetImagingSettings(soap, tag, NULL, "timg:SetImagingSettings");
	case SOAP_TYPE_PointerTo_timg__GetImagingSettings:
		return soap_in_PointerTo_timg__GetImagingSettings(soap, tag, NULL, "timg:GetImagingSettings");
	case SOAP_TYPE_PointerTo_timg__GetServiceCapabilities:
		return soap_in_PointerTo_timg__GetServiceCapabilities(soap, tag, NULL, "timg:GetServiceCapabilities");
	case SOAP_TYPE_PointerToxsd__NCName:
		return soap_in_PointerToxsd__NCName(soap, tag, NULL, "xsd:NCName");
	case SOAP_TYPE_PointerTowstop__ConcreteTopicExpression:
		return soap_in_PointerTowstop__ConcreteTopicExpression(soap, tag, NULL, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_in_PointerToxsd__QName(soap, tag, NULL, "xsd:QName");
	case SOAP_TYPE_PointerTowstop__TopicType:
		return soap_in_PointerTowstop__TopicType(soap, tag, NULL, "wstop:TopicType");
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		return soap_in_PointerTowstop__QueryExpressionType(soap, tag, NULL, "wstop:QueryExpressionType");
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension:
		return soap_in_PointerTott__PTZConfigurationExtension(soap, tag, NULL, "tt:PTZConfigurationExtension");
	case SOAP_TYPE_PointerTott__ZoomLimits:
		return soap_in_PointerTott__ZoomLimits(soap, tag, NULL, "tt:ZoomLimits");
	case SOAP_TYPE_PointerTott__PanTiltLimits:
		return soap_in_PointerTott__PanTiltLimits(soap, tag, NULL, "tt:PanTiltLimits");
	case SOAP_TYPE_PointerTott__PTZSpeed:
		return soap_in_PointerTott__PTZSpeed(soap, tag, NULL, "tt:PTZSpeed");
	case SOAP_TYPE_PointerTott__MetadataConfigurationExtension:
		return soap_in_PointerTott__MetadataConfigurationExtension(soap, tag, NULL, "tt:MetadataConfigurationExtension");
	case SOAP_TYPE_PointerTott__EventSubscription:
		return soap_in_PointerTott__EventSubscription(soap, tag, NULL, "tt:EventSubscription");
	case SOAP_TYPE_PointerTott__PTZFilter:
		return soap_in_PointerTott__PTZFilter(soap, tag, NULL, "tt:PTZFilter");
	case SOAP_TYPE_PointerTott__RuleEngineConfiguration:
		return soap_in_PointerTott__RuleEngineConfiguration(soap, tag, NULL, "tt:RuleEngineConfiguration");
	case SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration:
		return soap_in_PointerTott__AnalyticsEngineConfiguration(soap, tag, NULL, "tt:AnalyticsEngineConfiguration");
	case SOAP_TYPE_PointerTott__MulticastConfiguration:
		return soap_in_PointerTott__MulticastConfiguration(soap, tag, NULL, "tt:MulticastConfiguration");
	case SOAP_TYPE_PointerTott__H264Configuration:
		return soap_in_PointerTott__H264Configuration(soap, tag, NULL, "tt:H264Configuration");
	case SOAP_TYPE_PointerTott__Mpeg4Configuration:
		return soap_in_PointerTott__Mpeg4Configuration(soap, tag, NULL, "tt:Mpeg4Configuration");
	case SOAP_TYPE_PointerTott__VideoRateControl:
		return soap_in_PointerTott__VideoRateControl(soap, tag, NULL, "tt:VideoRateControl");
	case SOAP_TYPE_PointerTott__VideoResolution:
		return soap_in_PointerTott__VideoResolution(soap, tag, NULL, "tt:VideoResolution");
	case SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension:
		return soap_in_PointerTott__VideoSourceConfigurationExtension(soap, tag, NULL, "tt:VideoSourceConfigurationExtension");
	case SOAP_TYPE_PointerTott__IntRectangle:
		return soap_in_PointerTott__IntRectangle(soap, tag, NULL, "tt:IntRectangle");
	case SOAP_TYPE_PointerTowstop__Documentation:
		return soap_in_PointerTowstop__Documentation(soap, tag, NULL, "wstop:Documentation");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		return soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, NULL, "wsrfbf:BaseFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_in_PointerTo_xml__lang(soap, tag, NULL, "xml:lang");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		return soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, NULL, "wsrfbf:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_in_PointerToxsd__nonNegativeInteger(soap, tag, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy:
		return soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, NULL, "wsnt:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType:
		return soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, tag, NULL, "wsnt:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType:
		return soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, NULL, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType:
		return soap_in_PointerTowsnt__SubscriptionPolicyType(soap, tag, NULL, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		return soap_in_PointerTowstop__TopicSetType(soap, tag, NULL, "wstop:TopicSetType");
	case SOAP_TYPE_PointerTowsnt__TopicExpressionType:
		return soap_in_PointerTowsnt__TopicExpressionType(soap, tag, NULL, "wsnt:TopicExpressionType");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTott__PropertyOperation:
		return soap_in_PointerTott__PropertyOperation(soap, tag, NULL, "tt:PropertyOperation");
	case SOAP_TYPE_PointerTott__MessageExtension:
		return soap_in_PointerTott__MessageExtension(soap, tag, NULL, "tt:MessageExtension");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, tag, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTott__ItemList:
		return soap_in_PointerTott__ItemList(soap, tag, NULL, "tt:ItemList");
	case SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension:
		return soap_in_PointerTott__RuleEngineConfigurationExtension(soap, tag, NULL, "tt:RuleEngineConfigurationExtension");
	case SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension:
		return soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag, NULL, "tt:AnalyticsEngineConfigurationExtension");
	case SOAP_TYPE_PointerTott__Config:
		return soap_in_PointerTott__Config(soap, tag, NULL, "tt:Config");
	case SOAP_TYPE_PointerTott__Vector:
		return soap_in_PointerTott__Vector(soap, tag, NULL, "tt:Vector");
	case SOAP_TYPE_PointerTott__ItemListExtension:
		return soap_in_PointerTott__ItemListExtension(soap, tag, NULL, "tt:ItemListExtension");
	case SOAP_TYPE_PointerTott__FocusOptions20Extension:
		return soap_in_PointerTott__FocusOptions20Extension(soap, tag, NULL, "tt:FocusOptions20Extension");
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension:
		return soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, tag, NULL, "tt:WhiteBalanceOptions20Extension");
	case SOAP_TYPE_PointerTott__StringAttrList:
		return soap_in_PointerTott__StringAttrList(soap, tag, NULL, "tt:StringAttrList");
	case SOAP_TYPE_PointerTott__FocusConfiguration20Extension:
		return soap_in_PointerTott__FocusConfiguration20Extension(soap, tag, NULL, "tt:FocusConfiguration20Extension");
	case SOAP_TYPE_PointerTott__WhiteBalance20Extension:
		return soap_in_PointerTott__WhiteBalance20Extension(soap, tag, NULL, "tt:WhiteBalance20Extension");
	case SOAP_TYPE_PointerTott__ContinuousFocusOptions:
		return soap_in_PointerTott__ContinuousFocusOptions(soap, tag, NULL, "tt:ContinuousFocusOptions");
	case SOAP_TYPE_PointerTott__RelativeFocusOptions20:
		return soap_in_PointerTott__RelativeFocusOptions20(soap, tag, NULL, "tt:RelativeFocusOptions20");
	case SOAP_TYPE_PointerTott__AbsoluteFocusOptions:
		return soap_in_PointerTott__AbsoluteFocusOptions(soap, tag, NULL, "tt:AbsoluteFocusOptions");
	case SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension:
		return soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, NULL, "tt:IrCutFilterAutoAdjustmentOptionsExtension");
	case SOAP_TYPE_PointerTott__DurationRange:
		return soap_in_PointerTott__DurationRange(soap, tag, NULL, "tt:DurationRange");
	case SOAP_TYPE_PointerTott__ImageStabilizationOptionsExtension:
		return soap_in_PointerTott__ImageStabilizationOptionsExtension(soap, tag, NULL, "tt:ImageStabilizationOptionsExtension");
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension4:
		return soap_in_PointerTott__ImagingOptions20Extension4(soap, tag, NULL, "tt:ImagingOptions20Extension4");
	case SOAP_TYPE_PointerTott__NoiseReductionOptions:
		return soap_in_PointerTott__NoiseReductionOptions(soap, tag, NULL, "tt:NoiseReductionOptions");
	case SOAP_TYPE_PointerTott__DefoggingOptions:
		return soap_in_PointerTott__DefoggingOptions(soap, tag, NULL, "tt:DefoggingOptions");
	case SOAP_TYPE_PointerTott__ToneCompensationOptions:
		return soap_in_PointerTott__ToneCompensationOptions(soap, tag, NULL, "tt:ToneCompensationOptions");
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension3:
		return soap_in_PointerTott__ImagingOptions20Extension3(soap, tag, NULL, "tt:ImagingOptions20Extension3");
	case SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptions:
		return soap_in_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, tag, NULL, "tt:IrCutFilterAutoAdjustmentOptions");
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension2:
		return soap_in_PointerTott__ImagingOptions20Extension2(soap, tag, NULL, "tt:ImagingOptions20Extension2");
	case SOAP_TYPE_PointerTott__ImageStabilizationOptions:
		return soap_in_PointerTott__ImageStabilizationOptions(soap, tag, NULL, "tt:ImageStabilizationOptions");
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension:
		return soap_in_PointerTott__ImagingOptions20Extension(soap, tag, NULL, "tt:ImagingOptions20Extension");
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions20:
		return soap_in_PointerTott__WhiteBalanceOptions20(soap, tag, NULL, "tt:WhiteBalanceOptions20");
	case SOAP_TYPE_PointerTott__WideDynamicRangeOptions20:
		return soap_in_PointerTott__WideDynamicRangeOptions20(soap, tag, NULL, "tt:WideDynamicRangeOptions20");
	case SOAP_TYPE_PointerTott__FocusOptions20:
		return soap_in_PointerTott__FocusOptions20(soap, tag, NULL, "tt:FocusOptions20");
	case SOAP_TYPE_PointerTott__ExposureOptions20:
		return soap_in_PointerTott__ExposureOptions20(soap, tag, NULL, "tt:ExposureOptions20");
	case SOAP_TYPE_PointerTott__BacklightCompensationOptions20:
		return soap_in_PointerTott__BacklightCompensationOptions20(soap, tag, NULL, "tt:BacklightCompensationOptions20");
	case SOAP_TYPE_PointerTott__DefoggingExtension:
		return soap_in_PointerTott__DefoggingExtension(soap, tag, NULL, "tt:DefoggingExtension");
	case SOAP_TYPE_PointerTott__ToneCompensationExtension:
		return soap_in_PointerTott__ToneCompensationExtension(soap, tag, NULL, "tt:ToneCompensationExtension");
	case SOAP_TYPE_PointerTott__Rectangle:
		return soap_in_PointerTott__Rectangle(soap, tag, NULL, "tt:Rectangle");
	case SOAP_TYPE_PointerTott__ExposurePriority:
		return soap_in_PointerTott__ExposurePriority(soap, tag, NULL, "tt:ExposurePriority");
	case SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentExtension:
		return soap_in_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, tag, NULL, "tt:IrCutFilterAutoAdjustmentExtension");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_in_PointerToxsd__duration(soap, tag, NULL, "xsd:duration");
	case SOAP_TYPE_PointerTott__ImageStabilizationExtension:
		return soap_in_PointerTott__ImageStabilizationExtension(soap, tag, NULL, "tt:ImageStabilizationExtension");
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension204:
		return soap_in_PointerTott__ImagingSettingsExtension204(soap, tag, NULL, "tt:ImagingSettingsExtension204");
	case SOAP_TYPE_PointerTott__NoiseReduction:
		return soap_in_PointerTott__NoiseReduction(soap, tag, NULL, "tt:NoiseReduction");
	case SOAP_TYPE_PointerTott__Defogging:
		return soap_in_PointerTott__Defogging(soap, tag, NULL, "tt:Defogging");
	case SOAP_TYPE_PointerTott__ToneCompensation:
		return soap_in_PointerTott__ToneCompensation(soap, tag, NULL, "tt:ToneCompensation");
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension203:
		return soap_in_PointerTott__ImagingSettingsExtension203(soap, tag, NULL, "tt:ImagingSettingsExtension203");
	case SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustment:
		return soap_in_PointerTott__IrCutFilterAutoAdjustment(soap, tag, NULL, "tt:IrCutFilterAutoAdjustment");
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension202:
		return soap_in_PointerTott__ImagingSettingsExtension202(soap, tag, NULL, "tt:ImagingSettingsExtension202");
	case SOAP_TYPE_PointerTott__ImageStabilization:
		return soap_in_PointerTott__ImageStabilization(soap, tag, NULL, "tt:ImageStabilization");
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension20:
		return soap_in_PointerTott__ImagingSettingsExtension20(soap, tag, NULL, "tt:ImagingSettingsExtension20");
	case SOAP_TYPE_PointerTott__WhiteBalance20:
		return soap_in_PointerTott__WhiteBalance20(soap, tag, NULL, "tt:WhiteBalance20");
	case SOAP_TYPE_PointerTott__WideDynamicRange20:
		return soap_in_PointerTott__WideDynamicRange20(soap, tag, NULL, "tt:WideDynamicRange20");
	case SOAP_TYPE_PointerTott__IrCutFilterMode:
		return soap_in_PointerTott__IrCutFilterMode(soap, tag, NULL, "tt:IrCutFilterMode");
	case SOAP_TYPE_PointerTott__FocusConfiguration20:
		return soap_in_PointerTott__FocusConfiguration20(soap, tag, NULL, "tt:FocusConfiguration20");
	case SOAP_TYPE_PointerTott__Exposure20:
		return soap_in_PointerTott__Exposure20(soap, tag, NULL, "tt:Exposure20");
	case SOAP_TYPE_PointerTott__BacklightCompensation20:
		return soap_in_PointerTott__BacklightCompensation20(soap, tag, NULL, "tt:BacklightCompensation20");
	case SOAP_TYPE_PointerTott__FocusStatus20Extension:
		return soap_in_PointerTott__FocusStatus20Extension(soap, tag, NULL, "tt:FocusStatus20Extension");
	case SOAP_TYPE_PointerTott__ImagingStatus20Extension:
		return soap_in_PointerTott__ImagingStatus20Extension(soap, tag, NULL, "tt:ImagingStatus20Extension");
	case SOAP_TYPE_PointerTott__FocusStatus20:
		return soap_in_PointerTott__FocusStatus20(soap, tag, NULL, "tt:FocusStatus20");
	case SOAP_TYPE_PointerTott__ContinuousFocus:
		return soap_in_PointerTott__ContinuousFocus(soap, tag, NULL, "tt:ContinuousFocus");
	case SOAP_TYPE_PointerTott__RelativeFocus:
		return soap_in_PointerTott__RelativeFocus(soap, tag, NULL, "tt:RelativeFocus");
	case SOAP_TYPE_PointerTott__AbsoluteFocus:
		return soap_in_PointerTott__AbsoluteFocus(soap, tag, NULL, "tt:AbsoluteFocus");
	case SOAP_TYPE_PointerTott__Vector1D:
		return soap_in_PointerTott__Vector1D(soap, tag, NULL, "tt:Vector1D");
	case SOAP_TYPE_PointerTott__Vector2D:
		return soap_in_PointerTott__Vector2D(soap, tag, NULL, "tt:Vector2D");
	case SOAP_TYPE_PointerTott__FloatRange:
		return soap_in_PointerTott__FloatRange(soap, tag, NULL, "tt:FloatRange");
	case SOAP_TYPE_PointerTott__Space1DDescription:
		return soap_in_PointerTott__Space1DDescription(soap, tag, NULL, "tt:Space1DDescription");
	case SOAP_TYPE_PointerTott__Space2DDescription:
		return soap_in_PointerTott__Space2DDescription(soap, tag, NULL, "tt:Space2DDescription");
	case SOAP_TYPE_PointerTott__PTControlDirectionExtension:
		return soap_in_PointerTott__PTControlDirectionExtension(soap, tag, NULL, "tt:PTControlDirectionExtension");
	case SOAP_TYPE_PointerTott__Reverse:
		return soap_in_PointerTott__Reverse(soap, tag, NULL, "tt:Reverse");
	case SOAP_TYPE_PointerTott__EFlip:
		return soap_in_PointerTott__EFlip(soap, tag, NULL, "tt:EFlip");
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension2:
		return soap_in_PointerTott__PTZConfigurationExtension2(soap, tag, NULL, "tt:PTZConfigurationExtension2");
	case SOAP_TYPE_PointerTott__PTControlDirection:
		return soap_in_PointerTott__PTControlDirection(soap, tag, NULL, "tt:PTControlDirection");
	case SOAP_TYPE_PointerTott__IPv6Address:
		return soap_in_PointerTott__IPv6Address(soap, tag, NULL, "tt:IPv6Address");
	case SOAP_TYPE_PointerTott__IPv4Address:
		return soap_in_PointerTott__IPv4Address(soap, tag, NULL, "tt:IPv4Address");
	case SOAP_TYPE_PointerTott__IPAddress:
		return soap_in_PointerTott__IPAddress(soap, tag, NULL, "tt:IPAddress");
	case SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy:
		return soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, tag, NULL, "tt:EventSubscription-SubscriptionPolicy");
	case SOAP_TYPE_PointerTowsnt__FilterType:
		return soap_in_PointerTowsnt__FilterType(soap, tag, NULL, "wsnt:FilterType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTott__LensProjection:
		return soap_in_PointerTott__LensProjection(soap, tag, NULL, "tt:LensProjection");
	case SOAP_TYPE_PointerTott__LensOffset:
		return soap_in_PointerTott__LensOffset(soap, tag, NULL, "tt:LensOffset");
	case SOAP_TYPE_PointerTofloat:
		return soap_in_PointerTofloat(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_PointerTott__RotateExtension:
		return soap_in_PointerTott__RotateExtension(soap, tag, NULL, "tt:RotateExtension");
	case SOAP_TYPE_PointerTott__SceneOrientation:
		return soap_in_PointerTott__SceneOrientation(soap, tag, NULL, "tt:SceneOrientation");
	case SOAP_TYPE_PointerTott__LensDescription:
		return soap_in_PointerTott__LensDescription(soap, tag, NULL, "tt:LensDescription");
	case SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension2:
		return soap_in_PointerTott__VideoSourceConfigurationExtension2(soap, tag, NULL, "tt:VideoSourceConfigurationExtension2");
	case SOAP_TYPE_PointerTott__Rotate:
		return soap_in_PointerTott__Rotate(soap, tag, NULL, "tt:Rotate");
	case SOAP_TYPE_PointerTott__IntRange:
		return soap_in_PointerTott__IntRange(soap, tag, NULL, "tt:IntRange");
	case SOAP_TYPE_PointerTotimg__ImagingPreset:
		return soap_in_PointerTotimg__ImagingPreset(soap, tag, NULL, "timg:ImagingPreset");
	case SOAP_TYPE_PointerTott__ImagingStatus20:
		return soap_in_PointerTott__ImagingStatus20(soap, tag, NULL, "tt:ImagingStatus20");
	case SOAP_TYPE_PointerTott__MoveOptions20:
		return soap_in_PointerTott__MoveOptions20(soap, tag, NULL, "tt:MoveOptions20");
	case SOAP_TYPE_PointerTott__FocusMove:
		return soap_in_PointerTott__FocusMove(soap, tag, NULL, "tt:FocusMove");
	case SOAP_TYPE_PointerTott__ImagingOptions20:
		return soap_in_PointerTott__ImagingOptions20(soap, tag, NULL, "tt:ImagingOptions20");
	case SOAP_TYPE_PointerTott__ImagingSettings20:
		return soap_in_PointerTott__ImagingSettings20(soap, tag, NULL, "tt:ImagingSettings20");
	case SOAP_TYPE_PointerTotimg__Capabilities:
		return soap_in_PointerTotimg__Capabilities(soap, tag, NULL, "timg:Capabilities");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_in_PointerTochan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_in_PointerTo_wsa5__FaultTo(soap, tag, NULL, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_in_PointerTo_wsa5__ReplyTo(soap, tag, NULL, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_in_PointerTo_wsa5__From(soap, tag, NULL, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_in_PointerTo_wsa5__RelatesTo(soap, tag, NULL, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
	{	char **s;
		s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_in_PointerTowsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
	{	char **s;
		s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, "wsa5:FaultCodesOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
	{	char **s;
		s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, "wsa5:RelationshipTypeOpenEnum");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "wstop:ConcreteTopicExpression"))
		{	*type = SOAP_TYPE_wstop__ConcreteTopicExpression__;
			return soap_in_wstop__ConcreteTopicExpression__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:ConcreteTopicExpression"))
		{	*type = SOAP_TYPE_wstop__ConcreteTopicExpression;
			return soap_in_wstop__ConcreteTopicExpression(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MoveStatus"))
		{	*type = SOAP_TYPE_tt__MoveStatus_;
			return soap_in_tt__MoveStatus_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ReferenceToken"))
		{	*type = SOAP_TYPE_tt__ReferenceToken__;
			return soap_in_tt__ReferenceToken__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ReferenceToken"))
		{	*type = SOAP_TYPE_tt__ReferenceToken;
			return soap_in_tt__ReferenceToken(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PropertyOperation"))
		{	*type = SOAP_TYPE_tt__PropertyOperation_;
			return soap_in_tt__PropertyOperation_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImageStabilizationMode"))
		{	*type = SOAP_TYPE_tt__ImageStabilizationMode_;
			return soap_in_tt__ImageStabilizationMode_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IrCutFilterMode"))
		{	*type = SOAP_TYPE_tt__IrCutFilterMode_;
			return soap_in_tt__IrCutFilterMode_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WhiteBalanceMode"))
		{	*type = SOAP_TYPE_tt__WhiteBalanceMode_;
			return soap_in_tt__WhiteBalanceMode_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ExposureMode"))
		{	*type = SOAP_TYPE_tt__ExposureMode_;
			return soap_in_tt__ExposureMode_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ExposurePriority"))
		{	*type = SOAP_TYPE_tt__ExposurePriority_;
			return soap_in_tt__ExposurePriority_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BacklightCompensationMode"))
		{	*type = SOAP_TYPE_tt__BacklightCompensationMode_;
			return soap_in_tt__BacklightCompensationMode_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WideDynamicMode"))
		{	*type = SOAP_TYPE_tt__WideDynamicMode_;
			return soap_in_tt__WideDynamicMode_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AutoFocusMode"))
		{	*type = SOAP_TYPE_tt__AutoFocusMode_;
			return soap_in_tt__AutoFocusMode_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ReverseMode"))
		{	*type = SOAP_TYPE_tt__ReverseMode_;
			return soap_in_tt__ReverseMode_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EFlipMode"))
		{	*type = SOAP_TYPE_tt__EFlipMode_;
			return soap_in_tt__EFlipMode_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPType"))
		{	*type = SOAP_TYPE_tt__IPType_;
			return soap_in_tt__IPType_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6Address"))
		{	*type = SOAP_TYPE_tt__IPv6Address__;
			return soap_in_tt__IPv6Address__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6Address"))
		{	*type = SOAP_TYPE_tt__IPv6Address;
			return soap_in_tt__IPv6Address(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv4Address"))
		{	*type = SOAP_TYPE_tt__IPv4Address__;
			return soap_in_tt__IPv4Address__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv4Address"))
		{	*type = SOAP_TYPE_tt__IPv4Address;
			return soap_in_tt__IPv4Address(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioEncoding"))
		{	*type = SOAP_TYPE_tt__AudioEncoding_;
			return soap_in_tt__AudioEncoding_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:H264Profile"))
		{	*type = SOAP_TYPE_tt__H264Profile_;
			return soap_in_tt__H264Profile_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Mpeg4Profile"))
		{	*type = SOAP_TYPE_tt__Mpeg4Profile_;
			return soap_in_tt__Mpeg4Profile_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoEncoding"))
		{	*type = SOAP_TYPE_tt__VideoEncoding_;
			return soap_in_tt__VideoEncoding_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SceneOrientationMode"))
		{	*type = SOAP_TYPE_tt__SceneOrientationMode_;
			return soap_in_tt__SceneOrientationMode_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RotateMode"))
		{	*type = SOAP_TYPE_tt__RotateMode_;
			return soap_in_tt__RotateMode_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Name"))
		{	*type = SOAP_TYPE_tt__Name__;
			return soap_in_tt__Name__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Name"))
		{	*type = SOAP_TYPE_tt__Name;
			return soap_in_tt__Name(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:AbsoluteOrRelativeTimeType"))
		{	*type = SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType;
			return soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:StringList"))
		{	*type = SOAP_TYPE_tt__StringList;
			return soap_in_tt__StringList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:StringAttrList"))
		{	*type = SOAP_TYPE_tt__StringAttrList;
			return soap_in_tt__StringAttrList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FloatList"))
		{	*type = SOAP_TYPE_tt__FloatList;
			return soap_in_tt__FloatList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntList"))
		{	*type = SOAP_TYPE_tt__IntList;
			return soap_in_tt__IntList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicSetType"))
		{	*type = SOAP_TYPE_wstop__TopicSetType;
			return soap_in_wstop__TopicSetType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicType"))
		{	*type = SOAP_TYPE_wstop__TopicType;
			return soap_in_wstop__TopicType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicNamespaceType"))
		{	*type = SOAP_TYPE_wstop__TopicNamespaceType;
			return soap_in_wstop__TopicNamespaceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:QueryExpressionType"))
		{	*type = SOAP_TYPE_wstop__QueryExpressionType;
			return soap_in_wstop__QueryExpressionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:ExtensibleDocumented"))
		{	*type = SOAP_TYPE_wstop__ExtensibleDocumented;
			return soap_in_wstop__ExtensibleDocumented(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:Documentation"))
		{	*type = SOAP_TYPE_wstop__Documentation;
			return soap_in_wstop__Documentation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType"))
		{	*type = SOAP_TYPE_wsrfbf__BaseFaultType;
			return soap_in_wsrfbf__BaseFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeFailedFaultType"))
		{	*type = SOAP_TYPE_wsnt__ResumeFailedFaultType;
			return soap_in_wsnt__ResumeFailedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseFailedFaultType"))
		{	*type = SOAP_TYPE_wsnt__PauseFailedFaultType;
			return soap_in_wsnt__PauseFailedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroySubscriptionFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType;
			return soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType;
			return soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToCreatePullPointFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType;
			return soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroyPullPointFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType;
			return soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToGetMessagesFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToGetMessagesFaultType;
			return soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NoCurrentMessageOnTopicFaultType"))
		{	*type = SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType;
			return soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableInitialTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType;
			return soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotifyMessageNotSupportedFaultType"))
		{	*type = SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType;
			return soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsupportedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType;
			return soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnrecognizedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType;
			return soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidMessageContentExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType;
			return soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidProducerPropertiesExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType;
			return soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:MultipleTopicsSpecifiedFaultType"))
		{	*type = SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType;
			return soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicNotSupportedFaultType"))
		{	*type = SOAP_TYPE_wsnt__TopicNotSupportedFaultType;
			return soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidTopicExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType;
			return soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionDialectUnknownFaultType"))
		{	*type = SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType;
			return soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidFilterFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidFilterFaultType;
			return soap_in_wsnt__InvalidFilterFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeCreationFailedFaultType"))
		{	*type = SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType;
			return soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotificationMessageHolderType"))
		{	*type = SOAP_TYPE_wsnt__NotificationMessageHolderType;
			return soap_in_wsnt__NotificationMessageHolderType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscriptionPolicyType"))
		{	*type = SOAP_TYPE_wsnt__SubscriptionPolicyType;
			return soap_in_wsnt__SubscriptionPolicyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:FilterType"))
		{	*type = SOAP_TYPE_wsnt__FilterType;
			return soap_in_wsnt__FilterType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionType"))
		{	*type = SOAP_TYPE_wsnt__TopicExpressionType;
			return soap_in_wsnt__TopicExpressionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:QueryExpressionType"))
		{	*type = SOAP_TYPE_wsnt__QueryExpressionType;
			return soap_in_wsnt__QueryExpressionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Polygon"))
		{	*type = SOAP_TYPE_tt__Polygon;
			return soap_in_tt__Polygon(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Rectangle"))
		{	*type = SOAP_TYPE_tt__Rectangle;
			return soap_in_tt__Rectangle(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Vector"))
		{	*type = SOAP_TYPE_tt__Vector;
			return soap_in_tt__Vector(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Vector1D"))
		{	*type = SOAP_TYPE_tt__Vector1D;
			return soap_in_tt__Vector1D(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Vector2D"))
		{	*type = SOAP_TYPE_tt__Vector2D;
			return soap_in_tt__Vector2D(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntRange"))
		{	*type = SOAP_TYPE_tt__IntRange;
			return soap_in_tt__IntRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PolygonOptions"))
		{	*type = SOAP_TYPE_tt__PolygonOptions;
			return soap_in_tt__PolygonOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Config"))
		{	*type = SOAP_TYPE_tt__Config;
			return soap_in_tt__Config(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RuleEngineConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__RuleEngineConfigurationExtension;
			return soap_in_tt__RuleEngineConfigurationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RuleEngineConfiguration"))
		{	*type = SOAP_TYPE_tt__RuleEngineConfiguration;
			return soap_in_tt__RuleEngineConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AnalyticsEngineConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension;
			return soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AnalyticsEngineConfiguration"))
		{	*type = SOAP_TYPE_tt__AnalyticsEngineConfiguration;
			return soap_in_tt__AnalyticsEngineConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Polyline"))
		{	*type = SOAP_TYPE_tt__Polyline;
			return soap_in_tt__Polyline(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemListExtension"))
		{	*type = SOAP_TYPE_tt__ItemListExtension;
			return soap_in_tt__ItemListExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemList"))
		{	*type = SOAP_TYPE_tt__ItemList;
			return soap_in_tt__ItemList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MessageExtension"))
		{	*type = SOAP_TYPE_tt__MessageExtension;
			return soap_in_tt__MessageExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NoiseReductionOptions"))
		{	*type = SOAP_TYPE_tt__NoiseReductionOptions;
			return soap_in_tt__NoiseReductionOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DefoggingOptions"))
		{	*type = SOAP_TYPE_tt__DefoggingOptions;
			return soap_in_tt__DefoggingOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ToneCompensationOptions"))
		{	*type = SOAP_TYPE_tt__ToneCompensationOptions;
			return soap_in_tt__ToneCompensationOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusOptions20Extension"))
		{	*type = SOAP_TYPE_tt__FocusOptions20Extension;
			return soap_in_tt__FocusOptions20Extension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusOptions20"))
		{	*type = SOAP_TYPE_tt__FocusOptions20;
			return soap_in_tt__FocusOptions20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WhiteBalanceOptions20Extension"))
		{	*type = SOAP_TYPE_tt__WhiteBalanceOptions20Extension;
			return soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WhiteBalanceOptions20"))
		{	*type = SOAP_TYPE_tt__WhiteBalanceOptions20;
			return soap_in_tt__WhiteBalanceOptions20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusConfiguration20Extension"))
		{	*type = SOAP_TYPE_tt__FocusConfiguration20Extension;
			return soap_in_tt__FocusConfiguration20Extension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusConfiguration20"))
		{	*type = SOAP_TYPE_tt__FocusConfiguration20;
			return soap_in_tt__FocusConfiguration20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WhiteBalance20Extension"))
		{	*type = SOAP_TYPE_tt__WhiteBalance20Extension;
			return soap_in_tt__WhiteBalance20Extension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WhiteBalance20"))
		{	*type = SOAP_TYPE_tt__WhiteBalance20;
			return soap_in_tt__WhiteBalance20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelativeFocusOptions20"))
		{	*type = SOAP_TYPE_tt__RelativeFocusOptions20;
			return soap_in_tt__RelativeFocusOptions20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MoveOptions20"))
		{	*type = SOAP_TYPE_tt__MoveOptions20;
			return soap_in_tt__MoveOptions20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ExposureOptions20"))
		{	*type = SOAP_TYPE_tt__ExposureOptions20;
			return soap_in_tt__ExposureOptions20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BacklightCompensationOptions20"))
		{	*type = SOAP_TYPE_tt__BacklightCompensationOptions20;
			return soap_in_tt__BacklightCompensationOptions20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WideDynamicRangeOptions20"))
		{	*type = SOAP_TYPE_tt__WideDynamicRangeOptions20;
			return soap_in_tt__WideDynamicRangeOptions20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IrCutFilterAutoAdjustmentOptionsExtension"))
		{	*type = SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension;
			return soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IrCutFilterAutoAdjustmentOptions"))
		{	*type = SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions;
			return soap_in_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImageStabilizationOptionsExtension"))
		{	*type = SOAP_TYPE_tt__ImageStabilizationOptionsExtension;
			return soap_in_tt__ImageStabilizationOptionsExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImageStabilizationOptions"))
		{	*type = SOAP_TYPE_tt__ImageStabilizationOptions;
			return soap_in_tt__ImageStabilizationOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingOptions20Extension4"))
		{	*type = SOAP_TYPE_tt__ImagingOptions20Extension4;
			return soap_in_tt__ImagingOptions20Extension4(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingOptions20Extension3"))
		{	*type = SOAP_TYPE_tt__ImagingOptions20Extension3;
			return soap_in_tt__ImagingOptions20Extension3(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingOptions20Extension2"))
		{	*type = SOAP_TYPE_tt__ImagingOptions20Extension2;
			return soap_in_tt__ImagingOptions20Extension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingOptions20Extension"))
		{	*type = SOAP_TYPE_tt__ImagingOptions20Extension;
			return soap_in_tt__ImagingOptions20Extension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingOptions20"))
		{	*type = SOAP_TYPE_tt__ImagingOptions20;
			return soap_in_tt__ImagingOptions20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NoiseReduction"))
		{	*type = SOAP_TYPE_tt__NoiseReduction;
			return soap_in_tt__NoiseReduction(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DefoggingExtension"))
		{	*type = SOAP_TYPE_tt__DefoggingExtension;
			return soap_in_tt__DefoggingExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Defogging"))
		{	*type = SOAP_TYPE_tt__Defogging;
			return soap_in_tt__Defogging(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ToneCompensationExtension"))
		{	*type = SOAP_TYPE_tt__ToneCompensationExtension;
			return soap_in_tt__ToneCompensationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ToneCompensation"))
		{	*type = SOAP_TYPE_tt__ToneCompensation;
			return soap_in_tt__ToneCompensation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Exposure20"))
		{	*type = SOAP_TYPE_tt__Exposure20;
			return soap_in_tt__Exposure20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BacklightCompensation20"))
		{	*type = SOAP_TYPE_tt__BacklightCompensation20;
			return soap_in_tt__BacklightCompensation20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WideDynamicRange20"))
		{	*type = SOAP_TYPE_tt__WideDynamicRange20;
			return soap_in_tt__WideDynamicRange20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IrCutFilterAutoAdjustmentExtension"))
		{	*type = SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension;
			return soap_in_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IrCutFilterAutoAdjustment"))
		{	*type = SOAP_TYPE_tt__IrCutFilterAutoAdjustment;
			return soap_in_tt__IrCutFilterAutoAdjustment(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImageStabilizationExtension"))
		{	*type = SOAP_TYPE_tt__ImageStabilizationExtension;
			return soap_in_tt__ImageStabilizationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImageStabilization"))
		{	*type = SOAP_TYPE_tt__ImageStabilization;
			return soap_in_tt__ImageStabilization(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingSettingsExtension204"))
		{	*type = SOAP_TYPE_tt__ImagingSettingsExtension204;
			return soap_in_tt__ImagingSettingsExtension204(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingSettingsExtension203"))
		{	*type = SOAP_TYPE_tt__ImagingSettingsExtension203;
			return soap_in_tt__ImagingSettingsExtension203(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingSettingsExtension202"))
		{	*type = SOAP_TYPE_tt__ImagingSettingsExtension202;
			return soap_in_tt__ImagingSettingsExtension202(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingSettingsExtension20"))
		{	*type = SOAP_TYPE_tt__ImagingSettingsExtension20;
			return soap_in_tt__ImagingSettingsExtension20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingSettings20"))
		{	*type = SOAP_TYPE_tt__ImagingSettings20;
			return soap_in_tt__ImagingSettings20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusStatus20Extension"))
		{	*type = SOAP_TYPE_tt__FocusStatus20Extension;
			return soap_in_tt__FocusStatus20Extension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusStatus20"))
		{	*type = SOAP_TYPE_tt__FocusStatus20;
			return soap_in_tt__FocusStatus20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingStatus20Extension"))
		{	*type = SOAP_TYPE_tt__ImagingStatus20Extension;
			return soap_in_tt__ImagingStatus20Extension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingStatus20"))
		{	*type = SOAP_TYPE_tt__ImagingStatus20;
			return soap_in_tt__ImagingStatus20(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ContinuousFocusOptions"))
		{	*type = SOAP_TYPE_tt__ContinuousFocusOptions;
			return soap_in_tt__ContinuousFocusOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AbsoluteFocusOptions"))
		{	*type = SOAP_TYPE_tt__AbsoluteFocusOptions;
			return soap_in_tt__AbsoluteFocusOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ContinuousFocus"))
		{	*type = SOAP_TYPE_tt__ContinuousFocus;
			return soap_in_tt__ContinuousFocus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelativeFocus"))
		{	*type = SOAP_TYPE_tt__RelativeFocus;
			return soap_in_tt__RelativeFocus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AbsoluteFocus"))
		{	*type = SOAP_TYPE_tt__AbsoluteFocus;
			return soap_in_tt__AbsoluteFocus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusMove"))
		{	*type = SOAP_TYPE_tt__FocusMove;
			return soap_in_tt__FocusMove(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZSpeed"))
		{	*type = SOAP_TYPE_tt__PTZSpeed;
			return soap_in_tt__PTZSpeed(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Space1DDescription"))
		{	*type = SOAP_TYPE_tt__Space1DDescription;
			return soap_in_tt__Space1DDescription(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Space2DDescription"))
		{	*type = SOAP_TYPE_tt__Space2DDescription;
			return soap_in_tt__Space2DDescription(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ZoomLimits"))
		{	*type = SOAP_TYPE_tt__ZoomLimits;
			return soap_in_tt__ZoomLimits(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PanTiltLimits"))
		{	*type = SOAP_TYPE_tt__PanTiltLimits;
			return soap_in_tt__PanTiltLimits(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Reverse"))
		{	*type = SOAP_TYPE_tt__Reverse;
			return soap_in_tt__Reverse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EFlip"))
		{	*type = SOAP_TYPE_tt__EFlip;
			return soap_in_tt__EFlip(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTControlDirectionExtension"))
		{	*type = SOAP_TYPE_tt__PTControlDirectionExtension;
			return soap_in_tt__PTControlDirectionExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTControlDirection"))
		{	*type = SOAP_TYPE_tt__PTControlDirection;
			return soap_in_tt__PTControlDirection(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZConfigurationExtension2"))
		{	*type = SOAP_TYPE_tt__PTZConfigurationExtension2;
			return soap_in_tt__PTZConfigurationExtension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__PTZConfigurationExtension;
			return soap_in_tt__PTZConfigurationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZConfiguration"))
		{	*type = SOAP_TYPE_tt__PTZConfiguration;
			return soap_in_tt__PTZConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPAddress"))
		{	*type = SOAP_TYPE_tt__IPAddress;
			return soap_in_tt__IPAddress(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MulticastConfiguration"))
		{	*type = SOAP_TYPE_tt__MulticastConfiguration;
			return soap_in_tt__MulticastConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioDecoderConfiguration"))
		{	*type = SOAP_TYPE_tt__AudioDecoderConfiguration;
			return soap_in_tt__AudioDecoderConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioOutputConfiguration"))
		{	*type = SOAP_TYPE_tt__AudioOutputConfiguration;
			return soap_in_tt__AudioOutputConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EventSubscription"))
		{	*type = SOAP_TYPE_tt__EventSubscription;
			return soap_in_tt__EventSubscription(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZFilter"))
		{	*type = SOAP_TYPE_tt__PTZFilter;
			return soap_in_tt__PTZFilter(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MetadataConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__MetadataConfigurationExtension;
			return soap_in_tt__MetadataConfigurationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MetadataConfiguration"))
		{	*type = SOAP_TYPE_tt__MetadataConfiguration;
			return soap_in_tt__MetadataConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoAnalyticsConfiguration"))
		{	*type = SOAP_TYPE_tt__VideoAnalyticsConfiguration;
			return soap_in_tt__VideoAnalyticsConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioEncoderConfiguration"))
		{	*type = SOAP_TYPE_tt__AudioEncoderConfiguration;
			return soap_in_tt__AudioEncoderConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioSourceConfiguration"))
		{	*type = SOAP_TYPE_tt__AudioSourceConfiguration;
			return soap_in_tt__AudioSourceConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:H264Configuration"))
		{	*type = SOAP_TYPE_tt__H264Configuration;
			return soap_in_tt__H264Configuration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Mpeg4Configuration"))
		{	*type = SOAP_TYPE_tt__Mpeg4Configuration;
			return soap_in_tt__Mpeg4Configuration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoRateControl"))
		{	*type = SOAP_TYPE_tt__VideoRateControl;
			return soap_in_tt__VideoRateControl(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoResolution"))
		{	*type = SOAP_TYPE_tt__VideoResolution;
			return soap_in_tt__VideoResolution(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoEncoderConfiguration"))
		{	*type = SOAP_TYPE_tt__VideoEncoderConfiguration;
			return soap_in_tt__VideoEncoderConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SceneOrientation"))
		{	*type = SOAP_TYPE_tt__SceneOrientation;
			return soap_in_tt__SceneOrientation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:LensDescription"))
		{	*type = SOAP_TYPE_tt__LensDescription;
			return soap_in_tt__LensDescription(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:LensOffset"))
		{	*type = SOAP_TYPE_tt__LensOffset;
			return soap_in_tt__LensOffset(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:LensProjection"))
		{	*type = SOAP_TYPE_tt__LensProjection;
			return soap_in_tt__LensProjection(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RotateExtension"))
		{	*type = SOAP_TYPE_tt__RotateExtension;
			return soap_in_tt__RotateExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Rotate"))
		{	*type = SOAP_TYPE_tt__Rotate;
			return soap_in_tt__Rotate(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoSourceConfigurationExtension2"))
		{	*type = SOAP_TYPE_tt__VideoSourceConfigurationExtension2;
			return soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoSourceConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__VideoSourceConfigurationExtension;
			return soap_in_tt__VideoSourceConfigurationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoSourceConfiguration"))
		{	*type = SOAP_TYPE_tt__VideoSourceConfiguration;
			return soap_in_tt__VideoSourceConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ConfigurationEntity"))
		{	*type = SOAP_TYPE_tt__ConfigurationEntity;
			return soap_in_tt__ConfigurationEntity(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DurationRange"))
		{	*type = SOAP_TYPE_tt__DurationRange;
			return soap_in_tt__DurationRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FloatRange"))
		{	*type = SOAP_TYPE_tt__FloatRange;
			return soap_in_tt__FloatRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntRectangleRange"))
		{	*type = SOAP_TYPE_tt__IntRectangleRange;
			return soap_in_tt__IntRectangleRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntRectangle"))
		{	*type = SOAP_TYPE_tt__IntRectangle;
			return soap_in_tt__IntRectangle(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:ImagingPreset"))
		{	*type = SOAP_TYPE_timg__ImagingPreset;
			return soap_in_timg__ImagingPreset(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:Capabilities"))
		{	*type = SOAP_TYPE_timg__Capabilities;
			return soap_in_timg__Capabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	*type = SOAP_TYPE_xsd__token__;
			return soap_in_xsd__token__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	*type = SOAP_TYPE_xsd__token;
			return soap_in_xsd__token(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string_;
			return soap_in_xsd__string_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger__;
			return soap_in_xsd__nonNegativeInteger__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer__;
			return soap_in_xsd__integer__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int_;
			return soap_in_xsd__int_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:hexBinary"))
		{	*type = SOAP_TYPE_xsd__hexBinary__;
			return soap_in_xsd__hexBinary__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_xsd__float_;
			return soap_in_xsd__float_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration__;
			return soap_in_xsd__duration__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double_;
			return soap_in_xsd__double_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime_;
			return soap_in_xsd__dateTime_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean_;
			return soap_in_xsd__boolean_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary__;
			return soap_in_xsd__base64Binary__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI__;
			return soap_in_xsd__anyURI__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anySimpleType"))
		{	*type = SOAP_TYPE_xsd__anySimpleType__;
			return soap_in_xsd__anySimpleType__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anySimpleType"))
		{	*type = SOAP_TYPE_xsd__anySimpleType;
			return soap_in_xsd__anySimpleType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName__;
			return soap_in_xsd__QName__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_xsd__NCName__;
			return soap_in_xsd__NCName__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_xsd__NCName;
			return soap_in_xsd__NCName(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENV:Fault"))
		{	*type = SOAP_TYPE_SOAP_ENV__Fault_;
			return soap_in_SOAP_ENV__Fault_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENV:Envelope"))
		{	*type = SOAP_TYPE_SOAP_ENV__Envelope_;
			return soap_in_SOAP_ENV__Envelope_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa5__EndpointReferenceType__;
			return soap_in_wsa5__EndpointReferenceType__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:hexBinary"))
		{	*type = SOAP_TYPE_xsd__hexBinary;
			return soap_in_xsd__hexBinary(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_ULONG64;
			return soap_in_ULONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MoveStatus"))
		{	*type = SOAP_TYPE_tt__MoveStatus;
			return soap_in_tt__MoveStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PropertyOperation"))
		{	*type = SOAP_TYPE_tt__PropertyOperation;
			return soap_in_tt__PropertyOperation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImageStabilizationMode"))
		{	*type = SOAP_TYPE_tt__ImageStabilizationMode;
			return soap_in_tt__ImageStabilizationMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IrCutFilterMode"))
		{	*type = SOAP_TYPE_tt__IrCutFilterMode;
			return soap_in_tt__IrCutFilterMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WhiteBalanceMode"))
		{	*type = SOAP_TYPE_tt__WhiteBalanceMode;
			return soap_in_tt__WhiteBalanceMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ExposureMode"))
		{	*type = SOAP_TYPE_tt__ExposureMode;
			return soap_in_tt__ExposureMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ExposurePriority"))
		{	*type = SOAP_TYPE_tt__ExposurePriority;
			return soap_in_tt__ExposurePriority(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BacklightCompensationMode"))
		{	*type = SOAP_TYPE_tt__BacklightCompensationMode;
			return soap_in_tt__BacklightCompensationMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WideDynamicMode"))
		{	*type = SOAP_TYPE_tt__WideDynamicMode;
			return soap_in_tt__WideDynamicMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AutoFocusMode"))
		{	*type = SOAP_TYPE_tt__AutoFocusMode;
			return soap_in_tt__AutoFocusMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ReverseMode"))
		{	*type = SOAP_TYPE_tt__ReverseMode;
			return soap_in_tt__ReverseMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EFlipMode"))
		{	*type = SOAP_TYPE_tt__EFlipMode;
			return soap_in_tt__EFlipMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPType"))
		{	*type = SOAP_TYPE_tt__IPType;
			return soap_in_tt__IPType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioEncoding"))
		{	*type = SOAP_TYPE_tt__AudioEncoding;
			return soap_in_tt__AudioEncoding(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:H264Profile"))
		{	*type = SOAP_TYPE_tt__H264Profile;
			return soap_in_tt__H264Profile(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Mpeg4Profile"))
		{	*type = SOAP_TYPE_tt__Mpeg4Profile;
			return soap_in_tt__Mpeg4Profile(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoEncoding"))
		{	*type = SOAP_TYPE_tt__VideoEncoding;
			return soap_in_tt__VideoEncoding(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SceneOrientationMode"))
		{	*type = SOAP_TYPE_tt__SceneOrientationMode;
			return soap_in_tt__SceneOrientationMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RotateMode"))
		{	*type = SOAP_TYPE_tt__RotateMode;
			return soap_in_tt__RotateMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:IsReferenceParameter"))
		{	*type = SOAP_TYPE__wsa5__IsReferenceParameter;
			return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesType"))
		{	*type = SOAP_TYPE_wsa5__FaultCodesType;
			return soap_in_wsa5__FaultCodesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipType"))
		{	*type = SOAP_TYPE_wsa5__RelationshipType;
			return soap_in_wsa5__RelationshipType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENV:Envelope"))
		{	*type = SOAP_TYPE_SOAP_ENV__Envelope;
			return soap_in_SOAP_ENV__Envelope(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "chan:ChannelInstanceType"))
		{	*type = SOAP_TYPE_chan__ChannelInstanceType;
			return soap_in_chan__ChannelInstanceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemActionType"))
		{	*type = SOAP_TYPE_wsa5__ProblemActionType;
			return soap_in_wsa5__ProblemActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesToType"))
		{	*type = SOAP_TYPE_wsa5__RelatesToType;
			return soap_in_wsa5__RelatesToType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:MetadataType"))
		{	*type = SOAP_TYPE_wsa5__MetadataType;
			return soap_in_wsa5__MetadataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa5__ReferenceParametersType;
			return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa5__EndpointReferenceType;
			return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemHeaderQName;
			s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__FaultCodesOpenEnumType;
			s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipTypeOpenEnum"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__RelationshipTypeOpenEnum;
			s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsa5:RetryAfter"))
		{	*type = SOAP_TYPE__wsa5__RetryAfter;
			return soap_in__wsa5__RetryAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicNamespaceType-Topic"))
		{	*type = SOAP_TYPE__wstop__TopicNamespaceType_Topic;
			return soap_in__wstop__TopicNamespaceType_Topic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause;
			return soap_in__wsrfbf__BaseFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-Description"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_Description;
			return soap_in__wsrfbf__BaseFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode;
			return soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Subscribe-SubscriptionPolicy"))
		{	*type = SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy;
			return soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotificationMessageHolderType-Message"))
		{	*type = SOAP_TYPE__wsnt__NotificationMessageHolderType_Message;
			return soap_in__wsnt__NotificationMessageHolderType_Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemList-ElementItem"))
		{	*type = SOAP_TYPE__tt__ItemList_ElementItem;
			return soap_in__tt__ItemList_ElementItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemList-SimpleItem"))
		{	*type = SOAP_TYPE__tt__ItemList_SimpleItem;
			return soap_in__tt__ItemList_SimpleItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EventSubscription-SubscriptionPolicy"))
		{	*type = SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy;
			return soap_in__tt__EventSubscription_SubscriptionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeSubscriptionResponse"))
		{	*type = SOAP_TYPE__wsnt__ResumeSubscriptionResponse;
			return soap_in__wsnt__ResumeSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeSubscription"))
		{	*type = SOAP_TYPE__wsnt__ResumeSubscription;
			return soap_in__wsnt__ResumeSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseSubscriptionResponse"))
		{	*type = SOAP_TYPE__wsnt__PauseSubscriptionResponse;
			return soap_in__wsnt__PauseSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseSubscription"))
		{	*type = SOAP_TYPE__wsnt__PauseSubscription;
			return soap_in__wsnt__PauseSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsubscribeResponse"))
		{	*type = SOAP_TYPE__wsnt__UnsubscribeResponse;
			return soap_in__wsnt__UnsubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Unsubscribe"))
		{	*type = SOAP_TYPE__wsnt__Unsubscribe;
			return soap_in__wsnt__Unsubscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:RenewResponse"))
		{	*type = SOAP_TYPE__wsnt__RenewResponse;
			return soap_in__wsnt__RenewResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Renew"))
		{	*type = SOAP_TYPE__wsnt__Renew;
			return soap_in__wsnt__Renew(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:CreatePullPointResponse"))
		{	*type = SOAP_TYPE__wsnt__CreatePullPointResponse;
			return soap_in__wsnt__CreatePullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:CreatePullPoint"))
		{	*type = SOAP_TYPE__wsnt__CreatePullPoint;
			return soap_in__wsnt__CreatePullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:DestroyPullPointResponse"))
		{	*type = SOAP_TYPE__wsnt__DestroyPullPointResponse;
			return soap_in__wsnt__DestroyPullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:DestroyPullPoint"))
		{	*type = SOAP_TYPE__wsnt__DestroyPullPoint;
			return soap_in__wsnt__DestroyPullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetMessagesResponse"))
		{	*type = SOAP_TYPE__wsnt__GetMessagesResponse;
			return soap_in__wsnt__GetMessagesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetMessages"))
		{	*type = SOAP_TYPE__wsnt__GetMessages;
			return soap_in__wsnt__GetMessages(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetCurrentMessageResponse"))
		{	*type = SOAP_TYPE__wsnt__GetCurrentMessageResponse;
			return soap_in__wsnt__GetCurrentMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetCurrentMessage"))
		{	*type = SOAP_TYPE__wsnt__GetCurrentMessage;
			return soap_in__wsnt__GetCurrentMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeResponse"))
		{	*type = SOAP_TYPE__wsnt__SubscribeResponse;
			return soap_in__wsnt__SubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Subscribe"))
		{	*type = SOAP_TYPE__wsnt__Subscribe;
			return soap_in__wsnt__Subscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UseRaw"))
		{	*type = SOAP_TYPE__wsnt__UseRaw;
			return soap_in__wsnt__UseRaw(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Notify"))
		{	*type = SOAP_TYPE__wsnt__Notify;
			return soap_in__wsnt__Notify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscriptionManagerRP"))
		{	*type = SOAP_TYPE__wsnt__SubscriptionManagerRP;
			return soap_in__wsnt__SubscriptionManagerRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotificationProducerRP"))
		{	*type = SOAP_TYPE__wsnt__NotificationProducerRP;
			return soap_in__wsnt__NotificationProducerRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Message"))
		{	*type = SOAP_TYPE__tt__Message;
			return soap_in__tt__Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:StringItems"))
		{	*type = SOAP_TYPE__tt__StringItems;
			return soap_in__tt__StringItems(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:SetCurrentPresetResponse"))
		{	*type = SOAP_TYPE__timg__SetCurrentPresetResponse;
			return soap_in__timg__SetCurrentPresetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:SetCurrentPreset"))
		{	*type = SOAP_TYPE__timg__SetCurrentPreset;
			return soap_in__timg__SetCurrentPreset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetCurrentPresetResponse"))
		{	*type = SOAP_TYPE__timg__GetCurrentPresetResponse;
			return soap_in__timg__GetCurrentPresetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetCurrentPreset"))
		{	*type = SOAP_TYPE__timg__GetCurrentPreset;
			return soap_in__timg__GetCurrentPreset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetPresetsResponse"))
		{	*type = SOAP_TYPE__timg__GetPresetsResponse;
			return soap_in__timg__GetPresetsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetPresets"))
		{	*type = SOAP_TYPE__timg__GetPresets;
			return soap_in__timg__GetPresets(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetStatusResponse"))
		{	*type = SOAP_TYPE__timg__GetStatusResponse;
			return soap_in__timg__GetStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetStatus"))
		{	*type = SOAP_TYPE__timg__GetStatus;
			return soap_in__timg__GetStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:StopResponse"))
		{	*type = SOAP_TYPE__timg__StopResponse;
			return soap_in__timg__StopResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:Stop"))
		{	*type = SOAP_TYPE__timg__Stop;
			return soap_in__timg__Stop(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetMoveOptionsResponse"))
		{	*type = SOAP_TYPE__timg__GetMoveOptionsResponse;
			return soap_in__timg__GetMoveOptionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetMoveOptions"))
		{	*type = SOAP_TYPE__timg__GetMoveOptions;
			return soap_in__timg__GetMoveOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:MoveResponse"))
		{	*type = SOAP_TYPE__timg__MoveResponse;
			return soap_in__timg__MoveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:Move"))
		{	*type = SOAP_TYPE__timg__Move;
			return soap_in__timg__Move(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetOptionsResponse"))
		{	*type = SOAP_TYPE__timg__GetOptionsResponse;
			return soap_in__timg__GetOptionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetOptions"))
		{	*type = SOAP_TYPE__timg__GetOptions;
			return soap_in__timg__GetOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:SetImagingSettingsResponse"))
		{	*type = SOAP_TYPE__timg__SetImagingSettingsResponse;
			return soap_in__timg__SetImagingSettingsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:SetImagingSettings"))
		{	*type = SOAP_TYPE__timg__SetImagingSettings;
			return soap_in__timg__SetImagingSettings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetImagingSettingsResponse"))
		{	*type = SOAP_TYPE__timg__GetImagingSettingsResponse;
			return soap_in__timg__GetImagingSettingsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetImagingSettings"))
		{	*type = SOAP_TYPE__timg__GetImagingSettings;
			return soap_in__timg__GetImagingSettings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetServiceCapabilitiesResponse"))
		{	*type = SOAP_TYPE__timg__GetServiceCapabilitiesResponse;
			return soap_in__timg__GetServiceCapabilitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "timg:GetServiceCapabilities"))
		{	*type = SOAP_TYPE__timg__GetServiceCapabilities;
			return soap_in__timg__GetServiceCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xml:lang"))
		{	*type = SOAP_TYPE__xml__lang;
			return soap_in__xml__lang(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemAction"))
		{	*type = SOAP_TYPE__wsa5__ProblemAction;
			return soap_in__wsa5__ProblemAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultTo"))
		{	*type = SOAP_TYPE__wsa5__FaultTo;
			return soap_in__wsa5__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:From"))
		{	*type = SOAP_TYPE__wsa5__From;
			return soap_in__wsa5__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReplyTo"))
		{	*type = SOAP_TYPE__wsa5__ReplyTo;
			return soap_in__wsa5__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesTo"))
		{	*type = SOAP_TYPE__wsa5__RelatesTo;
			return soap_in__wsa5__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:Metadata"))
		{	*type = SOAP_TYPE__wsa5__Metadata;
			return soap_in__wsa5__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParameters"))
		{	*type = SOAP_TYPE__wsa5__ReferenceParameters;
			return soap_in__wsa5__ReferenceParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReference"))
		{	*type = SOAP_TYPE__wsa5__EndpointReference;
			return soap_in__wsa5__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xop:Include"))
		{	*type = SOAP_TYPE__xop__Include;
			return soap_in__xop__Include(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemIRI"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemIRI;
			s = soap_in__wsa5__ProblemIRI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__Action;
			s = soap_in__wsa5__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__To;
			s = soap_in__wsa5__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__MessageID;
			s = soap_in__wsa5__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE__wsa5__RetryAfter:
		return soap_out__wsa5__RetryAfter(soap, "wsa5:RetryAfter", id, (const ULONG64 *)ptr, "");
	case SOAP_TYPE_ULONG64:
		return soap_out_ULONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_tt__MoveStatus:
		return soap_out_tt__MoveStatus(soap, tag, id, (const enum tt__MoveStatus *)ptr, "tt:MoveStatus");
	case SOAP_TYPE_tt__PropertyOperation:
		return soap_out_tt__PropertyOperation(soap, tag, id, (const enum tt__PropertyOperation *)ptr, "tt:PropertyOperation");
	case SOAP_TYPE_tt__ImageStabilizationMode:
		return soap_out_tt__ImageStabilizationMode(soap, tag, id, (const enum tt__ImageStabilizationMode *)ptr, "tt:ImageStabilizationMode");
	case SOAP_TYPE_tt__IrCutFilterMode:
		return soap_out_tt__IrCutFilterMode(soap, tag, id, (const enum tt__IrCutFilterMode *)ptr, "tt:IrCutFilterMode");
	case SOAP_TYPE_tt__WhiteBalanceMode:
		return soap_out_tt__WhiteBalanceMode(soap, tag, id, (const enum tt__WhiteBalanceMode *)ptr, "tt:WhiteBalanceMode");
	case SOAP_TYPE_tt__ExposureMode:
		return soap_out_tt__ExposureMode(soap, tag, id, (const enum tt__ExposureMode *)ptr, "tt:ExposureMode");
	case SOAP_TYPE_tt__ExposurePriority:
		return soap_out_tt__ExposurePriority(soap, tag, id, (const enum tt__ExposurePriority *)ptr, "tt:ExposurePriority");
	case SOAP_TYPE_tt__BacklightCompensationMode:
		return soap_out_tt__BacklightCompensationMode(soap, tag, id, (const enum tt__BacklightCompensationMode *)ptr, "tt:BacklightCompensationMode");
	case SOAP_TYPE_tt__WideDynamicMode:
		return soap_out_tt__WideDynamicMode(soap, tag, id, (const enum tt__WideDynamicMode *)ptr, "tt:WideDynamicMode");
	case SOAP_TYPE_tt__AutoFocusMode:
		return soap_out_tt__AutoFocusMode(soap, tag, id, (const enum tt__AutoFocusMode *)ptr, "tt:AutoFocusMode");
	case SOAP_TYPE_tt__ReverseMode:
		return soap_out_tt__ReverseMode(soap, tag, id, (const enum tt__ReverseMode *)ptr, "tt:ReverseMode");
	case SOAP_TYPE_tt__EFlipMode:
		return soap_out_tt__EFlipMode(soap, tag, id, (const enum tt__EFlipMode *)ptr, "tt:EFlipMode");
	case SOAP_TYPE_tt__IPType:
		return soap_out_tt__IPType(soap, tag, id, (const enum tt__IPType *)ptr, "tt:IPType");
	case SOAP_TYPE_tt__AudioEncoding:
		return soap_out_tt__AudioEncoding(soap, tag, id, (const enum tt__AudioEncoding *)ptr, "tt:AudioEncoding");
	case SOAP_TYPE_tt__H264Profile:
		return soap_out_tt__H264Profile(soap, tag, id, (const enum tt__H264Profile *)ptr, "tt:H264Profile");
	case SOAP_TYPE_tt__Mpeg4Profile:
		return soap_out_tt__Mpeg4Profile(soap, tag, id, (const enum tt__Mpeg4Profile *)ptr, "tt:Mpeg4Profile");
	case SOAP_TYPE_tt__VideoEncoding:
		return soap_out_tt__VideoEncoding(soap, tag, id, (const enum tt__VideoEncoding *)ptr, "tt:VideoEncoding");
	case SOAP_TYPE_tt__SceneOrientationMode:
		return soap_out_tt__SceneOrientationMode(soap, tag, id, (const enum tt__SceneOrientationMode *)ptr, "tt:SceneOrientationMode");
	case SOAP_TYPE_tt__RotateMode:
		return soap_out_tt__RotateMode(soap, tag, id, (const enum tt__RotateMode *)ptr, "tt:RotateMode");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_out__wsa5__IsReferenceParameter(soap, tag, id, (const enum _wsa5__IsReferenceParameter *)ptr, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_out_wsa5__FaultCodesType(soap, tag, id, (const enum wsa5__FaultCodesType *)ptr, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_out_wsa5__RelationshipType(soap, tag, id, (const enum wsa5__RelationshipType *)ptr, "wsa5:RelationshipType");
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		return ((_wstop__TopicNamespaceType_Topic *)ptr)->soap_out(soap, "wstop:TopicNamespaceType-Topic", id, "");
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		return ((_wsrfbf__BaseFaultType_FaultCause *)ptr)->soap_out(soap, "wsrfbf:BaseFaultType-FaultCause", id, "");
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		return ((_wsrfbf__BaseFaultType_Description *)ptr)->soap_out(soap, "wsrfbf:BaseFaultType-Description", id, "");
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		return ((_wsrfbf__BaseFaultType_ErrorCode *)ptr)->soap_out(soap, "wsrfbf:BaseFaultType-ErrorCode", id, "");
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		return ((_wsnt__Subscribe_SubscriptionPolicy *)ptr)->soap_out(soap, "wsnt:Subscribe-SubscriptionPolicy", id, "");
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		return ((_wsnt__NotificationMessageHolderType_Message *)ptr)->soap_out(soap, "wsnt:NotificationMessageHolderType-Message", id, "");
	case SOAP_TYPE__tt__ItemList_ElementItem:
		return ((_tt__ItemList_ElementItem *)ptr)->soap_out(soap, "tt:ItemList-ElementItem", id, "");
	case SOAP_TYPE__tt__ItemList_SimpleItem:
		return ((_tt__ItemList_SimpleItem *)ptr)->soap_out(soap, "tt:ItemList-SimpleItem", id, "");
	case SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy:
		return ((_tt__EventSubscription_SubscriptionPolicy *)ptr)->soap_out(soap, "tt:EventSubscription-SubscriptionPolicy", id, "");
	case SOAP_TYPE_wstop__ConcreteTopicExpression__:
		return ((wstop__ConcreteTopicExpression__ *)ptr)->soap_out(soap, tag, id, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		return soap_out_wstop__ConcreteTopicExpression(soap, tag, id, (const std::string *)ptr, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_tt__MoveStatus_:
		return ((tt__MoveStatus_ *)ptr)->soap_out(soap, tag, id, "tt:MoveStatus");
	case SOAP_TYPE_tt__ReferenceToken__:
		return ((tt__ReferenceToken__ *)ptr)->soap_out(soap, tag, id, "tt:ReferenceToken");
	case SOAP_TYPE_tt__ReferenceToken:
		return soap_out_tt__ReferenceToken(soap, tag, id, (const std::string *)ptr, "tt:ReferenceToken");
	case SOAP_TYPE_tt__PropertyOperation_:
		return ((tt__PropertyOperation_ *)ptr)->soap_out(soap, tag, id, "tt:PropertyOperation");
	case SOAP_TYPE_tt__ImageStabilizationMode_:
		return ((tt__ImageStabilizationMode_ *)ptr)->soap_out(soap, tag, id, "tt:ImageStabilizationMode");
	case SOAP_TYPE_tt__IrCutFilterMode_:
		return ((tt__IrCutFilterMode_ *)ptr)->soap_out(soap, tag, id, "tt:IrCutFilterMode");
	case SOAP_TYPE_tt__WhiteBalanceMode_:
		return ((tt__WhiteBalanceMode_ *)ptr)->soap_out(soap, tag, id, "tt:WhiteBalanceMode");
	case SOAP_TYPE_tt__ExposureMode_:
		return ((tt__ExposureMode_ *)ptr)->soap_out(soap, tag, id, "tt:ExposureMode");
	case SOAP_TYPE_tt__ExposurePriority_:
		return ((tt__ExposurePriority_ *)ptr)->soap_out(soap, tag, id, "tt:ExposurePriority");
	case SOAP_TYPE_tt__BacklightCompensationMode_:
		return ((tt__BacklightCompensationMode_ *)ptr)->soap_out(soap, tag, id, "tt:BacklightCompensationMode");
	case SOAP_TYPE_tt__WideDynamicMode_:
		return ((tt__WideDynamicMode_ *)ptr)->soap_out(soap, tag, id, "tt:WideDynamicMode");
	case SOAP_TYPE_tt__AutoFocusMode_:
		return ((tt__AutoFocusMode_ *)ptr)->soap_out(soap, tag, id, "tt:AutoFocusMode");
	case SOAP_TYPE_tt__ReverseMode_:
		return ((tt__ReverseMode_ *)ptr)->soap_out(soap, tag, id, "tt:ReverseMode");
	case SOAP_TYPE_tt__EFlipMode_:
		return ((tt__EFlipMode_ *)ptr)->soap_out(soap, tag, id, "tt:EFlipMode");
	case SOAP_TYPE_tt__IPType_:
		return ((tt__IPType_ *)ptr)->soap_out(soap, tag, id, "tt:IPType");
	case SOAP_TYPE_tt__IPv6Address__:
		return ((tt__IPv6Address__ *)ptr)->soap_out(soap, tag, id, "tt:IPv6Address");
	case SOAP_TYPE_tt__IPv6Address:
		return soap_out_tt__IPv6Address(soap, tag, id, (const std::string *)ptr, "tt:IPv6Address");
	case SOAP_TYPE_tt__IPv4Address__:
		return ((tt__IPv4Address__ *)ptr)->soap_out(soap, tag, id, "tt:IPv4Address");
	case SOAP_TYPE_tt__IPv4Address:
		return soap_out_tt__IPv4Address(soap, tag, id, (const std::string *)ptr, "tt:IPv4Address");
	case SOAP_TYPE_tt__AudioEncoding_:
		return ((tt__AudioEncoding_ *)ptr)->soap_out(soap, tag, id, "tt:AudioEncoding");
	case SOAP_TYPE_tt__H264Profile_:
		return ((tt__H264Profile_ *)ptr)->soap_out(soap, tag, id, "tt:H264Profile");
	case SOAP_TYPE_tt__Mpeg4Profile_:
		return ((tt__Mpeg4Profile_ *)ptr)->soap_out(soap, tag, id, "tt:Mpeg4Profile");
	case SOAP_TYPE_tt__VideoEncoding_:
		return ((tt__VideoEncoding_ *)ptr)->soap_out(soap, tag, id, "tt:VideoEncoding");
	case SOAP_TYPE_tt__SceneOrientationMode_:
		return ((tt__SceneOrientationMode_ *)ptr)->soap_out(soap, tag, id, "tt:SceneOrientationMode");
	case SOAP_TYPE_tt__RotateMode_:
		return ((tt__RotateMode_ *)ptr)->soap_out(soap, tag, id, "tt:RotateMode");
	case SOAP_TYPE_tt__Name__:
		return ((tt__Name__ *)ptr)->soap_out(soap, tag, id, "tt:Name");
	case SOAP_TYPE_tt__Name:
		return soap_out_tt__Name(soap, tag, id, (const std::string *)ptr, "tt:Name");
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		return soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag, id, (const std::string *)ptr, "wsnt:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_tt__StringList:
		return soap_out_tt__StringList(soap, tag, id, (const std::string *)ptr, "tt:StringList");
	case SOAP_TYPE_tt__StringAttrList:
		return soap_out_tt__StringAttrList(soap, tag, id, (const std::string *)ptr, "tt:StringAttrList");
	case SOAP_TYPE_tt__FloatList:
		return soap_out_tt__FloatList(soap, tag, id, (const std::string *)ptr, "tt:FloatList");
	case SOAP_TYPE_tt__IntList:
		return soap_out_tt__IntList(soap, tag, id, (const std::string *)ptr, "tt:IntList");
	case SOAP_TYPE_wstop__TopicSetType:
		return ((wstop__TopicSetType *)ptr)->soap_out(soap, tag, id, "wstop:TopicSetType");
	case SOAP_TYPE_wstop__TopicType:
		return ((wstop__TopicType *)ptr)->soap_out(soap, tag, id, "wstop:TopicType");
	case SOAP_TYPE_wstop__TopicNamespaceType:
		return ((wstop__TopicNamespaceType *)ptr)->soap_out(soap, tag, id, "wstop:TopicNamespaceType");
	case SOAP_TYPE_wstop__QueryExpressionType:
		return ((wstop__QueryExpressionType *)ptr)->soap_out(soap, tag, id, "wstop:QueryExpressionType");
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		return ((wstop__ExtensibleDocumented *)ptr)->soap_out(soap, tag, id, "wstop:ExtensibleDocumented");
	case SOAP_TYPE_wstop__Documentation:
		return ((wstop__Documentation *)ptr)->soap_out(soap, tag, id, "wstop:Documentation");
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		return ((wsrfbf__BaseFaultType *)ptr)->soap_out(soap, tag, id, "wsrfbf:BaseFaultType");
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		return ((_wsnt__ResumeSubscriptionResponse *)ptr)->soap_out(soap, "wsnt:ResumeSubscriptionResponse", id, "");
	case SOAP_TYPE__wsnt__ResumeSubscription:
		return ((_wsnt__ResumeSubscription *)ptr)->soap_out(soap, "wsnt:ResumeSubscription", id, "");
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		return ((_wsnt__PauseSubscriptionResponse *)ptr)->soap_out(soap, "wsnt:PauseSubscriptionResponse", id, "");
	case SOAP_TYPE__wsnt__PauseSubscription:
		return ((_wsnt__PauseSubscription *)ptr)->soap_out(soap, "wsnt:PauseSubscription", id, "");
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		return ((_wsnt__UnsubscribeResponse *)ptr)->soap_out(soap, "wsnt:UnsubscribeResponse", id, "");
	case SOAP_TYPE__wsnt__Unsubscribe:
		return ((_wsnt__Unsubscribe *)ptr)->soap_out(soap, "wsnt:Unsubscribe", id, "");
	case SOAP_TYPE__wsnt__RenewResponse:
		return ((_wsnt__RenewResponse *)ptr)->soap_out(soap, "wsnt:RenewResponse", id, "");
	case SOAP_TYPE__wsnt__Renew:
		return ((_wsnt__Renew *)ptr)->soap_out(soap, "wsnt:Renew", id, "");
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		return ((_wsnt__CreatePullPointResponse *)ptr)->soap_out(soap, "wsnt:CreatePullPointResponse", id, "");
	case SOAP_TYPE__wsnt__CreatePullPoint:
		return ((_wsnt__CreatePullPoint *)ptr)->soap_out(soap, "wsnt:CreatePullPoint", id, "");
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		return ((_wsnt__DestroyPullPointResponse *)ptr)->soap_out(soap, "wsnt:DestroyPullPointResponse", id, "");
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		return ((_wsnt__DestroyPullPoint *)ptr)->soap_out(soap, "wsnt:DestroyPullPoint", id, "");
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		return ((_wsnt__GetMessagesResponse *)ptr)->soap_out(soap, "wsnt:GetMessagesResponse", id, "");
	case SOAP_TYPE__wsnt__GetMessages:
		return ((_wsnt__GetMessages *)ptr)->soap_out(soap, "wsnt:GetMessages", id, "");
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		return ((_wsnt__GetCurrentMessageResponse *)ptr)->soap_out(soap, "wsnt:GetCurrentMessageResponse", id, "");
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		return ((_wsnt__GetCurrentMessage *)ptr)->soap_out(soap, "wsnt:GetCurrentMessage", id, "");
	case SOAP_TYPE__wsnt__SubscribeResponse:
		return ((_wsnt__SubscribeResponse *)ptr)->soap_out(soap, "wsnt:SubscribeResponse", id, "");
	case SOAP_TYPE__wsnt__Subscribe:
		return ((_wsnt__Subscribe *)ptr)->soap_out(soap, "wsnt:Subscribe", id, "");
	case SOAP_TYPE__wsnt__UseRaw:
		return ((_wsnt__UseRaw *)ptr)->soap_out(soap, "wsnt:UseRaw", id, "");
	case SOAP_TYPE__wsnt__Notify:
		return ((_wsnt__Notify *)ptr)->soap_out(soap, "wsnt:Notify", id, "");
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		return ((_wsnt__SubscriptionManagerRP *)ptr)->soap_out(soap, "wsnt:SubscriptionManagerRP", id, "");
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		return ((_wsnt__NotificationProducerRP *)ptr)->soap_out(soap, "wsnt:NotificationProducerRP", id, "");
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		return ((wsnt__ResumeFailedFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:ResumeFailedFaultType");
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		return ((wsnt__PauseFailedFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:PauseFailedFaultType");
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		return ((wsnt__UnableToDestroySubscriptionFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		return ((wsnt__UnacceptableTerminationTimeFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		return ((wsnt__UnableToCreatePullPointFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		return ((wsnt__UnableToDestroyPullPointFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		return ((wsnt__UnableToGetMessagesFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnableToGetMessagesFaultType");
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		return ((wsnt__NoCurrentMessageOnTopicFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		return ((wsnt__UnacceptableInitialTerminationTimeFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		return ((wsnt__NotifyMessageNotSupportedFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		return ((wsnt__UnsupportedPolicyRequestFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		return ((wsnt__UnrecognizedPolicyRequestFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		return ((wsnt__InvalidMessageContentExpressionFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		return ((wsnt__InvalidProducerPropertiesExpressionFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		return ((wsnt__MultipleTopicsSpecifiedFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		return ((wsnt__TopicNotSupportedFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:TopicNotSupportedFaultType");
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		return ((wsnt__InvalidTopicExpressionFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		return ((wsnt__TopicExpressionDialectUnknownFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		return ((wsnt__InvalidFilterFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:InvalidFilterFaultType");
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		return ((wsnt__SubscribeCreationFailedFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		return ((wsnt__NotificationMessageHolderType *)ptr)->soap_out(soap, tag, id, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		return ((wsnt__SubscriptionPolicyType *)ptr)->soap_out(soap, tag, id, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_wsnt__FilterType:
		return ((wsnt__FilterType *)ptr)->soap_out(soap, tag, id, "wsnt:FilterType");
	case SOAP_TYPE_wsnt__TopicExpressionType:
		return ((wsnt__TopicExpressionType *)ptr)->soap_out(soap, tag, id, "wsnt:TopicExpressionType");
	case SOAP_TYPE_wsnt__QueryExpressionType:
		return ((wsnt__QueryExpressionType *)ptr)->soap_out(soap, tag, id, "wsnt:QueryExpressionType");
	case SOAP_TYPE__tt__Message:
		return ((_tt__Message *)ptr)->soap_out(soap, "tt:Message", id, "");
	case SOAP_TYPE__tt__StringItems:
		return ((_tt__StringItems *)ptr)->soap_out(soap, "tt:StringItems", id, "");
	case SOAP_TYPE_tt__Polygon:
		return ((tt__Polygon *)ptr)->soap_out(soap, tag, id, "tt:Polygon");
	case SOAP_TYPE_tt__Rectangle:
		return ((tt__Rectangle *)ptr)->soap_out(soap, tag, id, "tt:Rectangle");
	case SOAP_TYPE_tt__Vector:
		return ((tt__Vector *)ptr)->soap_out(soap, tag, id, "tt:Vector");
	case SOAP_TYPE_tt__Vector1D:
		return ((tt__Vector1D *)ptr)->soap_out(soap, tag, id, "tt:Vector1D");
	case SOAP_TYPE_tt__Vector2D:
		return ((tt__Vector2D *)ptr)->soap_out(soap, tag, id, "tt:Vector2D");
	case SOAP_TYPE_tt__IntRange:
		return ((tt__IntRange *)ptr)->soap_out(soap, tag, id, "tt:IntRange");
	case SOAP_TYPE_tt__PolygonOptions:
		return ((tt__PolygonOptions *)ptr)->soap_out(soap, tag, id, "tt:PolygonOptions");
	case SOAP_TYPE_tt__Config:
		return ((tt__Config *)ptr)->soap_out(soap, tag, id, "tt:Config");
	case SOAP_TYPE_tt__RuleEngineConfigurationExtension:
		return ((tt__RuleEngineConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:RuleEngineConfigurationExtension");
	case SOAP_TYPE_tt__RuleEngineConfiguration:
		return ((tt__RuleEngineConfiguration *)ptr)->soap_out(soap, tag, id, "tt:RuleEngineConfiguration");
	case SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension:
		return ((tt__AnalyticsEngineConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:AnalyticsEngineConfigurationExtension");
	case SOAP_TYPE_tt__AnalyticsEngineConfiguration:
		return ((tt__AnalyticsEngineConfiguration *)ptr)->soap_out(soap, tag, id, "tt:AnalyticsEngineConfiguration");
	case SOAP_TYPE_tt__Polyline:
		return ((tt__Polyline *)ptr)->soap_out(soap, tag, id, "tt:Polyline");
	case SOAP_TYPE_tt__ItemListExtension:
		return ((tt__ItemListExtension *)ptr)->soap_out(soap, tag, id, "tt:ItemListExtension");
	case SOAP_TYPE_tt__ItemList:
		return ((tt__ItemList *)ptr)->soap_out(soap, tag, id, "tt:ItemList");
	case SOAP_TYPE_tt__MessageExtension:
		return ((tt__MessageExtension *)ptr)->soap_out(soap, tag, id, "tt:MessageExtension");
	case SOAP_TYPE_tt__NoiseReductionOptions:
		return ((tt__NoiseReductionOptions *)ptr)->soap_out(soap, tag, id, "tt:NoiseReductionOptions");
	case SOAP_TYPE_tt__DefoggingOptions:
		return ((tt__DefoggingOptions *)ptr)->soap_out(soap, tag, id, "tt:DefoggingOptions");
	case SOAP_TYPE_tt__ToneCompensationOptions:
		return ((tt__ToneCompensationOptions *)ptr)->soap_out(soap, tag, id, "tt:ToneCompensationOptions");
	case SOAP_TYPE_tt__FocusOptions20Extension:
		return ((tt__FocusOptions20Extension *)ptr)->soap_out(soap, tag, id, "tt:FocusOptions20Extension");
	case SOAP_TYPE_tt__FocusOptions20:
		return ((tt__FocusOptions20 *)ptr)->soap_out(soap, tag, id, "tt:FocusOptions20");
	case SOAP_TYPE_tt__WhiteBalanceOptions20Extension:
		return ((tt__WhiteBalanceOptions20Extension *)ptr)->soap_out(soap, tag, id, "tt:WhiteBalanceOptions20Extension");
	case SOAP_TYPE_tt__WhiteBalanceOptions20:
		return ((tt__WhiteBalanceOptions20 *)ptr)->soap_out(soap, tag, id, "tt:WhiteBalanceOptions20");
	case SOAP_TYPE_tt__FocusConfiguration20Extension:
		return ((tt__FocusConfiguration20Extension *)ptr)->soap_out(soap, tag, id, "tt:FocusConfiguration20Extension");
	case SOAP_TYPE_tt__FocusConfiguration20:
		return ((tt__FocusConfiguration20 *)ptr)->soap_out(soap, tag, id, "tt:FocusConfiguration20");
	case SOAP_TYPE_tt__WhiteBalance20Extension:
		return ((tt__WhiteBalance20Extension *)ptr)->soap_out(soap, tag, id, "tt:WhiteBalance20Extension");
	case SOAP_TYPE_tt__WhiteBalance20:
		return ((tt__WhiteBalance20 *)ptr)->soap_out(soap, tag, id, "tt:WhiteBalance20");
	case SOAP_TYPE_tt__RelativeFocusOptions20:
		return ((tt__RelativeFocusOptions20 *)ptr)->soap_out(soap, tag, id, "tt:RelativeFocusOptions20");
	case SOAP_TYPE_tt__MoveOptions20:
		return ((tt__MoveOptions20 *)ptr)->soap_out(soap, tag, id, "tt:MoveOptions20");
	case SOAP_TYPE_tt__ExposureOptions20:
		return ((tt__ExposureOptions20 *)ptr)->soap_out(soap, tag, id, "tt:ExposureOptions20");
	case SOAP_TYPE_tt__BacklightCompensationOptions20:
		return ((tt__BacklightCompensationOptions20 *)ptr)->soap_out(soap, tag, id, "tt:BacklightCompensationOptions20");
	case SOAP_TYPE_tt__WideDynamicRangeOptions20:
		return ((tt__WideDynamicRangeOptions20 *)ptr)->soap_out(soap, tag, id, "tt:WideDynamicRangeOptions20");
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension:
		return ((tt__IrCutFilterAutoAdjustmentOptionsExtension *)ptr)->soap_out(soap, tag, id, "tt:IrCutFilterAutoAdjustmentOptionsExtension");
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions:
		return ((tt__IrCutFilterAutoAdjustmentOptions *)ptr)->soap_out(soap, tag, id, "tt:IrCutFilterAutoAdjustmentOptions");
	case SOAP_TYPE_tt__ImageStabilizationOptionsExtension:
		return ((tt__ImageStabilizationOptionsExtension *)ptr)->soap_out(soap, tag, id, "tt:ImageStabilizationOptionsExtension");
	case SOAP_TYPE_tt__ImageStabilizationOptions:
		return ((tt__ImageStabilizationOptions *)ptr)->soap_out(soap, tag, id, "tt:ImageStabilizationOptions");
	case SOAP_TYPE_tt__ImagingOptions20Extension4:
		return ((tt__ImagingOptions20Extension4 *)ptr)->soap_out(soap, tag, id, "tt:ImagingOptions20Extension4");
	case SOAP_TYPE_tt__ImagingOptions20Extension3:
		return ((tt__ImagingOptions20Extension3 *)ptr)->soap_out(soap, tag, id, "tt:ImagingOptions20Extension3");
	case SOAP_TYPE_tt__ImagingOptions20Extension2:
		return ((tt__ImagingOptions20Extension2 *)ptr)->soap_out(soap, tag, id, "tt:ImagingOptions20Extension2");
	case SOAP_TYPE_tt__ImagingOptions20Extension:
		return ((tt__ImagingOptions20Extension *)ptr)->soap_out(soap, tag, id, "tt:ImagingOptions20Extension");
	case SOAP_TYPE_tt__ImagingOptions20:
		return ((tt__ImagingOptions20 *)ptr)->soap_out(soap, tag, id, "tt:ImagingOptions20");
	case SOAP_TYPE_tt__NoiseReduction:
		return ((tt__NoiseReduction *)ptr)->soap_out(soap, tag, id, "tt:NoiseReduction");
	case SOAP_TYPE_tt__DefoggingExtension:
		return ((tt__DefoggingExtension *)ptr)->soap_out(soap, tag, id, "tt:DefoggingExtension");
	case SOAP_TYPE_tt__Defogging:
		return ((tt__Defogging *)ptr)->soap_out(soap, tag, id, "tt:Defogging");
	case SOAP_TYPE_tt__ToneCompensationExtension:
		return ((tt__ToneCompensationExtension *)ptr)->soap_out(soap, tag, id, "tt:ToneCompensationExtension");
	case SOAP_TYPE_tt__ToneCompensation:
		return ((tt__ToneCompensation *)ptr)->soap_out(soap, tag, id, "tt:ToneCompensation");
	case SOAP_TYPE_tt__Exposure20:
		return ((tt__Exposure20 *)ptr)->soap_out(soap, tag, id, "tt:Exposure20");
	case SOAP_TYPE_tt__BacklightCompensation20:
		return ((tt__BacklightCompensation20 *)ptr)->soap_out(soap, tag, id, "tt:BacklightCompensation20");
	case SOAP_TYPE_tt__WideDynamicRange20:
		return ((tt__WideDynamicRange20 *)ptr)->soap_out(soap, tag, id, "tt:WideDynamicRange20");
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension:
		return ((tt__IrCutFilterAutoAdjustmentExtension *)ptr)->soap_out(soap, tag, id, "tt:IrCutFilterAutoAdjustmentExtension");
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustment:
		return ((tt__IrCutFilterAutoAdjustment *)ptr)->soap_out(soap, tag, id, "tt:IrCutFilterAutoAdjustment");
	case SOAP_TYPE_tt__ImageStabilizationExtension:
		return ((tt__ImageStabilizationExtension *)ptr)->soap_out(soap, tag, id, "tt:ImageStabilizationExtension");
	case SOAP_TYPE_tt__ImageStabilization:
		return ((tt__ImageStabilization *)ptr)->soap_out(soap, tag, id, "tt:ImageStabilization");
	case SOAP_TYPE_tt__ImagingSettingsExtension204:
		return ((tt__ImagingSettingsExtension204 *)ptr)->soap_out(soap, tag, id, "tt:ImagingSettingsExtension204");
	case SOAP_TYPE_tt__ImagingSettingsExtension203:
		return ((tt__ImagingSettingsExtension203 *)ptr)->soap_out(soap, tag, id, "tt:ImagingSettingsExtension203");
	case SOAP_TYPE_tt__ImagingSettingsExtension202:
		return ((tt__ImagingSettingsExtension202 *)ptr)->soap_out(soap, tag, id, "tt:ImagingSettingsExtension202");
	case SOAP_TYPE_tt__ImagingSettingsExtension20:
		return ((tt__ImagingSettingsExtension20 *)ptr)->soap_out(soap, tag, id, "tt:ImagingSettingsExtension20");
	case SOAP_TYPE_tt__ImagingSettings20:
		return ((tt__ImagingSettings20 *)ptr)->soap_out(soap, tag, id, "tt:ImagingSettings20");
	case SOAP_TYPE_tt__FocusStatus20Extension:
		return ((tt__FocusStatus20Extension *)ptr)->soap_out(soap, tag, id, "tt:FocusStatus20Extension");
	case SOAP_TYPE_tt__FocusStatus20:
		return ((tt__FocusStatus20 *)ptr)->soap_out(soap, tag, id, "tt:FocusStatus20");
	case SOAP_TYPE_tt__ImagingStatus20Extension:
		return ((tt__ImagingStatus20Extension *)ptr)->soap_out(soap, tag, id, "tt:ImagingStatus20Extension");
	case SOAP_TYPE_tt__ImagingStatus20:
		return ((tt__ImagingStatus20 *)ptr)->soap_out(soap, tag, id, "tt:ImagingStatus20");
	case SOAP_TYPE_tt__ContinuousFocusOptions:
		return ((tt__ContinuousFocusOptions *)ptr)->soap_out(soap, tag, id, "tt:ContinuousFocusOptions");
	case SOAP_TYPE_tt__AbsoluteFocusOptions:
		return ((tt__AbsoluteFocusOptions *)ptr)->soap_out(soap, tag, id, "tt:AbsoluteFocusOptions");
	case SOAP_TYPE_tt__ContinuousFocus:
		return ((tt__ContinuousFocus *)ptr)->soap_out(soap, tag, id, "tt:ContinuousFocus");
	case SOAP_TYPE_tt__RelativeFocus:
		return ((tt__RelativeFocus *)ptr)->soap_out(soap, tag, id, "tt:RelativeFocus");
	case SOAP_TYPE_tt__AbsoluteFocus:
		return ((tt__AbsoluteFocus *)ptr)->soap_out(soap, tag, id, "tt:AbsoluteFocus");
	case SOAP_TYPE_tt__FocusMove:
		return ((tt__FocusMove *)ptr)->soap_out(soap, tag, id, "tt:FocusMove");
	case SOAP_TYPE_tt__PTZSpeed:
		return ((tt__PTZSpeed *)ptr)->soap_out(soap, tag, id, "tt:PTZSpeed");
	case SOAP_TYPE_tt__Space1DDescription:
		return ((tt__Space1DDescription *)ptr)->soap_out(soap, tag, id, "tt:Space1DDescription");
	case SOAP_TYPE_tt__Space2DDescription:
		return ((tt__Space2DDescription *)ptr)->soap_out(soap, tag, id, "tt:Space2DDescription");
	case SOAP_TYPE_tt__ZoomLimits:
		return ((tt__ZoomLimits *)ptr)->soap_out(soap, tag, id, "tt:ZoomLimits");
	case SOAP_TYPE_tt__PanTiltLimits:
		return ((tt__PanTiltLimits *)ptr)->soap_out(soap, tag, id, "tt:PanTiltLimits");
	case SOAP_TYPE_tt__Reverse:
		return ((tt__Reverse *)ptr)->soap_out(soap, tag, id, "tt:Reverse");
	case SOAP_TYPE_tt__EFlip:
		return ((tt__EFlip *)ptr)->soap_out(soap, tag, id, "tt:EFlip");
	case SOAP_TYPE_tt__PTControlDirectionExtension:
		return ((tt__PTControlDirectionExtension *)ptr)->soap_out(soap, tag, id, "tt:PTControlDirectionExtension");
	case SOAP_TYPE_tt__PTControlDirection:
		return ((tt__PTControlDirection *)ptr)->soap_out(soap, tag, id, "tt:PTControlDirection");
	case SOAP_TYPE_tt__PTZConfigurationExtension2:
		return ((tt__PTZConfigurationExtension2 *)ptr)->soap_out(soap, tag, id, "tt:PTZConfigurationExtension2");
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		return ((tt__PTZConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZConfigurationExtension");
	case SOAP_TYPE_tt__PTZConfiguration:
		return ((tt__PTZConfiguration *)ptr)->soap_out(soap, tag, id, "tt:PTZConfiguration");
	case SOAP_TYPE_tt__IPAddress:
		return ((tt__IPAddress *)ptr)->soap_out(soap, tag, id, "tt:IPAddress");
	case SOAP_TYPE_tt__MulticastConfiguration:
		return ((tt__MulticastConfiguration *)ptr)->soap_out(soap, tag, id, "tt:MulticastConfiguration");
	case SOAP_TYPE_tt__AudioDecoderConfiguration:
		return ((tt__AudioDecoderConfiguration *)ptr)->soap_out(soap, tag, id, "tt:AudioDecoderConfiguration");
	case SOAP_TYPE_tt__AudioOutputConfiguration:
		return ((tt__AudioOutputConfiguration *)ptr)->soap_out(soap, tag, id, "tt:AudioOutputConfiguration");
	case SOAP_TYPE_tt__EventSubscription:
		return ((tt__EventSubscription *)ptr)->soap_out(soap, tag, id, "tt:EventSubscription");
	case SOAP_TYPE_tt__PTZFilter:
		return ((tt__PTZFilter *)ptr)->soap_out(soap, tag, id, "tt:PTZFilter");
	case SOAP_TYPE_tt__MetadataConfigurationExtension:
		return ((tt__MetadataConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:MetadataConfigurationExtension");
	case SOAP_TYPE_tt__MetadataConfiguration:
		return ((tt__MetadataConfiguration *)ptr)->soap_out(soap, tag, id, "tt:MetadataConfiguration");
	case SOAP_TYPE_tt__VideoAnalyticsConfiguration:
		return ((tt__VideoAnalyticsConfiguration *)ptr)->soap_out(soap, tag, id, "tt:VideoAnalyticsConfiguration");
	case SOAP_TYPE_tt__AudioEncoderConfiguration:
		return ((tt__AudioEncoderConfiguration *)ptr)->soap_out(soap, tag, id, "tt:AudioEncoderConfiguration");
	case SOAP_TYPE_tt__AudioSourceConfiguration:
		return ((tt__AudioSourceConfiguration *)ptr)->soap_out(soap, tag, id, "tt:AudioSourceConfiguration");
	case SOAP_TYPE_tt__H264Configuration:
		return ((tt__H264Configuration *)ptr)->soap_out(soap, tag, id, "tt:H264Configuration");
	case SOAP_TYPE_tt__Mpeg4Configuration:
		return ((tt__Mpeg4Configuration *)ptr)->soap_out(soap, tag, id, "tt:Mpeg4Configuration");
	case SOAP_TYPE_tt__VideoRateControl:
		return ((tt__VideoRateControl *)ptr)->soap_out(soap, tag, id, "tt:VideoRateControl");
	case SOAP_TYPE_tt__VideoResolution:
		return ((tt__VideoResolution *)ptr)->soap_out(soap, tag, id, "tt:VideoResolution");
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		return ((tt__VideoEncoderConfiguration *)ptr)->soap_out(soap, tag, id, "tt:VideoEncoderConfiguration");
	case SOAP_TYPE_tt__SceneOrientation:
		return ((tt__SceneOrientation *)ptr)->soap_out(soap, tag, id, "tt:SceneOrientation");
	case SOAP_TYPE_tt__LensDescription:
		return ((tt__LensDescription *)ptr)->soap_out(soap, tag, id, "tt:LensDescription");
	case SOAP_TYPE_tt__LensOffset:
		return ((tt__LensOffset *)ptr)->soap_out(soap, tag, id, "tt:LensOffset");
	case SOAP_TYPE_tt__LensProjection:
		return ((tt__LensProjection *)ptr)->soap_out(soap, tag, id, "tt:LensProjection");
	case SOAP_TYPE_tt__RotateExtension:
		return ((tt__RotateExtension *)ptr)->soap_out(soap, tag, id, "tt:RotateExtension");
	case SOAP_TYPE_tt__Rotate:
		return ((tt__Rotate *)ptr)->soap_out(soap, tag, id, "tt:Rotate");
	case SOAP_TYPE_tt__VideoSourceConfigurationExtension2:
		return ((tt__VideoSourceConfigurationExtension2 *)ptr)->soap_out(soap, tag, id, "tt:VideoSourceConfigurationExtension2");
	case SOAP_TYPE_tt__VideoSourceConfigurationExtension:
		return ((tt__VideoSourceConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:VideoSourceConfigurationExtension");
	case SOAP_TYPE_tt__VideoSourceConfiguration:
		return ((tt__VideoSourceConfiguration *)ptr)->soap_out(soap, tag, id, "tt:VideoSourceConfiguration");
	case SOAP_TYPE_tt__ConfigurationEntity:
		return ((tt__ConfigurationEntity *)ptr)->soap_out(soap, tag, id, "tt:ConfigurationEntity");
	case SOAP_TYPE_tt__DurationRange:
		return ((tt__DurationRange *)ptr)->soap_out(soap, tag, id, "tt:DurationRange");
	case SOAP_TYPE_tt__FloatRange:
		return ((tt__FloatRange *)ptr)->soap_out(soap, tag, id, "tt:FloatRange");
	case SOAP_TYPE_tt__IntRectangleRange:
		return ((tt__IntRectangleRange *)ptr)->soap_out(soap, tag, id, "tt:IntRectangleRange");
	case SOAP_TYPE_tt__IntRectangle:
		return ((tt__IntRectangle *)ptr)->soap_out(soap, tag, id, "tt:IntRectangle");
	case SOAP_TYPE__timg__SetCurrentPresetResponse:
		return ((_timg__SetCurrentPresetResponse *)ptr)->soap_out(soap, "timg:SetCurrentPresetResponse", id, "");
	case SOAP_TYPE__timg__SetCurrentPreset:
		return ((_timg__SetCurrentPreset *)ptr)->soap_out(soap, "timg:SetCurrentPreset", id, "");
	case SOAP_TYPE__timg__GetCurrentPresetResponse:
		return ((_timg__GetCurrentPresetResponse *)ptr)->soap_out(soap, "timg:GetCurrentPresetResponse", id, "");
	case SOAP_TYPE__timg__GetCurrentPreset:
		return ((_timg__GetCurrentPreset *)ptr)->soap_out(soap, "timg:GetCurrentPreset", id, "");
	case SOAP_TYPE__timg__GetPresetsResponse:
		return ((_timg__GetPresetsResponse *)ptr)->soap_out(soap, "timg:GetPresetsResponse", id, "");
	case SOAP_TYPE__timg__GetPresets:
		return ((_timg__GetPresets *)ptr)->soap_out(soap, "timg:GetPresets", id, "");
	case SOAP_TYPE__timg__GetStatusResponse:
		return ((_timg__GetStatusResponse *)ptr)->soap_out(soap, "timg:GetStatusResponse", id, "");
	case SOAP_TYPE__timg__GetStatus:
		return ((_timg__GetStatus *)ptr)->soap_out(soap, "timg:GetStatus", id, "");
	case SOAP_TYPE__timg__StopResponse:
		return ((_timg__StopResponse *)ptr)->soap_out(soap, "timg:StopResponse", id, "");
	case SOAP_TYPE__timg__Stop:
		return ((_timg__Stop *)ptr)->soap_out(soap, "timg:Stop", id, "");
	case SOAP_TYPE__timg__GetMoveOptionsResponse:
		return ((_timg__GetMoveOptionsResponse *)ptr)->soap_out(soap, "timg:GetMoveOptionsResponse", id, "");
	case SOAP_TYPE__timg__GetMoveOptions:
		return ((_timg__GetMoveOptions *)ptr)->soap_out(soap, "timg:GetMoveOptions", id, "");
	case SOAP_TYPE__timg__MoveResponse:
		return ((_timg__MoveResponse *)ptr)->soap_out(soap, "timg:MoveResponse", id, "");
	case SOAP_TYPE__timg__Move:
		return ((_timg__Move *)ptr)->soap_out(soap, "timg:Move", id, "");
	case SOAP_TYPE__timg__GetOptionsResponse:
		return ((_timg__GetOptionsResponse *)ptr)->soap_out(soap, "timg:GetOptionsResponse", id, "");
	case SOAP_TYPE__timg__GetOptions:
		return ((_timg__GetOptions *)ptr)->soap_out(soap, "timg:GetOptions", id, "");
	case SOAP_TYPE__timg__SetImagingSettingsResponse:
		return ((_timg__SetImagingSettingsResponse *)ptr)->soap_out(soap, "timg:SetImagingSettingsResponse", id, "");
	case SOAP_TYPE__timg__SetImagingSettings:
		return ((_timg__SetImagingSettings *)ptr)->soap_out(soap, "timg:SetImagingSettings", id, "");
	case SOAP_TYPE__timg__GetImagingSettingsResponse:
		return ((_timg__GetImagingSettingsResponse *)ptr)->soap_out(soap, "timg:GetImagingSettingsResponse", id, "");
	case SOAP_TYPE__timg__GetImagingSettings:
		return ((_timg__GetImagingSettings *)ptr)->soap_out(soap, "timg:GetImagingSettings", id, "");
	case SOAP_TYPE__timg__GetServiceCapabilitiesResponse:
		return ((_timg__GetServiceCapabilitiesResponse *)ptr)->soap_out(soap, "timg:GetServiceCapabilitiesResponse", id, "");
	case SOAP_TYPE__timg__GetServiceCapabilities:
		return ((_timg__GetServiceCapabilities *)ptr)->soap_out(soap, "timg:GetServiceCapabilities", id, "");
	case SOAP_TYPE_timg__ImagingPreset:
		return ((timg__ImagingPreset *)ptr)->soap_out(soap, tag, id, "timg:ImagingPreset");
	case SOAP_TYPE_timg__Capabilities:
		return ((timg__Capabilities *)ptr)->soap_out(soap, tag, id, "timg:Capabilities");
	case SOAP_TYPE__xml__lang:
		return soap_out__xml__lang(soap, "xml:lang", id, (const std::string *)ptr, "");
	case SOAP_TYPE_xsd__token__:
		return ((xsd__token__ *)ptr)->soap_out(soap, tag, id, "xsd:token");
	case SOAP_TYPE_xsd__token:
		return soap_out_xsd__token(soap, tag, id, (const std::string *)ptr, "xsd:token");
	case SOAP_TYPE_xsd__string_:
		return ((xsd__string_ *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__nonNegativeInteger__:
		return ((xsd__nonNegativeInteger__ *)ptr)->soap_out(soap, tag, id, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer__:
		return ((xsd__integer__ *)ptr)->soap_out(soap, tag, id, "xsd:integer");
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::string *)ptr, "xsd:integer");
	case SOAP_TYPE_xsd__int_:
		return ((xsd__int_ *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__hexBinary__:
		return ((xsd__hexBinary__ *)ptr)->soap_out(soap, tag, id, "xsd:hexBinary");
	case SOAP_TYPE_xsd__float_:
		return ((xsd__float_ *)ptr)->soap_out(soap, tag, id, "xsd:float");
	case SOAP_TYPE_xsd__duration__:
		return ((xsd__duration__ *)ptr)->soap_out(soap, tag, id, "xsd:duration");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const std::string *)ptr, "xsd:duration");
	case SOAP_TYPE_xsd__double_:
		return ((xsd__double_ *)ptr)->soap_out(soap, tag, id, "xsd:double");
	case SOAP_TYPE_xsd__dateTime_:
		return ((xsd__dateTime_ *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean_:
		return ((xsd__boolean_ *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary__:
		return ((xsd__base64Binary__ *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI__:
		return ((xsd__anyURI__ *)ptr)->soap_out(soap, tag, id, "xsd:anyURI");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType__:
		return ((xsd__anySimpleType__ *)ptr)->soap_out(soap, tag, id, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__anySimpleType:
		return soap_out_xsd__anySimpleType(soap, tag, id, (const std::string *)ptr, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__QName__:
		return ((xsd__QName__ *)ptr)->soap_out(soap, tag, id, "xsd:QName");
	case SOAP_TYPE_xsd__NCName__:
		return ((xsd__NCName__ *)ptr)->soap_out(soap, tag, id, "xsd:NCName");
	case SOAP_TYPE_xsd__NCName:
		return soap_out_xsd__NCName(soap, tag, id, (const std::string *)ptr, "xsd:NCName");
	case SOAP_TYPE_SOAP_ENV__Fault_:
		return ((SOAP_ENV__Fault_ *)ptr)->soap_out(soap, tag, id, "SOAP-ENV:Fault");
	case SOAP_TYPE_SOAP_ENV__Envelope_:
		return ((SOAP_ENV__Envelope_ *)ptr)->soap_out(soap, tag, id, "SOAP-ENV:Envelope");
	case SOAP_TYPE_wsa5__EndpointReferenceType__:
		return ((wsa5__EndpointReferenceType__ *)ptr)->soap_out(soap, tag, id, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_xsd__hexBinary:
		return ((xsd__hexBinary *)ptr)->soap_out(soap, tag, id, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_SOAP_ENV__Envelope:
		return soap_out_SOAP_ENV__Envelope(soap, tag, id, (const struct SOAP_ENV__Envelope *)ptr, "SOAP-ENV:Envelope");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_out_chan__ChannelInstanceType(soap, tag, id, (const struct chan__ChannelInstanceType *)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE__wsa5__ProblemAction:
		return soap_out__wsa5__ProblemAction(soap, "wsa5:ProblemAction", id, (const struct wsa5__ProblemActionType *)ptr, "");
	case SOAP_TYPE__wsa5__FaultTo:
		return soap_out__wsa5__FaultTo(soap, "wsa5:FaultTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__From:
		return soap_out__wsa5__From(soap, "wsa5:From", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__ReplyTo:
		return soap_out__wsa5__ReplyTo(soap, "wsa5:ReplyTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__RelatesTo:
		return soap_out__wsa5__RelatesTo(soap, "wsa5:RelatesTo", id, (const struct wsa5__RelatesToType *)ptr, "");
	case SOAP_TYPE__wsa5__Metadata:
		return soap_out__wsa5__Metadata(soap, "wsa5:Metadata", id, (const struct wsa5__MetadataType *)ptr, "");
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return soap_out__wsa5__ReferenceParameters(soap, "wsa5:ReferenceParameters", id, (const struct wsa5__ReferenceParametersType *)ptr, "");
	case SOAP_TYPE__wsa5__EndpointReference:
		return soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_out_wsa5__ProblemActionType(soap, tag, id, (const struct wsa5__ProblemActionType *)ptr, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_out_wsa5__RelatesToType(soap, tag, id, (const struct wsa5__RelatesToType *)ptr, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_out_wsa5__MetadataType(soap, tag, id, (const struct wsa5__MetadataType *)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_out_wsa5__ReferenceParametersType(soap, tag, id, (const struct wsa5__ReferenceParametersType *)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_out_wsa5__EndpointReferenceType(soap, tag, id, (const struct wsa5__EndpointReferenceType *)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE__xop__Include:
		return soap_out__xop__Include(soap, "xop:Include", id, (const struct _xop__Include *)ptr, "");
	case SOAP_TYPE_PointerTo_timg__SetCurrentPreset:
		return soap_out_PointerTo_timg__SetCurrentPreset(soap, tag, id, (_timg__SetCurrentPreset *const*)ptr, "timg:SetCurrentPreset");
	case SOAP_TYPE_PointerTo_timg__GetCurrentPreset:
		return soap_out_PointerTo_timg__GetCurrentPreset(soap, tag, id, (_timg__GetCurrentPreset *const*)ptr, "timg:GetCurrentPreset");
	case SOAP_TYPE_PointerTo_timg__GetPresets:
		return soap_out_PointerTo_timg__GetPresets(soap, tag, id, (_timg__GetPresets *const*)ptr, "timg:GetPresets");
	case SOAP_TYPE_PointerTo_timg__GetMoveOptions:
		return soap_out_PointerTo_timg__GetMoveOptions(soap, tag, id, (_timg__GetMoveOptions *const*)ptr, "timg:GetMoveOptions");
	case SOAP_TYPE_PointerTo_timg__GetStatus:
		return soap_out_PointerTo_timg__GetStatus(soap, tag, id, (_timg__GetStatus *const*)ptr, "timg:GetStatus");
	case SOAP_TYPE_PointerTo_timg__Stop:
		return soap_out_PointerTo_timg__Stop(soap, tag, id, (_timg__Stop *const*)ptr, "timg:Stop");
	case SOAP_TYPE_PointerTo_timg__Move:
		return soap_out_PointerTo_timg__Move(soap, tag, id, (_timg__Move *const*)ptr, "timg:Move");
	case SOAP_TYPE_PointerTo_timg__GetOptions:
		return soap_out_PointerTo_timg__GetOptions(soap, tag, id, (_timg__GetOptions *const*)ptr, "timg:GetOptions");
	case SOAP_TYPE_PointerTo_timg__SetImagingSettings:
		return soap_out_PointerTo_timg__SetImagingSettings(soap, tag, id, (_timg__SetImagingSettings *const*)ptr, "timg:SetImagingSettings");
	case SOAP_TYPE_PointerTo_timg__GetImagingSettings:
		return soap_out_PointerTo_timg__GetImagingSettings(soap, tag, id, (_timg__GetImagingSettings *const*)ptr, "timg:GetImagingSettings");
	case SOAP_TYPE_PointerTo_timg__GetServiceCapabilities:
		return soap_out_PointerTo_timg__GetServiceCapabilities(soap, tag, id, (_timg__GetServiceCapabilities *const*)ptr, "timg:GetServiceCapabilities");
	case SOAP_TYPE_PointerToxsd__NCName:
		return soap_out_PointerToxsd__NCName(soap, tag, id, (std::string *const*)ptr, "xsd:NCName");
	case SOAP_TYPE_PointerTowstop__ConcreteTopicExpression:
		return soap_out_PointerTowstop__ConcreteTopicExpression(soap, tag, id, (std::string *const*)ptr, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_out_PointerToxsd__QName(soap, tag, id, (std::string *const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTowstop__TopicType:
		return soap_out_PointerTowstop__TopicType(soap, tag, id, (wstop__TopicType *const*)ptr, "wstop:TopicType");
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		return soap_out_PointerTowstop__QueryExpressionType(soap, tag, id, (wstop__QueryExpressionType *const*)ptr, "wstop:QueryExpressionType");
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension:
		return soap_out_PointerTott__PTZConfigurationExtension(soap, tag, id, (tt__PTZConfigurationExtension *const*)ptr, "tt:PTZConfigurationExtension");
	case SOAP_TYPE_PointerTott__ZoomLimits:
		return soap_out_PointerTott__ZoomLimits(soap, tag, id, (tt__ZoomLimits *const*)ptr, "tt:ZoomLimits");
	case SOAP_TYPE_PointerTott__PanTiltLimits:
		return soap_out_PointerTott__PanTiltLimits(soap, tag, id, (tt__PanTiltLimits *const*)ptr, "tt:PanTiltLimits");
	case SOAP_TYPE_PointerTott__PTZSpeed:
		return soap_out_PointerTott__PTZSpeed(soap, tag, id, (tt__PTZSpeed *const*)ptr, "tt:PTZSpeed");
	case SOAP_TYPE_PointerTott__MetadataConfigurationExtension:
		return soap_out_PointerTott__MetadataConfigurationExtension(soap, tag, id, (tt__MetadataConfigurationExtension *const*)ptr, "tt:MetadataConfigurationExtension");
	case SOAP_TYPE_PointerTott__EventSubscription:
		return soap_out_PointerTott__EventSubscription(soap, tag, id, (tt__EventSubscription *const*)ptr, "tt:EventSubscription");
	case SOAP_TYPE_PointerTott__PTZFilter:
		return soap_out_PointerTott__PTZFilter(soap, tag, id, (tt__PTZFilter *const*)ptr, "tt:PTZFilter");
	case SOAP_TYPE_PointerTott__RuleEngineConfiguration:
		return soap_out_PointerTott__RuleEngineConfiguration(soap, tag, id, (tt__RuleEngineConfiguration *const*)ptr, "tt:RuleEngineConfiguration");
	case SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration:
		return soap_out_PointerTott__AnalyticsEngineConfiguration(soap, tag, id, (tt__AnalyticsEngineConfiguration *const*)ptr, "tt:AnalyticsEngineConfiguration");
	case SOAP_TYPE_PointerTott__MulticastConfiguration:
		return soap_out_PointerTott__MulticastConfiguration(soap, tag, id, (tt__MulticastConfiguration *const*)ptr, "tt:MulticastConfiguration");
	case SOAP_TYPE_PointerTott__H264Configuration:
		return soap_out_PointerTott__H264Configuration(soap, tag, id, (tt__H264Configuration *const*)ptr, "tt:H264Configuration");
	case SOAP_TYPE_PointerTott__Mpeg4Configuration:
		return soap_out_PointerTott__Mpeg4Configuration(soap, tag, id, (tt__Mpeg4Configuration *const*)ptr, "tt:Mpeg4Configuration");
	case SOAP_TYPE_PointerTott__VideoRateControl:
		return soap_out_PointerTott__VideoRateControl(soap, tag, id, (tt__VideoRateControl *const*)ptr, "tt:VideoRateControl");
	case SOAP_TYPE_PointerTott__VideoResolution:
		return soap_out_PointerTott__VideoResolution(soap, tag, id, (tt__VideoResolution *const*)ptr, "tt:VideoResolution");
	case SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension:
		return soap_out_PointerTott__VideoSourceConfigurationExtension(soap, tag, id, (tt__VideoSourceConfigurationExtension *const*)ptr, "tt:VideoSourceConfigurationExtension");
	case SOAP_TYPE_PointerTott__IntRectangle:
		return soap_out_PointerTott__IntRectangle(soap, tag, id, (tt__IntRectangle *const*)ptr, "tt:IntRectangle");
	case SOAP_TYPE_PointerTowstop__Documentation:
		return soap_out_PointerTowstop__Documentation(soap, tag, id, (wstop__Documentation *const*)ptr, "wstop:Documentation");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		return soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, id, (_wsrfbf__BaseFaultType_FaultCause *const*)ptr, "wsrfbf:BaseFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_out_PointerTo_xml__lang(soap, tag, id, (std::string *const*)ptr, "xml:lang");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		return soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, id, (_wsrfbf__BaseFaultType_ErrorCode *const*)ptr, "wsrfbf:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_out_PointerToxsd__nonNegativeInteger(soap, tag, id, (std::string *const*)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy:
		return soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, id, (_wsnt__Subscribe_SubscriptionPolicy *const*)ptr, "wsnt:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType:
		return soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, tag, id, (std::string *const*)ptr, "wsnt:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType:
		return soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag, id, (wsnt__NotificationMessageHolderType *const*)ptr, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType:
		return soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag, id, (wsnt__SubscriptionPolicyType *const*)ptr, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		return soap_out_PointerTowstop__TopicSetType(soap, tag, id, (wstop__TopicSetType *const*)ptr, "wstop:TopicSetType");
	case SOAP_TYPE_PointerTowsnt__TopicExpressionType:
		return soap_out_PointerTowsnt__TopicExpressionType(soap, tag, id, (wsnt__TopicExpressionType *const*)ptr, "wsnt:TopicExpressionType");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_out_PointerTowsa5__EndpointReferenceType(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTott__PropertyOperation:
		return soap_out_PointerTott__PropertyOperation(soap, tag, id, (enum tt__PropertyOperation *const*)ptr, "tt:PropertyOperation");
	case SOAP_TYPE_PointerTott__MessageExtension:
		return soap_out_PointerTott__MessageExtension(soap, tag, id, (tt__MessageExtension *const*)ptr, "tt:MessageExtension");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTott__ItemList:
		return soap_out_PointerTott__ItemList(soap, tag, id, (tt__ItemList *const*)ptr, "tt:ItemList");
	case SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension:
		return soap_out_PointerTott__RuleEngineConfigurationExtension(soap, tag, id, (tt__RuleEngineConfigurationExtension *const*)ptr, "tt:RuleEngineConfigurationExtension");
	case SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension:
		return soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag, id, (tt__AnalyticsEngineConfigurationExtension *const*)ptr, "tt:AnalyticsEngineConfigurationExtension");
	case SOAP_TYPE_PointerTott__Config:
		return soap_out_PointerTott__Config(soap, tag, id, (tt__Config *const*)ptr, "tt:Config");
	case SOAP_TYPE_PointerTott__Vector:
		return soap_out_PointerTott__Vector(soap, tag, id, (tt__Vector *const*)ptr, "tt:Vector");
	case SOAP_TYPE_PointerTott__ItemListExtension:
		return soap_out_PointerTott__ItemListExtension(soap, tag, id, (tt__ItemListExtension *const*)ptr, "tt:ItemListExtension");
	case SOAP_TYPE_PointerTott__FocusOptions20Extension:
		return soap_out_PointerTott__FocusOptions20Extension(soap, tag, id, (tt__FocusOptions20Extension *const*)ptr, "tt:FocusOptions20Extension");
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension:
		return soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, tag, id, (tt__WhiteBalanceOptions20Extension *const*)ptr, "tt:WhiteBalanceOptions20Extension");
	case SOAP_TYPE_PointerTott__StringAttrList:
		return soap_out_PointerTott__StringAttrList(soap, tag, id, (std::string *const*)ptr, "tt:StringAttrList");
	case SOAP_TYPE_PointerTott__FocusConfiguration20Extension:
		return soap_out_PointerTott__FocusConfiguration20Extension(soap, tag, id, (tt__FocusConfiguration20Extension *const*)ptr, "tt:FocusConfiguration20Extension");
	case SOAP_TYPE_PointerTott__WhiteBalance20Extension:
		return soap_out_PointerTott__WhiteBalance20Extension(soap, tag, id, (tt__WhiteBalance20Extension *const*)ptr, "tt:WhiteBalance20Extension");
	case SOAP_TYPE_PointerTott__ContinuousFocusOptions:
		return soap_out_PointerTott__ContinuousFocusOptions(soap, tag, id, (tt__ContinuousFocusOptions *const*)ptr, "tt:ContinuousFocusOptions");
	case SOAP_TYPE_PointerTott__RelativeFocusOptions20:
		return soap_out_PointerTott__RelativeFocusOptions20(soap, tag, id, (tt__RelativeFocusOptions20 *const*)ptr, "tt:RelativeFocusOptions20");
	case SOAP_TYPE_PointerTott__AbsoluteFocusOptions:
		return soap_out_PointerTott__AbsoluteFocusOptions(soap, tag, id, (tt__AbsoluteFocusOptions *const*)ptr, "tt:AbsoluteFocusOptions");
	case SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension:
		return soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, id, (tt__IrCutFilterAutoAdjustmentOptionsExtension *const*)ptr, "tt:IrCutFilterAutoAdjustmentOptionsExtension");
	case SOAP_TYPE_PointerTott__DurationRange:
		return soap_out_PointerTott__DurationRange(soap, tag, id, (tt__DurationRange *const*)ptr, "tt:DurationRange");
	case SOAP_TYPE_PointerTott__ImageStabilizationOptionsExtension:
		return soap_out_PointerTott__ImageStabilizationOptionsExtension(soap, tag, id, (tt__ImageStabilizationOptionsExtension *const*)ptr, "tt:ImageStabilizationOptionsExtension");
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension4:
		return soap_out_PointerTott__ImagingOptions20Extension4(soap, tag, id, (tt__ImagingOptions20Extension4 *const*)ptr, "tt:ImagingOptions20Extension4");
	case SOAP_TYPE_PointerTott__NoiseReductionOptions:
		return soap_out_PointerTott__NoiseReductionOptions(soap, tag, id, (tt__NoiseReductionOptions *const*)ptr, "tt:NoiseReductionOptions");
	case SOAP_TYPE_PointerTott__DefoggingOptions:
		return soap_out_PointerTott__DefoggingOptions(soap, tag, id, (tt__DefoggingOptions *const*)ptr, "tt:DefoggingOptions");
	case SOAP_TYPE_PointerTott__ToneCompensationOptions:
		return soap_out_PointerTott__ToneCompensationOptions(soap, tag, id, (tt__ToneCompensationOptions *const*)ptr, "tt:ToneCompensationOptions");
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension3:
		return soap_out_PointerTott__ImagingOptions20Extension3(soap, tag, id, (tt__ImagingOptions20Extension3 *const*)ptr, "tt:ImagingOptions20Extension3");
	case SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptions:
		return soap_out_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, tag, id, (tt__IrCutFilterAutoAdjustmentOptions *const*)ptr, "tt:IrCutFilterAutoAdjustmentOptions");
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension2:
		return soap_out_PointerTott__ImagingOptions20Extension2(soap, tag, id, (tt__ImagingOptions20Extension2 *const*)ptr, "tt:ImagingOptions20Extension2");
	case SOAP_TYPE_PointerTott__ImageStabilizationOptions:
		return soap_out_PointerTott__ImageStabilizationOptions(soap, tag, id, (tt__ImageStabilizationOptions *const*)ptr, "tt:ImageStabilizationOptions");
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension:
		return soap_out_PointerTott__ImagingOptions20Extension(soap, tag, id, (tt__ImagingOptions20Extension *const*)ptr, "tt:ImagingOptions20Extension");
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions20:
		return soap_out_PointerTott__WhiteBalanceOptions20(soap, tag, id, (tt__WhiteBalanceOptions20 *const*)ptr, "tt:WhiteBalanceOptions20");
	case SOAP_TYPE_PointerTott__WideDynamicRangeOptions20:
		return soap_out_PointerTott__WideDynamicRangeOptions20(soap, tag, id, (tt__WideDynamicRangeOptions20 *const*)ptr, "tt:WideDynamicRangeOptions20");
	case SOAP_TYPE_PointerTott__FocusOptions20:
		return soap_out_PointerTott__FocusOptions20(soap, tag, id, (tt__FocusOptions20 *const*)ptr, "tt:FocusOptions20");
	case SOAP_TYPE_PointerTott__ExposureOptions20:
		return soap_out_PointerTott__ExposureOptions20(soap, tag, id, (tt__ExposureOptions20 *const*)ptr, "tt:ExposureOptions20");
	case SOAP_TYPE_PointerTott__BacklightCompensationOptions20:
		return soap_out_PointerTott__BacklightCompensationOptions20(soap, tag, id, (tt__BacklightCompensationOptions20 *const*)ptr, "tt:BacklightCompensationOptions20");
	case SOAP_TYPE_PointerTott__DefoggingExtension:
		return soap_out_PointerTott__DefoggingExtension(soap, tag, id, (tt__DefoggingExtension *const*)ptr, "tt:DefoggingExtension");
	case SOAP_TYPE_PointerTott__ToneCompensationExtension:
		return soap_out_PointerTott__ToneCompensationExtension(soap, tag, id, (tt__ToneCompensationExtension *const*)ptr, "tt:ToneCompensationExtension");
	case SOAP_TYPE_PointerTott__Rectangle:
		return soap_out_PointerTott__Rectangle(soap, tag, id, (tt__Rectangle *const*)ptr, "tt:Rectangle");
	case SOAP_TYPE_PointerTott__ExposurePriority:
		return soap_out_PointerTott__ExposurePriority(soap, tag, id, (enum tt__ExposurePriority *const*)ptr, "tt:ExposurePriority");
	case SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentExtension:
		return soap_out_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, tag, id, (tt__IrCutFilterAutoAdjustmentExtension *const*)ptr, "tt:IrCutFilterAutoAdjustmentExtension");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_out_PointerToxsd__duration(soap, tag, id, (std::string *const*)ptr, "xsd:duration");
	case SOAP_TYPE_PointerTott__ImageStabilizationExtension:
		return soap_out_PointerTott__ImageStabilizationExtension(soap, tag, id, (tt__ImageStabilizationExtension *const*)ptr, "tt:ImageStabilizationExtension");
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension204:
		return soap_out_PointerTott__ImagingSettingsExtension204(soap, tag, id, (tt__ImagingSettingsExtension204 *const*)ptr, "tt:ImagingSettingsExtension204");
	case SOAP_TYPE_PointerTott__NoiseReduction:
		return soap_out_PointerTott__NoiseReduction(soap, tag, id, (tt__NoiseReduction *const*)ptr, "tt:NoiseReduction");
	case SOAP_TYPE_PointerTott__Defogging:
		return soap_out_PointerTott__Defogging(soap, tag, id, (tt__Defogging *const*)ptr, "tt:Defogging");
	case SOAP_TYPE_PointerTott__ToneCompensation:
		return soap_out_PointerTott__ToneCompensation(soap, tag, id, (tt__ToneCompensation *const*)ptr, "tt:ToneCompensation");
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension203:
		return soap_out_PointerTott__ImagingSettingsExtension203(soap, tag, id, (tt__ImagingSettingsExtension203 *const*)ptr, "tt:ImagingSettingsExtension203");
	case SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustment:
		return soap_out_PointerTott__IrCutFilterAutoAdjustment(soap, tag, id, (tt__IrCutFilterAutoAdjustment *const*)ptr, "tt:IrCutFilterAutoAdjustment");
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension202:
		return soap_out_PointerTott__ImagingSettingsExtension202(soap, tag, id, (tt__ImagingSettingsExtension202 *const*)ptr, "tt:ImagingSettingsExtension202");
	case SOAP_TYPE_PointerTott__ImageStabilization:
		return soap_out_PointerTott__ImageStabilization(soap, tag, id, (tt__ImageStabilization *const*)ptr, "tt:ImageStabilization");
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension20:
		return soap_out_PointerTott__ImagingSettingsExtension20(soap, tag, id, (tt__ImagingSettingsExtension20 *const*)ptr, "tt:ImagingSettingsExtension20");
	case SOAP_TYPE_PointerTott__WhiteBalance20:
		return soap_out_PointerTott__WhiteBalance20(soap, tag, id, (tt__WhiteBalance20 *const*)ptr, "tt:WhiteBalance20");
	case SOAP_TYPE_PointerTott__WideDynamicRange20:
		return soap_out_PointerTott__WideDynamicRange20(soap, tag, id, (tt__WideDynamicRange20 *const*)ptr, "tt:WideDynamicRange20");
	case SOAP_TYPE_PointerTott__IrCutFilterMode:
		return soap_out_PointerTott__IrCutFilterMode(soap, tag, id, (enum tt__IrCutFilterMode *const*)ptr, "tt:IrCutFilterMode");
	case SOAP_TYPE_PointerTott__FocusConfiguration20:
		return soap_out_PointerTott__FocusConfiguration20(soap, tag, id, (tt__FocusConfiguration20 *const*)ptr, "tt:FocusConfiguration20");
	case SOAP_TYPE_PointerTott__Exposure20:
		return soap_out_PointerTott__Exposure20(soap, tag, id, (tt__Exposure20 *const*)ptr, "tt:Exposure20");
	case SOAP_TYPE_PointerTott__BacklightCompensation20:
		return soap_out_PointerTott__BacklightCompensation20(soap, tag, id, (tt__BacklightCompensation20 *const*)ptr, "tt:BacklightCompensation20");
	case SOAP_TYPE_PointerTott__FocusStatus20Extension:
		return soap_out_PointerTott__FocusStatus20Extension(soap, tag, id, (tt__FocusStatus20Extension *const*)ptr, "tt:FocusStatus20Extension");
	case SOAP_TYPE_PointerTott__ImagingStatus20Extension:
		return soap_out_PointerTott__ImagingStatus20Extension(soap, tag, id, (tt__ImagingStatus20Extension *const*)ptr, "tt:ImagingStatus20Extension");
	case SOAP_TYPE_PointerTott__FocusStatus20:
		return soap_out_PointerTott__FocusStatus20(soap, tag, id, (tt__FocusStatus20 *const*)ptr, "tt:FocusStatus20");
	case SOAP_TYPE_PointerTott__ContinuousFocus:
		return soap_out_PointerTott__ContinuousFocus(soap, tag, id, (tt__ContinuousFocus *const*)ptr, "tt:ContinuousFocus");
	case SOAP_TYPE_PointerTott__RelativeFocus:
		return soap_out_PointerTott__RelativeFocus(soap, tag, id, (tt__RelativeFocus *const*)ptr, "tt:RelativeFocus");
	case SOAP_TYPE_PointerTott__AbsoluteFocus:
		return soap_out_PointerTott__AbsoluteFocus(soap, tag, id, (tt__AbsoluteFocus *const*)ptr, "tt:AbsoluteFocus");
	case SOAP_TYPE_PointerTott__Vector1D:
		return soap_out_PointerTott__Vector1D(soap, tag, id, (tt__Vector1D *const*)ptr, "tt:Vector1D");
	case SOAP_TYPE_PointerTott__Vector2D:
		return soap_out_PointerTott__Vector2D(soap, tag, id, (tt__Vector2D *const*)ptr, "tt:Vector2D");
	case SOAP_TYPE_PointerTott__FloatRange:
		return soap_out_PointerTott__FloatRange(soap, tag, id, (tt__FloatRange *const*)ptr, "tt:FloatRange");
	case SOAP_TYPE_PointerTott__Space1DDescription:
		return soap_out_PointerTott__Space1DDescription(soap, tag, id, (tt__Space1DDescription *const*)ptr, "tt:Space1DDescription");
	case SOAP_TYPE_PointerTott__Space2DDescription:
		return soap_out_PointerTott__Space2DDescription(soap, tag, id, (tt__Space2DDescription *const*)ptr, "tt:Space2DDescription");
	case SOAP_TYPE_PointerTott__PTControlDirectionExtension:
		return soap_out_PointerTott__PTControlDirectionExtension(soap, tag, id, (tt__PTControlDirectionExtension *const*)ptr, "tt:PTControlDirectionExtension");
	case SOAP_TYPE_PointerTott__Reverse:
		return soap_out_PointerTott__Reverse(soap, tag, id, (tt__Reverse *const*)ptr, "tt:Reverse");
	case SOAP_TYPE_PointerTott__EFlip:
		return soap_out_PointerTott__EFlip(soap, tag, id, (tt__EFlip *const*)ptr, "tt:EFlip");
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension2:
		return soap_out_PointerTott__PTZConfigurationExtension2(soap, tag, id, (tt__PTZConfigurationExtension2 *const*)ptr, "tt:PTZConfigurationExtension2");
	case SOAP_TYPE_PointerTott__PTControlDirection:
		return soap_out_PointerTott__PTControlDirection(soap, tag, id, (tt__PTControlDirection *const*)ptr, "tt:PTControlDirection");
	case SOAP_TYPE_PointerTott__IPv6Address:
		return soap_out_PointerTott__IPv6Address(soap, tag, id, (std::string *const*)ptr, "tt:IPv6Address");
	case SOAP_TYPE_PointerTott__IPv4Address:
		return soap_out_PointerTott__IPv4Address(soap, tag, id, (std::string *const*)ptr, "tt:IPv4Address");
	case SOAP_TYPE_PointerTott__IPAddress:
		return soap_out_PointerTott__IPAddress(soap, tag, id, (tt__IPAddress *const*)ptr, "tt:IPAddress");
	case SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy:
		return soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, tag, id, (_tt__EventSubscription_SubscriptionPolicy *const*)ptr, "tt:EventSubscription-SubscriptionPolicy");
	case SOAP_TYPE_PointerTowsnt__FilterType:
		return soap_out_PointerTowsnt__FilterType(soap, tag, id, (wsnt__FilterType *const*)ptr, "wsnt:FilterType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTott__LensProjection:
		return soap_out_PointerTott__LensProjection(soap, tag, id, (tt__LensProjection *const*)ptr, "tt:LensProjection");
	case SOAP_TYPE_PointerTott__LensOffset:
		return soap_out_PointerTott__LensOffset(soap, tag, id, (tt__LensOffset *const*)ptr, "tt:LensOffset");
	case SOAP_TYPE_PointerTofloat:
		return soap_out_PointerTofloat(soap, tag, id, (float *const*)ptr, "xsd:float");
	case SOAP_TYPE_PointerTott__RotateExtension:
		return soap_out_PointerTott__RotateExtension(soap, tag, id, (tt__RotateExtension *const*)ptr, "tt:RotateExtension");
	case SOAP_TYPE_PointerTott__SceneOrientation:
		return soap_out_PointerTott__SceneOrientation(soap, tag, id, (tt__SceneOrientation *const*)ptr, "tt:SceneOrientation");
	case SOAP_TYPE_PointerTott__LensDescription:
		return soap_out_PointerTott__LensDescription(soap, tag, id, (tt__LensDescription *const*)ptr, "tt:LensDescription");
	case SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension2:
		return soap_out_PointerTott__VideoSourceConfigurationExtension2(soap, tag, id, (tt__VideoSourceConfigurationExtension2 *const*)ptr, "tt:VideoSourceConfigurationExtension2");
	case SOAP_TYPE_PointerTott__Rotate:
		return soap_out_PointerTott__Rotate(soap, tag, id, (tt__Rotate *const*)ptr, "tt:Rotate");
	case SOAP_TYPE_PointerTott__IntRange:
		return soap_out_PointerTott__IntRange(soap, tag, id, (tt__IntRange *const*)ptr, "tt:IntRange");
	case SOAP_TYPE_PointerTotimg__ImagingPreset:
		return soap_out_PointerTotimg__ImagingPreset(soap, tag, id, (timg__ImagingPreset *const*)ptr, "timg:ImagingPreset");
	case SOAP_TYPE_PointerTott__ImagingStatus20:
		return soap_out_PointerTott__ImagingStatus20(soap, tag, id, (tt__ImagingStatus20 *const*)ptr, "tt:ImagingStatus20");
	case SOAP_TYPE_PointerTott__MoveOptions20:
		return soap_out_PointerTott__MoveOptions20(soap, tag, id, (tt__MoveOptions20 *const*)ptr, "tt:MoveOptions20");
	case SOAP_TYPE_PointerTott__FocusMove:
		return soap_out_PointerTott__FocusMove(soap, tag, id, (tt__FocusMove *const*)ptr, "tt:FocusMove");
	case SOAP_TYPE_PointerTott__ImagingOptions20:
		return soap_out_PointerTott__ImagingOptions20(soap, tag, id, (tt__ImagingOptions20 *const*)ptr, "tt:ImagingOptions20");
	case SOAP_TYPE_PointerTott__ImagingSettings20:
		return soap_out_PointerTott__ImagingSettings20(soap, tag, id, (tt__ImagingSettings20 *const*)ptr, "tt:ImagingSettings20");
	case SOAP_TYPE_PointerTotimg__Capabilities:
		return soap_out_PointerTotimg__Capabilities(soap, tag, id, (timg__Capabilities *const*)ptr, "timg:Capabilities");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_out_PointerTochan__ChannelInstanceType(soap, tag, id, (struct chan__ChannelInstanceType *const*)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_out_PointerTo_wsa5__FaultTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_out_PointerTo_wsa5__ReplyTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_out_PointerTo_wsa5__From(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_out_PointerTo_wsa5__RelatesTo(soap, tag, id, (struct wsa5__RelatesToType *const*)ptr, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemIRI:
		return soap_out_string(soap, "wsa5:ProblemIRI", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE__wsa5__Action:
		return soap_out_string(soap, "wsa5:Action", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__To:
		return soap_out_string(soap, "wsa5:To", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__MessageID:
		return soap_out_string(soap, "wsa5:MessageID", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_out_PointerTowsa5__MetadataType(soap, tag, id, (struct wsa5__MetadataType *const*)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_out_PointerTowsa5__ReferenceParametersType(soap, tag, id, (struct wsa5__ReferenceParametersType *const*)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:FaultCodesOpenEnumType");
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:RelationshipTypeOpenEnum");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in imageingC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		((_wstop__TopicNamespaceType_Topic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		((_wsrfbf__BaseFaultType_FaultCause *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		((_wsrfbf__BaseFaultType_Description *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		((_wsrfbf__BaseFaultType_ErrorCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		((_wsnt__Subscribe_SubscriptionPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		((_wsnt__NotificationMessageHolderType_Message *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__ItemList_ElementItem:
		((_tt__ItemList_ElementItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__ItemList_SimpleItem:
		((_tt__ItemList_SimpleItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy:
		((_tt__EventSubscription_SubscriptionPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__ConcreteTopicExpression__:
		((wstop__ConcreteTopicExpression__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		soap_serialize_wstop__ConcreteTopicExpression(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__MoveStatus_:
		((tt__MoveStatus_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ReferenceToken__:
		((tt__ReferenceToken__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ReferenceToken:
		soap_serialize_tt__ReferenceToken(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__PropertyOperation_:
		((tt__PropertyOperation_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImageStabilizationMode_:
		((tt__ImageStabilizationMode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IrCutFilterMode_:
		((tt__IrCutFilterMode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WhiteBalanceMode_:
		((tt__WhiteBalanceMode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ExposureMode_:
		((tt__ExposureMode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ExposurePriority_:
		((tt__ExposurePriority_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__BacklightCompensationMode_:
		((tt__BacklightCompensationMode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WideDynamicMode_:
		((tt__WideDynamicMode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AutoFocusMode_:
		((tt__AutoFocusMode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ReverseMode_:
		((tt__ReverseMode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__EFlipMode_:
		((tt__EFlipMode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPType_:
		((tt__IPType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv6Address__:
		((tt__IPv6Address__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv6Address:
		soap_serialize_tt__IPv6Address(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__IPv4Address__:
		((tt__IPv4Address__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv4Address:
		soap_serialize_tt__IPv4Address(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__AudioEncoding_:
		((tt__AudioEncoding_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__H264Profile_:
		((tt__H264Profile_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Mpeg4Profile_:
		((tt__Mpeg4Profile_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoEncoding_:
		((tt__VideoEncoding_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SceneOrientationMode_:
		((tt__SceneOrientationMode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RotateMode_:
		((tt__RotateMode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Name__:
		((tt__Name__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Name:
		soap_serialize_tt__Name(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__StringList:
		soap_serialize_tt__StringList(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__StringAttrList:
		soap_serialize_tt__StringAttrList(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__FloatList:
		soap_serialize_tt__FloatList(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__IntList:
		soap_serialize_tt__IntList(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_wstop__TopicSetType:
		((wstop__TopicSetType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__TopicType:
		((wstop__TopicType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__TopicNamespaceType:
		((wstop__TopicNamespaceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__QueryExpressionType:
		((wstop__QueryExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		((wstop__ExtensibleDocumented *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__Documentation:
		((wstop__Documentation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		((wsrfbf__BaseFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		((_wsnt__ResumeSubscriptionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__ResumeSubscription:
		((_wsnt__ResumeSubscription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		((_wsnt__PauseSubscriptionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__PauseSubscription:
		((_wsnt__PauseSubscription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		((_wsnt__UnsubscribeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__Unsubscribe:
		((_wsnt__Unsubscribe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__RenewResponse:
		((_wsnt__RenewResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__Renew:
		((_wsnt__Renew *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		((_wsnt__CreatePullPointResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__CreatePullPoint:
		((_wsnt__CreatePullPoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		((_wsnt__DestroyPullPointResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		((_wsnt__DestroyPullPoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		((_wsnt__GetMessagesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__GetMessages:
		((_wsnt__GetMessages *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		((_wsnt__GetCurrentMessageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		((_wsnt__GetCurrentMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__SubscribeResponse:
		((_wsnt__SubscribeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__Subscribe:
		((_wsnt__Subscribe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__UseRaw:
		((_wsnt__UseRaw *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__Notify:
		((_wsnt__Notify *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		((_wsnt__SubscriptionManagerRP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		((_wsnt__NotificationProducerRP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		((wsnt__ResumeFailedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		((wsnt__PauseFailedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		((wsnt__UnableToDestroySubscriptionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		((wsnt__UnacceptableTerminationTimeFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		((wsnt__UnableToCreatePullPointFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		((wsnt__UnableToDestroyPullPointFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		((wsnt__UnableToGetMessagesFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		((wsnt__NoCurrentMessageOnTopicFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		((wsnt__UnacceptableInitialTerminationTimeFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		((wsnt__NotifyMessageNotSupportedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		((wsnt__UnsupportedPolicyRequestFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		((wsnt__UnrecognizedPolicyRequestFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		((wsnt__InvalidMessageContentExpressionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		((wsnt__InvalidProducerPropertiesExpressionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		((wsnt__MultipleTopicsSpecifiedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		((wsnt__TopicNotSupportedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		((wsnt__InvalidTopicExpressionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		((wsnt__TopicExpressionDialectUnknownFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		((wsnt__InvalidFilterFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		((wsnt__SubscribeCreationFailedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		((wsnt__NotificationMessageHolderType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		((wsnt__SubscriptionPolicyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__FilterType:
		((wsnt__FilterType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__TopicExpressionType:
		((wsnt__TopicExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__QueryExpressionType:
		((wsnt__QueryExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__Message:
		((_tt__Message *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__StringItems:
		((_tt__StringItems *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Polygon:
		((tt__Polygon *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Rectangle:
		((tt__Rectangle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Vector:
		((tt__Vector *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Vector1D:
		((tt__Vector1D *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Vector2D:
		((tt__Vector2D *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IntRange:
		((tt__IntRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PolygonOptions:
		((tt__PolygonOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Config:
		((tt__Config *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RuleEngineConfigurationExtension:
		((tt__RuleEngineConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RuleEngineConfiguration:
		((tt__RuleEngineConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension:
		((tt__AnalyticsEngineConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AnalyticsEngineConfiguration:
		((tt__AnalyticsEngineConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Polyline:
		((tt__Polyline *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ItemListExtension:
		((tt__ItemListExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ItemList:
		((tt__ItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MessageExtension:
		((tt__MessageExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NoiseReductionOptions:
		((tt__NoiseReductionOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DefoggingOptions:
		((tt__DefoggingOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ToneCompensationOptions:
		((tt__ToneCompensationOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusOptions20Extension:
		((tt__FocusOptions20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusOptions20:
		((tt__FocusOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WhiteBalanceOptions20Extension:
		((tt__WhiteBalanceOptions20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WhiteBalanceOptions20:
		((tt__WhiteBalanceOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusConfiguration20Extension:
		((tt__FocusConfiguration20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusConfiguration20:
		((tt__FocusConfiguration20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WhiteBalance20Extension:
		((tt__WhiteBalance20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WhiteBalance20:
		((tt__WhiteBalance20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RelativeFocusOptions20:
		((tt__RelativeFocusOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MoveOptions20:
		((tt__MoveOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ExposureOptions20:
		((tt__ExposureOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__BacklightCompensationOptions20:
		((tt__BacklightCompensationOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WideDynamicRangeOptions20:
		((tt__WideDynamicRangeOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension:
		((tt__IrCutFilterAutoAdjustmentOptionsExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions:
		((tt__IrCutFilterAutoAdjustmentOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImageStabilizationOptionsExtension:
		((tt__ImageStabilizationOptionsExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImageStabilizationOptions:
		((tt__ImageStabilizationOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension4:
		((tt__ImagingOptions20Extension4 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension3:
		((tt__ImagingOptions20Extension3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension2:
		((tt__ImagingOptions20Extension2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension:
		((tt__ImagingOptions20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingOptions20:
		((tt__ImagingOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NoiseReduction:
		((tt__NoiseReduction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DefoggingExtension:
		((tt__DefoggingExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Defogging:
		((tt__Defogging *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ToneCompensationExtension:
		((tt__ToneCompensationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ToneCompensation:
		((tt__ToneCompensation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Exposure20:
		((tt__Exposure20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__BacklightCompensation20:
		((tt__BacklightCompensation20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WideDynamicRange20:
		((tt__WideDynamicRange20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension:
		((tt__IrCutFilterAutoAdjustmentExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustment:
		((tt__IrCutFilterAutoAdjustment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImageStabilizationExtension:
		((tt__ImageStabilizationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImageStabilization:
		((tt__ImageStabilization *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension204:
		((tt__ImagingSettingsExtension204 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension203:
		((tt__ImagingSettingsExtension203 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension202:
		((tt__ImagingSettingsExtension202 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension20:
		((tt__ImagingSettingsExtension20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingSettings20:
		((tt__ImagingSettings20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusStatus20Extension:
		((tt__FocusStatus20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusStatus20:
		((tt__FocusStatus20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingStatus20Extension:
		((tt__ImagingStatus20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingStatus20:
		((tt__ImagingStatus20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ContinuousFocusOptions:
		((tt__ContinuousFocusOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AbsoluteFocusOptions:
		((tt__AbsoluteFocusOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ContinuousFocus:
		((tt__ContinuousFocus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RelativeFocus:
		((tt__RelativeFocus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AbsoluteFocus:
		((tt__AbsoluteFocus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusMove:
		((tt__FocusMove *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZSpeed:
		((tt__PTZSpeed *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Space1DDescription:
		((tt__Space1DDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Space2DDescription:
		((tt__Space2DDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ZoomLimits:
		((tt__ZoomLimits *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PanTiltLimits:
		((tt__PanTiltLimits *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Reverse:
		((tt__Reverse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__EFlip:
		((tt__EFlip *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTControlDirectionExtension:
		((tt__PTControlDirectionExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTControlDirection:
		((tt__PTControlDirection *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension2:
		((tt__PTZConfigurationExtension2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		((tt__PTZConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZConfiguration:
		((tt__PTZConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPAddress:
		((tt__IPAddress *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MulticastConfiguration:
		((tt__MulticastConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AudioDecoderConfiguration:
		((tt__AudioDecoderConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AudioOutputConfiguration:
		((tt__AudioOutputConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__EventSubscription:
		((tt__EventSubscription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZFilter:
		((tt__PTZFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MetadataConfigurationExtension:
		((tt__MetadataConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MetadataConfiguration:
		((tt__MetadataConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoAnalyticsConfiguration:
		((tt__VideoAnalyticsConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AudioEncoderConfiguration:
		((tt__AudioEncoderConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AudioSourceConfiguration:
		((tt__AudioSourceConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__H264Configuration:
		((tt__H264Configuration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Mpeg4Configuration:
		((tt__Mpeg4Configuration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoRateControl:
		((tt__VideoRateControl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoResolution:
		((tt__VideoResolution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		((tt__VideoEncoderConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SceneOrientation:
		((tt__SceneOrientation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__LensDescription:
		((tt__LensDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__LensOffset:
		((tt__LensOffset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__LensProjection:
		((tt__LensProjection *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RotateExtension:
		((tt__RotateExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Rotate:
		((tt__Rotate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoSourceConfigurationExtension2:
		((tt__VideoSourceConfigurationExtension2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoSourceConfigurationExtension:
		((tt__VideoSourceConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoSourceConfiguration:
		((tt__VideoSourceConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ConfigurationEntity:
		((tt__ConfigurationEntity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DurationRange:
		((tt__DurationRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FloatRange:
		((tt__FloatRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IntRectangleRange:
		((tt__IntRectangleRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IntRectangle:
		((tt__IntRectangle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__SetCurrentPresetResponse:
		((_timg__SetCurrentPresetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__SetCurrentPreset:
		((_timg__SetCurrentPreset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetCurrentPresetResponse:
		((_timg__GetCurrentPresetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetCurrentPreset:
		((_timg__GetCurrentPreset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetPresetsResponse:
		((_timg__GetPresetsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetPresets:
		((_timg__GetPresets *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetStatusResponse:
		((_timg__GetStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetStatus:
		((_timg__GetStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__StopResponse:
		((_timg__StopResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__Stop:
		((_timg__Stop *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetMoveOptionsResponse:
		((_timg__GetMoveOptionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetMoveOptions:
		((_timg__GetMoveOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__MoveResponse:
		((_timg__MoveResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__Move:
		((_timg__Move *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetOptionsResponse:
		((_timg__GetOptionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetOptions:
		((_timg__GetOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__SetImagingSettingsResponse:
		((_timg__SetImagingSettingsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__SetImagingSettings:
		((_timg__SetImagingSettings *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetImagingSettingsResponse:
		((_timg__GetImagingSettingsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetImagingSettings:
		((_timg__GetImagingSettings *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetServiceCapabilitiesResponse:
		((_timg__GetServiceCapabilitiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__timg__GetServiceCapabilities:
		((_timg__GetServiceCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_timg__ImagingPreset:
		((timg__ImagingPreset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_timg__Capabilities:
		((timg__Capabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__xml__lang:
		soap_serialize__xml__lang(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__token__:
		((xsd__token__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__token:
		soap_serialize_xsd__token(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__string_:
		((xsd__string_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger__:
		((xsd__nonNegativeInteger__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__integer__:
		((xsd__integer__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__int_:
		((xsd__int_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__hexBinary__:
		((xsd__hexBinary__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__float_:
		((xsd__float_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__duration__:
		((xsd__duration__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__duration:
		soap_serialize_xsd__duration(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__double_:
		((xsd__double_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__dateTime_:
		((xsd__dateTime_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__boolean_:
		((xsd__boolean_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary__:
		((xsd__base64Binary__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI__:
		((xsd__anyURI__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anySimpleType__:
		((xsd__anySimpleType__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		soap_serialize_xsd__anySimpleType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__QName__:
		((xsd__QName__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__NCName__:
		((xsd__NCName__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__NCName:
		soap_serialize_xsd__NCName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault_:
		((SOAP_ENV__Fault_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_SOAP_ENV__Envelope_:
		((SOAP_ENV__Envelope_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType__:
		((wsa5__EndpointReferenceType__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		((xsd__hexBinary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___timg__SetCurrentPreset:
		soap_serialize___timg__SetCurrentPreset(soap, (const struct __timg__SetCurrentPreset *)ptr);
		break;
	case SOAP_TYPE___timg__GetCurrentPreset:
		soap_serialize___timg__GetCurrentPreset(soap, (const struct __timg__GetCurrentPreset *)ptr);
		break;
	case SOAP_TYPE___timg__GetPresets:
		soap_serialize___timg__GetPresets(soap, (const struct __timg__GetPresets *)ptr);
		break;
	case SOAP_TYPE___timg__GetMoveOptions:
		soap_serialize___timg__GetMoveOptions(soap, (const struct __timg__GetMoveOptions *)ptr);
		break;
	case SOAP_TYPE___timg__GetStatus:
		soap_serialize___timg__GetStatus(soap, (const struct __timg__GetStatus *)ptr);
		break;
	case SOAP_TYPE___timg__Stop:
		soap_serialize___timg__Stop(soap, (const struct __timg__Stop *)ptr);
		break;
	case SOAP_TYPE___timg__Move:
		soap_serialize___timg__Move(soap, (const struct __timg__Move *)ptr);
		break;
	case SOAP_TYPE___timg__GetOptions:
		soap_serialize___timg__GetOptions(soap, (const struct __timg__GetOptions *)ptr);
		break;
	case SOAP_TYPE___timg__SetImagingSettings:
		soap_serialize___timg__SetImagingSettings(soap, (const struct __timg__SetImagingSettings *)ptr);
		break;
	case SOAP_TYPE___timg__GetImagingSettings:
		soap_serialize___timg__GetImagingSettings(soap, (const struct __timg__GetImagingSettings *)ptr);
		break;
	case SOAP_TYPE___timg__GetServiceCapabilities:
		soap_serialize___timg__GetServiceCapabilities(soap, (const struct __timg__GetServiceCapabilities *)ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Envelope:
		soap_serialize_SOAP_ENV__Envelope(soap, (const struct SOAP_ENV__Envelope *)ptr);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		soap_serialize_chan__ChannelInstanceType(soap, (const struct chan__ChannelInstanceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		soap_serialize__wsa5__ProblemAction(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		soap_serialize__wsa5__FaultTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		soap_serialize__wsa5__From(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		soap_serialize__wsa5__ReplyTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		soap_serialize__wsa5__RelatesTo(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		soap_serialize__wsa5__Metadata(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		soap_serialize__wsa5__ReferenceParameters(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		soap_serialize__wsa5__EndpointReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		soap_serialize_wsa5__ProblemActionType(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		soap_serialize_wsa5__RelatesToType(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		soap_serialize_wsa5__MetadataType(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		soap_serialize_wsa5__ReferenceParametersType(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		soap_serialize_wsa5__EndpointReferenceType(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__xop__Include:
		soap_serialize__xop__Include(soap, (const struct _xop__Include *)ptr);
		break;
	case SOAP_TYPE_PointerTo_timg__SetCurrentPreset:
		soap_serialize_PointerTo_timg__SetCurrentPreset(soap, (_timg__SetCurrentPreset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_timg__GetCurrentPreset:
		soap_serialize_PointerTo_timg__GetCurrentPreset(soap, (_timg__GetCurrentPreset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_timg__GetPresets:
		soap_serialize_PointerTo_timg__GetPresets(soap, (_timg__GetPresets *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_timg__GetMoveOptions:
		soap_serialize_PointerTo_timg__GetMoveOptions(soap, (_timg__GetMoveOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_timg__GetStatus:
		soap_serialize_PointerTo_timg__GetStatus(soap, (_timg__GetStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_timg__Stop:
		soap_serialize_PointerTo_timg__Stop(soap, (_timg__Stop *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_timg__Move:
		soap_serialize_PointerTo_timg__Move(soap, (_timg__Move *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_timg__GetOptions:
		soap_serialize_PointerTo_timg__GetOptions(soap, (_timg__GetOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_timg__SetImagingSettings:
		soap_serialize_PointerTo_timg__SetImagingSettings(soap, (_timg__SetImagingSettings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_timg__GetImagingSettings:
		soap_serialize_PointerTo_timg__GetImagingSettings(soap, (_timg__GetImagingSettings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_timg__GetServiceCapabilities:
		soap_serialize_PointerTo_timg__GetServiceCapabilities(soap, (_timg__GetServiceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__NCName:
		soap_serialize_PointerToxsd__NCName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__ConcreteTopicExpression:
		soap_serialize_PointerTowstop__ConcreteTopicExpression(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__QName:
		soap_serialize_PointerToxsd__QName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__TopicType:
		soap_serialize_PointerTowstop__TopicType(soap, (wstop__TopicType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		soap_serialize_PointerTowstop__QueryExpressionType(soap, (wstop__QueryExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension:
		soap_serialize_PointerTott__PTZConfigurationExtension(soap, (tt__PTZConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ZoomLimits:
		soap_serialize_PointerTott__ZoomLimits(soap, (tt__ZoomLimits *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PanTiltLimits:
		soap_serialize_PointerTott__PanTiltLimits(soap, (tt__PanTiltLimits *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZSpeed:
		soap_serialize_PointerTott__PTZSpeed(soap, (tt__PTZSpeed *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MetadataConfigurationExtension:
		soap_serialize_PointerTott__MetadataConfigurationExtension(soap, (tt__MetadataConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__EventSubscription:
		soap_serialize_PointerTott__EventSubscription(soap, (tt__EventSubscription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZFilter:
		soap_serialize_PointerTott__PTZFilter(soap, (tt__PTZFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RuleEngineConfiguration:
		soap_serialize_PointerTott__RuleEngineConfiguration(soap, (tt__RuleEngineConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration:
		soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, (tt__AnalyticsEngineConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MulticastConfiguration:
		soap_serialize_PointerTott__MulticastConfiguration(soap, (tt__MulticastConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__H264Configuration:
		soap_serialize_PointerTott__H264Configuration(soap, (tt__H264Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Mpeg4Configuration:
		soap_serialize_PointerTott__Mpeg4Configuration(soap, (tt__Mpeg4Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoRateControl:
		soap_serialize_PointerTott__VideoRateControl(soap, (tt__VideoRateControl *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoResolution:
		soap_serialize_PointerTott__VideoResolution(soap, (tt__VideoResolution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension:
		soap_serialize_PointerTott__VideoSourceConfigurationExtension(soap, (tt__VideoSourceConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IntRectangle:
		soap_serialize_PointerTott__IntRectangle(soap, (tt__IntRectangle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__Documentation:
		soap_serialize_PointerTowstop__Documentation(soap, (wstop__Documentation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, (_wsrfbf__BaseFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_xml__lang:
		soap_serialize_PointerTo_xml__lang(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, (_wsrfbf__BaseFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		soap_serialize_PointerToxsd__nonNegativeInteger(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy:
		soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, (_wsnt__Subscribe_SubscriptionPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType:
		soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType:
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, (wsnt__NotificationMessageHolderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType:
		soap_serialize_PointerTowsnt__SubscriptionPolicyType(soap, (wsnt__SubscriptionPolicyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		soap_serialize_PointerTowstop__TopicSetType(soap, (wstop__TopicSetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__TopicExpressionType:
		soap_serialize_PointerTowsnt__TopicExpressionType(soap, (wsnt__TopicExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		soap_serialize_PointerTowsa5__EndpointReferenceType(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PropertyOperation:
		soap_serialize_PointerTott__PropertyOperation(soap, (enum tt__PropertyOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MessageExtension:
		soap_serialize_PointerTott__MessageExtension(soap, (tt__MessageExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ItemList:
		soap_serialize_PointerTott__ItemList(soap, (tt__ItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension:
		soap_serialize_PointerTott__RuleEngineConfigurationExtension(soap, (tt__RuleEngineConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension:
		soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(soap, (tt__AnalyticsEngineConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Config:
		soap_serialize_PointerTott__Config(soap, (tt__Config *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Vector:
		soap_serialize_PointerTott__Vector(soap, (tt__Vector *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ItemListExtension:
		soap_serialize_PointerTott__ItemListExtension(soap, (tt__ItemListExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusOptions20Extension:
		soap_serialize_PointerTott__FocusOptions20Extension(soap, (tt__FocusOptions20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension:
		soap_serialize_PointerTott__WhiteBalanceOptions20Extension(soap, (tt__WhiteBalanceOptions20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__StringAttrList:
		soap_serialize_PointerTott__StringAttrList(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusConfiguration20Extension:
		soap_serialize_PointerTott__FocusConfiguration20Extension(soap, (tt__FocusConfiguration20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WhiteBalance20Extension:
		soap_serialize_PointerTott__WhiteBalance20Extension(soap, (tt__WhiteBalance20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ContinuousFocusOptions:
		soap_serialize_PointerTott__ContinuousFocusOptions(soap, (tt__ContinuousFocusOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RelativeFocusOptions20:
		soap_serialize_PointerTott__RelativeFocusOptions20(soap, (tt__RelativeFocusOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AbsoluteFocusOptions:
		soap_serialize_PointerTott__AbsoluteFocusOptions(soap, (tt__AbsoluteFocusOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension:
		soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, (tt__IrCutFilterAutoAdjustmentOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DurationRange:
		soap_serialize_PointerTott__DurationRange(soap, (tt__DurationRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImageStabilizationOptionsExtension:
		soap_serialize_PointerTott__ImageStabilizationOptionsExtension(soap, (tt__ImageStabilizationOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension4:
		soap_serialize_PointerTott__ImagingOptions20Extension4(soap, (tt__ImagingOptions20Extension4 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NoiseReductionOptions:
		soap_serialize_PointerTott__NoiseReductionOptions(soap, (tt__NoiseReductionOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DefoggingOptions:
		soap_serialize_PointerTott__DefoggingOptions(soap, (tt__DefoggingOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ToneCompensationOptions:
		soap_serialize_PointerTott__ToneCompensationOptions(soap, (tt__ToneCompensationOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension3:
		soap_serialize_PointerTott__ImagingOptions20Extension3(soap, (tt__ImagingOptions20Extension3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptions:
		soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, (tt__IrCutFilterAutoAdjustmentOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension2:
		soap_serialize_PointerTott__ImagingOptions20Extension2(soap, (tt__ImagingOptions20Extension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImageStabilizationOptions:
		soap_serialize_PointerTott__ImageStabilizationOptions(soap, (tt__ImageStabilizationOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension:
		soap_serialize_PointerTott__ImagingOptions20Extension(soap, (tt__ImagingOptions20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions20:
		soap_serialize_PointerTott__WhiteBalanceOptions20(soap, (tt__WhiteBalanceOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WideDynamicRangeOptions20:
		soap_serialize_PointerTott__WideDynamicRangeOptions20(soap, (tt__WideDynamicRangeOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusOptions20:
		soap_serialize_PointerTott__FocusOptions20(soap, (tt__FocusOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ExposureOptions20:
		soap_serialize_PointerTott__ExposureOptions20(soap, (tt__ExposureOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__BacklightCompensationOptions20:
		soap_serialize_PointerTott__BacklightCompensationOptions20(soap, (tt__BacklightCompensationOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DefoggingExtension:
		soap_serialize_PointerTott__DefoggingExtension(soap, (tt__DefoggingExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ToneCompensationExtension:
		soap_serialize_PointerTott__ToneCompensationExtension(soap, (tt__ToneCompensationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Rectangle:
		soap_serialize_PointerTott__Rectangle(soap, (tt__Rectangle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ExposurePriority:
		soap_serialize_PointerTott__ExposurePriority(soap, (enum tt__ExposurePriority *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentExtension:
		soap_serialize_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, (tt__IrCutFilterAutoAdjustmentExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__duration:
		soap_serialize_PointerToxsd__duration(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImageStabilizationExtension:
		soap_serialize_PointerTott__ImageStabilizationExtension(soap, (tt__ImageStabilizationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension204:
		soap_serialize_PointerTott__ImagingSettingsExtension204(soap, (tt__ImagingSettingsExtension204 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NoiseReduction:
		soap_serialize_PointerTott__NoiseReduction(soap, (tt__NoiseReduction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Defogging:
		soap_serialize_PointerTott__Defogging(soap, (tt__Defogging *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ToneCompensation:
		soap_serialize_PointerTott__ToneCompensation(soap, (tt__ToneCompensation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension203:
		soap_serialize_PointerTott__ImagingSettingsExtension203(soap, (tt__ImagingSettingsExtension203 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustment:
		soap_serialize_PointerTott__IrCutFilterAutoAdjustment(soap, (tt__IrCutFilterAutoAdjustment *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension202:
		soap_serialize_PointerTott__ImagingSettingsExtension202(soap, (tt__ImagingSettingsExtension202 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImageStabilization:
		soap_serialize_PointerTott__ImageStabilization(soap, (tt__ImageStabilization *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension20:
		soap_serialize_PointerTott__ImagingSettingsExtension20(soap, (tt__ImagingSettingsExtension20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WhiteBalance20:
		soap_serialize_PointerTott__WhiteBalance20(soap, (tt__WhiteBalance20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WideDynamicRange20:
		soap_serialize_PointerTott__WideDynamicRange20(soap, (tt__WideDynamicRange20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IrCutFilterMode:
		soap_serialize_PointerTott__IrCutFilterMode(soap, (enum tt__IrCutFilterMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusConfiguration20:
		soap_serialize_PointerTott__FocusConfiguration20(soap, (tt__FocusConfiguration20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Exposure20:
		soap_serialize_PointerTott__Exposure20(soap, (tt__Exposure20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__BacklightCompensation20:
		soap_serialize_PointerTott__BacklightCompensation20(soap, (tt__BacklightCompensation20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusStatus20Extension:
		soap_serialize_PointerTott__FocusStatus20Extension(soap, (tt__FocusStatus20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingStatus20Extension:
		soap_serialize_PointerTott__ImagingStatus20Extension(soap, (tt__ImagingStatus20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusStatus20:
		soap_serialize_PointerTott__FocusStatus20(soap, (tt__FocusStatus20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ContinuousFocus:
		soap_serialize_PointerTott__ContinuousFocus(soap, (tt__ContinuousFocus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RelativeFocus:
		soap_serialize_PointerTott__RelativeFocus(soap, (tt__RelativeFocus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AbsoluteFocus:
		soap_serialize_PointerTott__AbsoluteFocus(soap, (tt__AbsoluteFocus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Vector1D:
		soap_serialize_PointerTott__Vector1D(soap, (tt__Vector1D *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Vector2D:
		soap_serialize_PointerTott__Vector2D(soap, (tt__Vector2D *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FloatRange:
		soap_serialize_PointerTott__FloatRange(soap, (tt__FloatRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Space1DDescription:
		soap_serialize_PointerTott__Space1DDescription(soap, (tt__Space1DDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Space2DDescription:
		soap_serialize_PointerTott__Space2DDescription(soap, (tt__Space2DDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTControlDirectionExtension:
		soap_serialize_PointerTott__PTControlDirectionExtension(soap, (tt__PTControlDirectionExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Reverse:
		soap_serialize_PointerTott__Reverse(soap, (tt__Reverse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__EFlip:
		soap_serialize_PointerTott__EFlip(soap, (tt__EFlip *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension2:
		soap_serialize_PointerTott__PTZConfigurationExtension2(soap, (tt__PTZConfigurationExtension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTControlDirection:
		soap_serialize_PointerTott__PTControlDirection(soap, (tt__PTControlDirection *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv6Address:
		soap_serialize_PointerTott__IPv6Address(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv4Address:
		soap_serialize_PointerTott__IPv4Address(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPAddress:
		soap_serialize_PointerTott__IPAddress(soap, (tt__IPAddress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy:
		soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, (_tt__EventSubscription_SubscriptionPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__FilterType:
		soap_serialize_PointerTowsnt__FilterType(soap, (wsnt__FilterType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__LensProjection:
		soap_serialize_PointerTott__LensProjection(soap, (tt__LensProjection *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__LensOffset:
		soap_serialize_PointerTott__LensOffset(soap, (tt__LensOffset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofloat:
		soap_serialize_PointerTofloat(soap, (float *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RotateExtension:
		soap_serialize_PointerTott__RotateExtension(soap, (tt__RotateExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SceneOrientation:
		soap_serialize_PointerTott__SceneOrientation(soap, (tt__SceneOrientation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__LensDescription:
		soap_serialize_PointerTott__LensDescription(soap, (tt__LensDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension2:
		soap_serialize_PointerTott__VideoSourceConfigurationExtension2(soap, (tt__VideoSourceConfigurationExtension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Rotate:
		soap_serialize_PointerTott__Rotate(soap, (tt__Rotate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IntRange:
		soap_serialize_PointerTott__IntRange(soap, (tt__IntRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotimg__ImagingPreset:
		soap_serialize_PointerTotimg__ImagingPreset(soap, (timg__ImagingPreset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingStatus20:
		soap_serialize_PointerTott__ImagingStatus20(soap, (tt__ImagingStatus20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MoveOptions20:
		soap_serialize_PointerTott__MoveOptions20(soap, (tt__MoveOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusMove:
		soap_serialize_PointerTott__FocusMove(soap, (tt__FocusMove *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingOptions20:
		soap_serialize_PointerTott__ImagingOptions20(soap, (tt__ImagingOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingSettings20:
		soap_serialize_PointerTott__ImagingSettings20(soap, (tt__ImagingSettings20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotimg__Capabilities:
		soap_serialize_PointerTotimg__Capabilities(soap, (timg__Capabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		soap_serialize_PointerTochan__ChannelInstanceType(soap, (struct chan__ChannelInstanceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		soap_serialize_PointerTo_wsa5__FaultTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		soap_serialize_PointerTo_wsa5__ReplyTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__From:
		soap_serialize_PointerTo_wsa5__From(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		soap_serialize_PointerTo_wsa5__RelatesTo(soap, (struct wsa5__RelatesToType *const*)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemIRI:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__Action:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__To:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__MessageID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		soap_serialize_PointerTowsa5__MetadataType(soap, (struct wsa5__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		soap_serialize_PointerTowsa5__ReferenceParametersType(soap, (struct wsa5__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 imageing_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE__xop__Include:
		return (void*)imageing_instantiate__xop__Include(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return (void*)imageing_instantiate_wsa5__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return (void*)imageing_instantiate_wsa5__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__MetadataType:
		return (void*)imageing_instantiate_wsa5__MetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ProblemActionType:
		return (void*)imageing_instantiate_wsa5__ProblemActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__RelatesToType:
		return (void*)imageing_instantiate_wsa5__RelatesToType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_chan__ChannelInstanceType:
		return (void*)imageing_instantiate_chan__ChannelInstanceType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)imageing_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)imageing_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)imageing_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)imageing_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)imageing_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__anyType:
		return (void*)imageing_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Envelope:
		return (void*)imageing_instantiate_SOAP_ENV__Envelope(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)imageing_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)imageing_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__hexBinary:
		return (void*)imageing_instantiate_xsd__hexBinary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__EndpointReferenceType__:
		return (void*)imageing_instantiate_wsa5__EndpointReferenceType__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Envelope_:
		return (void*)imageing_instantiate_SOAP_ENV__Envelope_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Fault_:
		return (void*)imageing_instantiate_SOAP_ENV__Fault_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NCName__:
		return (void*)imageing_instantiate_xsd__NCName__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName__:
		return (void*)imageing_instantiate_xsd__QName__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anySimpleType__:
		return (void*)imageing_instantiate_xsd__anySimpleType__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI__:
		return (void*)imageing_instantiate_xsd__anyURI__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary__:
		return (void*)imageing_instantiate_xsd__base64Binary__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean_:
		return (void*)imageing_instantiate_xsd__boolean_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime_:
		return (void*)imageing_instantiate_xsd__dateTime_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__double_:
		return (void*)imageing_instantiate_xsd__double_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration__:
		return (void*)imageing_instantiate_xsd__duration__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__float_:
		return (void*)imageing_instantiate_xsd__float_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__hexBinary__:
		return (void*)imageing_instantiate_xsd__hexBinary__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int_:
		return (void*)imageing_instantiate_xsd__int_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer__:
		return (void*)imageing_instantiate_xsd__integer__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger__:
		return (void*)imageing_instantiate_xsd__nonNegativeInteger__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string_:
		return (void*)imageing_instantiate_xsd__string_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__token__:
		return (void*)imageing_instantiate_xsd__token__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Name__:
		return (void*)imageing_instantiate_tt__Name__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RotateMode_:
		return (void*)imageing_instantiate_tt__RotateMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SceneOrientationMode_:
		return (void*)imageing_instantiate_tt__SceneOrientationMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoEncoding_:
		return (void*)imageing_instantiate_tt__VideoEncoding_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Mpeg4Profile_:
		return (void*)imageing_instantiate_tt__Mpeg4Profile_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__H264Profile_:
		return (void*)imageing_instantiate_tt__H264Profile_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AudioEncoding_:
		return (void*)imageing_instantiate_tt__AudioEncoding_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv4Address__:
		return (void*)imageing_instantiate_tt__IPv4Address__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv6Address__:
		return (void*)imageing_instantiate_tt__IPv6Address__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPType_:
		return (void*)imageing_instantiate_tt__IPType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__EFlipMode_:
		return (void*)imageing_instantiate_tt__EFlipMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ReverseMode_:
		return (void*)imageing_instantiate_tt__ReverseMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AutoFocusMode_:
		return (void*)imageing_instantiate_tt__AutoFocusMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WideDynamicMode_:
		return (void*)imageing_instantiate_tt__WideDynamicMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__BacklightCompensationMode_:
		return (void*)imageing_instantiate_tt__BacklightCompensationMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ExposurePriority_:
		return (void*)imageing_instantiate_tt__ExposurePriority_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ExposureMode_:
		return (void*)imageing_instantiate_tt__ExposureMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WhiteBalanceMode_:
		return (void*)imageing_instantiate_tt__WhiteBalanceMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IrCutFilterMode_:
		return (void*)imageing_instantiate_tt__IrCutFilterMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImageStabilizationMode_:
		return (void*)imageing_instantiate_tt__ImageStabilizationMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PropertyOperation_:
		return (void*)imageing_instantiate_tt__PropertyOperation_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ReferenceToken__:
		return (void*)imageing_instantiate_tt__ReferenceToken__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MoveStatus_:
		return (void*)imageing_instantiate_tt__MoveStatus_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__ConcreteTopicExpression__:
		return (void*)imageing_instantiate_wstop__ConcreteTopicExpression__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_timg__Capabilities:
		return (void*)imageing_instantiate_timg__Capabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_timg__ImagingPreset:
		return (void*)imageing_instantiate_timg__ImagingPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetServiceCapabilities:
		return (void*)imageing_instantiate__timg__GetServiceCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetServiceCapabilitiesResponse:
		return (void*)imageing_instantiate__timg__GetServiceCapabilitiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetImagingSettings:
		return (void*)imageing_instantiate__timg__GetImagingSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetImagingSettingsResponse:
		return (void*)imageing_instantiate__timg__GetImagingSettingsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__SetImagingSettings:
		return (void*)imageing_instantiate__timg__SetImagingSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__SetImagingSettingsResponse:
		return (void*)imageing_instantiate__timg__SetImagingSettingsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetOptions:
		return (void*)imageing_instantiate__timg__GetOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetOptionsResponse:
		return (void*)imageing_instantiate__timg__GetOptionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__Move:
		return (void*)imageing_instantiate__timg__Move(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__MoveResponse:
		return (void*)imageing_instantiate__timg__MoveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetMoveOptions:
		return (void*)imageing_instantiate__timg__GetMoveOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetMoveOptionsResponse:
		return (void*)imageing_instantiate__timg__GetMoveOptionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__Stop:
		return (void*)imageing_instantiate__timg__Stop(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__StopResponse:
		return (void*)imageing_instantiate__timg__StopResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetStatus:
		return (void*)imageing_instantiate__timg__GetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetStatusResponse:
		return (void*)imageing_instantiate__timg__GetStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetPresets:
		return (void*)imageing_instantiate__timg__GetPresets(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetPresetsResponse:
		return (void*)imageing_instantiate__timg__GetPresetsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetCurrentPreset:
		return (void*)imageing_instantiate__timg__GetCurrentPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__GetCurrentPresetResponse:
		return (void*)imageing_instantiate__timg__GetCurrentPresetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__SetCurrentPreset:
		return (void*)imageing_instantiate__timg__SetCurrentPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__timg__SetCurrentPresetResponse:
		return (void*)imageing_instantiate__timg__SetCurrentPresetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IntRectangle:
		return (void*)imageing_instantiate_tt__IntRectangle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IntRectangleRange:
		return (void*)imageing_instantiate_tt__IntRectangleRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FloatRange:
		return (void*)imageing_instantiate_tt__FloatRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DurationRange:
		return (void*)imageing_instantiate_tt__DurationRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ConfigurationEntity:
		return (void*)imageing_instantiate_tt__ConfigurationEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoSourceConfigurationExtension:
		return (void*)imageing_instantiate_tt__VideoSourceConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoSourceConfigurationExtension2:
		return (void*)imageing_instantiate_tt__VideoSourceConfigurationExtension2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Rotate:
		return (void*)imageing_instantiate_tt__Rotate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RotateExtension:
		return (void*)imageing_instantiate_tt__RotateExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__LensProjection:
		return (void*)imageing_instantiate_tt__LensProjection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__LensOffset:
		return (void*)imageing_instantiate_tt__LensOffset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__LensDescription:
		return (void*)imageing_instantiate_tt__LensDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SceneOrientation:
		return (void*)imageing_instantiate_tt__SceneOrientation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoResolution:
		return (void*)imageing_instantiate_tt__VideoResolution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoRateControl:
		return (void*)imageing_instantiate_tt__VideoRateControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Mpeg4Configuration:
		return (void*)imageing_instantiate_tt__Mpeg4Configuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__H264Configuration:
		return (void*)imageing_instantiate_tt__H264Configuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MetadataConfigurationExtension:
		return (void*)imageing_instantiate_tt__MetadataConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZFilter:
		return (void*)imageing_instantiate_tt__PTZFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy:
		return (void*)imageing_instantiate__tt__EventSubscription_SubscriptionPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__EventSubscription:
		return (void*)imageing_instantiate_tt__EventSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MulticastConfiguration:
		return (void*)imageing_instantiate_tt__MulticastConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPAddress:
		return (void*)imageing_instantiate_tt__IPAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		return (void*)imageing_instantiate_tt__PTZConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZConfigurationExtension2:
		return (void*)imageing_instantiate_tt__PTZConfigurationExtension2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTControlDirection:
		return (void*)imageing_instantiate_tt__PTControlDirection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTControlDirectionExtension:
		return (void*)imageing_instantiate_tt__PTControlDirectionExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__EFlip:
		return (void*)imageing_instantiate_tt__EFlip(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Reverse:
		return (void*)imageing_instantiate_tt__Reverse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PanTiltLimits:
		return (void*)imageing_instantiate_tt__PanTiltLimits(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ZoomLimits:
		return (void*)imageing_instantiate_tt__ZoomLimits(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Space2DDescription:
		return (void*)imageing_instantiate_tt__Space2DDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Space1DDescription:
		return (void*)imageing_instantiate_tt__Space1DDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZSpeed:
		return (void*)imageing_instantiate_tt__PTZSpeed(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusMove:
		return (void*)imageing_instantiate_tt__FocusMove(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AbsoluteFocus:
		return (void*)imageing_instantiate_tt__AbsoluteFocus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RelativeFocus:
		return (void*)imageing_instantiate_tt__RelativeFocus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ContinuousFocus:
		return (void*)imageing_instantiate_tt__ContinuousFocus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AbsoluteFocusOptions:
		return (void*)imageing_instantiate_tt__AbsoluteFocusOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ContinuousFocusOptions:
		return (void*)imageing_instantiate_tt__ContinuousFocusOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingStatus20:
		return (void*)imageing_instantiate_tt__ImagingStatus20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingStatus20Extension:
		return (void*)imageing_instantiate_tt__ImagingStatus20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusStatus20:
		return (void*)imageing_instantiate_tt__FocusStatus20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusStatus20Extension:
		return (void*)imageing_instantiate_tt__FocusStatus20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingSettings20:
		return (void*)imageing_instantiate_tt__ImagingSettings20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingSettingsExtension20:
		return (void*)imageing_instantiate_tt__ImagingSettingsExtension20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingSettingsExtension202:
		return (void*)imageing_instantiate_tt__ImagingSettingsExtension202(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingSettingsExtension203:
		return (void*)imageing_instantiate_tt__ImagingSettingsExtension203(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingSettingsExtension204:
		return (void*)imageing_instantiate_tt__ImagingSettingsExtension204(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImageStabilization:
		return (void*)imageing_instantiate_tt__ImageStabilization(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImageStabilizationExtension:
		return (void*)imageing_instantiate_tt__ImageStabilizationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustment:
		return (void*)imageing_instantiate_tt__IrCutFilterAutoAdjustment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension:
		return (void*)imageing_instantiate_tt__IrCutFilterAutoAdjustmentExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WideDynamicRange20:
		return (void*)imageing_instantiate_tt__WideDynamicRange20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__BacklightCompensation20:
		return (void*)imageing_instantiate_tt__BacklightCompensation20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Exposure20:
		return (void*)imageing_instantiate_tt__Exposure20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ToneCompensation:
		return (void*)imageing_instantiate_tt__ToneCompensation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ToneCompensationExtension:
		return (void*)imageing_instantiate_tt__ToneCompensationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Defogging:
		return (void*)imageing_instantiate_tt__Defogging(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DefoggingExtension:
		return (void*)imageing_instantiate_tt__DefoggingExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NoiseReduction:
		return (void*)imageing_instantiate_tt__NoiseReduction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingOptions20:
		return (void*)imageing_instantiate_tt__ImagingOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingOptions20Extension:
		return (void*)imageing_instantiate_tt__ImagingOptions20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingOptions20Extension2:
		return (void*)imageing_instantiate_tt__ImagingOptions20Extension2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingOptions20Extension3:
		return (void*)imageing_instantiate_tt__ImagingOptions20Extension3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingOptions20Extension4:
		return (void*)imageing_instantiate_tt__ImagingOptions20Extension4(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImageStabilizationOptions:
		return (void*)imageing_instantiate_tt__ImageStabilizationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImageStabilizationOptionsExtension:
		return (void*)imageing_instantiate_tt__ImageStabilizationOptionsExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions:
		return (void*)imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension:
		return (void*)imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WideDynamicRangeOptions20:
		return (void*)imageing_instantiate_tt__WideDynamicRangeOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__BacklightCompensationOptions20:
		return (void*)imageing_instantiate_tt__BacklightCompensationOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ExposureOptions20:
		return (void*)imageing_instantiate_tt__ExposureOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MoveOptions20:
		return (void*)imageing_instantiate_tt__MoveOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RelativeFocusOptions20:
		return (void*)imageing_instantiate_tt__RelativeFocusOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WhiteBalance20:
		return (void*)imageing_instantiate_tt__WhiteBalance20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WhiteBalance20Extension:
		return (void*)imageing_instantiate_tt__WhiteBalance20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusConfiguration20:
		return (void*)imageing_instantiate_tt__FocusConfiguration20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusConfiguration20Extension:
		return (void*)imageing_instantiate_tt__FocusConfiguration20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WhiteBalanceOptions20:
		return (void*)imageing_instantiate_tt__WhiteBalanceOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WhiteBalanceOptions20Extension:
		return (void*)imageing_instantiate_tt__WhiteBalanceOptions20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusOptions20:
		return (void*)imageing_instantiate_tt__FocusOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusOptions20Extension:
		return (void*)imageing_instantiate_tt__FocusOptions20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ToneCompensationOptions:
		return (void*)imageing_instantiate_tt__ToneCompensationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DefoggingOptions:
		return (void*)imageing_instantiate_tt__DefoggingOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NoiseReductionOptions:
		return (void*)imageing_instantiate_tt__NoiseReductionOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MessageExtension:
		return (void*)imageing_instantiate_tt__MessageExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__ItemList_SimpleItem:
		return (void*)imageing_instantiate__tt__ItemList_SimpleItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__ItemList_ElementItem:
		return (void*)imageing_instantiate__tt__ItemList_ElementItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ItemList:
		return (void*)imageing_instantiate_tt__ItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ItemListExtension:
		return (void*)imageing_instantiate_tt__ItemListExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Polyline:
		return (void*)imageing_instantiate_tt__Polyline(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AnalyticsEngineConfiguration:
		return (void*)imageing_instantiate_tt__AnalyticsEngineConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension:
		return (void*)imageing_instantiate_tt__AnalyticsEngineConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RuleEngineConfiguration:
		return (void*)imageing_instantiate_tt__RuleEngineConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RuleEngineConfigurationExtension:
		return (void*)imageing_instantiate_tt__RuleEngineConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Config:
		return (void*)imageing_instantiate_tt__Config(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PolygonOptions:
		return (void*)imageing_instantiate_tt__PolygonOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IntRange:
		return (void*)imageing_instantiate_tt__IntRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Vector2D:
		return (void*)imageing_instantiate_tt__Vector2D(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Vector1D:
		return (void*)imageing_instantiate_tt__Vector1D(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Vector:
		return (void*)imageing_instantiate_tt__Vector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Rectangle:
		return (void*)imageing_instantiate_tt__Rectangle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Polygon:
		return (void*)imageing_instantiate_tt__Polygon(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__StringItems:
		return (void*)imageing_instantiate__tt__StringItems(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__Message:
		return (void*)imageing_instantiate__tt__Message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__QueryExpressionType:
		return (void*)imageing_instantiate_wsnt__QueryExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__TopicExpressionType:
		return (void*)imageing_instantiate_wsnt__TopicExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__FilterType:
		return (void*)imageing_instantiate_wsnt__FilterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		return (void*)imageing_instantiate_wsnt__SubscriptionPolicyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		return (void*)imageing_instantiate__wsnt__NotificationMessageHolderType_Message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		return (void*)imageing_instantiate_wsnt__NotificationMessageHolderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		return (void*)imageing_instantiate__wsnt__NotificationProducerRP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		return (void*)imageing_instantiate__wsnt__SubscriptionManagerRP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__Notify:
		return (void*)imageing_instantiate__wsnt__Notify(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__UseRaw:
		return (void*)imageing_instantiate__wsnt__UseRaw(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		return (void*)imageing_instantiate__wsnt__Subscribe_SubscriptionPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__Subscribe:
		return (void*)imageing_instantiate__wsnt__Subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__SubscribeResponse:
		return (void*)imageing_instantiate__wsnt__SubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		return (void*)imageing_instantiate__wsnt__GetCurrentMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		return (void*)imageing_instantiate__wsnt__GetCurrentMessageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__GetMessages:
		return (void*)imageing_instantiate__wsnt__GetMessages(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		return (void*)imageing_instantiate__wsnt__GetMessagesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		return (void*)imageing_instantiate__wsnt__DestroyPullPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		return (void*)imageing_instantiate__wsnt__DestroyPullPointResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__CreatePullPoint:
		return (void*)imageing_instantiate__wsnt__CreatePullPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		return (void*)imageing_instantiate__wsnt__CreatePullPointResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__Renew:
		return (void*)imageing_instantiate__wsnt__Renew(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__RenewResponse:
		return (void*)imageing_instantiate__wsnt__RenewResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__Unsubscribe:
		return (void*)imageing_instantiate__wsnt__Unsubscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		return (void*)imageing_instantiate__wsnt__UnsubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__PauseSubscription:
		return (void*)imageing_instantiate__wsnt__PauseSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		return (void*)imageing_instantiate__wsnt__PauseSubscriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__ResumeSubscription:
		return (void*)imageing_instantiate__wsnt__ResumeSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		return (void*)imageing_instantiate__wsnt__ResumeSubscriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		return (void*)imageing_instantiate__wsrfbf__BaseFaultType_ErrorCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		return (void*)imageing_instantiate__wsrfbf__BaseFaultType_Description(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		return (void*)imageing_instantiate__wsrfbf__BaseFaultType_FaultCause(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		return (void*)imageing_instantiate_wsrfbf__BaseFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__Documentation:
		return (void*)imageing_instantiate_wstop__Documentation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		return (void*)imageing_instantiate_wstop__ExtensibleDocumented(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__QueryExpressionType:
		return (void*)imageing_instantiate_wstop__QueryExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoSourceConfiguration:
		return (void*)imageing_instantiate_tt__VideoSourceConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		return (void*)imageing_instantiate_tt__VideoEncoderConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AudioSourceConfiguration:
		return (void*)imageing_instantiate_tt__AudioSourceConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AudioEncoderConfiguration:
		return (void*)imageing_instantiate_tt__AudioEncoderConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoAnalyticsConfiguration:
		return (void*)imageing_instantiate_tt__VideoAnalyticsConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MetadataConfiguration:
		return (void*)imageing_instantiate_tt__MetadataConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AudioOutputConfiguration:
		return (void*)imageing_instantiate_tt__AudioOutputConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AudioDecoderConfiguration:
		return (void*)imageing_instantiate_tt__AudioDecoderConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZConfiguration:
		return (void*)imageing_instantiate_tt__PTZConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		return (void*)imageing_instantiate_wsnt__SubscribeCreationFailedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		return (void*)imageing_instantiate_wsnt__InvalidFilterFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		return (void*)imageing_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		return (void*)imageing_instantiate_wsnt__InvalidTopicExpressionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		return (void*)imageing_instantiate_wsnt__TopicNotSupportedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		return (void*)imageing_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		return (void*)imageing_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		return (void*)imageing_instantiate_wsnt__InvalidMessageContentExpressionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		return (void*)imageing_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		return (void*)imageing_instantiate_wsnt__UnsupportedPolicyRequestFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		return (void*)imageing_instantiate_wsnt__NotifyMessageNotSupportedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		return (void*)imageing_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		return (void*)imageing_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		return (void*)imageing_instantiate_wsnt__UnableToGetMessagesFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		return (void*)imageing_instantiate_wsnt__UnableToDestroyPullPointFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		return (void*)imageing_instantiate_wsnt__UnableToCreatePullPointFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		return (void*)imageing_instantiate_wsnt__UnacceptableTerminationTimeFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		return (void*)imageing_instantiate_wsnt__UnableToDestroySubscriptionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		return (void*)imageing_instantiate_wsnt__PauseFailedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		return (void*)imageing_instantiate_wsnt__ResumeFailedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		return (void*)imageing_instantiate__wstop__TopicNamespaceType_Topic(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__TopicNamespaceType:
		return (void*)imageing_instantiate_wstop__TopicNamespaceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__TopicType:
		return (void*)imageing_instantiate_wstop__TopicType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__TopicSetType:
		return (void*)imageing_instantiate_wstop__TopicSetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___timg__GetServiceCapabilities:
		return (void*)imageing_instantiate___timg__GetServiceCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE___timg__GetImagingSettings:
		return (void*)imageing_instantiate___timg__GetImagingSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE___timg__SetImagingSettings:
		return (void*)imageing_instantiate___timg__SetImagingSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE___timg__GetOptions:
		return (void*)imageing_instantiate___timg__GetOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE___timg__Move:
		return (void*)imageing_instantiate___timg__Move(soap, -1, type, arrayType, n);
	case SOAP_TYPE___timg__Stop:
		return (void*)imageing_instantiate___timg__Stop(soap, -1, type, arrayType, n);
	case SOAP_TYPE___timg__GetStatus:
		return (void*)imageing_instantiate___timg__GetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___timg__GetMoveOptions:
		return (void*)imageing_instantiate___timg__GetMoveOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE___timg__GetPresets:
		return (void*)imageing_instantiate___timg__GetPresets(soap, -1, type, arrayType, n);
	case SOAP_TYPE___timg__GetCurrentPreset:
		return (void*)imageing_instantiate___timg__GetCurrentPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___timg__SetCurrentPreset:
		return (void*)imageing_instantiate___timg__SetCurrentPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__EndpointReference:
		return (void*)imageing_instantiate__wsa5__EndpointReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return (void*)imageing_instantiate__wsa5__ReferenceParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__Metadata:
		return (void*)imageing_instantiate__wsa5__Metadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__RelatesTo:
		return (void*)imageing_instantiate__wsa5__RelatesTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReplyTo:
		return (void*)imageing_instantiate__wsa5__ReplyTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__From:
		return (void*)imageing_instantiate__wsa5__From(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__FaultTo:
		return (void*)imageing_instantiate__wsa5__FaultTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ProblemAction:
		return (void*)imageing_instantiate__wsa5__ProblemAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName:
		return (void*)imageing_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NCName:
		return (void*)imageing_instantiate_xsd__NCName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anySimpleType:
		return (void*)imageing_instantiate_xsd__anySimpleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)imageing_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration:
		return (void*)imageing_instantiate_xsd__duration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer:
		return (void*)imageing_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)imageing_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__token:
		return (void*)imageing_instantiate_xsd__token(soap, -1, type, arrayType, n);
	case SOAP_TYPE__xml__lang:
		return (void*)imageing_instantiate__xml__lang(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IntList:
		return (void*)imageing_instantiate_tt__IntList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FloatList:
		return (void*)imageing_instantiate_tt__FloatList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__StringAttrList:
		return (void*)imageing_instantiate_tt__StringAttrList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__StringList:
		return (void*)imageing_instantiate_tt__StringList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		return (void*)imageing_instantiate_wsnt__AbsoluteOrRelativeTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Name:
		return (void*)imageing_instantiate_tt__Name(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv4Address:
		return (void*)imageing_instantiate_tt__IPv4Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv6Address:
		return (void*)imageing_instantiate_tt__IPv6Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ReferenceToken:
		return (void*)imageing_instantiate_tt__ReferenceToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		return (void*)imageing_instantiate_wstop__ConcreteTopicExpression(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic:
		return (void*)imageing_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType:
		return (void*)imageing_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		return (void*)imageing_instantiate_std__vectorTemplateOfxsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description:
		return (void*)imageing_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType:
		return (void*)imageing_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		return (void*)imageing_instantiate_std__vectorTemplateOfxsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType:
		return (void*)imageing_instantiate_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Config:
		return (void*)imageing_instantiate_std__vectorTemplateOfPointerTott__Config(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector:
		return (void*)imageing_instantiate_std__vectorTemplateOfPointerTott__Vector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem:
		return (void*)imageing_instantiate_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem:
		return (void*)imageing_instantiate_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode:
		return (void*)imageing_instantiate_std__vectorTemplateOftt__AutoFocusMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode:
		return (void*)imageing_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority:
		return (void*)imageing_instantiate_std__vectorTemplateOftt__ExposurePriority(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__ExposureMode:
		return (void*)imageing_instantiate_std__vectorTemplateOftt__ExposureMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode:
		return (void*)imageing_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode:
		return (void*)imageing_instantiate_std__vectorTemplateOftt__WideDynamicMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)imageing_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode:
		return (void*)imageing_instantiate_std__vectorTemplateOftt__ImageStabilizationMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode:
		return (void*)imageing_instantiate_std__vectorTemplateOftt__IrCutFilterMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment:
		return (void*)imageing_instantiate_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection:
		return (void*)imageing_instantiate_std__vectorTemplateOfPointerTott__LensProjection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription:
		return (void*)imageing_instantiate_std__vectorTemplateOfPointerTott__LensDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset:
		return (void*)imageing_instantiate_std__vectorTemplateOfPointerTotimg__ImagingPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)imageing_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 imageing_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE__xop__Include:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _xop__Include*>(p->ptr), struct _xop__Include);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _xop__Include*>(p->ptr), struct _xop__Include);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct chan__ChannelInstanceType*>(p->ptr), struct chan__ChannelInstanceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct chan__ChannelInstanceType*>(p->ptr), struct chan__ChannelInstanceType);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__anyType*>(p->ptr), xsd__anyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__anyType*>(p->ptr), xsd__anyType);
		break;
	case SOAP_TYPE_SOAP_ENV__Envelope:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Envelope*>(p->ptr), struct SOAP_ENV__Envelope);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Envelope*>(p->ptr), struct SOAP_ENV__Envelope);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__hexBinary*>(p->ptr), xsd__hexBinary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__hexBinary*>(p->ptr), xsd__hexBinary);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsa5__EndpointReferenceType__*>(p->ptr), wsa5__EndpointReferenceType__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsa5__EndpointReferenceType__*>(p->ptr), wsa5__EndpointReferenceType__);
		break;
	case SOAP_TYPE_SOAP_ENV__Envelope_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<SOAP_ENV__Envelope_*>(p->ptr), SOAP_ENV__Envelope_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<SOAP_ENV__Envelope_*>(p->ptr), SOAP_ENV__Envelope_);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<SOAP_ENV__Fault_*>(p->ptr), SOAP_ENV__Fault_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<SOAP_ENV__Fault_*>(p->ptr), SOAP_ENV__Fault_);
		break;
	case SOAP_TYPE_xsd__NCName__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__NCName__*>(p->ptr), xsd__NCName__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__NCName__*>(p->ptr), xsd__NCName__);
		break;
	case SOAP_TYPE_xsd__QName__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__QName__*>(p->ptr), xsd__QName__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__QName__*>(p->ptr), xsd__QName__);
		break;
	case SOAP_TYPE_xsd__anySimpleType__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__anySimpleType__*>(p->ptr), xsd__anySimpleType__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__anySimpleType__*>(p->ptr), xsd__anySimpleType__);
		break;
	case SOAP_TYPE_xsd__anyURI__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__anyURI__*>(p->ptr), xsd__anyURI__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__anyURI__*>(p->ptr), xsd__anyURI__);
		break;
	case SOAP_TYPE_xsd__base64Binary__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__base64Binary__*>(p->ptr), xsd__base64Binary__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__base64Binary__*>(p->ptr), xsd__base64Binary__);
		break;
	case SOAP_TYPE_xsd__boolean_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__boolean_*>(p->ptr), xsd__boolean_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__boolean_*>(p->ptr), xsd__boolean_);
		break;
	case SOAP_TYPE_xsd__dateTime_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__dateTime_*>(p->ptr), xsd__dateTime_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__dateTime_*>(p->ptr), xsd__dateTime_);
		break;
	case SOAP_TYPE_xsd__double_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__double_*>(p->ptr), xsd__double_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__double_*>(p->ptr), xsd__double_);
		break;
	case SOAP_TYPE_xsd__duration__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__duration__*>(p->ptr), xsd__duration__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__duration__*>(p->ptr), xsd__duration__);
		break;
	case SOAP_TYPE_xsd__float_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__float_*>(p->ptr), xsd__float_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__float_*>(p->ptr), xsd__float_);
		break;
	case SOAP_TYPE_xsd__hexBinary__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__hexBinary__*>(p->ptr), xsd__hexBinary__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__hexBinary__*>(p->ptr), xsd__hexBinary__);
		break;
	case SOAP_TYPE_xsd__int_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__int_*>(p->ptr), xsd__int_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__int_*>(p->ptr), xsd__int_);
		break;
	case SOAP_TYPE_xsd__integer__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__integer__*>(p->ptr), xsd__integer__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__integer__*>(p->ptr), xsd__integer__);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__nonNegativeInteger__*>(p->ptr), xsd__nonNegativeInteger__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__nonNegativeInteger__*>(p->ptr), xsd__nonNegativeInteger__);
		break;
	case SOAP_TYPE_xsd__string_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__string_*>(p->ptr), xsd__string_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__string_*>(p->ptr), xsd__string_);
		break;
	case SOAP_TYPE_xsd__token__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__token__*>(p->ptr), xsd__token__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__token__*>(p->ptr), xsd__token__);
		break;
	case SOAP_TYPE_tt__Name__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Name__*>(p->ptr), tt__Name__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Name__*>(p->ptr), tt__Name__);
		break;
	case SOAP_TYPE_tt__RotateMode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__RotateMode_*>(p->ptr), tt__RotateMode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__RotateMode_*>(p->ptr), tt__RotateMode_);
		break;
	case SOAP_TYPE_tt__SceneOrientationMode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SceneOrientationMode_*>(p->ptr), tt__SceneOrientationMode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SceneOrientationMode_*>(p->ptr), tt__SceneOrientationMode_);
		break;
	case SOAP_TYPE_tt__VideoEncoding_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__VideoEncoding_*>(p->ptr), tt__VideoEncoding_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__VideoEncoding_*>(p->ptr), tt__VideoEncoding_);
		break;
	case SOAP_TYPE_tt__Mpeg4Profile_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Mpeg4Profile_*>(p->ptr), tt__Mpeg4Profile_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Mpeg4Profile_*>(p->ptr), tt__Mpeg4Profile_);
		break;
	case SOAP_TYPE_tt__H264Profile_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__H264Profile_*>(p->ptr), tt__H264Profile_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__H264Profile_*>(p->ptr), tt__H264Profile_);
		break;
	case SOAP_TYPE_tt__AudioEncoding_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AudioEncoding_*>(p->ptr), tt__AudioEncoding_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AudioEncoding_*>(p->ptr), tt__AudioEncoding_);
		break;
	case SOAP_TYPE_tt__IPv4Address__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPv4Address__*>(p->ptr), tt__IPv4Address__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPv4Address__*>(p->ptr), tt__IPv4Address__);
		break;
	case SOAP_TYPE_tt__IPv6Address__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPv6Address__*>(p->ptr), tt__IPv6Address__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPv6Address__*>(p->ptr), tt__IPv6Address__);
		break;
	case SOAP_TYPE_tt__IPType_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPType_*>(p->ptr), tt__IPType_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPType_*>(p->ptr), tt__IPType_);
		break;
	case SOAP_TYPE_tt__EFlipMode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__EFlipMode_*>(p->ptr), tt__EFlipMode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__EFlipMode_*>(p->ptr), tt__EFlipMode_);
		break;
	case SOAP_TYPE_tt__ReverseMode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ReverseMode_*>(p->ptr), tt__ReverseMode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ReverseMode_*>(p->ptr), tt__ReverseMode_);
		break;
	case SOAP_TYPE_tt__AutoFocusMode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AutoFocusMode_*>(p->ptr), tt__AutoFocusMode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AutoFocusMode_*>(p->ptr), tt__AutoFocusMode_);
		break;
	case SOAP_TYPE_tt__WideDynamicMode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__WideDynamicMode_*>(p->ptr), tt__WideDynamicMode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__WideDynamicMode_*>(p->ptr), tt__WideDynamicMode_);
		break;
	case SOAP_TYPE_tt__BacklightCompensationMode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__BacklightCompensationMode_*>(p->ptr), tt__BacklightCompensationMode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__BacklightCompensationMode_*>(p->ptr), tt__BacklightCompensationMode_);
		break;
	case SOAP_TYPE_tt__ExposurePriority_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ExposurePriority_*>(p->ptr), tt__ExposurePriority_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ExposurePriority_*>(p->ptr), tt__ExposurePriority_);
		break;
	case SOAP_TYPE_tt__ExposureMode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ExposureMode_*>(p->ptr), tt__ExposureMode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ExposureMode_*>(p->ptr), tt__ExposureMode_);
		break;
	case SOAP_TYPE_tt__WhiteBalanceMode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__WhiteBalanceMode_*>(p->ptr), tt__WhiteBalanceMode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__WhiteBalanceMode_*>(p->ptr), tt__WhiteBalanceMode_);
		break;
	case SOAP_TYPE_tt__IrCutFilterMode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IrCutFilterMode_*>(p->ptr), tt__IrCutFilterMode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IrCutFilterMode_*>(p->ptr), tt__IrCutFilterMode_);
		break;
	case SOAP_TYPE_tt__ImageStabilizationMode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImageStabilizationMode_*>(p->ptr), tt__ImageStabilizationMode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImageStabilizationMode_*>(p->ptr), tt__ImageStabilizationMode_);
		break;
	case SOAP_TYPE_tt__PropertyOperation_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PropertyOperation_*>(p->ptr), tt__PropertyOperation_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PropertyOperation_*>(p->ptr), tt__PropertyOperation_);
		break;
	case SOAP_TYPE_tt__ReferenceToken__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ReferenceToken__*>(p->ptr), tt__ReferenceToken__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ReferenceToken__*>(p->ptr), tt__ReferenceToken__);
		break;
	case SOAP_TYPE_tt__MoveStatus_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__MoveStatus_*>(p->ptr), tt__MoveStatus_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__MoveStatus_*>(p->ptr), tt__MoveStatus_);
		break;
	case SOAP_TYPE_wstop__ConcreteTopicExpression__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__ConcreteTopicExpression__*>(p->ptr), wstop__ConcreteTopicExpression__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__ConcreteTopicExpression__*>(p->ptr), wstop__ConcreteTopicExpression__);
		break;
	case SOAP_TYPE_timg__Capabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<timg__Capabilities*>(p->ptr), timg__Capabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<timg__Capabilities*>(p->ptr), timg__Capabilities);
		break;
	case SOAP_TYPE_timg__ImagingPreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<timg__ImagingPreset*>(p->ptr), timg__ImagingPreset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<timg__ImagingPreset*>(p->ptr), timg__ImagingPreset);
		break;
	case SOAP_TYPE__timg__GetServiceCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetServiceCapabilities*>(p->ptr), _timg__GetServiceCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetServiceCapabilities*>(p->ptr), _timg__GetServiceCapabilities);
		break;
	case SOAP_TYPE__timg__GetServiceCapabilitiesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetServiceCapabilitiesResponse*>(p->ptr), _timg__GetServiceCapabilitiesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetServiceCapabilitiesResponse*>(p->ptr), _timg__GetServiceCapabilitiesResponse);
		break;
	case SOAP_TYPE__timg__GetImagingSettings:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetImagingSettings*>(p->ptr), _timg__GetImagingSettings);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetImagingSettings*>(p->ptr), _timg__GetImagingSettings);
		break;
	case SOAP_TYPE__timg__GetImagingSettingsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetImagingSettingsResponse*>(p->ptr), _timg__GetImagingSettingsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetImagingSettingsResponse*>(p->ptr), _timg__GetImagingSettingsResponse);
		break;
	case SOAP_TYPE__timg__SetImagingSettings:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__SetImagingSettings*>(p->ptr), _timg__SetImagingSettings);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__SetImagingSettings*>(p->ptr), _timg__SetImagingSettings);
		break;
	case SOAP_TYPE__timg__SetImagingSettingsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__SetImagingSettingsResponse*>(p->ptr), _timg__SetImagingSettingsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__SetImagingSettingsResponse*>(p->ptr), _timg__SetImagingSettingsResponse);
		break;
	case SOAP_TYPE__timg__GetOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetOptions*>(p->ptr), _timg__GetOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetOptions*>(p->ptr), _timg__GetOptions);
		break;
	case SOAP_TYPE__timg__GetOptionsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetOptionsResponse*>(p->ptr), _timg__GetOptionsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetOptionsResponse*>(p->ptr), _timg__GetOptionsResponse);
		break;
	case SOAP_TYPE__timg__Move:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__Move*>(p->ptr), _timg__Move);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__Move*>(p->ptr), _timg__Move);
		break;
	case SOAP_TYPE__timg__MoveResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__MoveResponse*>(p->ptr), _timg__MoveResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__MoveResponse*>(p->ptr), _timg__MoveResponse);
		break;
	case SOAP_TYPE__timg__GetMoveOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetMoveOptions*>(p->ptr), _timg__GetMoveOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetMoveOptions*>(p->ptr), _timg__GetMoveOptions);
		break;
	case SOAP_TYPE__timg__GetMoveOptionsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetMoveOptionsResponse*>(p->ptr), _timg__GetMoveOptionsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetMoveOptionsResponse*>(p->ptr), _timg__GetMoveOptionsResponse);
		break;
	case SOAP_TYPE__timg__Stop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__Stop*>(p->ptr), _timg__Stop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__Stop*>(p->ptr), _timg__Stop);
		break;
	case SOAP_TYPE__timg__StopResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__StopResponse*>(p->ptr), _timg__StopResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__StopResponse*>(p->ptr), _timg__StopResponse);
		break;
	case SOAP_TYPE__timg__GetStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetStatus*>(p->ptr), _timg__GetStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetStatus*>(p->ptr), _timg__GetStatus);
		break;
	case SOAP_TYPE__timg__GetStatusResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetStatusResponse*>(p->ptr), _timg__GetStatusResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetStatusResponse*>(p->ptr), _timg__GetStatusResponse);
		break;
	case SOAP_TYPE__timg__GetPresets:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetPresets*>(p->ptr), _timg__GetPresets);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetPresets*>(p->ptr), _timg__GetPresets);
		break;
	case SOAP_TYPE__timg__GetPresetsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetPresetsResponse*>(p->ptr), _timg__GetPresetsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetPresetsResponse*>(p->ptr), _timg__GetPresetsResponse);
		break;
	case SOAP_TYPE__timg__GetCurrentPreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetCurrentPreset*>(p->ptr), _timg__GetCurrentPreset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetCurrentPreset*>(p->ptr), _timg__GetCurrentPreset);
		break;
	case SOAP_TYPE__timg__GetCurrentPresetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__GetCurrentPresetResponse*>(p->ptr), _timg__GetCurrentPresetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__GetCurrentPresetResponse*>(p->ptr), _timg__GetCurrentPresetResponse);
		break;
	case SOAP_TYPE__timg__SetCurrentPreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__SetCurrentPreset*>(p->ptr), _timg__SetCurrentPreset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__SetCurrentPreset*>(p->ptr), _timg__SetCurrentPreset);
		break;
	case SOAP_TYPE__timg__SetCurrentPresetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_timg__SetCurrentPresetResponse*>(p->ptr), _timg__SetCurrentPresetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_timg__SetCurrentPresetResponse*>(p->ptr), _timg__SetCurrentPresetResponse);
		break;
	case SOAP_TYPE_tt__IntRectangle:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IntRectangle*>(p->ptr), tt__IntRectangle);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IntRectangle*>(p->ptr), tt__IntRectangle);
		break;
	case SOAP_TYPE_tt__IntRectangleRange:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IntRectangleRange*>(p->ptr), tt__IntRectangleRange);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IntRectangleRange*>(p->ptr), tt__IntRectangleRange);
		break;
	case SOAP_TYPE_tt__FloatRange:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__FloatRange*>(p->ptr), tt__FloatRange);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__FloatRange*>(p->ptr), tt__FloatRange);
		break;
	case SOAP_TYPE_tt__DurationRange:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DurationRange*>(p->ptr), tt__DurationRange);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DurationRange*>(p->ptr), tt__DurationRange);
		break;
	case SOAP_TYPE_tt__ConfigurationEntity:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ConfigurationEntity*>(p->ptr), tt__ConfigurationEntity);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ConfigurationEntity*>(p->ptr), tt__ConfigurationEntity);
		break;
	case SOAP_TYPE_tt__VideoSourceConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__VideoSourceConfigurationExtension*>(p->ptr), tt__VideoSourceConfigurationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__VideoSourceConfigurationExtension*>(p->ptr), tt__VideoSourceConfigurationExtension);
		break;
	case SOAP_TYPE_tt__VideoSourceConfigurationExtension2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__VideoSourceConfigurationExtension2*>(p->ptr), tt__VideoSourceConfigurationExtension2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__VideoSourceConfigurationExtension2*>(p->ptr), tt__VideoSourceConfigurationExtension2);
		break;
	case SOAP_TYPE_tt__Rotate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Rotate*>(p->ptr), tt__Rotate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Rotate*>(p->ptr), tt__Rotate);
		break;
	case SOAP_TYPE_tt__RotateExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__RotateExtension*>(p->ptr), tt__RotateExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__RotateExtension*>(p->ptr), tt__RotateExtension);
		break;
	case SOAP_TYPE_tt__LensProjection:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__LensProjection*>(p->ptr), tt__LensProjection);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__LensProjection*>(p->ptr), tt__LensProjection);
		break;
	case SOAP_TYPE_tt__LensOffset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__LensOffset*>(p->ptr), tt__LensOffset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__LensOffset*>(p->ptr), tt__LensOffset);
		break;
	case SOAP_TYPE_tt__LensDescription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__LensDescription*>(p->ptr), tt__LensDescription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__LensDescription*>(p->ptr), tt__LensDescription);
		break;
	case SOAP_TYPE_tt__SceneOrientation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SceneOrientation*>(p->ptr), tt__SceneOrientation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SceneOrientation*>(p->ptr), tt__SceneOrientation);
		break;
	case SOAP_TYPE_tt__VideoResolution:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__VideoResolution*>(p->ptr), tt__VideoResolution);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__VideoResolution*>(p->ptr), tt__VideoResolution);
		break;
	case SOAP_TYPE_tt__VideoRateControl:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__VideoRateControl*>(p->ptr), tt__VideoRateControl);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__VideoRateControl*>(p->ptr), tt__VideoRateControl);
		break;
	case SOAP_TYPE_tt__Mpeg4Configuration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Mpeg4Configuration*>(p->ptr), tt__Mpeg4Configuration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Mpeg4Configuration*>(p->ptr), tt__Mpeg4Configuration);
		break;
	case SOAP_TYPE_tt__H264Configuration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__H264Configuration*>(p->ptr), tt__H264Configuration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__H264Configuration*>(p->ptr), tt__H264Configuration);
		break;
	case SOAP_TYPE_tt__MetadataConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__MetadataConfigurationExtension*>(p->ptr), tt__MetadataConfigurationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__MetadataConfigurationExtension*>(p->ptr), tt__MetadataConfigurationExtension);
		break;
	case SOAP_TYPE_tt__PTZFilter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZFilter*>(p->ptr), tt__PTZFilter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZFilter*>(p->ptr), tt__PTZFilter);
		break;
	case SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tt__EventSubscription_SubscriptionPolicy*>(p->ptr), _tt__EventSubscription_SubscriptionPolicy);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tt__EventSubscription_SubscriptionPolicy*>(p->ptr), _tt__EventSubscription_SubscriptionPolicy);
		break;
	case SOAP_TYPE_tt__EventSubscription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__EventSubscription*>(p->ptr), tt__EventSubscription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__EventSubscription*>(p->ptr), tt__EventSubscription);
		break;
	case SOAP_TYPE_tt__MulticastConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__MulticastConfiguration*>(p->ptr), tt__MulticastConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__MulticastConfiguration*>(p->ptr), tt__MulticastConfiguration);
		break;
	case SOAP_TYPE_tt__IPAddress:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPAddress*>(p->ptr), tt__IPAddress);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPAddress*>(p->ptr), tt__IPAddress);
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZConfigurationExtension*>(p->ptr), tt__PTZConfigurationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZConfigurationExtension*>(p->ptr), tt__PTZConfigurationExtension);
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZConfigurationExtension2*>(p->ptr), tt__PTZConfigurationExtension2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZConfigurationExtension2*>(p->ptr), tt__PTZConfigurationExtension2);
		break;
	case SOAP_TYPE_tt__PTControlDirection:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTControlDirection*>(p->ptr), tt__PTControlDirection);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTControlDirection*>(p->ptr), tt__PTControlDirection);
		break;
	case SOAP_TYPE_tt__PTControlDirectionExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTControlDirectionExtension*>(p->ptr), tt__PTControlDirectionExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTControlDirectionExtension*>(p->ptr), tt__PTControlDirectionExtension);
		break;
	case SOAP_TYPE_tt__EFlip:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__EFlip*>(p->ptr), tt__EFlip);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__EFlip*>(p->ptr), tt__EFlip);
		break;
	case SOAP_TYPE_tt__Reverse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Reverse*>(p->ptr), tt__Reverse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Reverse*>(p->ptr), tt__Reverse);
		break;
	case SOAP_TYPE_tt__PanTiltLimits:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PanTiltLimits*>(p->ptr), tt__PanTiltLimits);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PanTiltLimits*>(p->ptr), tt__PanTiltLimits);
		break;
	case SOAP_TYPE_tt__ZoomLimits:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ZoomLimits*>(p->ptr), tt__ZoomLimits);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ZoomLimits*>(p->ptr), tt__ZoomLimits);
		break;
	case SOAP_TYPE_tt__Space2DDescription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Space2DDescription*>(p->ptr), tt__Space2DDescription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Space2DDescription*>(p->ptr), tt__Space2DDescription);
		break;
	case SOAP_TYPE_tt__Space1DDescription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Space1DDescription*>(p->ptr), tt__Space1DDescription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Space1DDescription*>(p->ptr), tt__Space1DDescription);
		break;
	case SOAP_TYPE_tt__PTZSpeed:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZSpeed*>(p->ptr), tt__PTZSpeed);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZSpeed*>(p->ptr), tt__PTZSpeed);
		break;
	case SOAP_TYPE_tt__FocusMove:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__FocusMove*>(p->ptr), tt__FocusMove);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__FocusMove*>(p->ptr), tt__FocusMove);
		break;
	case SOAP_TYPE_tt__AbsoluteFocus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AbsoluteFocus*>(p->ptr), tt__AbsoluteFocus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AbsoluteFocus*>(p->ptr), tt__AbsoluteFocus);
		break;
	case SOAP_TYPE_tt__RelativeFocus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__RelativeFocus*>(p->ptr), tt__RelativeFocus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__RelativeFocus*>(p->ptr), tt__RelativeFocus);
		break;
	case SOAP_TYPE_tt__ContinuousFocus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ContinuousFocus*>(p->ptr), tt__ContinuousFocus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ContinuousFocus*>(p->ptr), tt__ContinuousFocus);
		break;
	case SOAP_TYPE_tt__AbsoluteFocusOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AbsoluteFocusOptions*>(p->ptr), tt__AbsoluteFocusOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AbsoluteFocusOptions*>(p->ptr), tt__AbsoluteFocusOptions);
		break;
	case SOAP_TYPE_tt__ContinuousFocusOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ContinuousFocusOptions*>(p->ptr), tt__ContinuousFocusOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ContinuousFocusOptions*>(p->ptr), tt__ContinuousFocusOptions);
		break;
	case SOAP_TYPE_tt__ImagingStatus20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImagingStatus20*>(p->ptr), tt__ImagingStatus20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImagingStatus20*>(p->ptr), tt__ImagingStatus20);
		break;
	case SOAP_TYPE_tt__ImagingStatus20Extension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImagingStatus20Extension*>(p->ptr), tt__ImagingStatus20Extension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImagingStatus20Extension*>(p->ptr), tt__ImagingStatus20Extension);
		break;
	case SOAP_TYPE_tt__FocusStatus20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__FocusStatus20*>(p->ptr), tt__FocusStatus20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__FocusStatus20*>(p->ptr), tt__FocusStatus20);
		break;
	case SOAP_TYPE_tt__FocusStatus20Extension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__FocusStatus20Extension*>(p->ptr), tt__FocusStatus20Extension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__FocusStatus20Extension*>(p->ptr), tt__FocusStatus20Extension);
		break;
	case SOAP_TYPE_tt__ImagingSettings20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImagingSettings20*>(p->ptr), tt__ImagingSettings20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImagingSettings20*>(p->ptr), tt__ImagingSettings20);
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImagingSettingsExtension20*>(p->ptr), tt__ImagingSettingsExtension20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImagingSettingsExtension20*>(p->ptr), tt__ImagingSettingsExtension20);
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension202:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImagingSettingsExtension202*>(p->ptr), tt__ImagingSettingsExtension202);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImagingSettingsExtension202*>(p->ptr), tt__ImagingSettingsExtension202);
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension203:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImagingSettingsExtension203*>(p->ptr), tt__ImagingSettingsExtension203);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImagingSettingsExtension203*>(p->ptr), tt__ImagingSettingsExtension203);
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension204:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImagingSettingsExtension204*>(p->ptr), tt__ImagingSettingsExtension204);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImagingSettingsExtension204*>(p->ptr), tt__ImagingSettingsExtension204);
		break;
	case SOAP_TYPE_tt__ImageStabilization:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImageStabilization*>(p->ptr), tt__ImageStabilization);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImageStabilization*>(p->ptr), tt__ImageStabilization);
		break;
	case SOAP_TYPE_tt__ImageStabilizationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImageStabilizationExtension*>(p->ptr), tt__ImageStabilizationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImageStabilizationExtension*>(p->ptr), tt__ImageStabilizationExtension);
		break;
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustment:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IrCutFilterAutoAdjustment*>(p->ptr), tt__IrCutFilterAutoAdjustment);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IrCutFilterAutoAdjustment*>(p->ptr), tt__IrCutFilterAutoAdjustment);
		break;
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IrCutFilterAutoAdjustmentExtension*>(p->ptr), tt__IrCutFilterAutoAdjustmentExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IrCutFilterAutoAdjustmentExtension*>(p->ptr), tt__IrCutFilterAutoAdjustmentExtension);
		break;
	case SOAP_TYPE_tt__WideDynamicRange20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__WideDynamicRange20*>(p->ptr), tt__WideDynamicRange20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__WideDynamicRange20*>(p->ptr), tt__WideDynamicRange20);
		break;
	case SOAP_TYPE_tt__BacklightCompensation20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__BacklightCompensation20*>(p->ptr), tt__BacklightCompensation20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__BacklightCompensation20*>(p->ptr), tt__BacklightCompensation20);
		break;
	case SOAP_TYPE_tt__Exposure20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Exposure20*>(p->ptr), tt__Exposure20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Exposure20*>(p->ptr), tt__Exposure20);
		break;
	case SOAP_TYPE_tt__ToneCompensation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ToneCompensation*>(p->ptr), tt__ToneCompensation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ToneCompensation*>(p->ptr), tt__ToneCompensation);
		break;
	case SOAP_TYPE_tt__ToneCompensationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ToneCompensationExtension*>(p->ptr), tt__ToneCompensationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ToneCompensationExtension*>(p->ptr), tt__ToneCompensationExtension);
		break;
	case SOAP_TYPE_tt__Defogging:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Defogging*>(p->ptr), tt__Defogging);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Defogging*>(p->ptr), tt__Defogging);
		break;
	case SOAP_TYPE_tt__DefoggingExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DefoggingExtension*>(p->ptr), tt__DefoggingExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DefoggingExtension*>(p->ptr), tt__DefoggingExtension);
		break;
	case SOAP_TYPE_tt__NoiseReduction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NoiseReduction*>(p->ptr), tt__NoiseReduction);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NoiseReduction*>(p->ptr), tt__NoiseReduction);
		break;
	case SOAP_TYPE_tt__ImagingOptions20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImagingOptions20*>(p->ptr), tt__ImagingOptions20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImagingOptions20*>(p->ptr), tt__ImagingOptions20);
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImagingOptions20Extension*>(p->ptr), tt__ImagingOptions20Extension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImagingOptions20Extension*>(p->ptr), tt__ImagingOptions20Extension);
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImagingOptions20Extension2*>(p->ptr), tt__ImagingOptions20Extension2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImagingOptions20Extension2*>(p->ptr), tt__ImagingOptions20Extension2);
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension3:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImagingOptions20Extension3*>(p->ptr), tt__ImagingOptions20Extension3);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImagingOptions20Extension3*>(p->ptr), tt__ImagingOptions20Extension3);
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension4:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImagingOptions20Extension4*>(p->ptr), tt__ImagingOptions20Extension4);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImagingOptions20Extension4*>(p->ptr), tt__ImagingOptions20Extension4);
		break;
	case SOAP_TYPE_tt__ImageStabilizationOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImageStabilizationOptions*>(p->ptr), tt__ImageStabilizationOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImageStabilizationOptions*>(p->ptr), tt__ImageStabilizationOptions);
		break;
	case SOAP_TYPE_tt__ImageStabilizationOptionsExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImageStabilizationOptionsExtension*>(p->ptr), tt__ImageStabilizationOptionsExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImageStabilizationOptionsExtension*>(p->ptr), tt__ImageStabilizationOptionsExtension);
		break;
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IrCutFilterAutoAdjustmentOptions*>(p->ptr), tt__IrCutFilterAutoAdjustmentOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IrCutFilterAutoAdjustmentOptions*>(p->ptr), tt__IrCutFilterAutoAdjustmentOptions);
		break;
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IrCutFilterAutoAdjustmentOptionsExtension*>(p->ptr), tt__IrCutFilterAutoAdjustmentOptionsExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IrCutFilterAutoAdjustmentOptionsExtension*>(p->ptr), tt__IrCutFilterAutoAdjustmentOptionsExtension);
		break;
	case SOAP_TYPE_tt__WideDynamicRangeOptions20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__WideDynamicRangeOptions20*>(p->ptr), tt__WideDynamicRangeOptions20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__WideDynamicRangeOptions20*>(p->ptr), tt__WideDynamicRangeOptions20);
		break;
	case SOAP_TYPE_tt__BacklightCompensationOptions20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__BacklightCompensationOptions20*>(p->ptr), tt__BacklightCompensationOptions20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__BacklightCompensationOptions20*>(p->ptr), tt__BacklightCompensationOptions20);
		break;
	case SOAP_TYPE_tt__ExposureOptions20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ExposureOptions20*>(p->ptr), tt__ExposureOptions20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ExposureOptions20*>(p->ptr), tt__ExposureOptions20);
		break;
	case SOAP_TYPE_tt__MoveOptions20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__MoveOptions20*>(p->ptr), tt__MoveOptions20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__MoveOptions20*>(p->ptr), tt__MoveOptions20);
		break;
	case SOAP_TYPE_tt__RelativeFocusOptions20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__RelativeFocusOptions20*>(p->ptr), tt__RelativeFocusOptions20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__RelativeFocusOptions20*>(p->ptr), tt__RelativeFocusOptions20);
		break;
	case SOAP_TYPE_tt__WhiteBalance20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__WhiteBalance20*>(p->ptr), tt__WhiteBalance20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__WhiteBalance20*>(p->ptr), tt__WhiteBalance20);
		break;
	case SOAP_TYPE_tt__WhiteBalance20Extension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__WhiteBalance20Extension*>(p->ptr), tt__WhiteBalance20Extension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__WhiteBalance20Extension*>(p->ptr), tt__WhiteBalance20Extension);
		break;
	case SOAP_TYPE_tt__FocusConfiguration20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__FocusConfiguration20*>(p->ptr), tt__FocusConfiguration20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__FocusConfiguration20*>(p->ptr), tt__FocusConfiguration20);
		break;
	case SOAP_TYPE_tt__FocusConfiguration20Extension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__FocusConfiguration20Extension*>(p->ptr), tt__FocusConfiguration20Extension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__FocusConfiguration20Extension*>(p->ptr), tt__FocusConfiguration20Extension);
		break;
	case SOAP_TYPE_tt__WhiteBalanceOptions20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__WhiteBalanceOptions20*>(p->ptr), tt__WhiteBalanceOptions20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__WhiteBalanceOptions20*>(p->ptr), tt__WhiteBalanceOptions20);
		break;
	case SOAP_TYPE_tt__WhiteBalanceOptions20Extension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__WhiteBalanceOptions20Extension*>(p->ptr), tt__WhiteBalanceOptions20Extension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__WhiteBalanceOptions20Extension*>(p->ptr), tt__WhiteBalanceOptions20Extension);
		break;
	case SOAP_TYPE_tt__FocusOptions20:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__FocusOptions20*>(p->ptr), tt__FocusOptions20);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__FocusOptions20*>(p->ptr), tt__FocusOptions20);
		break;
	case SOAP_TYPE_tt__FocusOptions20Extension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__FocusOptions20Extension*>(p->ptr), tt__FocusOptions20Extension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__FocusOptions20Extension*>(p->ptr), tt__FocusOptions20Extension);
		break;
	case SOAP_TYPE_tt__ToneCompensationOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ToneCompensationOptions*>(p->ptr), tt__ToneCompensationOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ToneCompensationOptions*>(p->ptr), tt__ToneCompensationOptions);
		break;
	case SOAP_TYPE_tt__DefoggingOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DefoggingOptions*>(p->ptr), tt__DefoggingOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DefoggingOptions*>(p->ptr), tt__DefoggingOptions);
		break;
	case SOAP_TYPE_tt__NoiseReductionOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NoiseReductionOptions*>(p->ptr), tt__NoiseReductionOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NoiseReductionOptions*>(p->ptr), tt__NoiseReductionOptions);
		break;
	case SOAP_TYPE_tt__MessageExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__MessageExtension*>(p->ptr), tt__MessageExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__MessageExtension*>(p->ptr), tt__MessageExtension);
		break;
	case SOAP_TYPE__tt__ItemList_SimpleItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tt__ItemList_SimpleItem*>(p->ptr), _tt__ItemList_SimpleItem);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tt__ItemList_SimpleItem*>(p->ptr), _tt__ItemList_SimpleItem);
		break;
	case SOAP_TYPE__tt__ItemList_ElementItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tt__ItemList_ElementItem*>(p->ptr), _tt__ItemList_ElementItem);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tt__ItemList_ElementItem*>(p->ptr), _tt__ItemList_ElementItem);
		break;
	case SOAP_TYPE_tt__ItemList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ItemList*>(p->ptr), tt__ItemList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ItemList*>(p->ptr), tt__ItemList);
		break;
	case SOAP_TYPE_tt__ItemListExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ItemListExtension*>(p->ptr), tt__ItemListExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ItemListExtension*>(p->ptr), tt__ItemListExtension);
		break;
	case SOAP_TYPE_tt__Polyline:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Polyline*>(p->ptr), tt__Polyline);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Polyline*>(p->ptr), tt__Polyline);
		break;
	case SOAP_TYPE_tt__AnalyticsEngineConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AnalyticsEngineConfiguration*>(p->ptr), tt__AnalyticsEngineConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AnalyticsEngineConfiguration*>(p->ptr), tt__AnalyticsEngineConfiguration);
		break;
	case SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AnalyticsEngineConfigurationExtension*>(p->ptr), tt__AnalyticsEngineConfigurationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AnalyticsEngineConfigurationExtension*>(p->ptr), tt__AnalyticsEngineConfigurationExtension);
		break;
	case SOAP_TYPE_tt__RuleEngineConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__RuleEngineConfiguration*>(p->ptr), tt__RuleEngineConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__RuleEngineConfiguration*>(p->ptr), tt__RuleEngineConfiguration);
		break;
	case SOAP_TYPE_tt__RuleEngineConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__RuleEngineConfigurationExtension*>(p->ptr), tt__RuleEngineConfigurationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__RuleEngineConfigurationExtension*>(p->ptr), tt__RuleEngineConfigurationExtension);
		break;
	case SOAP_TYPE_tt__Config:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Config*>(p->ptr), tt__Config);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Config*>(p->ptr), tt__Config);
		break;
	case SOAP_TYPE_tt__PolygonOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PolygonOptions*>(p->ptr), tt__PolygonOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PolygonOptions*>(p->ptr), tt__PolygonOptions);
		break;
	case SOAP_TYPE_tt__IntRange:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IntRange*>(p->ptr), tt__IntRange);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IntRange*>(p->ptr), tt__IntRange);
		break;
	case SOAP_TYPE_tt__Vector2D:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Vector2D*>(p->ptr), tt__Vector2D);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Vector2D*>(p->ptr), tt__Vector2D);
		break;
	case SOAP_TYPE_tt__Vector1D:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Vector1D*>(p->ptr), tt__Vector1D);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Vector1D*>(p->ptr), tt__Vector1D);
		break;
	case SOAP_TYPE_tt__Vector:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Vector*>(p->ptr), tt__Vector);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Vector*>(p->ptr), tt__Vector);
		break;
	case SOAP_TYPE_tt__Rectangle:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Rectangle*>(p->ptr), tt__Rectangle);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Rectangle*>(p->ptr), tt__Rectangle);
		break;
	case SOAP_TYPE_tt__Polygon:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Polygon*>(p->ptr), tt__Polygon);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Polygon*>(p->ptr), tt__Polygon);
		break;
	case SOAP_TYPE__tt__StringItems:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tt__StringItems*>(p->ptr), _tt__StringItems);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tt__StringItems*>(p->ptr), _tt__StringItems);
		break;
	case SOAP_TYPE__tt__Message:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tt__Message*>(p->ptr), _tt__Message);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tt__Message*>(p->ptr), _tt__Message);
		break;
	case SOAP_TYPE_wsnt__QueryExpressionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__QueryExpressionType*>(p->ptr), wsnt__QueryExpressionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__QueryExpressionType*>(p->ptr), wsnt__QueryExpressionType);
		break;
	case SOAP_TYPE_wsnt__TopicExpressionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__TopicExpressionType*>(p->ptr), wsnt__TopicExpressionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__TopicExpressionType*>(p->ptr), wsnt__TopicExpressionType);
		break;
	case SOAP_TYPE_wsnt__FilterType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__FilterType*>(p->ptr), wsnt__FilterType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__FilterType*>(p->ptr), wsnt__FilterType);
		break;
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__SubscriptionPolicyType*>(p->ptr), wsnt__SubscriptionPolicyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__SubscriptionPolicyType*>(p->ptr), wsnt__SubscriptionPolicyType);
		break;
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__NotificationMessageHolderType_Message*>(p->ptr), _wsnt__NotificationMessageHolderType_Message);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__NotificationMessageHolderType_Message*>(p->ptr), _wsnt__NotificationMessageHolderType_Message);
		break;
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__NotificationMessageHolderType*>(p->ptr), wsnt__NotificationMessageHolderType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__NotificationMessageHolderType*>(p->ptr), wsnt__NotificationMessageHolderType);
		break;
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__NotificationProducerRP*>(p->ptr), _wsnt__NotificationProducerRP);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__NotificationProducerRP*>(p->ptr), _wsnt__NotificationProducerRP);
		break;
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__SubscriptionManagerRP*>(p->ptr), _wsnt__SubscriptionManagerRP);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__SubscriptionManagerRP*>(p->ptr), _wsnt__SubscriptionManagerRP);
		break;
	case SOAP_TYPE__wsnt__Notify:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__Notify*>(p->ptr), _wsnt__Notify);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__Notify*>(p->ptr), _wsnt__Notify);
		break;
	case SOAP_TYPE__wsnt__UseRaw:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__UseRaw*>(p->ptr), _wsnt__UseRaw);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__UseRaw*>(p->ptr), _wsnt__UseRaw);
		break;
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__Subscribe_SubscriptionPolicy*>(p->ptr), _wsnt__Subscribe_SubscriptionPolicy);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__Subscribe_SubscriptionPolicy*>(p->ptr), _wsnt__Subscribe_SubscriptionPolicy);
		break;
	case SOAP_TYPE__wsnt__Subscribe:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__Subscribe*>(p->ptr), _wsnt__Subscribe);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__Subscribe*>(p->ptr), _wsnt__Subscribe);
		break;
	case SOAP_TYPE__wsnt__SubscribeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__SubscribeResponse*>(p->ptr), _wsnt__SubscribeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__SubscribeResponse*>(p->ptr), _wsnt__SubscribeResponse);
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__GetCurrentMessage*>(p->ptr), _wsnt__GetCurrentMessage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__GetCurrentMessage*>(p->ptr), _wsnt__GetCurrentMessage);
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__GetCurrentMessageResponse*>(p->ptr), _wsnt__GetCurrentMessageResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__GetCurrentMessageResponse*>(p->ptr), _wsnt__GetCurrentMessageResponse);
		break;
	case SOAP_TYPE__wsnt__GetMessages:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__GetMessages*>(p->ptr), _wsnt__GetMessages);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__GetMessages*>(p->ptr), _wsnt__GetMessages);
		break;
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__GetMessagesResponse*>(p->ptr), _wsnt__GetMessagesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__GetMessagesResponse*>(p->ptr), _wsnt__GetMessagesResponse);
		break;
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__DestroyPullPoint*>(p->ptr), _wsnt__DestroyPullPoint);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__DestroyPullPoint*>(p->ptr), _wsnt__DestroyPullPoint);
		break;
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__DestroyPullPointResponse*>(p->ptr), _wsnt__DestroyPullPointResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__DestroyPullPointResponse*>(p->ptr), _wsnt__DestroyPullPointResponse);
		break;
	case SOAP_TYPE__wsnt__CreatePullPoint:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__CreatePullPoint*>(p->ptr), _wsnt__CreatePullPoint);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__CreatePullPoint*>(p->ptr), _wsnt__CreatePullPoint);
		break;
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__CreatePullPointResponse*>(p->ptr), _wsnt__CreatePullPointResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__CreatePullPointResponse*>(p->ptr), _wsnt__CreatePullPointResponse);
		break;
	case SOAP_TYPE__wsnt__Renew:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__Renew*>(p->ptr), _wsnt__Renew);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__Renew*>(p->ptr), _wsnt__Renew);
		break;
	case SOAP_TYPE__wsnt__RenewResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__RenewResponse*>(p->ptr), _wsnt__RenewResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__RenewResponse*>(p->ptr), _wsnt__RenewResponse);
		break;
	case SOAP_TYPE__wsnt__Unsubscribe:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__Unsubscribe*>(p->ptr), _wsnt__Unsubscribe);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__Unsubscribe*>(p->ptr), _wsnt__Unsubscribe);
		break;
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__UnsubscribeResponse*>(p->ptr), _wsnt__UnsubscribeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__UnsubscribeResponse*>(p->ptr), _wsnt__UnsubscribeResponse);
		break;
	case SOAP_TYPE__wsnt__PauseSubscription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__PauseSubscription*>(p->ptr), _wsnt__PauseSubscription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__PauseSubscription*>(p->ptr), _wsnt__PauseSubscription);
		break;
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__PauseSubscriptionResponse*>(p->ptr), _wsnt__PauseSubscriptionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__PauseSubscriptionResponse*>(p->ptr), _wsnt__PauseSubscriptionResponse);
		break;
	case SOAP_TYPE__wsnt__ResumeSubscription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__ResumeSubscription*>(p->ptr), _wsnt__ResumeSubscription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__ResumeSubscription*>(p->ptr), _wsnt__ResumeSubscription);
		break;
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__ResumeSubscriptionResponse*>(p->ptr), _wsnt__ResumeSubscriptionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__ResumeSubscriptionResponse*>(p->ptr), _wsnt__ResumeSubscriptionResponse);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsrfbf__BaseFaultType_ErrorCode*>(p->ptr), _wsrfbf__BaseFaultType_ErrorCode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsrfbf__BaseFaultType_ErrorCode*>(p->ptr), _wsrfbf__BaseFaultType_ErrorCode);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsrfbf__BaseFaultType_Description*>(p->ptr), _wsrfbf__BaseFaultType_Description);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsrfbf__BaseFaultType_Description*>(p->ptr), _wsrfbf__BaseFaultType_Description);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsrfbf__BaseFaultType_FaultCause*>(p->ptr), _wsrfbf__BaseFaultType_FaultCause);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsrfbf__BaseFaultType_FaultCause*>(p->ptr), _wsrfbf__BaseFaultType_FaultCause);
		break;
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsrfbf__BaseFaultType*>(p->ptr), wsrfbf__BaseFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsrfbf__BaseFaultType*>(p->ptr), wsrfbf__BaseFaultType);
		break;
	case SOAP_TYPE_wstop__Documentation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__Documentation*>(p->ptr), wstop__Documentation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__Documentation*>(p->ptr), wstop__Documentation);
		break;
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__ExtensibleDocumented*>(p->ptr), wstop__ExtensibleDocumented);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__ExtensibleDocumented*>(p->ptr), wstop__ExtensibleDocumented);
		break;
	case SOAP_TYPE_wstop__QueryExpressionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__QueryExpressionType*>(p->ptr), wstop__QueryExpressionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__QueryExpressionType*>(p->ptr), wstop__QueryExpressionType);
		break;
	case SOAP_TYPE_tt__VideoSourceConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__VideoSourceConfiguration*>(p->ptr), tt__VideoSourceConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__VideoSourceConfiguration*>(p->ptr), tt__VideoSourceConfiguration);
		break;
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__VideoEncoderConfiguration*>(p->ptr), tt__VideoEncoderConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__VideoEncoderConfiguration*>(p->ptr), tt__VideoEncoderConfiguration);
		break;
	case SOAP_TYPE_tt__AudioSourceConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AudioSourceConfiguration*>(p->ptr), tt__AudioSourceConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AudioSourceConfiguration*>(p->ptr), tt__AudioSourceConfiguration);
		break;
	case SOAP_TYPE_tt__AudioEncoderConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AudioEncoderConfiguration*>(p->ptr), tt__AudioEncoderConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AudioEncoderConfiguration*>(p->ptr), tt__AudioEncoderConfiguration);
		break;
	case SOAP_TYPE_tt__VideoAnalyticsConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__VideoAnalyticsConfiguration*>(p->ptr), tt__VideoAnalyticsConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__VideoAnalyticsConfiguration*>(p->ptr), tt__VideoAnalyticsConfiguration);
		break;
	case SOAP_TYPE_tt__MetadataConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__MetadataConfiguration*>(p->ptr), tt__MetadataConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__MetadataConfiguration*>(p->ptr), tt__MetadataConfiguration);
		break;
	case SOAP_TYPE_tt__AudioOutputConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AudioOutputConfiguration*>(p->ptr), tt__AudioOutputConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AudioOutputConfiguration*>(p->ptr), tt__AudioOutputConfiguration);
		break;
	case SOAP_TYPE_tt__AudioDecoderConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AudioDecoderConfiguration*>(p->ptr), tt__AudioDecoderConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AudioDecoderConfiguration*>(p->ptr), tt__AudioDecoderConfiguration);
		break;
	case SOAP_TYPE_tt__PTZConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZConfiguration*>(p->ptr), tt__PTZConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZConfiguration*>(p->ptr), tt__PTZConfiguration);
		break;
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__SubscribeCreationFailedFaultType*>(p->ptr), wsnt__SubscribeCreationFailedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__SubscribeCreationFailedFaultType*>(p->ptr), wsnt__SubscribeCreationFailedFaultType);
		break;
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__InvalidFilterFaultType*>(p->ptr), wsnt__InvalidFilterFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__InvalidFilterFaultType*>(p->ptr), wsnt__InvalidFilterFaultType);
		break;
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__TopicExpressionDialectUnknownFaultType*>(p->ptr), wsnt__TopicExpressionDialectUnknownFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__TopicExpressionDialectUnknownFaultType*>(p->ptr), wsnt__TopicExpressionDialectUnknownFaultType);
		break;
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__InvalidTopicExpressionFaultType*>(p->ptr), wsnt__InvalidTopicExpressionFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__InvalidTopicExpressionFaultType*>(p->ptr), wsnt__InvalidTopicExpressionFaultType);
		break;
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__TopicNotSupportedFaultType*>(p->ptr), wsnt__TopicNotSupportedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__TopicNotSupportedFaultType*>(p->ptr), wsnt__TopicNotSupportedFaultType);
		break;
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__MultipleTopicsSpecifiedFaultType*>(p->ptr), wsnt__MultipleTopicsSpecifiedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__MultipleTopicsSpecifiedFaultType*>(p->ptr), wsnt__MultipleTopicsSpecifiedFaultType);
		break;
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__InvalidProducerPropertiesExpressionFaultType*>(p->ptr), wsnt__InvalidProducerPropertiesExpressionFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__InvalidProducerPropertiesExpressionFaultType*>(p->ptr), wsnt__InvalidProducerPropertiesExpressionFaultType);
		break;
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__InvalidMessageContentExpressionFaultType*>(p->ptr), wsnt__InvalidMessageContentExpressionFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__InvalidMessageContentExpressionFaultType*>(p->ptr), wsnt__InvalidMessageContentExpressionFaultType);
		break;
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnrecognizedPolicyRequestFaultType*>(p->ptr), wsnt__UnrecognizedPolicyRequestFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnrecognizedPolicyRequestFaultType*>(p->ptr), wsnt__UnrecognizedPolicyRequestFaultType);
		break;
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnsupportedPolicyRequestFaultType*>(p->ptr), wsnt__UnsupportedPolicyRequestFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnsupportedPolicyRequestFaultType*>(p->ptr), wsnt__UnsupportedPolicyRequestFaultType);
		break;
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__NotifyMessageNotSupportedFaultType*>(p->ptr), wsnt__NotifyMessageNotSupportedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__NotifyMessageNotSupportedFaultType*>(p->ptr), wsnt__NotifyMessageNotSupportedFaultType);
		break;
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnacceptableInitialTerminationTimeFaultType*>(p->ptr), wsnt__UnacceptableInitialTerminationTimeFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnacceptableInitialTerminationTimeFaultType*>(p->ptr), wsnt__UnacceptableInitialTerminationTimeFaultType);
		break;
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__NoCurrentMessageOnTopicFaultType*>(p->ptr), wsnt__NoCurrentMessageOnTopicFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__NoCurrentMessageOnTopicFaultType*>(p->ptr), wsnt__NoCurrentMessageOnTopicFaultType);
		break;
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnableToGetMessagesFaultType*>(p->ptr), wsnt__UnableToGetMessagesFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnableToGetMessagesFaultType*>(p->ptr), wsnt__UnableToGetMessagesFaultType);
		break;
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnableToDestroyPullPointFaultType*>(p->ptr), wsnt__UnableToDestroyPullPointFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnableToDestroyPullPointFaultType*>(p->ptr), wsnt__UnableToDestroyPullPointFaultType);
		break;
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnableToCreatePullPointFaultType*>(p->ptr), wsnt__UnableToCreatePullPointFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnableToCreatePullPointFaultType*>(p->ptr), wsnt__UnableToCreatePullPointFaultType);
		break;
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnacceptableTerminationTimeFaultType*>(p->ptr), wsnt__UnacceptableTerminationTimeFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnacceptableTerminationTimeFaultType*>(p->ptr), wsnt__UnacceptableTerminationTimeFaultType);
		break;
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnableToDestroySubscriptionFaultType*>(p->ptr), wsnt__UnableToDestroySubscriptionFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnableToDestroySubscriptionFaultType*>(p->ptr), wsnt__UnableToDestroySubscriptionFaultType);
		break;
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__PauseFailedFaultType*>(p->ptr), wsnt__PauseFailedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__PauseFailedFaultType*>(p->ptr), wsnt__PauseFailedFaultType);
		break;
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__ResumeFailedFaultType*>(p->ptr), wsnt__ResumeFailedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__ResumeFailedFaultType*>(p->ptr), wsnt__ResumeFailedFaultType);
		break;
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wstop__TopicNamespaceType_Topic*>(p->ptr), _wstop__TopicNamespaceType_Topic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wstop__TopicNamespaceType_Topic*>(p->ptr), _wstop__TopicNamespaceType_Topic);
		break;
	case SOAP_TYPE_wstop__TopicNamespaceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__TopicNamespaceType*>(p->ptr), wstop__TopicNamespaceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__TopicNamespaceType*>(p->ptr), wstop__TopicNamespaceType);
		break;
	case SOAP_TYPE_wstop__TopicType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__TopicType*>(p->ptr), wstop__TopicType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__TopicType*>(p->ptr), wstop__TopicType);
		break;
	case SOAP_TYPE_wstop__TopicSetType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__TopicSetType*>(p->ptr), wstop__TopicSetType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__TopicSetType*>(p->ptr), wstop__TopicSetType);
		break;
	case SOAP_TYPE___timg__GetServiceCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __timg__GetServiceCapabilities*>(p->ptr), struct __timg__GetServiceCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __timg__GetServiceCapabilities*>(p->ptr), struct __timg__GetServiceCapabilities);
		break;
	case SOAP_TYPE___timg__GetImagingSettings:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __timg__GetImagingSettings*>(p->ptr), struct __timg__GetImagingSettings);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __timg__GetImagingSettings*>(p->ptr), struct __timg__GetImagingSettings);
		break;
	case SOAP_TYPE___timg__SetImagingSettings:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __timg__SetImagingSettings*>(p->ptr), struct __timg__SetImagingSettings);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __timg__SetImagingSettings*>(p->ptr), struct __timg__SetImagingSettings);
		break;
	case SOAP_TYPE___timg__GetOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __timg__GetOptions*>(p->ptr), struct __timg__GetOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __timg__GetOptions*>(p->ptr), struct __timg__GetOptions);
		break;
	case SOAP_TYPE___timg__Move:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __timg__Move*>(p->ptr), struct __timg__Move);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __timg__Move*>(p->ptr), struct __timg__Move);
		break;
	case SOAP_TYPE___timg__Stop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __timg__Stop*>(p->ptr), struct __timg__Stop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __timg__Stop*>(p->ptr), struct __timg__Stop);
		break;
	case SOAP_TYPE___timg__GetStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __timg__GetStatus*>(p->ptr), struct __timg__GetStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __timg__GetStatus*>(p->ptr), struct __timg__GetStatus);
		break;
	case SOAP_TYPE___timg__GetMoveOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __timg__GetMoveOptions*>(p->ptr), struct __timg__GetMoveOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __timg__GetMoveOptions*>(p->ptr), struct __timg__GetMoveOptions);
		break;
	case SOAP_TYPE___timg__GetPresets:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __timg__GetPresets*>(p->ptr), struct __timg__GetPresets);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __timg__GetPresets*>(p->ptr), struct __timg__GetPresets);
		break;
	case SOAP_TYPE___timg__GetCurrentPreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __timg__GetCurrentPreset*>(p->ptr), struct __timg__GetCurrentPreset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __timg__GetCurrentPreset*>(p->ptr), struct __timg__GetCurrentPreset);
		break;
	case SOAP_TYPE___timg__SetCurrentPreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __timg__SetCurrentPreset*>(p->ptr), struct __timg__SetCurrentPreset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __timg__SetCurrentPreset*>(p->ptr), struct __timg__SetCurrentPreset);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__From:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		break;
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__NCName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__duration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__token:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE__xml__lang:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__IntList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__FloatList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__StringAttrList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__StringList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__Name:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__IPv4Address:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__IPv6Address:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__ReferenceToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_wstop__TopicNamespaceType_Topic> *>(p->ptr), std::vector<_wstop__TopicNamespaceType_Topic> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_wstop__TopicNamespaceType_Topic> *>(p->ptr), std::vector<_wstop__TopicNamespaceType_Topic> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<wstop__TopicType *> *>(p->ptr), std::vector<wstop__TopicType *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<wstop__TopicType *> *>(p->ptr), std::vector<wstop__TopicType *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_wsrfbf__BaseFaultType_Description> *>(p->ptr), std::vector<_wsrfbf__BaseFaultType_Description> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_wsrfbf__BaseFaultType_Description> *>(p->ptr), std::vector<_wsrfbf__BaseFaultType_Description> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<wsnt__NotificationMessageHolderType *> *>(p->ptr), std::vector<wsnt__NotificationMessageHolderType *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<wsnt__NotificationMessageHolderType *> *>(p->ptr), std::vector<wsnt__NotificationMessageHolderType *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<wsnt__TopicExpressionType *> *>(p->ptr), std::vector<wsnt__TopicExpressionType *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<wsnt__TopicExpressionType *> *>(p->ptr), std::vector<wsnt__TopicExpressionType *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Config:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__Config *> *>(p->ptr), std::vector<tt__Config *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__Config *> *>(p->ptr), std::vector<tt__Config *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__Vector *> *>(p->ptr), std::vector<tt__Vector *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__Vector *> *>(p->ptr), std::vector<tt__Vector *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_tt__ItemList_ElementItem> *>(p->ptr), std::vector<_tt__ItemList_ElementItem> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_tt__ItemList_ElementItem> *>(p->ptr), std::vector<_tt__ItemList_ElementItem> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_tt__ItemList_SimpleItem> *>(p->ptr), std::vector<_tt__ItemList_SimpleItem> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_tt__ItemList_SimpleItem> *>(p->ptr), std::vector<_tt__ItemList_SimpleItem> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__AutoFocusMode> *>(p->ptr), std::vector<enum tt__AutoFocusMode> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__AutoFocusMode> *>(p->ptr), std::vector<enum tt__AutoFocusMode> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__WhiteBalanceMode> *>(p->ptr), std::vector<enum tt__WhiteBalanceMode> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__WhiteBalanceMode> *>(p->ptr), std::vector<enum tt__WhiteBalanceMode> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__ExposurePriority> *>(p->ptr), std::vector<enum tt__ExposurePriority> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__ExposurePriority> *>(p->ptr), std::vector<enum tt__ExposurePriority> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ExposureMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__ExposureMode> *>(p->ptr), std::vector<enum tt__ExposureMode> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__ExposureMode> *>(p->ptr), std::vector<enum tt__ExposureMode> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__BacklightCompensationMode> *>(p->ptr), std::vector<enum tt__BacklightCompensationMode> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__BacklightCompensationMode> *>(p->ptr), std::vector<enum tt__BacklightCompensationMode> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__WideDynamicMode> *>(p->ptr), std::vector<enum tt__WideDynamicMode> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__WideDynamicMode> *>(p->ptr), std::vector<enum tt__WideDynamicMode> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__ImageStabilizationMode> *>(p->ptr), std::vector<enum tt__ImageStabilizationMode> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__ImageStabilizationMode> *>(p->ptr), std::vector<enum tt__ImageStabilizationMode> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__IrCutFilterMode> *>(p->ptr), std::vector<enum tt__IrCutFilterMode> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__IrCutFilterMode> *>(p->ptr), std::vector<enum tt__IrCutFilterMode> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__IrCutFilterAutoAdjustment *> *>(p->ptr), std::vector<tt__IrCutFilterAutoAdjustment *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__IrCutFilterAutoAdjustment *> *>(p->ptr), std::vector<tt__IrCutFilterAutoAdjustment *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__LensProjection *> *>(p->ptr), std::vector<tt__LensProjection *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__LensProjection *> *>(p->ptr), std::vector<tt__LensProjection *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__LensDescription *> *>(p->ptr), std::vector<tt__LensDescription *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__LensDescription *> *>(p->ptr), std::vector<tt__LensDescription *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<timg__ImagingPreset *> *>(p->ptr), std::vector<timg__ImagingPreset *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<timg__ImagingPreset *> *>(p->ptr), std::vector<timg__ImagingPreset *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<char *> *>(p->ptr), std::vector<char *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<char *> *>(p->ptr), std::vector<char *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 imageing_fbase(int t, int b)
{
	do
	{	switch (t)
		{

		case SOAP_TYPE_wsa5__EndpointReferenceType__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_SOAP_ENV__Envelope_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_SOAP_ENV__Fault_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__NCName__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__QName__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__anySimpleType__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__anyURI__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__base64Binary__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__boolean_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__dateTime_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__double_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__duration__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__float_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__hexBinary__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__int_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__integer__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__nonNegativeInteger__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__string_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__token__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Name__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__RotateMode_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__SceneOrientationMode_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__VideoEncoding_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Mpeg4Profile_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__H264Profile_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__AudioEncoding_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__IPv4Address__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__IPv6Address__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__IPType_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__EFlipMode_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ReverseMode_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__AutoFocusMode_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__WideDynamicMode_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__BacklightCompensationMode_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ExposurePriority_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ExposureMode_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__WhiteBalanceMode_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__IrCutFilterMode_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImageStabilizationMode_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__PropertyOperation_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ReferenceToken__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__MoveStatus_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_wstop__ConcreteTopicExpression__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_timg__Capabilities: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_timg__ImagingPreset: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__IntRectangle: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__IntRectangleRange: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__FloatRange: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__DurationRange: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ConfigurationEntity: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__VideoSourceConfigurationExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__VideoSourceConfigurationExtension2: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Rotate: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__RotateExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__LensProjection: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__LensOffset: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__LensDescription: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__SceneOrientation: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__VideoResolution: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__VideoRateControl: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Mpeg4Configuration: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__H264Configuration: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__MetadataConfigurationExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__PTZFilter: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__EventSubscription: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__MulticastConfiguration: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__IPAddress: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__PTZConfigurationExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__PTZConfigurationExtension2: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__PTControlDirection: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__PTControlDirectionExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__EFlip: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Reverse: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__PanTiltLimits: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ZoomLimits: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Space2DDescription: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Space1DDescription: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__PTZSpeed: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__FocusMove: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__AbsoluteFocus: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__RelativeFocus: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ContinuousFocus: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__AbsoluteFocusOptions: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ContinuousFocusOptions: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImagingStatus20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImagingStatus20Extension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__FocusStatus20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__FocusStatus20Extension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImagingSettings20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImagingSettingsExtension20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImagingSettingsExtension202: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImagingSettingsExtension203: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImagingSettingsExtension204: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImageStabilization: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImageStabilizationExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__IrCutFilterAutoAdjustment: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__WideDynamicRange20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__BacklightCompensation20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Exposure20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ToneCompensation: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ToneCompensationExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Defogging: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__DefoggingExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__NoiseReduction: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImagingOptions20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImagingOptions20Extension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImagingOptions20Extension2: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImagingOptions20Extension3: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImagingOptions20Extension4: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImageStabilizationOptions: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ImageStabilizationOptionsExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__WideDynamicRangeOptions20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__BacklightCompensationOptions20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ExposureOptions20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__MoveOptions20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__RelativeFocusOptions20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__WhiteBalance20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__WhiteBalance20Extension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__FocusConfiguration20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__FocusConfiguration20Extension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__WhiteBalanceOptions20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__WhiteBalanceOptions20Extension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__FocusOptions20: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__FocusOptions20Extension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ToneCompensationOptions: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__DefoggingOptions: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__NoiseReductionOptions: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__MessageExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ItemList: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__ItemListExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Polyline: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__AnalyticsEngineConfiguration: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__RuleEngineConfiguration: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__RuleEngineConfigurationExtension: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Config: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__PolygonOptions: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__IntRange: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Vector2D: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Vector1D: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Vector: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Rectangle: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__Polygon: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_wsnt__QueryExpressionType: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_wsnt__TopicExpressionType: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_wsnt__FilterType: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_wsnt__SubscriptionPolicyType: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_wsnt__NotificationMessageHolderType: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_wsrfbf__BaseFaultType: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_wstop__Documentation: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_wstop__ExtensibleDocumented: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_wstop__QueryExpressionType: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_tt__VideoSourceConfiguration: t = SOAP_TYPE_tt__ConfigurationEntity; break;
		case SOAP_TYPE_tt__VideoEncoderConfiguration: t = SOAP_TYPE_tt__ConfigurationEntity; break;
		case SOAP_TYPE_tt__AudioSourceConfiguration: t = SOAP_TYPE_tt__ConfigurationEntity; break;
		case SOAP_TYPE_tt__AudioEncoderConfiguration: t = SOAP_TYPE_tt__ConfigurationEntity; break;
		case SOAP_TYPE_tt__VideoAnalyticsConfiguration: t = SOAP_TYPE_tt__ConfigurationEntity; break;
		case SOAP_TYPE_tt__MetadataConfiguration: t = SOAP_TYPE_tt__ConfigurationEntity; break;
		case SOAP_TYPE_tt__AudioOutputConfiguration: t = SOAP_TYPE_tt__ConfigurationEntity; break;
		case SOAP_TYPE_tt__AudioDecoderConfiguration: t = SOAP_TYPE_tt__ConfigurationEntity; break;
		case SOAP_TYPE_tt__PTZConfiguration: t = SOAP_TYPE_tt__ConfigurationEntity; break;
		case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__InvalidFilterFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__TopicNotSupportedFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__PauseFailedFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__ResumeFailedFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wstop__TopicNamespaceType: t = SOAP_TYPE_wstop__ExtensibleDocumented; break;
		case SOAP_TYPE_wstop__TopicType: t = SOAP_TYPE_wstop__ExtensibleDocumented; break;
		case SOAP_TYPE_wstop__TopicSetType: t = SOAP_TYPE_wstop__ExtensibleDocumented; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 imageing_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic:
		if (t == SOAP_TYPE__wstop__TopicNamespaceType_Topic)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_wstop__TopicNamespaceType_Topic>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_wstop__TopicNamespaceType_Topic> *)p)[index] = *(_wstop__TopicNamespaceType_Topic *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType:
		if (t == SOAP_TYPE_wstop__TopicType || imageing_fbase(t, SOAP_TYPE_wstop__TopicType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wstop__TopicType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wstop__TopicType *> *)p)[index] = *(wstop__TopicType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		if (t == SOAP_TYPE_xsd__QName)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description:
		if (t == SOAP_TYPE__wsrfbf__BaseFaultType_Description)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_wsrfbf__BaseFaultType_Description>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_wsrfbf__BaseFaultType_Description> *)p)[index] = *(_wsrfbf__BaseFaultType_Description *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType:
		if (t == SOAP_TYPE_wsnt__NotificationMessageHolderType || imageing_fbase(t, SOAP_TYPE_wsnt__NotificationMessageHolderType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsnt__NotificationMessageHolderType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsnt__NotificationMessageHolderType *> *)p)[index] = *(wsnt__NotificationMessageHolderType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		if (t == SOAP_TYPE_xsd__anyURI)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType:
		if (t == SOAP_TYPE_wsnt__TopicExpressionType || imageing_fbase(t, SOAP_TYPE_wsnt__TopicExpressionType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsnt__TopicExpressionType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsnt__TopicExpressionType *> *)p)[index] = *(wsnt__TopicExpressionType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Config:
		if (t == SOAP_TYPE_tt__Config || imageing_fbase(t, SOAP_TYPE_tt__Config))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__Config *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__Config *> *)p)[index] = *(tt__Config **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector:
		if (t == SOAP_TYPE_tt__Vector || imageing_fbase(t, SOAP_TYPE_tt__Vector))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__Vector *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__Vector *> *)p)[index] = *(tt__Vector **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem:
		if (t == SOAP_TYPE__tt__ItemList_ElementItem)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_tt__ItemList_ElementItem>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_tt__ItemList_ElementItem> *)p)[index] = *(_tt__ItemList_ElementItem *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem:
		if (t == SOAP_TYPE__tt__ItemList_SimpleItem)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_tt__ItemList_SimpleItem>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_tt__ItemList_SimpleItem> *)p)[index] = *(_tt__ItemList_SimpleItem *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode:
		if (t == SOAP_TYPE_tt__AutoFocusMode)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__AutoFocusMode>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__AutoFocusMode> *)p)[index] = *(enum tt__AutoFocusMode *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode:
		if (t == SOAP_TYPE_tt__WhiteBalanceMode)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__WhiteBalanceMode>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__WhiteBalanceMode> *)p)[index] = *(enum tt__WhiteBalanceMode *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority:
		if (t == SOAP_TYPE_tt__ExposurePriority)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__ExposurePriority>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__ExposurePriority> *)p)[index] = *(enum tt__ExposurePriority *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ExposureMode:
		if (t == SOAP_TYPE_tt__ExposureMode)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__ExposureMode>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__ExposureMode> *)p)[index] = *(enum tt__ExposureMode *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode:
		if (t == SOAP_TYPE_tt__BacklightCompensationMode)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__BacklightCompensationMode>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__BacklightCompensationMode> *)p)[index] = *(enum tt__BacklightCompensationMode *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode:
		if (t == SOAP_TYPE_tt__WideDynamicMode)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__WideDynamicMode>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__WideDynamicMode> *)p)[index] = *(enum tt__WideDynamicMode *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (t == SOAP_TYPE_std__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode:
		if (t == SOAP_TYPE_tt__ImageStabilizationMode)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__ImageStabilizationMode>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__ImageStabilizationMode> *)p)[index] = *(enum tt__ImageStabilizationMode *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode:
		if (t == SOAP_TYPE_tt__IrCutFilterMode)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__IrCutFilterMode>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__IrCutFilterMode> *)p)[index] = *(enum tt__IrCutFilterMode *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment:
		if (t == SOAP_TYPE_tt__IrCutFilterAutoAdjustment || imageing_fbase(t, SOAP_TYPE_tt__IrCutFilterAutoAdjustment))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__IrCutFilterAutoAdjustment *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__IrCutFilterAutoAdjustment *> *)p)[index] = *(tt__IrCutFilterAutoAdjustment **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection:
		if (t == SOAP_TYPE_tt__LensProjection || imageing_fbase(t, SOAP_TYPE_tt__LensProjection))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__LensProjection *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__LensProjection *> *)p)[index] = *(tt__LensProjection **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription:
		if (t == SOAP_TYPE_tt__LensDescription || imageing_fbase(t, SOAP_TYPE_tt__LensDescription))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__LensDescription *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__LensDescription *> *)p)[index] = *(tt__LensDescription **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset:
		if (t == SOAP_TYPE_timg__ImagingPreset || imageing_fbase(t, SOAP_TYPE_timg__ImagingPreset))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<timg__ImagingPreset *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<timg__ImagingPreset *> *)p)[index] = *(timg__ImagingPreset **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (t == SOAP_TYPE__XML)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<char *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<char *> *)p)[index] = *(char **)q;
		}
		break;
	case SOAP_TYPE__xop__Include:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _xop__Include type=%d location=%p object=%p\n", t, p, q));
		*(struct _xop__Include*)p = *(struct _xop__Include*)q;
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__MetadataType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ProblemActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__RelatesToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct chan__ChannelInstanceType type=%d location=%p object=%p\n", t, p, q));
		*(struct chan__ChannelInstanceType*)p = *(struct chan__ChannelInstanceType*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__anyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__anyType type=%d location=%p object=%p\n", t, p, q));
		*(xsd__anyType*)p = *(xsd__anyType*)q;
		break;
	case SOAP_TYPE_SOAP_ENV__Envelope:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Envelope type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Envelope*)p = *(struct SOAP_ENV__Envelope*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__base64Binary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE_xsd__hexBinary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__hexBinary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__hexBinary*)p = *(xsd__hexBinary*)q;
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsa5__EndpointReferenceType__ type=%d location=%p object=%p\n", t, p, q));
		*(wsa5__EndpointReferenceType__*)p = *(wsa5__EndpointReferenceType__*)q;
		break;
	case SOAP_TYPE_SOAP_ENV__Envelope_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy SOAP_ENV__Envelope_ type=%d location=%p object=%p\n", t, p, q));
		*(SOAP_ENV__Envelope_*)p = *(SOAP_ENV__Envelope_*)q;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy SOAP_ENV__Fault_ type=%d location=%p object=%p\n", t, p, q));
		*(SOAP_ENV__Fault_*)p = *(SOAP_ENV__Fault_*)q;
		break;
	case SOAP_TYPE_xsd__NCName__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__NCName__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__NCName__*)p = *(xsd__NCName__*)q;
		break;
	case SOAP_TYPE_xsd__QName__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__QName__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__QName__*)p = *(xsd__QName__*)q;
		break;
	case SOAP_TYPE_xsd__anySimpleType__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__anySimpleType__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__anySimpleType__*)p = *(xsd__anySimpleType__*)q;
		break;
	case SOAP_TYPE_xsd__anyURI__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__anyURI__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__anyURI__*)p = *(xsd__anyURI__*)q;
		break;
	case SOAP_TYPE_xsd__base64Binary__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary__*)p = *(xsd__base64Binary__*)q;
		break;
	case SOAP_TYPE_xsd__boolean_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__boolean_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__boolean_*)p = *(xsd__boolean_*)q;
		break;
	case SOAP_TYPE_xsd__dateTime_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__dateTime_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__dateTime_*)p = *(xsd__dateTime_*)q;
		break;
	case SOAP_TYPE_xsd__double_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__double_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__double_*)p = *(xsd__double_*)q;
		break;
	case SOAP_TYPE_xsd__duration__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__duration__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__duration__*)p = *(xsd__duration__*)q;
		break;
	case SOAP_TYPE_xsd__float_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__float_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__float_*)p = *(xsd__float_*)q;
		break;
	case SOAP_TYPE_xsd__hexBinary__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__hexBinary__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__hexBinary__*)p = *(xsd__hexBinary__*)q;
		break;
	case SOAP_TYPE_xsd__int_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__int_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__int_*)p = *(xsd__int_*)q;
		break;
	case SOAP_TYPE_xsd__integer__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__integer__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__integer__*)p = *(xsd__integer__*)q;
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__nonNegativeInteger__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__nonNegativeInteger__*)p = *(xsd__nonNegativeInteger__*)q;
		break;
	case SOAP_TYPE_xsd__string_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__string_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__string_*)p = *(xsd__string_*)q;
		break;
	case SOAP_TYPE_xsd__token__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__token__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__token__*)p = *(xsd__token__*)q;
		break;
	case SOAP_TYPE_tt__Name__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Name__ type=%d location=%p object=%p\n", t, p, q));
		*(tt__Name__*)p = *(tt__Name__*)q;
		break;
	case SOAP_TYPE_tt__RotateMode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__RotateMode_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__RotateMode_*)p = *(tt__RotateMode_*)q;
		break;
	case SOAP_TYPE_tt__SceneOrientationMode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SceneOrientationMode_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__SceneOrientationMode_*)p = *(tt__SceneOrientationMode_*)q;
		break;
	case SOAP_TYPE_tt__VideoEncoding_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__VideoEncoding_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__VideoEncoding_*)p = *(tt__VideoEncoding_*)q;
		break;
	case SOAP_TYPE_tt__Mpeg4Profile_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Mpeg4Profile_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__Mpeg4Profile_*)p = *(tt__Mpeg4Profile_*)q;
		break;
	case SOAP_TYPE_tt__H264Profile_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__H264Profile_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__H264Profile_*)p = *(tt__H264Profile_*)q;
		break;
	case SOAP_TYPE_tt__AudioEncoding_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AudioEncoding_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__AudioEncoding_*)p = *(tt__AudioEncoding_*)q;
		break;
	case SOAP_TYPE_tt__IPv4Address__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPv4Address__ type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPv4Address__*)p = *(tt__IPv4Address__*)q;
		break;
	case SOAP_TYPE_tt__IPv6Address__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPv6Address__ type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPv6Address__*)p = *(tt__IPv6Address__*)q;
		break;
	case SOAP_TYPE_tt__IPType_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPType_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPType_*)p = *(tt__IPType_*)q;
		break;
	case SOAP_TYPE_tt__EFlipMode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__EFlipMode_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__EFlipMode_*)p = *(tt__EFlipMode_*)q;
		break;
	case SOAP_TYPE_tt__ReverseMode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ReverseMode_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__ReverseMode_*)p = *(tt__ReverseMode_*)q;
		break;
	case SOAP_TYPE_tt__AutoFocusMode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AutoFocusMode_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__AutoFocusMode_*)p = *(tt__AutoFocusMode_*)q;
		break;
	case SOAP_TYPE_tt__WideDynamicMode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__WideDynamicMode_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__WideDynamicMode_*)p = *(tt__WideDynamicMode_*)q;
		break;
	case SOAP_TYPE_tt__BacklightCompensationMode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__BacklightCompensationMode_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__BacklightCompensationMode_*)p = *(tt__BacklightCompensationMode_*)q;
		break;
	case SOAP_TYPE_tt__ExposurePriority_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ExposurePriority_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__ExposurePriority_*)p = *(tt__ExposurePriority_*)q;
		break;
	case SOAP_TYPE_tt__ExposureMode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ExposureMode_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__ExposureMode_*)p = *(tt__ExposureMode_*)q;
		break;
	case SOAP_TYPE_tt__WhiteBalanceMode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__WhiteBalanceMode_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__WhiteBalanceMode_*)p = *(tt__WhiteBalanceMode_*)q;
		break;
	case SOAP_TYPE_tt__IrCutFilterMode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IrCutFilterMode_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__IrCutFilterMode_*)p = *(tt__IrCutFilterMode_*)q;
		break;
	case SOAP_TYPE_tt__ImageStabilizationMode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImageStabilizationMode_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImageStabilizationMode_*)p = *(tt__ImageStabilizationMode_*)q;
		break;
	case SOAP_TYPE_tt__PropertyOperation_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PropertyOperation_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__PropertyOperation_*)p = *(tt__PropertyOperation_*)q;
		break;
	case SOAP_TYPE_tt__ReferenceToken__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ReferenceToken__ type=%d location=%p object=%p\n", t, p, q));
		*(tt__ReferenceToken__*)p = *(tt__ReferenceToken__*)q;
		break;
	case SOAP_TYPE_tt__MoveStatus_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__MoveStatus_ type=%d location=%p object=%p\n", t, p, q));
		*(tt__MoveStatus_*)p = *(tt__MoveStatus_*)q;
		break;
	case SOAP_TYPE_wstop__ConcreteTopicExpression__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__ConcreteTopicExpression__ type=%d location=%p object=%p\n", t, p, q));
		*(wstop__ConcreteTopicExpression__*)p = *(wstop__ConcreteTopicExpression__*)q;
		break;
	case SOAP_TYPE_timg__Capabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy timg__Capabilities type=%d location=%p object=%p\n", t, p, q));
		*(timg__Capabilities*)p = *(timg__Capabilities*)q;
		break;
	case SOAP_TYPE_timg__ImagingPreset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy timg__ImagingPreset type=%d location=%p object=%p\n", t, p, q));
		*(timg__ImagingPreset*)p = *(timg__ImagingPreset*)q;
		break;
	case SOAP_TYPE__timg__GetServiceCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetServiceCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetServiceCapabilities*)p = *(_timg__GetServiceCapabilities*)q;
		break;
	case SOAP_TYPE__timg__GetServiceCapabilitiesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetServiceCapabilitiesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetServiceCapabilitiesResponse*)p = *(_timg__GetServiceCapabilitiesResponse*)q;
		break;
	case SOAP_TYPE__timg__GetImagingSettings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetImagingSettings type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetImagingSettings*)p = *(_timg__GetImagingSettings*)q;
		break;
	case SOAP_TYPE__timg__GetImagingSettingsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetImagingSettingsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetImagingSettingsResponse*)p = *(_timg__GetImagingSettingsResponse*)q;
		break;
	case SOAP_TYPE__timg__SetImagingSettings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__SetImagingSettings type=%d location=%p object=%p\n", t, p, q));
		*(_timg__SetImagingSettings*)p = *(_timg__SetImagingSettings*)q;
		break;
	case SOAP_TYPE__timg__SetImagingSettingsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__SetImagingSettingsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_timg__SetImagingSettingsResponse*)p = *(_timg__SetImagingSettingsResponse*)q;
		break;
	case SOAP_TYPE__timg__GetOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetOptions type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetOptions*)p = *(_timg__GetOptions*)q;
		break;
	case SOAP_TYPE__timg__GetOptionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetOptionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetOptionsResponse*)p = *(_timg__GetOptionsResponse*)q;
		break;
	case SOAP_TYPE__timg__Move:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__Move type=%d location=%p object=%p\n", t, p, q));
		*(_timg__Move*)p = *(_timg__Move*)q;
		break;
	case SOAP_TYPE__timg__MoveResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__MoveResponse type=%d location=%p object=%p\n", t, p, q));
		*(_timg__MoveResponse*)p = *(_timg__MoveResponse*)q;
		break;
	case SOAP_TYPE__timg__GetMoveOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetMoveOptions type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetMoveOptions*)p = *(_timg__GetMoveOptions*)q;
		break;
	case SOAP_TYPE__timg__GetMoveOptionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetMoveOptionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetMoveOptionsResponse*)p = *(_timg__GetMoveOptionsResponse*)q;
		break;
	case SOAP_TYPE__timg__Stop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__Stop type=%d location=%p object=%p\n", t, p, q));
		*(_timg__Stop*)p = *(_timg__Stop*)q;
		break;
	case SOAP_TYPE__timg__StopResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__StopResponse type=%d location=%p object=%p\n", t, p, q));
		*(_timg__StopResponse*)p = *(_timg__StopResponse*)q;
		break;
	case SOAP_TYPE__timg__GetStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetStatus type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetStatus*)p = *(_timg__GetStatus*)q;
		break;
	case SOAP_TYPE__timg__GetStatusResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetStatusResponse type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetStatusResponse*)p = *(_timg__GetStatusResponse*)q;
		break;
	case SOAP_TYPE__timg__GetPresets:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetPresets type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetPresets*)p = *(_timg__GetPresets*)q;
		break;
	case SOAP_TYPE__timg__GetPresetsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetPresetsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetPresetsResponse*)p = *(_timg__GetPresetsResponse*)q;
		break;
	case SOAP_TYPE__timg__GetCurrentPreset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetCurrentPreset type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetCurrentPreset*)p = *(_timg__GetCurrentPreset*)q;
		break;
	case SOAP_TYPE__timg__GetCurrentPresetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__GetCurrentPresetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_timg__GetCurrentPresetResponse*)p = *(_timg__GetCurrentPresetResponse*)q;
		break;
	case SOAP_TYPE__timg__SetCurrentPreset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__SetCurrentPreset type=%d location=%p object=%p\n", t, p, q));
		*(_timg__SetCurrentPreset*)p = *(_timg__SetCurrentPreset*)q;
		break;
	case SOAP_TYPE__timg__SetCurrentPresetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _timg__SetCurrentPresetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_timg__SetCurrentPresetResponse*)p = *(_timg__SetCurrentPresetResponse*)q;
		break;
	case SOAP_TYPE_tt__IntRectangle:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IntRectangle type=%d location=%p object=%p\n", t, p, q));
		*(tt__IntRectangle*)p = *(tt__IntRectangle*)q;
		break;
	case SOAP_TYPE_tt__IntRectangleRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IntRectangleRange type=%d location=%p object=%p\n", t, p, q));
		*(tt__IntRectangleRange*)p = *(tt__IntRectangleRange*)q;
		break;
	case SOAP_TYPE_tt__FloatRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__FloatRange type=%d location=%p object=%p\n", t, p, q));
		*(tt__FloatRange*)p = *(tt__FloatRange*)q;
		break;
	case SOAP_TYPE_tt__DurationRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DurationRange type=%d location=%p object=%p\n", t, p, q));
		*(tt__DurationRange*)p = *(tt__DurationRange*)q;
		break;
	case SOAP_TYPE_tt__ConfigurationEntity:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ConfigurationEntity type=%d location=%p object=%p\n", t, p, q));
		*(tt__ConfigurationEntity*)p = *(tt__ConfigurationEntity*)q;
		break;
	case SOAP_TYPE_tt__VideoSourceConfigurationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__VideoSourceConfigurationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__VideoSourceConfigurationExtension*)p = *(tt__VideoSourceConfigurationExtension*)q;
		break;
	case SOAP_TYPE_tt__VideoSourceConfigurationExtension2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__VideoSourceConfigurationExtension2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__VideoSourceConfigurationExtension2*)p = *(tt__VideoSourceConfigurationExtension2*)q;
		break;
	case SOAP_TYPE_tt__Rotate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Rotate type=%d location=%p object=%p\n", t, p, q));
		*(tt__Rotate*)p = *(tt__Rotate*)q;
		break;
	case SOAP_TYPE_tt__RotateExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__RotateExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__RotateExtension*)p = *(tt__RotateExtension*)q;
		break;
	case SOAP_TYPE_tt__LensProjection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__LensProjection type=%d location=%p object=%p\n", t, p, q));
		*(tt__LensProjection*)p = *(tt__LensProjection*)q;
		break;
	case SOAP_TYPE_tt__LensOffset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__LensOffset type=%d location=%p object=%p\n", t, p, q));
		*(tt__LensOffset*)p = *(tt__LensOffset*)q;
		break;
	case SOAP_TYPE_tt__LensDescription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__LensDescription type=%d location=%p object=%p\n", t, p, q));
		*(tt__LensDescription*)p = *(tt__LensDescription*)q;
		break;
	case SOAP_TYPE_tt__SceneOrientation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SceneOrientation type=%d location=%p object=%p\n", t, p, q));
		*(tt__SceneOrientation*)p = *(tt__SceneOrientation*)q;
		break;
	case SOAP_TYPE_tt__VideoResolution:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__VideoResolution type=%d location=%p object=%p\n", t, p, q));
		*(tt__VideoResolution*)p = *(tt__VideoResolution*)q;
		break;
	case SOAP_TYPE_tt__VideoRateControl:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__VideoRateControl type=%d location=%p object=%p\n", t, p, q));
		*(tt__VideoRateControl*)p = *(tt__VideoRateControl*)q;
		break;
	case SOAP_TYPE_tt__Mpeg4Configuration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Mpeg4Configuration type=%d location=%p object=%p\n", t, p, q));
		*(tt__Mpeg4Configuration*)p = *(tt__Mpeg4Configuration*)q;
		break;
	case SOAP_TYPE_tt__H264Configuration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__H264Configuration type=%d location=%p object=%p\n", t, p, q));
		*(tt__H264Configuration*)p = *(tt__H264Configuration*)q;
		break;
	case SOAP_TYPE_tt__MetadataConfigurationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__MetadataConfigurationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__MetadataConfigurationExtension*)p = *(tt__MetadataConfigurationExtension*)q;
		break;
	case SOAP_TYPE_tt__PTZFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZFilter type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZFilter*)p = *(tt__PTZFilter*)q;
		break;
	case SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tt__EventSubscription_SubscriptionPolicy type=%d location=%p object=%p\n", t, p, q));
		*(_tt__EventSubscription_SubscriptionPolicy*)p = *(_tt__EventSubscription_SubscriptionPolicy*)q;
		break;
	case SOAP_TYPE_tt__EventSubscription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__EventSubscription type=%d location=%p object=%p\n", t, p, q));
		*(tt__EventSubscription*)p = *(tt__EventSubscription*)q;
		break;
	case SOAP_TYPE_tt__MulticastConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__MulticastConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__MulticastConfiguration*)p = *(tt__MulticastConfiguration*)q;
		break;
	case SOAP_TYPE_tt__IPAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPAddress type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPAddress*)p = *(tt__IPAddress*)q;
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZConfigurationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZConfigurationExtension*)p = *(tt__PTZConfigurationExtension*)q;
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZConfigurationExtension2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZConfigurationExtension2*)p = *(tt__PTZConfigurationExtension2*)q;
		break;
	case SOAP_TYPE_tt__PTControlDirection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTControlDirection type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTControlDirection*)p = *(tt__PTControlDirection*)q;
		break;
	case SOAP_TYPE_tt__PTControlDirectionExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTControlDirectionExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTControlDirectionExtension*)p = *(tt__PTControlDirectionExtension*)q;
		break;
	case SOAP_TYPE_tt__EFlip:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__EFlip type=%d location=%p object=%p\n", t, p, q));
		*(tt__EFlip*)p = *(tt__EFlip*)q;
		break;
	case SOAP_TYPE_tt__Reverse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Reverse type=%d location=%p object=%p\n", t, p, q));
		*(tt__Reverse*)p = *(tt__Reverse*)q;
		break;
	case SOAP_TYPE_tt__PanTiltLimits:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PanTiltLimits type=%d location=%p object=%p\n", t, p, q));
		*(tt__PanTiltLimits*)p = *(tt__PanTiltLimits*)q;
		break;
	case SOAP_TYPE_tt__ZoomLimits:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ZoomLimits type=%d location=%p object=%p\n", t, p, q));
		*(tt__ZoomLimits*)p = *(tt__ZoomLimits*)q;
		break;
	case SOAP_TYPE_tt__Space2DDescription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Space2DDescription type=%d location=%p object=%p\n", t, p, q));
		*(tt__Space2DDescription*)p = *(tt__Space2DDescription*)q;
		break;
	case SOAP_TYPE_tt__Space1DDescription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Space1DDescription type=%d location=%p object=%p\n", t, p, q));
		*(tt__Space1DDescription*)p = *(tt__Space1DDescription*)q;
		break;
	case SOAP_TYPE_tt__PTZSpeed:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZSpeed type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZSpeed*)p = *(tt__PTZSpeed*)q;
		break;
	case SOAP_TYPE_tt__FocusMove:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__FocusMove type=%d location=%p object=%p\n", t, p, q));
		*(tt__FocusMove*)p = *(tt__FocusMove*)q;
		break;
	case SOAP_TYPE_tt__AbsoluteFocus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AbsoluteFocus type=%d location=%p object=%p\n", t, p, q));
		*(tt__AbsoluteFocus*)p = *(tt__AbsoluteFocus*)q;
		break;
	case SOAP_TYPE_tt__RelativeFocus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__RelativeFocus type=%d location=%p object=%p\n", t, p, q));
		*(tt__RelativeFocus*)p = *(tt__RelativeFocus*)q;
		break;
	case SOAP_TYPE_tt__ContinuousFocus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ContinuousFocus type=%d location=%p object=%p\n", t, p, q));
		*(tt__ContinuousFocus*)p = *(tt__ContinuousFocus*)q;
		break;
	case SOAP_TYPE_tt__AbsoluteFocusOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AbsoluteFocusOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__AbsoluteFocusOptions*)p = *(tt__AbsoluteFocusOptions*)q;
		break;
	case SOAP_TYPE_tt__ContinuousFocusOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ContinuousFocusOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__ContinuousFocusOptions*)p = *(tt__ContinuousFocusOptions*)q;
		break;
	case SOAP_TYPE_tt__ImagingStatus20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImagingStatus20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImagingStatus20*)p = *(tt__ImagingStatus20*)q;
		break;
	case SOAP_TYPE_tt__ImagingStatus20Extension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImagingStatus20Extension type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImagingStatus20Extension*)p = *(tt__ImagingStatus20Extension*)q;
		break;
	case SOAP_TYPE_tt__FocusStatus20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__FocusStatus20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__FocusStatus20*)p = *(tt__FocusStatus20*)q;
		break;
	case SOAP_TYPE_tt__FocusStatus20Extension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__FocusStatus20Extension type=%d location=%p object=%p\n", t, p, q));
		*(tt__FocusStatus20Extension*)p = *(tt__FocusStatus20Extension*)q;
		break;
	case SOAP_TYPE_tt__ImagingSettings20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImagingSettings20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImagingSettings20*)p = *(tt__ImagingSettings20*)q;
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImagingSettingsExtension20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImagingSettingsExtension20*)p = *(tt__ImagingSettingsExtension20*)q;
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension202:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImagingSettingsExtension202 type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImagingSettingsExtension202*)p = *(tt__ImagingSettingsExtension202*)q;
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension203:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImagingSettingsExtension203 type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImagingSettingsExtension203*)p = *(tt__ImagingSettingsExtension203*)q;
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension204:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImagingSettingsExtension204 type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImagingSettingsExtension204*)p = *(tt__ImagingSettingsExtension204*)q;
		break;
	case SOAP_TYPE_tt__ImageStabilization:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImageStabilization type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImageStabilization*)p = *(tt__ImageStabilization*)q;
		break;
	case SOAP_TYPE_tt__ImageStabilizationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImageStabilizationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImageStabilizationExtension*)p = *(tt__ImageStabilizationExtension*)q;
		break;
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustment:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IrCutFilterAutoAdjustment type=%d location=%p object=%p\n", t, p, q));
		*(tt__IrCutFilterAutoAdjustment*)p = *(tt__IrCutFilterAutoAdjustment*)q;
		break;
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IrCutFilterAutoAdjustmentExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__IrCutFilterAutoAdjustmentExtension*)p = *(tt__IrCutFilterAutoAdjustmentExtension*)q;
		break;
	case SOAP_TYPE_tt__WideDynamicRange20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__WideDynamicRange20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__WideDynamicRange20*)p = *(tt__WideDynamicRange20*)q;
		break;
	case SOAP_TYPE_tt__BacklightCompensation20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__BacklightCompensation20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__BacklightCompensation20*)p = *(tt__BacklightCompensation20*)q;
		break;
	case SOAP_TYPE_tt__Exposure20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Exposure20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__Exposure20*)p = *(tt__Exposure20*)q;
		break;
	case SOAP_TYPE_tt__ToneCompensation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ToneCompensation type=%d location=%p object=%p\n", t, p, q));
		*(tt__ToneCompensation*)p = *(tt__ToneCompensation*)q;
		break;
	case SOAP_TYPE_tt__ToneCompensationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ToneCompensationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__ToneCompensationExtension*)p = *(tt__ToneCompensationExtension*)q;
		break;
	case SOAP_TYPE_tt__Defogging:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Defogging type=%d location=%p object=%p\n", t, p, q));
		*(tt__Defogging*)p = *(tt__Defogging*)q;
		break;
	case SOAP_TYPE_tt__DefoggingExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DefoggingExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__DefoggingExtension*)p = *(tt__DefoggingExtension*)q;
		break;
	case SOAP_TYPE_tt__NoiseReduction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NoiseReduction type=%d location=%p object=%p\n", t, p, q));
		*(tt__NoiseReduction*)p = *(tt__NoiseReduction*)q;
		break;
	case SOAP_TYPE_tt__ImagingOptions20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImagingOptions20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImagingOptions20*)p = *(tt__ImagingOptions20*)q;
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImagingOptions20Extension type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImagingOptions20Extension*)p = *(tt__ImagingOptions20Extension*)q;
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImagingOptions20Extension2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImagingOptions20Extension2*)p = *(tt__ImagingOptions20Extension2*)q;
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImagingOptions20Extension3 type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImagingOptions20Extension3*)p = *(tt__ImagingOptions20Extension3*)q;
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension4:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImagingOptions20Extension4 type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImagingOptions20Extension4*)p = *(tt__ImagingOptions20Extension4*)q;
		break;
	case SOAP_TYPE_tt__ImageStabilizationOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImageStabilizationOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImageStabilizationOptions*)p = *(tt__ImageStabilizationOptions*)q;
		break;
	case SOAP_TYPE_tt__ImageStabilizationOptionsExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImageStabilizationOptionsExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImageStabilizationOptionsExtension*)p = *(tt__ImageStabilizationOptionsExtension*)q;
		break;
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IrCutFilterAutoAdjustmentOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__IrCutFilterAutoAdjustmentOptions*)p = *(tt__IrCutFilterAutoAdjustmentOptions*)q;
		break;
	case SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IrCutFilterAutoAdjustmentOptionsExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__IrCutFilterAutoAdjustmentOptionsExtension*)p = *(tt__IrCutFilterAutoAdjustmentOptionsExtension*)q;
		break;
	case SOAP_TYPE_tt__WideDynamicRangeOptions20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__WideDynamicRangeOptions20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__WideDynamicRangeOptions20*)p = *(tt__WideDynamicRangeOptions20*)q;
		break;
	case SOAP_TYPE_tt__BacklightCompensationOptions20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__BacklightCompensationOptions20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__BacklightCompensationOptions20*)p = *(tt__BacklightCompensationOptions20*)q;
		break;
	case SOAP_TYPE_tt__ExposureOptions20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ExposureOptions20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__ExposureOptions20*)p = *(tt__ExposureOptions20*)q;
		break;
	case SOAP_TYPE_tt__MoveOptions20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__MoveOptions20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__MoveOptions20*)p = *(tt__MoveOptions20*)q;
		break;
	case SOAP_TYPE_tt__RelativeFocusOptions20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__RelativeFocusOptions20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__RelativeFocusOptions20*)p = *(tt__RelativeFocusOptions20*)q;
		break;
	case SOAP_TYPE_tt__WhiteBalance20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__WhiteBalance20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__WhiteBalance20*)p = *(tt__WhiteBalance20*)q;
		break;
	case SOAP_TYPE_tt__WhiteBalance20Extension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__WhiteBalance20Extension type=%d location=%p object=%p\n", t, p, q));
		*(tt__WhiteBalance20Extension*)p = *(tt__WhiteBalance20Extension*)q;
		break;
	case SOAP_TYPE_tt__FocusConfiguration20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__FocusConfiguration20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__FocusConfiguration20*)p = *(tt__FocusConfiguration20*)q;
		break;
	case SOAP_TYPE_tt__FocusConfiguration20Extension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__FocusConfiguration20Extension type=%d location=%p object=%p\n", t, p, q));
		*(tt__FocusConfiguration20Extension*)p = *(tt__FocusConfiguration20Extension*)q;
		break;
	case SOAP_TYPE_tt__WhiteBalanceOptions20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__WhiteBalanceOptions20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__WhiteBalanceOptions20*)p = *(tt__WhiteBalanceOptions20*)q;
		break;
	case SOAP_TYPE_tt__WhiteBalanceOptions20Extension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__WhiteBalanceOptions20Extension type=%d location=%p object=%p\n", t, p, q));
		*(tt__WhiteBalanceOptions20Extension*)p = *(tt__WhiteBalanceOptions20Extension*)q;
		break;
	case SOAP_TYPE_tt__FocusOptions20:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__FocusOptions20 type=%d location=%p object=%p\n", t, p, q));
		*(tt__FocusOptions20*)p = *(tt__FocusOptions20*)q;
		break;
	case SOAP_TYPE_tt__FocusOptions20Extension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__FocusOptions20Extension type=%d location=%p object=%p\n", t, p, q));
		*(tt__FocusOptions20Extension*)p = *(tt__FocusOptions20Extension*)q;
		break;
	case SOAP_TYPE_tt__ToneCompensationOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ToneCompensationOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__ToneCompensationOptions*)p = *(tt__ToneCompensationOptions*)q;
		break;
	case SOAP_TYPE_tt__DefoggingOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DefoggingOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__DefoggingOptions*)p = *(tt__DefoggingOptions*)q;
		break;
	case SOAP_TYPE_tt__NoiseReductionOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NoiseReductionOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__NoiseReductionOptions*)p = *(tt__NoiseReductionOptions*)q;
		break;
	case SOAP_TYPE_tt__MessageExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__MessageExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__MessageExtension*)p = *(tt__MessageExtension*)q;
		break;
	case SOAP_TYPE__tt__ItemList_SimpleItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tt__ItemList_SimpleItem type=%d location=%p object=%p\n", t, p, q));
		*(_tt__ItemList_SimpleItem*)p = *(_tt__ItemList_SimpleItem*)q;
		break;
	case SOAP_TYPE__tt__ItemList_ElementItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tt__ItemList_ElementItem type=%d location=%p object=%p\n", t, p, q));
		*(_tt__ItemList_ElementItem*)p = *(_tt__ItemList_ElementItem*)q;
		break;
	case SOAP_TYPE_tt__ItemList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ItemList type=%d location=%p object=%p\n", t, p, q));
		*(tt__ItemList*)p = *(tt__ItemList*)q;
		break;
	case SOAP_TYPE_tt__ItemListExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ItemListExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__ItemListExtension*)p = *(tt__ItemListExtension*)q;
		break;
	case SOAP_TYPE_tt__Polyline:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Polyline type=%d location=%p object=%p\n", t, p, q));
		*(tt__Polyline*)p = *(tt__Polyline*)q;
		break;
	case SOAP_TYPE_tt__AnalyticsEngineConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AnalyticsEngineConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__AnalyticsEngineConfiguration*)p = *(tt__AnalyticsEngineConfiguration*)q;
		break;
	case SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AnalyticsEngineConfigurationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__AnalyticsEngineConfigurationExtension*)p = *(tt__AnalyticsEngineConfigurationExtension*)q;
		break;
	case SOAP_TYPE_tt__RuleEngineConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__RuleEngineConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__RuleEngineConfiguration*)p = *(tt__RuleEngineConfiguration*)q;
		break;
	case SOAP_TYPE_tt__RuleEngineConfigurationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__RuleEngineConfigurationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__RuleEngineConfigurationExtension*)p = *(tt__RuleEngineConfigurationExtension*)q;
		break;
	case SOAP_TYPE_tt__Config:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Config type=%d location=%p object=%p\n", t, p, q));
		*(tt__Config*)p = *(tt__Config*)q;
		break;
	case SOAP_TYPE_tt__PolygonOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PolygonOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__PolygonOptions*)p = *(tt__PolygonOptions*)q;
		break;
	case SOAP_TYPE_tt__IntRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IntRange type=%d location=%p object=%p\n", t, p, q));
		*(tt__IntRange*)p = *(tt__IntRange*)q;
		break;
	case SOAP_TYPE_tt__Vector2D:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Vector2D type=%d location=%p object=%p\n", t, p, q));
		*(tt__Vector2D*)p = *(tt__Vector2D*)q;
		break;
	case SOAP_TYPE_tt__Vector1D:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Vector1D type=%d location=%p object=%p\n", t, p, q));
		*(tt__Vector1D*)p = *(tt__Vector1D*)q;
		break;
	case SOAP_TYPE_tt__Vector:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Vector type=%d location=%p object=%p\n", t, p, q));
		*(tt__Vector*)p = *(tt__Vector*)q;
		break;
	case SOAP_TYPE_tt__Rectangle:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Rectangle type=%d location=%p object=%p\n", t, p, q));
		*(tt__Rectangle*)p = *(tt__Rectangle*)q;
		break;
	case SOAP_TYPE_tt__Polygon:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Polygon type=%d location=%p object=%p\n", t, p, q));
		*(tt__Polygon*)p = *(tt__Polygon*)q;
		break;
	case SOAP_TYPE__tt__StringItems:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tt__StringItems type=%d location=%p object=%p\n", t, p, q));
		*(_tt__StringItems*)p = *(_tt__StringItems*)q;
		break;
	case SOAP_TYPE__tt__Message:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tt__Message type=%d location=%p object=%p\n", t, p, q));
		*(_tt__Message*)p = *(_tt__Message*)q;
		break;
	case SOAP_TYPE_wsnt__QueryExpressionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__QueryExpressionType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__QueryExpressionType*)p = *(wsnt__QueryExpressionType*)q;
		break;
	case SOAP_TYPE_wsnt__TopicExpressionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__TopicExpressionType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__TopicExpressionType*)p = *(wsnt__TopicExpressionType*)q;
		break;
	case SOAP_TYPE_wsnt__FilterType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__FilterType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__FilterType*)p = *(wsnt__FilterType*)q;
		break;
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__SubscriptionPolicyType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__SubscriptionPolicyType*)p = *(wsnt__SubscriptionPolicyType*)q;
		break;
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__NotificationMessageHolderType_Message type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__NotificationMessageHolderType_Message*)p = *(_wsnt__NotificationMessageHolderType_Message*)q;
		break;
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__NotificationMessageHolderType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__NotificationMessageHolderType*)p = *(wsnt__NotificationMessageHolderType*)q;
		break;
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__NotificationProducerRP type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__NotificationProducerRP*)p = *(_wsnt__NotificationProducerRP*)q;
		break;
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__SubscriptionManagerRP type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__SubscriptionManagerRP*)p = *(_wsnt__SubscriptionManagerRP*)q;
		break;
	case SOAP_TYPE__wsnt__Notify:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__Notify type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__Notify*)p = *(_wsnt__Notify*)q;
		break;
	case SOAP_TYPE__wsnt__UseRaw:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__UseRaw type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__UseRaw*)p = *(_wsnt__UseRaw*)q;
		break;
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__Subscribe_SubscriptionPolicy type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__Subscribe_SubscriptionPolicy*)p = *(_wsnt__Subscribe_SubscriptionPolicy*)q;
		break;
	case SOAP_TYPE__wsnt__Subscribe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__Subscribe type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__Subscribe*)p = *(_wsnt__Subscribe*)q;
		break;
	case SOAP_TYPE__wsnt__SubscribeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__SubscribeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__SubscribeResponse*)p = *(_wsnt__SubscribeResponse*)q;
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__GetCurrentMessage type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__GetCurrentMessage*)p = *(_wsnt__GetCurrentMessage*)q;
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__GetCurrentMessageResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__GetCurrentMessageResponse*)p = *(_wsnt__GetCurrentMessageResponse*)q;
		break;
	case SOAP_TYPE__wsnt__GetMessages:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__GetMessages type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__GetMessages*)p = *(_wsnt__GetMessages*)q;
		break;
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__GetMessagesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__GetMessagesResponse*)p = *(_wsnt__GetMessagesResponse*)q;
		break;
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__DestroyPullPoint type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__DestroyPullPoint*)p = *(_wsnt__DestroyPullPoint*)q;
		break;
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__DestroyPullPointResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__DestroyPullPointResponse*)p = *(_wsnt__DestroyPullPointResponse*)q;
		break;
	case SOAP_TYPE__wsnt__CreatePullPoint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__CreatePullPoint type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__CreatePullPoint*)p = *(_wsnt__CreatePullPoint*)q;
		break;
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__CreatePullPointResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__CreatePullPointResponse*)p = *(_wsnt__CreatePullPointResponse*)q;
		break;
	case SOAP_TYPE__wsnt__Renew:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__Renew type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__Renew*)p = *(_wsnt__Renew*)q;
		break;
	case SOAP_TYPE__wsnt__RenewResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__RenewResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__RenewResponse*)p = *(_wsnt__RenewResponse*)q;
		break;
	case SOAP_TYPE__wsnt__Unsubscribe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__Unsubscribe type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__Unsubscribe*)p = *(_wsnt__Unsubscribe*)q;
		break;
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__UnsubscribeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__UnsubscribeResponse*)p = *(_wsnt__UnsubscribeResponse*)q;
		break;
	case SOAP_TYPE__wsnt__PauseSubscription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__PauseSubscription type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__PauseSubscription*)p = *(_wsnt__PauseSubscription*)q;
		break;
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__PauseSubscriptionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__PauseSubscriptionResponse*)p = *(_wsnt__PauseSubscriptionResponse*)q;
		break;
	case SOAP_TYPE__wsnt__ResumeSubscription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__ResumeSubscription type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__ResumeSubscription*)p = *(_wsnt__ResumeSubscription*)q;
		break;
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__ResumeSubscriptionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__ResumeSubscriptionResponse*)p = *(_wsnt__ResumeSubscriptionResponse*)q;
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsrfbf__BaseFaultType_ErrorCode type=%d location=%p object=%p\n", t, p, q));
		*(_wsrfbf__BaseFaultType_ErrorCode*)p = *(_wsrfbf__BaseFaultType_ErrorCode*)q;
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsrfbf__BaseFaultType_Description type=%d location=%p object=%p\n", t, p, q));
		*(_wsrfbf__BaseFaultType_Description*)p = *(_wsrfbf__BaseFaultType_Description*)q;
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsrfbf__BaseFaultType_FaultCause type=%d location=%p object=%p\n", t, p, q));
		*(_wsrfbf__BaseFaultType_FaultCause*)p = *(_wsrfbf__BaseFaultType_FaultCause*)q;
		break;
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsrfbf__BaseFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsrfbf__BaseFaultType*)p = *(wsrfbf__BaseFaultType*)q;
		break;
	case SOAP_TYPE_wstop__Documentation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__Documentation type=%d location=%p object=%p\n", t, p, q));
		*(wstop__Documentation*)p = *(wstop__Documentation*)q;
		break;
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__ExtensibleDocumented type=%d location=%p object=%p\n", t, p, q));
		*(wstop__ExtensibleDocumented*)p = *(wstop__ExtensibleDocumented*)q;
		break;
	case SOAP_TYPE_wstop__QueryExpressionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__QueryExpressionType type=%d location=%p object=%p\n", t, p, q));
		*(wstop__QueryExpressionType*)p = *(wstop__QueryExpressionType*)q;
		break;
	case SOAP_TYPE_tt__VideoSourceConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__VideoSourceConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__VideoSourceConfiguration*)p = *(tt__VideoSourceConfiguration*)q;
		break;
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__VideoEncoderConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__VideoEncoderConfiguration*)p = *(tt__VideoEncoderConfiguration*)q;
		break;
	case SOAP_TYPE_tt__AudioSourceConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AudioSourceConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__AudioSourceConfiguration*)p = *(tt__AudioSourceConfiguration*)q;
		break;
	case SOAP_TYPE_tt__AudioEncoderConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AudioEncoderConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__AudioEncoderConfiguration*)p = *(tt__AudioEncoderConfiguration*)q;
		break;
	case SOAP_TYPE_tt__VideoAnalyticsConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__VideoAnalyticsConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__VideoAnalyticsConfiguration*)p = *(tt__VideoAnalyticsConfiguration*)q;
		break;
	case SOAP_TYPE_tt__MetadataConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__MetadataConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__MetadataConfiguration*)p = *(tt__MetadataConfiguration*)q;
		break;
	case SOAP_TYPE_tt__AudioOutputConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AudioOutputConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__AudioOutputConfiguration*)p = *(tt__AudioOutputConfiguration*)q;
		break;
	case SOAP_TYPE_tt__AudioDecoderConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AudioDecoderConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__AudioDecoderConfiguration*)p = *(tt__AudioDecoderConfiguration*)q;
		break;
	case SOAP_TYPE_tt__PTZConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZConfiguration*)p = *(tt__PTZConfiguration*)q;
		break;
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__SubscribeCreationFailedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__SubscribeCreationFailedFaultType*)p = *(wsnt__SubscribeCreationFailedFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__InvalidFilterFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__InvalidFilterFaultType*)p = *(wsnt__InvalidFilterFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__TopicExpressionDialectUnknownFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__TopicExpressionDialectUnknownFaultType*)p = *(wsnt__TopicExpressionDialectUnknownFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__InvalidTopicExpressionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__InvalidTopicExpressionFaultType*)p = *(wsnt__InvalidTopicExpressionFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__TopicNotSupportedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__TopicNotSupportedFaultType*)p = *(wsnt__TopicNotSupportedFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__MultipleTopicsSpecifiedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__MultipleTopicsSpecifiedFaultType*)p = *(wsnt__MultipleTopicsSpecifiedFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__InvalidProducerPropertiesExpressionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__InvalidProducerPropertiesExpressionFaultType*)p = *(wsnt__InvalidProducerPropertiesExpressionFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__InvalidMessageContentExpressionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__InvalidMessageContentExpressionFaultType*)p = *(wsnt__InvalidMessageContentExpressionFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnrecognizedPolicyRequestFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnrecognizedPolicyRequestFaultType*)p = *(wsnt__UnrecognizedPolicyRequestFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnsupportedPolicyRequestFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnsupportedPolicyRequestFaultType*)p = *(wsnt__UnsupportedPolicyRequestFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__NotifyMessageNotSupportedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__NotifyMessageNotSupportedFaultType*)p = *(wsnt__NotifyMessageNotSupportedFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnacceptableInitialTerminationTimeFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnacceptableInitialTerminationTimeFaultType*)p = *(wsnt__UnacceptableInitialTerminationTimeFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__NoCurrentMessageOnTopicFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__NoCurrentMessageOnTopicFaultType*)p = *(wsnt__NoCurrentMessageOnTopicFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnableToGetMessagesFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnableToGetMessagesFaultType*)p = *(wsnt__UnableToGetMessagesFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnableToDestroyPullPointFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnableToDestroyPullPointFaultType*)p = *(wsnt__UnableToDestroyPullPointFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnableToCreatePullPointFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnableToCreatePullPointFaultType*)p = *(wsnt__UnableToCreatePullPointFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnacceptableTerminationTimeFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnacceptableTerminationTimeFaultType*)p = *(wsnt__UnacceptableTerminationTimeFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnableToDestroySubscriptionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnableToDestroySubscriptionFaultType*)p = *(wsnt__UnableToDestroySubscriptionFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__PauseFailedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__PauseFailedFaultType*)p = *(wsnt__PauseFailedFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__ResumeFailedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__ResumeFailedFaultType*)p = *(wsnt__ResumeFailedFaultType*)q;
		break;
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wstop__TopicNamespaceType_Topic type=%d location=%p object=%p\n", t, p, q));
		*(_wstop__TopicNamespaceType_Topic*)p = *(_wstop__TopicNamespaceType_Topic*)q;
		break;
	case SOAP_TYPE_wstop__TopicNamespaceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__TopicNamespaceType type=%d location=%p object=%p\n", t, p, q));
		*(wstop__TopicNamespaceType*)p = *(wstop__TopicNamespaceType*)q;
		break;
	case SOAP_TYPE_wstop__TopicType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__TopicType type=%d location=%p object=%p\n", t, p, q));
		*(wstop__TopicType*)p = *(wstop__TopicType*)q;
		break;
	case SOAP_TYPE_wstop__TopicSetType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__TopicSetType type=%d location=%p object=%p\n", t, p, q));
		*(wstop__TopicSetType*)p = *(wstop__TopicSetType*)q;
		break;
	case SOAP_TYPE___timg__GetServiceCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __timg__GetServiceCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(struct __timg__GetServiceCapabilities*)p = *(struct __timg__GetServiceCapabilities*)q;
		break;
	case SOAP_TYPE___timg__GetImagingSettings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __timg__GetImagingSettings type=%d location=%p object=%p\n", t, p, q));
		*(struct __timg__GetImagingSettings*)p = *(struct __timg__GetImagingSettings*)q;
		break;
	case SOAP_TYPE___timg__SetImagingSettings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __timg__SetImagingSettings type=%d location=%p object=%p\n", t, p, q));
		*(struct __timg__SetImagingSettings*)p = *(struct __timg__SetImagingSettings*)q;
		break;
	case SOAP_TYPE___timg__GetOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __timg__GetOptions type=%d location=%p object=%p\n", t, p, q));
		*(struct __timg__GetOptions*)p = *(struct __timg__GetOptions*)q;
		break;
	case SOAP_TYPE___timg__Move:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __timg__Move type=%d location=%p object=%p\n", t, p, q));
		*(struct __timg__Move*)p = *(struct __timg__Move*)q;
		break;
	case SOAP_TYPE___timg__Stop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __timg__Stop type=%d location=%p object=%p\n", t, p, q));
		*(struct __timg__Stop*)p = *(struct __timg__Stop*)q;
		break;
	case SOAP_TYPE___timg__GetStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __timg__GetStatus type=%d location=%p object=%p\n", t, p, q));
		*(struct __timg__GetStatus*)p = *(struct __timg__GetStatus*)q;
		break;
	case SOAP_TYPE___timg__GetMoveOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __timg__GetMoveOptions type=%d location=%p object=%p\n", t, p, q));
		*(struct __timg__GetMoveOptions*)p = *(struct __timg__GetMoveOptions*)q;
		break;
	case SOAP_TYPE___timg__GetPresets:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __timg__GetPresets type=%d location=%p object=%p\n", t, p, q));
		*(struct __timg__GetPresets*)p = *(struct __timg__GetPresets*)q;
		break;
	case SOAP_TYPE___timg__GetCurrentPreset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __timg__GetCurrentPreset type=%d location=%p object=%p\n", t, p, q));
		*(struct __timg__GetCurrentPreset*)p = *(struct __timg__GetCurrentPreset*)q;
		break;
	case SOAP_TYPE___timg__SetCurrentPreset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __timg__SetCurrentPreset type=%d location=%p object=%p\n", t, p, q));
		*(struct __timg__SetCurrentPreset*)p = *(struct __timg__SetCurrentPreset*)q;
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE__wsa5__Metadata:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__MetadataType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__RelatesToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__From:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ProblemActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
		break;
	case SOAP_TYPE_xsd__QName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__NCName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__anyURI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__duration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__integer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__token:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__xml__lang:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__IntList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__FloatList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__StringAttrList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__StringList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__Name:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__IPv4Address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__IPv6Address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__ReferenceToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	a = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return a;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_new_float(struct soap *soap, int n)
{
	float *a = static_cast<float *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(float)));
	for (float *p = a; p && n--; ++p)
		soap_default_float(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	if (soap_out_float(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *a = static_cast<double *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(double)));
	for (double *p = a; p && n--; ++p)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *a = static_cast<unsigned char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned char)));
	for (unsigned char *p = a; p && n--; ++p)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RetryAfter(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RetryAfter(soap, tag ? tag : "wsa5:RetryAfter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_ULONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_ULONG64);
	return a;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_new_ULONG64(struct soap *soap, int n)
{
	ULONG64 *a = static_cast<ULONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(ULONG64)));
	for (ULONG64 *p = a; p && n--; ++p)
		soap_default_ULONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__MoveStatus[] =
{	{ (LONG64)tt__MoveStatus__IDLE, "IDLE" },
	{ (LONG64)tt__MoveStatus__MOVING, "MOVING" },
	{ (LONG64)tt__MoveStatus__UNKNOWN, "UNKNOWN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__MoveStatus2s(struct soap *soap, enum tt__MoveStatus n)
{
	const char *s = soap_code_str(soap_codes_tt__MoveStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveStatus(struct soap *soap, const char *tag, int id, const enum tt__MoveStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveStatus), type) || soap_send(soap, soap_tt__MoveStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__MoveStatus(struct soap *soap, const char *s, enum tt__MoveStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__MoveStatus, s);
	if (map)
		*a = (enum tt__MoveStatus)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__MoveStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_in_tt__MoveStatus(struct soap *soap, const char *tag, enum tt__MoveStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__MoveStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__MoveStatus(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__MoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveStatus, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_new_tt__MoveStatus(struct soap *soap, int n)
{
	enum tt__MoveStatus *a = static_cast<enum tt__MoveStatus *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__MoveStatus)));
	for (enum tt__MoveStatus *p = a; p && n--; ++p)
		soap_default_tt__MoveStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MoveStatus(struct soap *soap, const enum tt__MoveStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__MoveStatus(soap, tag ? tag : "tt:MoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_get_tt__MoveStatus(struct soap *soap, enum tt__MoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__PropertyOperation[] =
{	{ (LONG64)tt__PropertyOperation__Initialized, "Initialized" },
	{ (LONG64)tt__PropertyOperation__Deleted, "Deleted" },
	{ (LONG64)tt__PropertyOperation__Changed, "Changed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__PropertyOperation2s(struct soap *soap, enum tt__PropertyOperation n)
{
	const char *s = soap_code_str(soap_codes_tt__PropertyOperation, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PropertyOperation(struct soap *soap, const char *tag, int id, const enum tt__PropertyOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PropertyOperation), type) || soap_send(soap, soap_tt__PropertyOperation2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__PropertyOperation(struct soap *soap, const char *s, enum tt__PropertyOperation *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__PropertyOperation, s);
	if (map)
		*a = (enum tt__PropertyOperation)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__PropertyOperation)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_in_tt__PropertyOperation(struct soap *soap, const char *tag, enum tt__PropertyOperation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__PropertyOperation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__PropertyOperation(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__PropertyOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PropertyOperation, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_new_tt__PropertyOperation(struct soap *soap, int n)
{
	enum tt__PropertyOperation *a = static_cast<enum tt__PropertyOperation *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__PropertyOperation)));
	for (enum tt__PropertyOperation *p = a; p && n--; ++p)
		soap_default_tt__PropertyOperation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PropertyOperation(struct soap *soap, const enum tt__PropertyOperation *a, const char *tag, const char *type)
{
	if (soap_out_tt__PropertyOperation(soap, tag ? tag : "tt:PropertyOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_get_tt__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ImageStabilizationMode[] =
{	{ (LONG64)tt__ImageStabilizationMode__OFF, "OFF" },
	{ (LONG64)tt__ImageStabilizationMode__ON, "ON" },
	{ (LONG64)tt__ImageStabilizationMode__AUTO, "AUTO" },
	{ (LONG64)tt__ImageStabilizationMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ImageStabilizationMode2s(struct soap *soap, enum tt__ImageStabilizationMode n)
{
	const char *s = soap_code_str(soap_codes_tt__ImageStabilizationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationMode(struct soap *soap, const char *tag, int id, const enum tt__ImageStabilizationMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationMode), type) || soap_send(soap, soap_tt__ImageStabilizationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ImageStabilizationMode(struct soap *soap, const char *s, enum tt__ImageStabilizationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ImageStabilizationMode, s);
	if (map)
		*a = (enum tt__ImageStabilizationMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ImageStabilizationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ImageStabilizationMode * SOAP_FMAC4 soap_in_tt__ImageStabilizationMode(struct soap *soap, const char *tag, enum tt__ImageStabilizationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ImageStabilizationMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationMode, sizeof(enum tt__ImageStabilizationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ImageStabilizationMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ImageStabilizationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationMode, SOAP_TYPE_tt__ImageStabilizationMode, sizeof(enum tt__ImageStabilizationMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ImageStabilizationMode * SOAP_FMAC4 soap_new_tt__ImageStabilizationMode(struct soap *soap, int n)
{
	enum tt__ImageStabilizationMode *a = static_cast<enum tt__ImageStabilizationMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ImageStabilizationMode)));
	for (enum tt__ImageStabilizationMode *p = a; p && n--; ++p)
		soap_default_tt__ImageStabilizationMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImageStabilizationMode(struct soap *soap, const enum tt__ImageStabilizationMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImageStabilizationMode(soap, tag ? tag : "tt:ImageStabilizationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ImageStabilizationMode * SOAP_FMAC4 soap_get_tt__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IrCutFilterMode[] =
{	{ (LONG64)tt__IrCutFilterMode__ON, "ON" },
	{ (LONG64)tt__IrCutFilterMode__OFF, "OFF" },
	{ (LONG64)tt__IrCutFilterMode__AUTO, "AUTO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IrCutFilterMode2s(struct soap *soap, enum tt__IrCutFilterMode n)
{
	const char *s = soap_code_str(soap_codes_tt__IrCutFilterMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterMode(struct soap *soap, const char *tag, int id, const enum tt__IrCutFilterMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterMode), type) || soap_send(soap, soap_tt__IrCutFilterMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IrCutFilterMode(struct soap *soap, const char *s, enum tt__IrCutFilterMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IrCutFilterMode, s);
	if (map)
		*a = (enum tt__IrCutFilterMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IrCutFilterMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IrCutFilterMode * SOAP_FMAC4 soap_in_tt__IrCutFilterMode(struct soap *soap, const char *tag, enum tt__IrCutFilterMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IrCutFilterMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__IrCutFilterMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__IrCutFilterMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterMode, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IrCutFilterMode * SOAP_FMAC4 soap_new_tt__IrCutFilterMode(struct soap *soap, int n)
{
	enum tt__IrCutFilterMode *a = static_cast<enum tt__IrCutFilterMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IrCutFilterMode)));
	for (enum tt__IrCutFilterMode *p = a; p && n--; ++p)
		soap_default_tt__IrCutFilterMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IrCutFilterMode(struct soap *soap, const enum tt__IrCutFilterMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__IrCutFilterMode(soap, tag ? tag : "tt:IrCutFilterMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IrCutFilterMode * SOAP_FMAC4 soap_get_tt__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__WhiteBalanceMode[] =
{	{ (LONG64)tt__WhiteBalanceMode__AUTO, "AUTO" },
	{ (LONG64)tt__WhiteBalanceMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__WhiteBalanceMode2s(struct soap *soap, enum tt__WhiteBalanceMode n)
{
	const char *s = soap_code_str(soap_codes_tt__WhiteBalanceMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceMode(struct soap *soap, const char *tag, int id, const enum tt__WhiteBalanceMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceMode), type) || soap_send(soap, soap_tt__WhiteBalanceMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__WhiteBalanceMode(struct soap *soap, const char *s, enum tt__WhiteBalanceMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__WhiteBalanceMode, s);
	if (map)
		*a = (enum tt__WhiteBalanceMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__WhiteBalanceMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__WhiteBalanceMode * SOAP_FMAC4 soap_in_tt__WhiteBalanceMode(struct soap *soap, const char *tag, enum tt__WhiteBalanceMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__WhiteBalanceMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__WhiteBalanceMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__WhiteBalanceMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceMode, SOAP_TYPE_tt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__WhiteBalanceMode * SOAP_FMAC4 soap_new_tt__WhiteBalanceMode(struct soap *soap, int n)
{
	enum tt__WhiteBalanceMode *a = static_cast<enum tt__WhiteBalanceMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__WhiteBalanceMode)));
	for (enum tt__WhiteBalanceMode *p = a; p && n--; ++p)
		soap_default_tt__WhiteBalanceMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalanceMode(struct soap *soap, const enum tt__WhiteBalanceMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__WhiteBalanceMode(soap, tag ? tag : "tt:WhiteBalanceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__WhiteBalanceMode * SOAP_FMAC4 soap_get_tt__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ExposureMode[] =
{	{ (LONG64)tt__ExposureMode__AUTO, "AUTO" },
	{ (LONG64)tt__ExposureMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ExposureMode2s(struct soap *soap, enum tt__ExposureMode n)
{
	const char *s = soap_code_str(soap_codes_tt__ExposureMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureMode(struct soap *soap, const char *tag, int id, const enum tt__ExposureMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureMode), type) || soap_send(soap, soap_tt__ExposureMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ExposureMode(struct soap *soap, const char *s, enum tt__ExposureMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ExposureMode, s);
	if (map)
		*a = (enum tt__ExposureMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ExposureMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ExposureMode * SOAP_FMAC4 soap_in_tt__ExposureMode(struct soap *soap, const char *tag, enum tt__ExposureMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ExposureMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureMode, sizeof(enum tt__ExposureMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ExposureMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ExposureMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureMode, SOAP_TYPE_tt__ExposureMode, sizeof(enum tt__ExposureMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ExposureMode * SOAP_FMAC4 soap_new_tt__ExposureMode(struct soap *soap, int n)
{
	enum tt__ExposureMode *a = static_cast<enum tt__ExposureMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ExposureMode)));
	for (enum tt__ExposureMode *p = a; p && n--; ++p)
		soap_default_tt__ExposureMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposureMode(struct soap *soap, const enum tt__ExposureMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__ExposureMode(soap, tag ? tag : "tt:ExposureMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposureMode * SOAP_FMAC4 soap_get_tt__ExposureMode(struct soap *soap, enum tt__ExposureMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ExposurePriority[] =
{	{ (LONG64)tt__ExposurePriority__LowNoise, "LowNoise" },
	{ (LONG64)tt__ExposurePriority__FrameRate, "FrameRate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ExposurePriority2s(struct soap *soap, enum tt__ExposurePriority n)
{
	const char *s = soap_code_str(soap_codes_tt__ExposurePriority, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposurePriority(struct soap *soap, const char *tag, int id, const enum tt__ExposurePriority *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposurePriority), type) || soap_send(soap, soap_tt__ExposurePriority2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ExposurePriority(struct soap *soap, const char *s, enum tt__ExposurePriority *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ExposurePriority, s);
	if (map)
		*a = (enum tt__ExposurePriority)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ExposurePriority)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ExposurePriority * SOAP_FMAC4 soap_in_tt__ExposurePriority(struct soap *soap, const char *tag, enum tt__ExposurePriority *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ExposurePriority*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ExposurePriority(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ExposurePriority *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposurePriority, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ExposurePriority * SOAP_FMAC4 soap_new_tt__ExposurePriority(struct soap *soap, int n)
{
	enum tt__ExposurePriority *a = static_cast<enum tt__ExposurePriority *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ExposurePriority)));
	for (enum tt__ExposurePriority *p = a; p && n--; ++p)
		soap_default_tt__ExposurePriority(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposurePriority(struct soap *soap, const enum tt__ExposurePriority *a, const char *tag, const char *type)
{
	if (soap_out_tt__ExposurePriority(soap, tag ? tag : "tt:ExposurePriority", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposurePriority * SOAP_FMAC4 soap_get_tt__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposurePriority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__BacklightCompensationMode[] =
{	{ (LONG64)tt__BacklightCompensationMode__OFF, "OFF" },
	{ (LONG64)tt__BacklightCompensationMode__ON, "ON" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__BacklightCompensationMode2s(struct soap *soap, enum tt__BacklightCompensationMode n)
{
	const char *s = soap_code_str(soap_codes_tt__BacklightCompensationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationMode(struct soap *soap, const char *tag, int id, const enum tt__BacklightCompensationMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationMode), type) || soap_send(soap, soap_tt__BacklightCompensationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__BacklightCompensationMode(struct soap *soap, const char *s, enum tt__BacklightCompensationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__BacklightCompensationMode, s);
	if (map)
		*a = (enum tt__BacklightCompensationMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__BacklightCompensationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__BacklightCompensationMode * SOAP_FMAC4 soap_in_tt__BacklightCompensationMode(struct soap *soap, const char *tag, enum tt__BacklightCompensationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__BacklightCompensationMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__BacklightCompensationMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__BacklightCompensationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationMode, SOAP_TYPE_tt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__BacklightCompensationMode * SOAP_FMAC4 soap_new_tt__BacklightCompensationMode(struct soap *soap, int n)
{
	enum tt__BacklightCompensationMode *a = static_cast<enum tt__BacklightCompensationMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__BacklightCompensationMode)));
	for (enum tt__BacklightCompensationMode *p = a; p && n--; ++p)
		soap_default_tt__BacklightCompensationMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensationMode(struct soap *soap, const enum tt__BacklightCompensationMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__BacklightCompensationMode(soap, tag ? tag : "tt:BacklightCompensationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__BacklightCompensationMode * SOAP_FMAC4 soap_get_tt__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__WideDynamicMode[] =
{	{ (LONG64)tt__WideDynamicMode__OFF, "OFF" },
	{ (LONG64)tt__WideDynamicMode__ON, "ON" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__WideDynamicMode2s(struct soap *soap, enum tt__WideDynamicMode n)
{
	const char *s = soap_code_str(soap_codes_tt__WideDynamicMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicMode(struct soap *soap, const char *tag, int id, const enum tt__WideDynamicMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicMode), type) || soap_send(soap, soap_tt__WideDynamicMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__WideDynamicMode(struct soap *soap, const char *s, enum tt__WideDynamicMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__WideDynamicMode, s);
	if (map)
		*a = (enum tt__WideDynamicMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__WideDynamicMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__WideDynamicMode * SOAP_FMAC4 soap_in_tt__WideDynamicMode(struct soap *soap, const char *tag, enum tt__WideDynamicMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__WideDynamicMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__WideDynamicMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__WideDynamicMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicMode, SOAP_TYPE_tt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__WideDynamicMode * SOAP_FMAC4 soap_new_tt__WideDynamicMode(struct soap *soap, int n)
{
	enum tt__WideDynamicMode *a = static_cast<enum tt__WideDynamicMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__WideDynamicMode)));
	for (enum tt__WideDynamicMode *p = a; p && n--; ++p)
		soap_default_tt__WideDynamicMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicMode(struct soap *soap, const enum tt__WideDynamicMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__WideDynamicMode(soap, tag ? tag : "tt:WideDynamicMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__WideDynamicMode * SOAP_FMAC4 soap_get_tt__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__AutoFocusMode[] =
{	{ (LONG64)tt__AutoFocusMode__AUTO, "AUTO" },
	{ (LONG64)tt__AutoFocusMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AutoFocusMode2s(struct soap *soap, enum tt__AutoFocusMode n)
{
	const char *s = soap_code_str(soap_codes_tt__AutoFocusMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AutoFocusMode(struct soap *soap, const char *tag, int id, const enum tt__AutoFocusMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AutoFocusMode), type) || soap_send(soap, soap_tt__AutoFocusMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AutoFocusMode(struct soap *soap, const char *s, enum tt__AutoFocusMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__AutoFocusMode, s);
	if (map)
		*a = (enum tt__AutoFocusMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__AutoFocusMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AutoFocusMode * SOAP_FMAC4 soap_in_tt__AutoFocusMode(struct soap *soap, const char *tag, enum tt__AutoFocusMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__AutoFocusMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__AutoFocusMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__AutoFocusMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AutoFocusMode, SOAP_TYPE_tt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__AutoFocusMode * SOAP_FMAC4 soap_new_tt__AutoFocusMode(struct soap *soap, int n)
{
	enum tt__AutoFocusMode *a = static_cast<enum tt__AutoFocusMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__AutoFocusMode)));
	for (enum tt__AutoFocusMode *p = a; p && n--; ++p)
		soap_default_tt__AutoFocusMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AutoFocusMode(struct soap *soap, const enum tt__AutoFocusMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__AutoFocusMode(soap, tag ? tag : "tt:AutoFocusMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AutoFocusMode * SOAP_FMAC4 soap_get_tt__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AutoFocusMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ReverseMode[] =
{	{ (LONG64)tt__ReverseMode__OFF, "OFF" },
	{ (LONG64)tt__ReverseMode__ON, "ON" },
	{ (LONG64)tt__ReverseMode__AUTO, "AUTO" },
	{ (LONG64)tt__ReverseMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ReverseMode2s(struct soap *soap, enum tt__ReverseMode n)
{
	const char *s = soap_code_str(soap_codes_tt__ReverseMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseMode(struct soap *soap, const char *tag, int id, const enum tt__ReverseMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReverseMode), type) || soap_send(soap, soap_tt__ReverseMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ReverseMode(struct soap *soap, const char *s, enum tt__ReverseMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ReverseMode, s);
	if (map)
		*a = (enum tt__ReverseMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ReverseMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_in_tt__ReverseMode(struct soap *soap, const char *tag, enum tt__ReverseMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ReverseMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseMode, sizeof(enum tt__ReverseMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ReverseMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ReverseMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseMode, SOAP_TYPE_tt__ReverseMode, sizeof(enum tt__ReverseMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_new_tt__ReverseMode(struct soap *soap, int n)
{
	enum tt__ReverseMode *a = static_cast<enum tt__ReverseMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ReverseMode)));
	for (enum tt__ReverseMode *p = a; p && n--; ++p)
		soap_default_tt__ReverseMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReverseMode(struct soap *soap, const enum tt__ReverseMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReverseMode(soap, tag ? tag : "tt:ReverseMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_get_tt__ReverseMode(struct soap *soap, enum tt__ReverseMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__EFlipMode[] =
{	{ (LONG64)tt__EFlipMode__OFF, "OFF" },
	{ (LONG64)tt__EFlipMode__ON, "ON" },
	{ (LONG64)tt__EFlipMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__EFlipMode2s(struct soap *soap, enum tt__EFlipMode n)
{
	const char *s = soap_code_str(soap_codes_tt__EFlipMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipMode(struct soap *soap, const char *tag, int id, const enum tt__EFlipMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlipMode), type) || soap_send(soap, soap_tt__EFlipMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__EFlipMode(struct soap *soap, const char *s, enum tt__EFlipMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__EFlipMode, s);
	if (map)
		*a = (enum tt__EFlipMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__EFlipMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_in_tt__EFlipMode(struct soap *soap, const char *tag, enum tt__EFlipMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__EFlipMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipMode, sizeof(enum tt__EFlipMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__EFlipMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__EFlipMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipMode, SOAP_TYPE_tt__EFlipMode, sizeof(enum tt__EFlipMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_new_tt__EFlipMode(struct soap *soap, int n)
{
	enum tt__EFlipMode *a = static_cast<enum tt__EFlipMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__EFlipMode)));
	for (enum tt__EFlipMode *p = a; p && n--; ++p)
		soap_default_tt__EFlipMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EFlipMode(struct soap *soap, const enum tt__EFlipMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__EFlipMode(soap, tag ? tag : "tt:EFlipMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_get_tt__EFlipMode(struct soap *soap, enum tt__EFlipMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IPType[] =
{	{ (LONG64)tt__IPType__IPv4, "IPv4" },
	{ (LONG64)tt__IPType__IPv6, "IPv6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPType2s(struct soap *soap, enum tt__IPType n)
{
	const char *s = soap_code_str(soap_codes_tt__IPType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPType(struct soap *soap, const char *tag, int id, const enum tt__IPType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPType), type) || soap_send(soap, soap_tt__IPType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPType(struct soap *soap, const char *s, enum tt__IPType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPType, s);
	if (map)
		*a = (enum tt__IPType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_in_tt__IPType(struct soap *soap, const char *tag, enum tt__IPType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__IPType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__IPType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPType, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_new_tt__IPType(struct soap *soap, int n)
{
	enum tt__IPType *a = static_cast<enum tt__IPType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IPType)));
	for (enum tt__IPType *p = a; p && n--; ++p)
		soap_default_tt__IPType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPType(struct soap *soap, const enum tt__IPType *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPType(soap, tag ? tag : "tt:IPType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_get_tt__IPType(struct soap *soap, enum tt__IPType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__AudioEncoding[] =
{	{ (LONG64)tt__AudioEncoding__G711, "G711" },
	{ (LONG64)tt__AudioEncoding__G726, "G726" },
	{ (LONG64)tt__AudioEncoding__AAC, "AAC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AudioEncoding2s(struct soap *soap, enum tt__AudioEncoding n)
{
	const char *s = soap_code_str(soap_codes_tt__AudioEncoding, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoding(struct soap *soap, const char *tag, int id, const enum tt__AudioEncoding *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoding), type) || soap_send(soap, soap_tt__AudioEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AudioEncoding(struct soap *soap, const char *s, enum tt__AudioEncoding *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__AudioEncoding, s);
	if (map)
		*a = (enum tt__AudioEncoding)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__AudioEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_in_tt__AudioEncoding(struct soap *soap, const char *tag, enum tt__AudioEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__AudioEncoding*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoding, sizeof(enum tt__AudioEncoding), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__AudioEncoding(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__AudioEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoding, SOAP_TYPE_tt__AudioEncoding, sizeof(enum tt__AudioEncoding), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_new_tt__AudioEncoding(struct soap *soap, int n)
{
	enum tt__AudioEncoding *a = static_cast<enum tt__AudioEncoding *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__AudioEncoding)));
	for (enum tt__AudioEncoding *p = a; p && n--; ++p)
		soap_default_tt__AudioEncoding(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoding(struct soap *soap, const enum tt__AudioEncoding *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncoding(soap, tag ? tag : "tt:AudioEncoding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_get_tt__AudioEncoding(struct soap *soap, enum tt__AudioEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__H264Profile[] =
{	{ (LONG64)tt__H264Profile__Baseline, "Baseline" },
	{ (LONG64)tt__H264Profile__Main, "Main" },
	{ (LONG64)tt__H264Profile__Extended, "Extended" },
	{ (LONG64)tt__H264Profile__High, "High" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__H264Profile2s(struct soap *soap, enum tt__H264Profile n)
{
	const char *s = soap_code_str(soap_codes_tt__H264Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Profile(struct soap *soap, const char *tag, int id, const enum tt__H264Profile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Profile), type) || soap_send(soap, soap_tt__H264Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__H264Profile(struct soap *soap, const char *s, enum tt__H264Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__H264Profile, s);
	if (map)
		*a = (enum tt__H264Profile)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__H264Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_in_tt__H264Profile(struct soap *soap, const char *tag, enum tt__H264Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__H264Profile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__H264Profile(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__H264Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Profile, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_new_tt__H264Profile(struct soap *soap, int n)
{
	enum tt__H264Profile *a = static_cast<enum tt__H264Profile *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__H264Profile)));
	for (enum tt__H264Profile *p = a; p && n--; ++p)
		soap_default_tt__H264Profile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Profile(struct soap *soap, const enum tt__H264Profile *a, const char *tag, const char *type)
{
	if (soap_out_tt__H264Profile(soap, tag ? tag : "tt:H264Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_get_tt__H264Profile(struct soap *soap, enum tt__H264Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Mpeg4Profile[] =
{	{ (LONG64)tt__Mpeg4Profile__SP, "SP" },
	{ (LONG64)tt__Mpeg4Profile__ASP, "ASP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Mpeg4Profile2s(struct soap *soap, enum tt__Mpeg4Profile n)
{
	const char *s = soap_code_str(soap_codes_tt__Mpeg4Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Profile(struct soap *soap, const char *tag, int id, const enum tt__Mpeg4Profile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Profile), type) || soap_send(soap, soap_tt__Mpeg4Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Mpeg4Profile(struct soap *soap, const char *s, enum tt__Mpeg4Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Mpeg4Profile, s);
	if (map)
		*a = (enum tt__Mpeg4Profile)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Mpeg4Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_in_tt__Mpeg4Profile(struct soap *soap, const char *tag, enum tt__Mpeg4Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Mpeg4Profile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Mpeg4Profile(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Mpeg4Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Profile, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_new_tt__Mpeg4Profile(struct soap *soap, int n)
{
	enum tt__Mpeg4Profile *a = static_cast<enum tt__Mpeg4Profile *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Mpeg4Profile)));
	for (enum tt__Mpeg4Profile *p = a; p && n--; ++p)
		soap_default_tt__Mpeg4Profile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Profile(struct soap *soap, const enum tt__Mpeg4Profile *a, const char *tag, const char *type)
{
	if (soap_out_tt__Mpeg4Profile(soap, tag ? tag : "tt:Mpeg4Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_get_tt__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__VideoEncoding[] =
{	{ (LONG64)tt__VideoEncoding__JPEG, "JPEG" },
	{ (LONG64)tt__VideoEncoding__MPEG4, "MPEG4" },
	{ (LONG64)tt__VideoEncoding__H264, "H264" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncoding2s(struct soap *soap, enum tt__VideoEncoding n)
{
	const char *s = soap_code_str(soap_codes_tt__VideoEncoding, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoding(struct soap *soap, const char *tag, int id, const enum tt__VideoEncoding *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoding), type) || soap_send(soap, soap_tt__VideoEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncoding(struct soap *soap, const char *s, enum tt__VideoEncoding *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__VideoEncoding, s);
	if (map)
		*a = (enum tt__VideoEncoding)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__VideoEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_in_tt__VideoEncoding(struct soap *soap, const char *tag, enum tt__VideoEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__VideoEncoding*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__VideoEncoding(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__VideoEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoding, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_new_tt__VideoEncoding(struct soap *soap, int n)
{
	enum tt__VideoEncoding *a = static_cast<enum tt__VideoEncoding *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__VideoEncoding)));
	for (enum tt__VideoEncoding *p = a; p && n--; ++p)
		soap_default_tt__VideoEncoding(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoding(struct soap *soap, const enum tt__VideoEncoding *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoding(soap, tag ? tag : "tt:VideoEncoding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_get_tt__VideoEncoding(struct soap *soap, enum tt__VideoEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__SceneOrientationMode[] =
{	{ (LONG64)tt__SceneOrientationMode__MANUAL, "MANUAL" },
	{ (LONG64)tt__SceneOrientationMode__AUTO, "AUTO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SceneOrientationMode2s(struct soap *soap, enum tt__SceneOrientationMode n)
{
	const char *s = soap_code_str(soap_codes_tt__SceneOrientationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientationMode(struct soap *soap, const char *tag, int id, const enum tt__SceneOrientationMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SceneOrientationMode), type) || soap_send(soap, soap_tt__SceneOrientationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SceneOrientationMode(struct soap *soap, const char *s, enum tt__SceneOrientationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SceneOrientationMode, s);
	if (map)
		*a = (enum tt__SceneOrientationMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SceneOrientationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SceneOrientationMode * SOAP_FMAC4 soap_in_tt__SceneOrientationMode(struct soap *soap, const char *tag, enum tt__SceneOrientationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SceneOrientationMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientationMode, sizeof(enum tt__SceneOrientationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__SceneOrientationMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__SceneOrientationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SceneOrientationMode, SOAP_TYPE_tt__SceneOrientationMode, sizeof(enum tt__SceneOrientationMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__SceneOrientationMode * SOAP_FMAC4 soap_new_tt__SceneOrientationMode(struct soap *soap, int n)
{
	enum tt__SceneOrientationMode *a = static_cast<enum tt__SceneOrientationMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__SceneOrientationMode)));
	for (enum tt__SceneOrientationMode *p = a; p && n--; ++p)
		soap_default_tt__SceneOrientationMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SceneOrientationMode(struct soap *soap, const enum tt__SceneOrientationMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__SceneOrientationMode(soap, tag ? tag : "tt:SceneOrientationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SceneOrientationMode * SOAP_FMAC4 soap_get_tt__SceneOrientationMode(struct soap *soap, enum tt__SceneOrientationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SceneOrientationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RotateMode[] =
{	{ (LONG64)tt__RotateMode__OFF, "OFF" },
	{ (LONG64)tt__RotateMode__ON, "ON" },
	{ (LONG64)tt__RotateMode__AUTO, "AUTO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RotateMode2s(struct soap *soap, enum tt__RotateMode n)
{
	const char *s = soap_code_str(soap_codes_tt__RotateMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateMode(struct soap *soap, const char *tag, int id, const enum tt__RotateMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateMode), type) || soap_send(soap, soap_tt__RotateMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RotateMode(struct soap *soap, const char *s, enum tt__RotateMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RotateMode, s);
	if (map)
		*a = (enum tt__RotateMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RotateMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_in_tt__RotateMode(struct soap *soap, const char *tag, enum tt__RotateMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RotateMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__RotateMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__RotateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateMode, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_new_tt__RotateMode(struct soap *soap, int n)
{
	enum tt__RotateMode *a = static_cast<enum tt__RotateMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RotateMode)));
	for (enum tt__RotateMode *p = a; p && n--; ++p)
		soap_default_tt__RotateMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RotateMode(struct soap *soap, const enum tt__RotateMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__RotateMode(soap, tag ? tag : "tt:RotateMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_get_tt__RotateMode(struct soap *soap, enum tt__RotateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (LONG64)_wsa5__IsReferenceParameter__false, "false" },
	{ (LONG64)_wsa5__IsReferenceParameter__true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{
	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, s);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_new__wsa5__IsReferenceParameter(struct soap *soap, int n)
{
	enum _wsa5__IsReferenceParameter *a = static_cast<enum _wsa5__IsReferenceParameter *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _wsa5__IsReferenceParameter)));
	for (enum _wsa5__IsReferenceParameter *p = a; p && n--; ++p)
		soap_default__wsa5__IsReferenceParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__IsReferenceParameter(soap, tag ? tag : "wsa5:IsReferenceParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (LONG64)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (LONG64)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (LONG64)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (LONG64)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (LONG64)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (LONG64)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (LONG64)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (LONG64)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (LONG64)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (LONG64)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (LONG64)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 10)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_new_wsa5__FaultCodesType(struct soap *soap, int n)
{
	enum wsa5__FaultCodesType *a = static_cast<enum wsa5__FaultCodesType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__FaultCodesType)));
	for (enum wsa5__FaultCodesType *p = a; p && n--; ++p)
		soap_default_wsa5__FaultCodesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesType(soap, tag ? tag : "wsa5:FaultCodesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (LONG64)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__RelationshipType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_new_wsa5__RelationshipType(struct soap *soap, int n)
{
	enum wsa5__RelationshipType *a = static_cast<enum wsa5__RelationshipType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__RelationshipType)));
	for (enum wsa5__RelationshipType *p = a; p && n--; ++p)
		soap_default_wsa5__RelationshipType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipType(soap, tag ? tag : "wsa5:RelationshipType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wstop__TopicNamespaceType_Topic::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_wstop__TopicNamespaceType_Topic::documentation = NULL;
	this->_wstop__TopicNamespaceType_Topic::__anyAttribute = NULL;
	this->_wstop__TopicNamespaceType_Topic::MessagePattern = NULL;
	soap_default_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->_wstop__TopicNamespaceType_Topic::Topic);
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wstop__TopicNamespaceType_Topic::__any);
	soap_default_xsd__NCName(soap, &this->_wstop__TopicNamespaceType_Topic::name);
	this->_wstop__TopicNamespaceType_Topic::messageTypes = NULL;
	this->_wstop__TopicNamespaceType_Topic::final_ = (bool)0;
	this->_wstop__TopicNamespaceType_Topic::parent = NULL;
}

void _wstop__TopicNamespaceType_Topic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &this->_wstop__TopicNamespaceType_Topic::documentation);
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &this->_wstop__TopicNamespaceType_Topic::MessagePattern);
	soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->_wstop__TopicNamespaceType_Topic::Topic);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wstop__TopicNamespaceType_Topic::__any);
#endif
}

int _wstop__TopicNamespaceType_Topic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wstop__TopicNamespaceType_Topic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	if (((_wstop__TopicNamespaceType_Topic*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wstop__TopicNamespaceType_Topic*)a)->__anyAttribute, 1);
	soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((_wstop__TopicNamespaceType_Topic*)a)->name), 1);
	if (((_wstop__TopicNamespaceType_Topic*)a)->messageTypes)
	{	soap_set_attr(soap, "messageTypes", soap_xsd__QName2s(soap, *((_wstop__TopicNamespaceType_Topic*)a)->messageTypes), 1);
	}
	if (((_wstop__TopicNamespaceType_Topic*)a)->final_ != (bool)0)
	{	soap_set_attr(soap, "final", soap_bool2s(soap, ((_wstop__TopicNamespaceType_Topic*)a)->final_), 1);
	}
	if (((_wstop__TopicNamespaceType_Topic*)a)->parent)
	{	soap_set_attr(soap, "parent", soap_wstop__ConcreteTopicExpression2s(soap, *((_wstop__TopicNamespaceType_Topic*)a)->parent), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->_wstop__TopicNamespaceType_Topic::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &a->_wstop__TopicNamespaceType_Topic::MessagePattern, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", -1, &a->_wstop__TopicNamespaceType_Topic::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wstop__TopicNamespaceType_Topic::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wstop__TopicNamespaceType_Topic::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wstop__TopicNamespaceType_Topic(soap, tag, this, type);
}

SOAP_FMAC3 _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_in__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wstop__TopicNamespaceType_Topic*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(_wstop__TopicNamespaceType_Topic), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wstop__TopicNamespaceType_Topic)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wstop__TopicNamespaceType_Topic *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wstop__TopicNamespaceType_Topic*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 1), &((_wstop__TopicNamespaceType_Topic*)a)->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "messageTypes", 2, 0);
		if (t)
		{
			if (!(((_wstop__TopicNamespaceType_Topic*)a)->messageTypes = soap_new_xsd__QName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__QName(soap, t, ((_wstop__TopicNamespaceType_Topic*)a)->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 5, 0), &((_wstop__TopicNamespaceType_Topic*)a)->final_))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "parent", 5, 0);
		if (t)
		{
			if (!(((_wstop__TopicNamespaceType_Topic*)a)->parent = soap_new_wstop__ConcreteTopicExpression(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2wstop__ConcreteTopicExpression(soap, t, ((_wstop__TopicNamespaceType_Topic*)a)->parent))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_MessagePattern1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->_wstop__TopicNamespaceType_Topic::documentation, "wstop:Documentation"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_MessagePattern1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &a->_wstop__TopicNamespaceType_Topic::MessagePattern, "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", &a->_wstop__TopicNamespaceType_Topic::Topic, "wstop:TopicType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wstop__TopicNamespaceType_Topic::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wstop__TopicNamespaceType_Topic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wstop__TopicNamespaceType_Topic, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(_wstop__TopicNamespaceType_Topic), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wstop__TopicNamespaceType_Topic * SOAP_FMAC2 imageing_instantiate__wstop__TopicNamespaceType_Topic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wstop__TopicNamespaceType_Topic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wstop__TopicNamespaceType_Topic *p;
	size_t k = sizeof(_wstop__TopicNamespaceType_Topic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wstop__TopicNamespaceType_Topic, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wstop__TopicNamespaceType_Topic);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wstop__TopicNamespaceType_Topic, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wstop__TopicNamespaceType_Topic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wstop__TopicNamespaceType_Topic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wstop__TopicNamespaceType_Topic(soap, tag ? tag : "wstop:TopicNamespaceType-Topic", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wstop__TopicNamespaceType_Topic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wstop__TopicNamespaceType_Topic(soap, this, tag, type);
}

SOAP_FMAC3 _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_get__wstop__TopicNamespaceType_Topic(struct soap *soap, _wstop__TopicNamespaceType_Topic *p, const char *tag, const char *type)
{
	if ((p = soap_in__wstop__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsrfbf__BaseFaultType_FaultCause::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_wsrfbf__BaseFaultType_FaultCause::__any = NULL;
}

void _wsrfbf__BaseFaultType_FaultCause::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _wsrfbf__BaseFaultType_FaultCause::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsrfbf__BaseFaultType_FaultCause(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, const _wsrfbf__BaseFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_wsrfbf__BaseFaultType_FaultCause::__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsrfbf__BaseFaultType_FaultCause::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, this, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_FaultCause *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsrfbf__BaseFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(_wsrfbf__BaseFaultType_FaultCause), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsrfbf__BaseFaultType_FaultCause *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_wsrfbf__BaseFaultType_FaultCause::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsrfbf__BaseFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(_wsrfbf__BaseFaultType_FaultCause), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC2 imageing_instantiate__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsrfbf__BaseFaultType_FaultCause(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsrfbf__BaseFaultType_FaultCause *p;
	size_t k = sizeof(_wsrfbf__BaseFaultType_FaultCause);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsrfbf__BaseFaultType_FaultCause);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsrfbf__BaseFaultType_FaultCause, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsrfbf__BaseFaultType_FaultCause location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsrfbf__BaseFaultType_FaultCause::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsrfbf__BaseFaultType_FaultCause(soap, tag ? tag : "wsrfbf:BaseFaultType-FaultCause", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsrfbf__BaseFaultType_FaultCause::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsrfbf__BaseFaultType_FaultCause(soap, this, tag, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsrfbf__BaseFaultType_Description::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_wsrfbf__BaseFaultType_Description::__item);
	this->_wsrfbf__BaseFaultType_Description::xml__lang = NULL;
}

void _wsrfbf__BaseFaultType_Description::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsrfbf__BaseFaultType_Description::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_wsrfbf__BaseFaultType_Description::__item);
#endif
}

int _wsrfbf__BaseFaultType_Description::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsrfbf__BaseFaultType_Description(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const _wsrfbf__BaseFaultType_Description *a, const char *type)
{
	if (((_wsrfbf__BaseFaultType_Description*)a)->xml__lang)
	{	soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, *((_wsrfbf__BaseFaultType_Description*)a)->xml__lang), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_std__string(soap, tag, id, &a->_wsrfbf__BaseFaultType_Description::__item, "");
}

void *_wsrfbf__BaseFaultType_Description::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsrfbf__BaseFaultType_Description(soap, tag, this, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_wsrfbf__BaseFaultType_Description*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(_wsrfbf__BaseFaultType_Description), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsrfbf__BaseFaultType_Description)
		return (_wsrfbf__BaseFaultType_Description *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "xml:lang", 1, 0);
		if (t)
		{
			if (!(((_wsrfbf__BaseFaultType_Description*)a)->xml__lang = soap_new__xml__lang(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2_xml__lang(soap, t, ((_wsrfbf__BaseFaultType_Description*)a)->xml__lang))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__string(soap, tag, &a->_wsrfbf__BaseFaultType_Description::__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 _wsrfbf__BaseFaultType_Description * SOAP_FMAC2 imageing_instantiate__wsrfbf__BaseFaultType_Description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsrfbf__BaseFaultType_Description(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsrfbf__BaseFaultType_Description *p;
	size_t k = sizeof(_wsrfbf__BaseFaultType_Description);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsrfbf__BaseFaultType_Description, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsrfbf__BaseFaultType_Description);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsrfbf__BaseFaultType_Description, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsrfbf__BaseFaultType_Description location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsrfbf__BaseFaultType_Description::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsrfbf__BaseFaultType_Description(soap, tag ? tag : "wsrfbf:BaseFaultType-Description", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsrfbf__BaseFaultType_Description::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsrfbf__BaseFaultType_Description(soap, this, tag, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_Description(struct soap *soap, _wsrfbf__BaseFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsrfbf__BaseFaultType_ErrorCode::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->_wsrfbf__BaseFaultType_ErrorCode::dialect);
	this->_wsrfbf__BaseFaultType_ErrorCode::__mixed = NULL;
}

void _wsrfbf__BaseFaultType_ErrorCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _wsrfbf__BaseFaultType_ErrorCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const _wsrfbf__BaseFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", soap_xsd__anyURI2s(soap, ((_wsrfbf__BaseFaultType_ErrorCode*)a)->dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->_wsrfbf__BaseFaultType_ErrorCode::__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsrfbf__BaseFaultType_ErrorCode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, this, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_ErrorCode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsrfbf__BaseFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(_wsrfbf__BaseFaultType_ErrorCode), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsrfbf__BaseFaultType_ErrorCode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &((_wsrfbf__BaseFaultType_ErrorCode*)a)->dialect))
		return NULL;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->_wsrfbf__BaseFaultType_ErrorCode::__mixed))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsrfbf__BaseFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(_wsrfbf__BaseFaultType_ErrorCode), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC2 imageing_instantiate__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsrfbf__BaseFaultType_ErrorCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsrfbf__BaseFaultType_ErrorCode *p;
	size_t k = sizeof(_wsrfbf__BaseFaultType_ErrorCode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsrfbf__BaseFaultType_ErrorCode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsrfbf__BaseFaultType_ErrorCode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsrfbf__BaseFaultType_ErrorCode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsrfbf__BaseFaultType_ErrorCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, tag ? tag : "wsrfbf:BaseFaultType-ErrorCode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsrfbf__BaseFaultType_ErrorCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsrfbf__BaseFaultType_ErrorCode(soap, this, tag, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Subscribe_SubscriptionPolicy::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__Subscribe_SubscriptionPolicy::__any);
}

void _wsnt__Subscribe_SubscriptionPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__Subscribe_SubscriptionPolicy::__any);
#endif
}

int _wsnt__Subscribe_SubscriptionPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const _wsnt__Subscribe_SubscriptionPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__Subscribe_SubscriptionPolicy::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Subscribe_SubscriptionPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_in__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, _wsnt__Subscribe_SubscriptionPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Subscribe_SubscriptionPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(_wsnt__Subscribe_SubscriptionPolicy), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Subscribe_SubscriptionPolicy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__Subscribe_SubscriptionPolicy::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__Subscribe_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(_wsnt__Subscribe_SubscriptionPolicy), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC2 imageing_instantiate__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__Subscribe_SubscriptionPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Subscribe_SubscriptionPolicy *p;
	size_t k = sizeof(_wsnt__Subscribe_SubscriptionPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Subscribe_SubscriptionPolicy);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Subscribe_SubscriptionPolicy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Subscribe_SubscriptionPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Subscribe_SubscriptionPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, tag ? tag : "wsnt:Subscribe-SubscriptionPolicy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Subscribe_SubscriptionPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Subscribe_SubscriptionPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_get__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__NotificationMessageHolderType_Message::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_wsnt__NotificationMessageHolderType_Message::__any = NULL;
}

void _wsnt__NotificationMessageHolderType_Message::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _wsnt__NotificationMessageHolderType_Message::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__NotificationMessageHolderType_Message(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, int id, const _wsnt__NotificationMessageHolderType_Message *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_wsnt__NotificationMessageHolderType_Message::__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__NotificationMessageHolderType_Message::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__NotificationMessageHolderType_Message(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_in__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, _wsnt__NotificationMessageHolderType_Message *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__NotificationMessageHolderType_Message*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, sizeof(_wsnt__NotificationMessageHolderType_Message), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__NotificationMessageHolderType_Message)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__NotificationMessageHolderType_Message *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_wsnt__NotificationMessageHolderType_Message::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__NotificationMessageHolderType_Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, sizeof(_wsnt__NotificationMessageHolderType_Message), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC2 imageing_instantiate__wsnt__NotificationMessageHolderType_Message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__NotificationMessageHolderType_Message(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__NotificationMessageHolderType_Message *p;
	size_t k = sizeof(_wsnt__NotificationMessageHolderType_Message);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__NotificationMessageHolderType_Message);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__NotificationMessageHolderType_Message, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__NotificationMessageHolderType_Message location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__NotificationMessageHolderType_Message::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__NotificationMessageHolderType_Message(soap, tag ? tag : "wsnt:NotificationMessageHolderType-Message", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__NotificationMessageHolderType_Message::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__NotificationMessageHolderType_Message(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_get__wsnt__NotificationMessageHolderType_Message(struct soap *soap, _wsnt__NotificationMessageHolderType_Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotificationMessageHolderType_Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tt__ItemList_ElementItem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_tt__ItemList_ElementItem::__any = NULL;
	soap_default_std__string(soap, &this->_tt__ItemList_ElementItem::Name);
}

void _tt__ItemList_ElementItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tt__ItemList_ElementItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__ItemList_ElementItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, const _tt__ItemList_ElementItem *a, const char *type)
{
	soap_set_attr(soap, "Name", soap_std__string2s(soap, ((_tt__ItemList_ElementItem*)a)->Name), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_ElementItem), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_tt__ItemList_ElementItem::__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__ItemList_ElementItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tt__ItemList_ElementItem(soap, tag, this, type);
}

SOAP_FMAC3 _tt__ItemList_ElementItem * SOAP_FMAC4 soap_in__tt__ItemList_ElementItem(struct soap *soap, const char *tag, _tt__ItemList_ElementItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__ItemList_ElementItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(_tt__ItemList_ElementItem), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tt__ItemList_ElementItem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tt__ItemList_ElementItem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2std__string(soap, soap_attr_value(soap, "Name", 1, 1), &((_tt__ItemList_ElementItem*)a)->Name))
		return NULL;
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_tt__ItemList_ElementItem::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__ItemList_ElementItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_ElementItem, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(_tt__ItemList_ElementItem), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tt__ItemList_ElementItem * SOAP_FMAC2 imageing_instantiate__tt__ItemList_ElementItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__tt__ItemList_ElementItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tt__ItemList_ElementItem *p;
	size_t k = sizeof(_tt__ItemList_ElementItem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tt__ItemList_ElementItem, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tt__ItemList_ElementItem);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tt__ItemList_ElementItem, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tt__ItemList_ElementItem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tt__ItemList_ElementItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tt__ItemList_ElementItem(soap, tag ? tag : "tt:ItemList-ElementItem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__ItemList_ElementItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__ItemList_ElementItem(soap, this, tag, type);
}

SOAP_FMAC3 _tt__ItemList_ElementItem * SOAP_FMAC4 soap_get__tt__ItemList_ElementItem(struct soap *soap, _tt__ItemList_ElementItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tt__ItemList_SimpleItem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_tt__ItemList_SimpleItem::Name);
	soap_default_xsd__anySimpleType(soap, &this->_tt__ItemList_SimpleItem::Value);
}

void _tt__ItemList_SimpleItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tt__ItemList_SimpleItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__ItemList_SimpleItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, const _tt__ItemList_SimpleItem *a, const char *type)
{
	soap_set_attr(soap, "Name", soap_std__string2s(soap, ((_tt__ItemList_SimpleItem*)a)->Name), 1);
	soap_set_attr(soap, "Value", soap_xsd__anySimpleType2s(soap, ((_tt__ItemList_SimpleItem*)a)->Value), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_SimpleItem), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__ItemList_SimpleItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tt__ItemList_SimpleItem(soap, tag, this, type);
}

SOAP_FMAC3 _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_in__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, _tt__ItemList_SimpleItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__ItemList_SimpleItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(_tt__ItemList_SimpleItem), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tt__ItemList_SimpleItem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tt__ItemList_SimpleItem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2std__string(soap, soap_attr_value(soap, "Name", 1, 1), &((_tt__ItemList_SimpleItem*)a)->Name))
		return NULL;
	if (soap_s2xsd__anySimpleType(soap, soap_attr_value(soap, "Value", 1, 1), &((_tt__ItemList_SimpleItem*)a)->Value))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__ItemList_SimpleItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_SimpleItem, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(_tt__ItemList_SimpleItem), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tt__ItemList_SimpleItem * SOAP_FMAC2 imageing_instantiate__tt__ItemList_SimpleItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__tt__ItemList_SimpleItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tt__ItemList_SimpleItem *p;
	size_t k = sizeof(_tt__ItemList_SimpleItem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tt__ItemList_SimpleItem, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tt__ItemList_SimpleItem);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tt__ItemList_SimpleItem, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tt__ItemList_SimpleItem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tt__ItemList_SimpleItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tt__ItemList_SimpleItem(soap, tag ? tag : "tt:ItemList-SimpleItem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__ItemList_SimpleItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__ItemList_SimpleItem(soap, this, tag, type);
}

SOAP_FMAC3 _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_get__tt__ItemList_SimpleItem(struct soap *soap, _tt__ItemList_SimpleItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tt__EventSubscription_SubscriptionPolicy::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_tt__EventSubscription_SubscriptionPolicy::__any);
}

void _tt__EventSubscription_SubscriptionPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_tt__EventSubscription_SubscriptionPolicy::__any);
#endif
}

int _tt__EventSubscription_SubscriptionPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__EventSubscription_SubscriptionPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const _tt__EventSubscription_SubscriptionPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_tt__EventSubscription_SubscriptionPolicy::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__EventSubscription_SubscriptionPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tt__EventSubscription_SubscriptionPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_in__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, _tt__EventSubscription_SubscriptionPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__EventSubscription_SubscriptionPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(_tt__EventSubscription_SubscriptionPolicy), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tt__EventSubscription_SubscriptionPolicy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_tt__EventSubscription_SubscriptionPolicy::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__EventSubscription_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(_tt__EventSubscription_SubscriptionPolicy), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC2 imageing_instantiate__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__tt__EventSubscription_SubscriptionPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tt__EventSubscription_SubscriptionPolicy *p;
	size_t k = sizeof(_tt__EventSubscription_SubscriptionPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tt__EventSubscription_SubscriptionPolicy);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tt__EventSubscription_SubscriptionPolicy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tt__EventSubscription_SubscriptionPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tt__EventSubscription_SubscriptionPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tt__EventSubscription_SubscriptionPolicy(soap, tag ? tag : "tt:EventSubscription-SubscriptionPolicy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__EventSubscription_SubscriptionPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__EventSubscription_SubscriptionPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_get__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__EventSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__ConcreteTopicExpression__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_wstop__ConcreteTopicExpression(soap, &this->wstop__ConcreteTopicExpression__::__item);
}

void wstop__ConcreteTopicExpression__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wstop__ConcreteTopicExpression__::__item, SOAP_TYPE_wstop__ConcreteTopicExpression);
	soap_serialize_wstop__ConcreteTopicExpression(soap, &this->wstop__ConcreteTopicExpression__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wstop__ConcreteTopicExpression__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__ConcreteTopicExpression__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ConcreteTopicExpression__(struct soap *soap, const char *tag, int id, const wstop__ConcreteTopicExpression__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wstop__ConcreteTopicExpression(soap, tag, id, &a->wstop__ConcreteTopicExpression__::__item, "wstop:ConcreteTopicExpression");
}

void *wstop__ConcreteTopicExpression__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__ConcreteTopicExpression__(soap, tag, this, type);
}

SOAP_FMAC3 wstop__ConcreteTopicExpression__ * SOAP_FMAC4 soap_in_wstop__ConcreteTopicExpression__(struct soap *soap, const char *tag, wstop__ConcreteTopicExpression__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wstop__ConcreteTopicExpression__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__ConcreteTopicExpression__, sizeof(wstop__ConcreteTopicExpression__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__ConcreteTopicExpression__)
		return (wstop__ConcreteTopicExpression__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_wstop__ConcreteTopicExpression(soap, tag, &a->wstop__ConcreteTopicExpression__::__item, "wstop:ConcreteTopicExpression"))
		return NULL;
	return a;
}

SOAP_FMAC1 wstop__ConcreteTopicExpression__ * SOAP_FMAC2 imageing_instantiate_wstop__ConcreteTopicExpression__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wstop__ConcreteTopicExpression__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__ConcreteTopicExpression__ *p;
	size_t k = sizeof(wstop__ConcreteTopicExpression__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__ConcreteTopicExpression__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__ConcreteTopicExpression__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__ConcreteTopicExpression__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__ConcreteTopicExpression__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__ConcreteTopicExpression__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__ConcreteTopicExpression__(soap, tag ? tag : "wstop:ConcreteTopicExpression", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__ConcreteTopicExpression__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__ConcreteTopicExpression__(soap, this, tag, type);
}

SOAP_FMAC3 wstop__ConcreteTopicExpression__ * SOAP_FMAC4 soap_get_wstop__ConcreteTopicExpression__(struct soap *soap, wstop__ConcreteTopicExpression__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ConcreteTopicExpression__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_wstop__ConcreteTopicExpression), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)(/([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_wstop__ConcreteTopicExpression, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ConcreteTopicExpression(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_wstop__ConcreteTopicExpression(soap, tag ? tag : "wstop:ConcreteTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wstop__ConcreteTopicExpression(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MoveStatus_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__MoveStatus(soap, &this->tt__MoveStatus_::__item);
}

void tt__MoveStatus_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MoveStatus_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MoveStatus_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveStatus_(struct soap *soap, const char *tag, int id, const tt__MoveStatus_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__MoveStatus(soap, tag, id, &a->tt__MoveStatus_::__item, "tt:MoveStatus");
}

void *tt__MoveStatus_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MoveStatus_(soap, tag, this, type);
}

SOAP_FMAC3 tt__MoveStatus_ * SOAP_FMAC4 soap_in_tt__MoveStatus_(struct soap *soap, const char *tag, tt__MoveStatus_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__MoveStatus_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveStatus_, sizeof(tt__MoveStatus_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MoveStatus_)
		return (tt__MoveStatus_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__MoveStatus(soap, tag, &a->tt__MoveStatus_::__item, "tt:MoveStatus"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__MoveStatus_ * SOAP_FMAC2 imageing_instantiate_tt__MoveStatus_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__MoveStatus_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MoveStatus_ *p;
	size_t k = sizeof(tt__MoveStatus_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MoveStatus_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MoveStatus_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MoveStatus_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MoveStatus_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MoveStatus_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MoveStatus_(soap, tag ? tag : "tt:MoveStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MoveStatus_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MoveStatus_(soap, this, tag, type);
}

SOAP_FMAC3 tt__MoveStatus_ * SOAP_FMAC4 soap_get_tt__MoveStatus_(struct soap *soap, tt__MoveStatus_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveStatus_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReferenceToken__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__ReferenceToken__::__item);
}

void tt__ReferenceToken__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->tt__ReferenceToken__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ReferenceToken__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReferenceToken__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken__(struct soap *soap, const char *tag, int id, const tt__ReferenceToken__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ReferenceToken(soap, tag, id, &a->tt__ReferenceToken__::__item, "tt:ReferenceToken");
}

void *tt__ReferenceToken__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReferenceToken__(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReferenceToken__ * SOAP_FMAC4 soap_in_tt__ReferenceToken__(struct soap *soap, const char *tag, tt__ReferenceToken__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ReferenceToken__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReferenceToken__, sizeof(tt__ReferenceToken__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReferenceToken__)
		return (tt__ReferenceToken__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ReferenceToken(soap, tag, &a->tt__ReferenceToken__::__item, "tt:ReferenceToken"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ReferenceToken__ * SOAP_FMAC2 imageing_instantiate_tt__ReferenceToken__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ReferenceToken__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReferenceToken__ *p;
	size_t k = sizeof(tt__ReferenceToken__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReferenceToken__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReferenceToken__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReferenceToken__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReferenceToken__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReferenceToken__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReferenceToken__(soap, tag ? tag : "tt:ReferenceToken", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReferenceToken__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReferenceToken__(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReferenceToken__ * SOAP_FMAC4 soap_get_tt__ReferenceToken__(struct soap *soap, tt__ReferenceToken__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceToken__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceToken(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__ReferenceToken), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__ReferenceToken(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 64, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_tt__ReferenceToken, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceToken(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReferenceToken(soap, tag ? tag : "tt:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__ReferenceToken(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PropertyOperation_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__PropertyOperation(soap, &this->tt__PropertyOperation_::__item);
}

void tt__PropertyOperation_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PropertyOperation_::__item, SOAP_TYPE_tt__PropertyOperation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PropertyOperation_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PropertyOperation_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PropertyOperation_(struct soap *soap, const char *tag, int id, const tt__PropertyOperation_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__PropertyOperation(soap, tag, id, &a->tt__PropertyOperation_::__item, "tt:PropertyOperation");
}

void *tt__PropertyOperation_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PropertyOperation_(soap, tag, this, type);
}

SOAP_FMAC3 tt__PropertyOperation_ * SOAP_FMAC4 soap_in_tt__PropertyOperation_(struct soap *soap, const char *tag, tt__PropertyOperation_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__PropertyOperation_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PropertyOperation_, sizeof(tt__PropertyOperation_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PropertyOperation_)
		return (tt__PropertyOperation_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__PropertyOperation(soap, tag, &a->tt__PropertyOperation_::__item, "tt:PropertyOperation"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__PropertyOperation_ * SOAP_FMAC2 imageing_instantiate_tt__PropertyOperation_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__PropertyOperation_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PropertyOperation_ *p;
	size_t k = sizeof(tt__PropertyOperation_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PropertyOperation_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PropertyOperation_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PropertyOperation_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PropertyOperation_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PropertyOperation_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PropertyOperation_(soap, tag ? tag : "tt:PropertyOperation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PropertyOperation_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PropertyOperation_(soap, this, tag, type);
}

SOAP_FMAC3 tt__PropertyOperation_ * SOAP_FMAC4 soap_get_tt__PropertyOperation_(struct soap *soap, tt__PropertyOperation_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PropertyOperation_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilizationMode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ImageStabilizationMode(soap, &this->tt__ImageStabilizationMode_::__item);
}

void tt__ImageStabilizationMode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImageStabilizationMode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilizationMode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationMode_(struct soap *soap, const char *tag, int id, const tt__ImageStabilizationMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ImageStabilizationMode(soap, tag, id, &a->tt__ImageStabilizationMode_::__item, "tt:ImageStabilizationMode");
}

void *tt__ImageStabilizationMode_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilizationMode_(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilizationMode_ * SOAP_FMAC4 soap_in_tt__ImageStabilizationMode_(struct soap *soap, const char *tag, tt__ImageStabilizationMode_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ImageStabilizationMode_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationMode_, sizeof(tt__ImageStabilizationMode_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilizationMode_)
		return (tt__ImageStabilizationMode_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ImageStabilizationMode(soap, tag, &a->tt__ImageStabilizationMode_::__item, "tt:ImageStabilizationMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationMode_ * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilizationMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImageStabilizationMode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilizationMode_ *p;
	size_t k = sizeof(tt__ImageStabilizationMode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilizationMode_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilizationMode_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilizationMode_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilizationMode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilizationMode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilizationMode_(soap, tag ? tag : "tt:ImageStabilizationMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilizationMode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilizationMode_(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilizationMode_ * SOAP_FMAC4 soap_get_tt__ImageStabilizationMode_(struct soap *soap, tt__ImageStabilizationMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterMode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__IrCutFilterMode(soap, &this->tt__IrCutFilterMode_::__item);
}

void tt__IrCutFilterMode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IrCutFilterMode_::__item, SOAP_TYPE_tt__IrCutFilterMode);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IrCutFilterMode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterMode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterMode_(struct soap *soap, const char *tag, int id, const tt__IrCutFilterMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__IrCutFilterMode(soap, tag, id, &a->tt__IrCutFilterMode_::__item, "tt:IrCutFilterMode");
}

void *tt__IrCutFilterMode_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterMode_(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterMode_ * SOAP_FMAC4 soap_in_tt__IrCutFilterMode_(struct soap *soap, const char *tag, tt__IrCutFilterMode_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IrCutFilterMode_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterMode_, sizeof(tt__IrCutFilterMode_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterMode_)
		return (tt__IrCutFilterMode_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__IrCutFilterMode(soap, tag, &a->tt__IrCutFilterMode_::__item, "tt:IrCutFilterMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IrCutFilterMode_ * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__IrCutFilterMode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterMode_ *p;
	size_t k = sizeof(tt__IrCutFilterMode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterMode_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterMode_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterMode_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterMode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterMode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterMode_(soap, tag ? tag : "tt:IrCutFilterMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterMode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterMode_(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterMode_ * SOAP_FMAC4 soap_get_tt__IrCutFilterMode_(struct soap *soap, tt__IrCutFilterMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalanceMode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceMode_::__item);
}

void tt__WhiteBalanceMode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WhiteBalanceMode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalanceMode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceMode_(struct soap *soap, const char *tag, int id, const tt__WhiteBalanceMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__WhiteBalanceMode(soap, tag, id, &a->tt__WhiteBalanceMode_::__item, "tt:WhiteBalanceMode");
}

void *tt__WhiteBalanceMode_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalanceMode_(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalanceMode_ * SOAP_FMAC4 soap_in_tt__WhiteBalanceMode_(struct soap *soap, const char *tag, tt__WhiteBalanceMode_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__WhiteBalanceMode_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceMode_, sizeof(tt__WhiteBalanceMode_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalanceMode_)
		return (tt__WhiteBalanceMode_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__WhiteBalanceMode(soap, tag, &a->tt__WhiteBalanceMode_::__item, "tt:WhiteBalanceMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__WhiteBalanceMode_ * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalanceMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__WhiteBalanceMode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalanceMode_ *p;
	size_t k = sizeof(tt__WhiteBalanceMode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalanceMode_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalanceMode_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalanceMode_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalanceMode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalanceMode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalanceMode_(soap, tag ? tag : "tt:WhiteBalanceMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalanceMode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalanceMode_(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalanceMode_ * SOAP_FMAC4 soap_get_tt__WhiteBalanceMode_(struct soap *soap, tt__WhiteBalanceMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ExposureMode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ExposureMode(soap, &this->tt__ExposureMode_::__item);
}

void tt__ExposureMode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ExposureMode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ExposureMode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureMode_(struct soap *soap, const char *tag, int id, const tt__ExposureMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ExposureMode(soap, tag, id, &a->tt__ExposureMode_::__item, "tt:ExposureMode");
}

void *tt__ExposureMode_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ExposureMode_(soap, tag, this, type);
}

SOAP_FMAC3 tt__ExposureMode_ * SOAP_FMAC4 soap_in_tt__ExposureMode_(struct soap *soap, const char *tag, tt__ExposureMode_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ExposureMode_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureMode_, sizeof(tt__ExposureMode_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ExposureMode_)
		return (tt__ExposureMode_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ExposureMode(soap, tag, &a->tt__ExposureMode_::__item, "tt:ExposureMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ExposureMode_ * SOAP_FMAC2 imageing_instantiate_tt__ExposureMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ExposureMode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ExposureMode_ *p;
	size_t k = sizeof(tt__ExposureMode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ExposureMode_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ExposureMode_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ExposureMode_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ExposureMode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ExposureMode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ExposureMode_(soap, tag ? tag : "tt:ExposureMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ExposureMode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ExposureMode_(soap, this, tag, type);
}

SOAP_FMAC3 tt__ExposureMode_ * SOAP_FMAC4 soap_get_tt__ExposureMode_(struct soap *soap, tt__ExposureMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ExposurePriority_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ExposurePriority(soap, &this->tt__ExposurePriority_::__item);
}

void tt__ExposurePriority_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ExposurePriority_::__item, SOAP_TYPE_tt__ExposurePriority);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ExposurePriority_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ExposurePriority_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposurePriority_(struct soap *soap, const char *tag, int id, const tt__ExposurePriority_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ExposurePriority(soap, tag, id, &a->tt__ExposurePriority_::__item, "tt:ExposurePriority");
}

void *tt__ExposurePriority_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ExposurePriority_(soap, tag, this, type);
}

SOAP_FMAC3 tt__ExposurePriority_ * SOAP_FMAC4 soap_in_tt__ExposurePriority_(struct soap *soap, const char *tag, tt__ExposurePriority_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ExposurePriority_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposurePriority_, sizeof(tt__ExposurePriority_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ExposurePriority_)
		return (tt__ExposurePriority_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ExposurePriority(soap, tag, &a->tt__ExposurePriority_::__item, "tt:ExposurePriority"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ExposurePriority_ * SOAP_FMAC2 imageing_instantiate_tt__ExposurePriority_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ExposurePriority_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ExposurePriority_ *p;
	size_t k = sizeof(tt__ExposurePriority_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ExposurePriority_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ExposurePriority_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ExposurePriority_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ExposurePriority_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ExposurePriority_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ExposurePriority_(soap, tag ? tag : "tt:ExposurePriority", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ExposurePriority_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ExposurePriority_(soap, this, tag, type);
}

SOAP_FMAC3 tt__ExposurePriority_ * SOAP_FMAC4 soap_get_tt__ExposurePriority_(struct soap *soap, tt__ExposurePriority_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposurePriority_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BacklightCompensationMode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__BacklightCompensationMode(soap, &this->tt__BacklightCompensationMode_::__item);
}

void tt__BacklightCompensationMode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__BacklightCompensationMode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensationMode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationMode_(struct soap *soap, const char *tag, int id, const tt__BacklightCompensationMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__BacklightCompensationMode(soap, tag, id, &a->tt__BacklightCompensationMode_::__item, "tt:BacklightCompensationMode");
}

void *tt__BacklightCompensationMode_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BacklightCompensationMode_(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensationMode_ * SOAP_FMAC4 soap_in_tt__BacklightCompensationMode_(struct soap *soap, const char *tag, tt__BacklightCompensationMode_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__BacklightCompensationMode_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationMode_, sizeof(tt__BacklightCompensationMode_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BacklightCompensationMode_)
		return (tt__BacklightCompensationMode_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__BacklightCompensationMode(soap, tag, &a->tt__BacklightCompensationMode_::__item, "tt:BacklightCompensationMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__BacklightCompensationMode_ * SOAP_FMAC2 imageing_instantiate_tt__BacklightCompensationMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__BacklightCompensationMode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BacklightCompensationMode_ *p;
	size_t k = sizeof(tt__BacklightCompensationMode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BacklightCompensationMode_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BacklightCompensationMode_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BacklightCompensationMode_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BacklightCompensationMode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BacklightCompensationMode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BacklightCompensationMode_(soap, tag ? tag : "tt:BacklightCompensationMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensationMode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensationMode_(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensationMode_ * SOAP_FMAC4 soap_get_tt__BacklightCompensationMode_(struct soap *soap, tt__BacklightCompensationMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WideDynamicMode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__WideDynamicMode(soap, &this->tt__WideDynamicMode_::__item);
}

void tt__WideDynamicMode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WideDynamicMode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicMode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicMode_(struct soap *soap, const char *tag, int id, const tt__WideDynamicMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__WideDynamicMode(soap, tag, id, &a->tt__WideDynamicMode_::__item, "tt:WideDynamicMode");
}

void *tt__WideDynamicMode_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WideDynamicMode_(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicMode_ * SOAP_FMAC4 soap_in_tt__WideDynamicMode_(struct soap *soap, const char *tag, tt__WideDynamicMode_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__WideDynamicMode_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicMode_, sizeof(tt__WideDynamicMode_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WideDynamicMode_)
		return (tt__WideDynamicMode_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__WideDynamicMode(soap, tag, &a->tt__WideDynamicMode_::__item, "tt:WideDynamicMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__WideDynamicMode_ * SOAP_FMAC2 imageing_instantiate_tt__WideDynamicMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__WideDynamicMode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WideDynamicMode_ *p;
	size_t k = sizeof(tt__WideDynamicMode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WideDynamicMode_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WideDynamicMode_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WideDynamicMode_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WideDynamicMode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WideDynamicMode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WideDynamicMode_(soap, tag ? tag : "tt:WideDynamicMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicMode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicMode_(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicMode_ * SOAP_FMAC4 soap_get_tt__WideDynamicMode_(struct soap *soap, tt__WideDynamicMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AutoFocusMode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__AutoFocusMode(soap, &this->tt__AutoFocusMode_::__item);
}

void tt__AutoFocusMode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AutoFocusMode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AutoFocusMode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AutoFocusMode_(struct soap *soap, const char *tag, int id, const tt__AutoFocusMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__AutoFocusMode(soap, tag, id, &a->tt__AutoFocusMode_::__item, "tt:AutoFocusMode");
}

void *tt__AutoFocusMode_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AutoFocusMode_(soap, tag, this, type);
}

SOAP_FMAC3 tt__AutoFocusMode_ * SOAP_FMAC4 soap_in_tt__AutoFocusMode_(struct soap *soap, const char *tag, tt__AutoFocusMode_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__AutoFocusMode_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AutoFocusMode_, sizeof(tt__AutoFocusMode_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AutoFocusMode_)
		return (tt__AutoFocusMode_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__AutoFocusMode(soap, tag, &a->tt__AutoFocusMode_::__item, "tt:AutoFocusMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__AutoFocusMode_ * SOAP_FMAC2 imageing_instantiate_tt__AutoFocusMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__AutoFocusMode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AutoFocusMode_ *p;
	size_t k = sizeof(tt__AutoFocusMode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AutoFocusMode_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AutoFocusMode_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AutoFocusMode_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AutoFocusMode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AutoFocusMode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AutoFocusMode_(soap, tag ? tag : "tt:AutoFocusMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AutoFocusMode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AutoFocusMode_(soap, this, tag, type);
}

SOAP_FMAC3 tt__AutoFocusMode_ * SOAP_FMAC4 soap_get_tt__AutoFocusMode_(struct soap *soap, tt__AutoFocusMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AutoFocusMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReverseMode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ReverseMode(soap, &this->tt__ReverseMode_::__item);
}

void tt__ReverseMode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ReverseMode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReverseMode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseMode_(struct soap *soap, const char *tag, int id, const tt__ReverseMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ReverseMode(soap, tag, id, &a->tt__ReverseMode_::__item, "tt:ReverseMode");
}

void *tt__ReverseMode_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReverseMode_(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReverseMode_ * SOAP_FMAC4 soap_in_tt__ReverseMode_(struct soap *soap, const char *tag, tt__ReverseMode_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ReverseMode_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseMode_, sizeof(tt__ReverseMode_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReverseMode_)
		return (tt__ReverseMode_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ReverseMode(soap, tag, &a->tt__ReverseMode_::__item, "tt:ReverseMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ReverseMode_ * SOAP_FMAC2 imageing_instantiate_tt__ReverseMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ReverseMode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReverseMode_ *p;
	size_t k = sizeof(tt__ReverseMode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReverseMode_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReverseMode_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReverseMode_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReverseMode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReverseMode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReverseMode_(soap, tag ? tag : "tt:ReverseMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReverseMode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReverseMode_(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReverseMode_ * SOAP_FMAC4 soap_get_tt__ReverseMode_(struct soap *soap, tt__ReverseMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EFlipMode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__EFlipMode(soap, &this->tt__EFlipMode_::__item);
}

void tt__EFlipMode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__EFlipMode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EFlipMode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipMode_(struct soap *soap, const char *tag, int id, const tt__EFlipMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__EFlipMode(soap, tag, id, &a->tt__EFlipMode_::__item, "tt:EFlipMode");
}

void *tt__EFlipMode_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EFlipMode_(soap, tag, this, type);
}

SOAP_FMAC3 tt__EFlipMode_ * SOAP_FMAC4 soap_in_tt__EFlipMode_(struct soap *soap, const char *tag, tt__EFlipMode_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__EFlipMode_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipMode_, sizeof(tt__EFlipMode_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EFlipMode_)
		return (tt__EFlipMode_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__EFlipMode(soap, tag, &a->tt__EFlipMode_::__item, "tt:EFlipMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__EFlipMode_ * SOAP_FMAC2 imageing_instantiate_tt__EFlipMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__EFlipMode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EFlipMode_ *p;
	size_t k = sizeof(tt__EFlipMode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EFlipMode_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EFlipMode_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EFlipMode_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EFlipMode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EFlipMode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EFlipMode_(soap, tag ? tag : "tt:EFlipMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EFlipMode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EFlipMode_(soap, this, tag, type);
}

SOAP_FMAC3 tt__EFlipMode_ * SOAP_FMAC4 soap_get_tt__EFlipMode_(struct soap *soap, tt__EFlipMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__IPType(soap, &this->tt__IPType_::__item);
}

void tt__IPType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPType_(struct soap *soap, const char *tag, int id, const tt__IPType_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__IPType(soap, tag, id, &a->tt__IPType_::__item, "tt:IPType");
}

void *tt__IPType_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPType_(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPType_ * SOAP_FMAC4 soap_in_tt__IPType_(struct soap *soap, const char *tag, tt__IPType_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IPType_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPType_, sizeof(tt__IPType_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPType_)
		return (tt__IPType_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__IPType(soap, tag, &a->tt__IPType_::__item, "tt:IPType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IPType_ * SOAP_FMAC2 imageing_instantiate_tt__IPType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__IPType_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPType_ *p;
	size_t k = sizeof(tt__IPType_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPType_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPType_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPType_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPType_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPType_(soap, tag ? tag : "tt:IPType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPType_(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPType_ * SOAP_FMAC4 soap_get_tt__IPType_(struct soap *soap, tt__IPType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6Address__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__IPv6Address(soap, &this->tt__IPv6Address__::__item);
}

void tt__IPv6Address__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IPv6Address__::__item, SOAP_TYPE_tt__IPv6Address);
	soap_serialize_tt__IPv6Address(soap, &this->tt__IPv6Address__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPv6Address__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6Address__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6Address__(struct soap *soap, const char *tag, int id, const tt__IPv6Address__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__IPv6Address(soap, tag, id, &a->tt__IPv6Address__::__item, "tt:IPv6Address");
}

void *tt__IPv6Address__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6Address__(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6Address__ * SOAP_FMAC4 soap_in_tt__IPv6Address__(struct soap *soap, const char *tag, tt__IPv6Address__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IPv6Address__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6Address__, sizeof(tt__IPv6Address__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6Address__)
		return (tt__IPv6Address__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__IPv6Address(soap, tag, &a->tt__IPv6Address__::__item, "tt:IPv6Address"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IPv6Address__ * SOAP_FMAC2 imageing_instantiate_tt__IPv6Address__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__IPv6Address__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6Address__ *p;
	size_t k = sizeof(tt__IPv6Address__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6Address__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6Address__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6Address__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6Address__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6Address__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6Address__(soap, tag ? tag : "tt:IPv6Address", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6Address__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6Address__(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6Address__ * SOAP_FMAC4 soap_get_tt__IPv6Address__(struct soap *soap, tt__IPv6Address__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6Address__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv4Address__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__IPv4Address(soap, &this->tt__IPv4Address__::__item);
}

void tt__IPv4Address__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IPv4Address__::__item, SOAP_TYPE_tt__IPv4Address);
	soap_serialize_tt__IPv4Address(soap, &this->tt__IPv4Address__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPv4Address__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4Address__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4Address__(struct soap *soap, const char *tag, int id, const tt__IPv4Address__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__IPv4Address(soap, tag, id, &a->tt__IPv4Address__::__item, "tt:IPv4Address");
}

void *tt__IPv4Address__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv4Address__(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4Address__ * SOAP_FMAC4 soap_in_tt__IPv4Address__(struct soap *soap, const char *tag, tt__IPv4Address__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IPv4Address__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4Address__, sizeof(tt__IPv4Address__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv4Address__)
		return (tt__IPv4Address__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__IPv4Address(soap, tag, &a->tt__IPv4Address__::__item, "tt:IPv4Address"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IPv4Address__ * SOAP_FMAC2 imageing_instantiate_tt__IPv4Address__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__IPv4Address__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv4Address__ *p;
	size_t k = sizeof(tt__IPv4Address__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv4Address__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv4Address__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv4Address__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv4Address__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv4Address__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv4Address__(soap, tag ? tag : "tt:IPv4Address", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4Address__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4Address__(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4Address__ * SOAP_FMAC4 soap_get_tt__IPv4Address__(struct soap *soap, tt__IPv4Address__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4Address__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioEncoding_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__AudioEncoding(soap, &this->tt__AudioEncoding_::__item);
}

void tt__AudioEncoding_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioEncoding_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoding_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoding_(struct soap *soap, const char *tag, int id, const tt__AudioEncoding_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__AudioEncoding(soap, tag, id, &a->tt__AudioEncoding_::__item, "tt:AudioEncoding");
}

void *tt__AudioEncoding_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioEncoding_(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoding_ * SOAP_FMAC4 soap_in_tt__AudioEncoding_(struct soap *soap, const char *tag, tt__AudioEncoding_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__AudioEncoding_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoding_, sizeof(tt__AudioEncoding_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioEncoding_)
		return (tt__AudioEncoding_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__AudioEncoding(soap, tag, &a->tt__AudioEncoding_::__item, "tt:AudioEncoding"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__AudioEncoding_ * SOAP_FMAC2 imageing_instantiate_tt__AudioEncoding_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__AudioEncoding_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioEncoding_ *p;
	size_t k = sizeof(tt__AudioEncoding_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioEncoding_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioEncoding_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioEncoding_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioEncoding_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioEncoding_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioEncoding_(soap, tag ? tag : "tt:AudioEncoding", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoding_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoding_(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoding_ * SOAP_FMAC4 soap_get_tt__AudioEncoding_(struct soap *soap, tt__AudioEncoding_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoding_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__H264Profile_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__H264Profile(soap, &this->tt__H264Profile_::__item);
}

void tt__H264Profile_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__H264Profile_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Profile_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Profile_(struct soap *soap, const char *tag, int id, const tt__H264Profile_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__H264Profile(soap, tag, id, &a->tt__H264Profile_::__item, "tt:H264Profile");
}

void *tt__H264Profile_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__H264Profile_(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Profile_ * SOAP_FMAC4 soap_in_tt__H264Profile_(struct soap *soap, const char *tag, tt__H264Profile_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__H264Profile_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Profile_, sizeof(tt__H264Profile_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__H264Profile_)
		return (tt__H264Profile_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__H264Profile(soap, tag, &a->tt__H264Profile_::__item, "tt:H264Profile"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__H264Profile_ * SOAP_FMAC2 imageing_instantiate_tt__H264Profile_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__H264Profile_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__H264Profile_ *p;
	size_t k = sizeof(tt__H264Profile_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__H264Profile_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__H264Profile_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__H264Profile_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__H264Profile_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__H264Profile_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__H264Profile_(soap, tag ? tag : "tt:H264Profile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Profile_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Profile_(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Profile_ * SOAP_FMAC4 soap_get_tt__H264Profile_(struct soap *soap, tt__H264Profile_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Profile_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Mpeg4Profile_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__Mpeg4Profile(soap, &this->tt__Mpeg4Profile_::__item);
}

void tt__Mpeg4Profile_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Mpeg4Profile_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Profile_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Profile_(struct soap *soap, const char *tag, int id, const tt__Mpeg4Profile_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Mpeg4Profile(soap, tag, id, &a->tt__Mpeg4Profile_::__item, "tt:Mpeg4Profile");
}

void *tt__Mpeg4Profile_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Mpeg4Profile_(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Profile_ * SOAP_FMAC4 soap_in_tt__Mpeg4Profile_(struct soap *soap, const char *tag, tt__Mpeg4Profile_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Mpeg4Profile_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Profile_, sizeof(tt__Mpeg4Profile_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Mpeg4Profile_)
		return (tt__Mpeg4Profile_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Mpeg4Profile(soap, tag, &a->tt__Mpeg4Profile_::__item, "tt:Mpeg4Profile"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Mpeg4Profile_ * SOAP_FMAC2 imageing_instantiate_tt__Mpeg4Profile_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Mpeg4Profile_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Mpeg4Profile_ *p;
	size_t k = sizeof(tt__Mpeg4Profile_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Mpeg4Profile_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Mpeg4Profile_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Mpeg4Profile_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Mpeg4Profile_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Mpeg4Profile_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Mpeg4Profile_(soap, tag ? tag : "tt:Mpeg4Profile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Profile_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Profile_(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Profile_ * SOAP_FMAC4 soap_get_tt__Mpeg4Profile_(struct soap *soap, tt__Mpeg4Profile_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Profile_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncoding_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__VideoEncoding(soap, &this->tt__VideoEncoding_::__item);
}

void tt__VideoEncoding_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoEncoding_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoding_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoding_(struct soap *soap, const char *tag, int id, const tt__VideoEncoding_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__VideoEncoding(soap, tag, id, &a->tt__VideoEncoding_::__item, "tt:VideoEncoding");
}

void *tt__VideoEncoding_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncoding_(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoding_ * SOAP_FMAC4 soap_in_tt__VideoEncoding_(struct soap *soap, const char *tag, tt__VideoEncoding_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__VideoEncoding_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoding_, sizeof(tt__VideoEncoding_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncoding_)
		return (tt__VideoEncoding_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__VideoEncoding(soap, tag, &a->tt__VideoEncoding_::__item, "tt:VideoEncoding"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__VideoEncoding_ * SOAP_FMAC2 imageing_instantiate_tt__VideoEncoding_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__VideoEncoding_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncoding_ *p;
	size_t k = sizeof(tt__VideoEncoding_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncoding_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncoding_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncoding_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncoding_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncoding_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncoding_(soap, tag ? tag : "tt:VideoEncoding", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoding_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoding_(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoding_ * SOAP_FMAC4 soap_get_tt__VideoEncoding_(struct soap *soap, tt__VideoEncoding_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoding_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SceneOrientationMode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__SceneOrientationMode(soap, &this->tt__SceneOrientationMode_::__item);
}

void tt__SceneOrientationMode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SceneOrientationMode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SceneOrientationMode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientationMode_(struct soap *soap, const char *tag, int id, const tt__SceneOrientationMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__SceneOrientationMode(soap, tag, id, &a->tt__SceneOrientationMode_::__item, "tt:SceneOrientationMode");
}

void *tt__SceneOrientationMode_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SceneOrientationMode_(soap, tag, this, type);
}

SOAP_FMAC3 tt__SceneOrientationMode_ * SOAP_FMAC4 soap_in_tt__SceneOrientationMode_(struct soap *soap, const char *tag, tt__SceneOrientationMode_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__SceneOrientationMode_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientationMode_, sizeof(tt__SceneOrientationMode_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SceneOrientationMode_)
		return (tt__SceneOrientationMode_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__SceneOrientationMode(soap, tag, &a->tt__SceneOrientationMode_::__item, "tt:SceneOrientationMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__SceneOrientationMode_ * SOAP_FMAC2 imageing_instantiate_tt__SceneOrientationMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__SceneOrientationMode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SceneOrientationMode_ *p;
	size_t k = sizeof(tt__SceneOrientationMode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SceneOrientationMode_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SceneOrientationMode_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SceneOrientationMode_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SceneOrientationMode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SceneOrientationMode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SceneOrientationMode_(soap, tag ? tag : "tt:SceneOrientationMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SceneOrientationMode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SceneOrientationMode_(soap, this, tag, type);
}

SOAP_FMAC3 tt__SceneOrientationMode_ * SOAP_FMAC4 soap_get_tt__SceneOrientationMode_(struct soap *soap, tt__SceneOrientationMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SceneOrientationMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RotateMode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__RotateMode(soap, &this->tt__RotateMode_::__item);
}

void tt__RotateMode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RotateMode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RotateMode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateMode_(struct soap *soap, const char *tag, int id, const tt__RotateMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__RotateMode(soap, tag, id, &a->tt__RotateMode_::__item, "tt:RotateMode");
}

void *tt__RotateMode_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RotateMode_(soap, tag, this, type);
}

SOAP_FMAC3 tt__RotateMode_ * SOAP_FMAC4 soap_in_tt__RotateMode_(struct soap *soap, const char *tag, tt__RotateMode_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__RotateMode_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateMode_, sizeof(tt__RotateMode_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RotateMode_)
		return (tt__RotateMode_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__RotateMode(soap, tag, &a->tt__RotateMode_::__item, "tt:RotateMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__RotateMode_ * SOAP_FMAC2 imageing_instantiate_tt__RotateMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__RotateMode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RotateMode_ *p;
	size_t k = sizeof(tt__RotateMode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RotateMode_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RotateMode_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RotateMode_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RotateMode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RotateMode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RotateMode_(soap, tag ? tag : "tt:RotateMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RotateMode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RotateMode_(soap, this, tag, type);
}

SOAP_FMAC3 tt__RotateMode_ * SOAP_FMAC4 soap_get_tt__RotateMode_(struct soap *soap, tt__RotateMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Name__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__Name(soap, &this->tt__Name__::__item);
}

void tt__Name__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, &this->tt__Name__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Name__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Name__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name__(struct soap *soap, const char *tag, int id, const tt__Name__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Name(soap, tag, id, &a->tt__Name__::__item, "tt:Name");
}

void *tt__Name__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Name__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Name__ * SOAP_FMAC4 soap_in_tt__Name__(struct soap *soap, const char *tag, tt__Name__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Name__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Name__, sizeof(tt__Name__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Name__)
		return (tt__Name__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Name(soap, tag, &a->tt__Name__::__item, "tt:Name"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Name__ * SOAP_FMAC2 imageing_instantiate_tt__Name__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Name__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Name__ *p;
	size_t k = sizeof(tt__Name__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Name__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Name__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Name__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Name__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Name__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Name__(soap, tag ? tag : "tt:Name", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Name__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Name__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Name__ * SOAP_FMAC4 soap_get_tt__Name__(struct soap *soap, tt__Name__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Name__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Name(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__Name), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__Name(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Name, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 64, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Name, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_tt__Name, SOAP_TYPE_tt__Name, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Name(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__Name(soap, tag ? tag : "tt:Name", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__Name(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag ? tag : "wsnt:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__StringList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__StringList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__StringList, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__StringList, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_tt__StringList, SOAP_TYPE_tt__StringList, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__StringList(soap, tag ? tag : "tt:StringList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__StringList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringAttrList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringAttrList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__StringAttrList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__StringAttrList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__StringAttrList, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__StringAttrList, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_tt__StringAttrList, SOAP_TYPE_tt__StringAttrList, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringAttrList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__StringAttrList(soap, tag ? tag : "tt:StringAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__StringAttrList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__FloatList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__FloatList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__FloatList, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__FloatList, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_tt__FloatList, SOAP_TYPE_tt__FloatList, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__FloatList(soap, tag ? tag : "tt:FloatList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__FloatList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__IntList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__IntList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__IntList, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__IntList, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_tt__IntList, SOAP_TYPE_tt__IntList, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__IntList(soap, tag ? tag : "tt:IntList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__IntList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__TopicSetType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wstop__ExtensibleDocumented::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->wstop__TopicSetType::__any);
}

void wstop__TopicSetType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wstop__TopicSetType::__any);
	this->wstop__ExtensibleDocumented::soap_serialize(soap);
#endif
}

int wstop__TopicSetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__TopicSetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicSetType(struct soap *soap, const char *tag, int id, const wstop__TopicSetType *a, const char *type)
{
	if (((wstop__ExtensibleDocumented*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wstop__ExtensibleDocumented*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicSetType), type ? type : "wstop:TopicSetType"))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->wstop__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wstop__TopicSetType::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__TopicSetType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__TopicSetType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__TopicSetType * SOAP_FMAC4 soap_in_wstop__TopicSetType(struct soap *soap, const char *tag, wstop__TopicSetType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__TopicSetType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicSetType, sizeof(wstop__TopicSetType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__TopicSetType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__TopicSetType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wstop__ExtensibleDocumented*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_documentation2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->wstop__ExtensibleDocumented::documentation, "wstop:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wstop__TopicSetType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__TopicSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicSetType, SOAP_TYPE_wstop__TopicSetType, sizeof(wstop__TopicSetType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__TopicSetType * SOAP_FMAC2 imageing_instantiate_wstop__TopicSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wstop__TopicSetType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__TopicSetType *p;
	size_t k = sizeof(wstop__TopicSetType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__TopicSetType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__TopicSetType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__TopicSetType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__TopicSetType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__TopicSetType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__TopicSetType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__TopicSetType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__TopicSetType * SOAP_FMAC4 soap_get_wstop__TopicSetType(struct soap *soap, wstop__TopicSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__TopicType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wstop__ExtensibleDocumented::soap_default(soap);
	this->wstop__TopicType::MessagePattern = NULL;
	soap_default_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->wstop__TopicType::Topic);
	soap_default_std__vectorTemplateOf_XML(soap, &this->wstop__TopicType::__any);
	soap_default_xsd__NCName(soap, &this->wstop__TopicType::name);
	this->wstop__TopicType::messageTypes = NULL;
	this->wstop__TopicType::final_ = (bool)0;
}

void wstop__TopicType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &this->wstop__TopicType::MessagePattern);
	soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->wstop__TopicType::Topic);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wstop__TopicType::__any);
	this->wstop__ExtensibleDocumented::soap_serialize(soap);
#endif
}

int wstop__TopicType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__TopicType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicType(struct soap *soap, const char *tag, int id, const wstop__TopicType *a, const char *type)
{
	soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((wstop__TopicType*)a)->name), 1);
	if (((wstop__TopicType*)a)->messageTypes)
	{	soap_set_attr(soap, "messageTypes", soap_xsd__QName2s(soap, *((wstop__TopicType*)a)->messageTypes), 1);
	}
	if (((wstop__TopicType*)a)->final_ != (bool)0)
	{	soap_set_attr(soap, "final", soap_bool2s(soap, ((wstop__TopicType*)a)->final_), 1);
	}
	if (((wstop__ExtensibleDocumented*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wstop__ExtensibleDocumented*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicType), type ? type : "wstop:TopicType"))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->wstop__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &a->wstop__TopicType::MessagePattern, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", -1, &a->wstop__TopicType::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wstop__TopicType::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__TopicType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__TopicType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__TopicType * SOAP_FMAC4 soap_in_wstop__TopicType(struct soap *soap, const char *tag, wstop__TopicType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__TopicType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicType, sizeof(wstop__TopicType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__TopicType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__TopicType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 1), &((wstop__TopicType*)a)->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "messageTypes", 2, 0);
		if (t)
		{
			if (!(((wstop__TopicType*)a)->messageTypes = soap_new_xsd__QName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__QName(soap, t, ((wstop__TopicType*)a)->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 5, 0), &((wstop__TopicType*)a)->final_))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wstop__ExtensibleDocumented*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_documentation2 = 1;
	size_t soap_flag_MessagePattern1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->wstop__ExtensibleDocumented::documentation, "wstop:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			}
			if (soap_flag_MessagePattern1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &a->wstop__TopicType::MessagePattern, "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", &a->wstop__TopicType::Topic, "wstop:TopicType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wstop__TopicType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__TopicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicType, SOAP_TYPE_wstop__TopicType, sizeof(wstop__TopicType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__TopicType * SOAP_FMAC2 imageing_instantiate_wstop__TopicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wstop__TopicType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__TopicType *p;
	size_t k = sizeof(wstop__TopicType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__TopicType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__TopicType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__TopicType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__TopicType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__TopicType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__TopicType(soap, tag ? tag : "wstop:TopicType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__TopicType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__TopicType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__TopicType * SOAP_FMAC4 soap_get_wstop__TopicType(struct soap *soap, wstop__TopicType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__TopicNamespaceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wstop__ExtensibleDocumented::soap_default(soap);
	soap_default_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, &this->wstop__TopicNamespaceType::Topic);
	soap_default_std__vectorTemplateOf_XML(soap, &this->wstop__TopicNamespaceType::__any);
	this->wstop__TopicNamespaceType::name = NULL;
	soap_default_xsd__anyURI(soap, &this->wstop__TopicNamespaceType::targetNamespace);
	this->wstop__TopicNamespaceType::final_ = (bool)0;
}

void wstop__TopicNamespaceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, &this->wstop__TopicNamespaceType::Topic);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wstop__TopicNamespaceType::__any);
	this->wstop__ExtensibleDocumented::soap_serialize(soap);
#endif
}

int wstop__TopicNamespaceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__TopicNamespaceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicNamespaceType(struct soap *soap, const char *tag, int id, const wstop__TopicNamespaceType *a, const char *type)
{
	if (((wstop__TopicNamespaceType*)a)->name)
	{	soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, *((wstop__TopicNamespaceType*)a)->name), 1);
	}
	soap_set_attr(soap, "targetNamespace", soap_xsd__anyURI2s(soap, ((wstop__TopicNamespaceType*)a)->targetNamespace), 1);
	if (((wstop__TopicNamespaceType*)a)->final_ != (bool)0)
	{	soap_set_attr(soap, "final", soap_bool2s(soap, ((wstop__TopicNamespaceType*)a)->final_), 1);
	}
	if (((wstop__ExtensibleDocumented*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wstop__ExtensibleDocumented*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicNamespaceType), type ? type : "wstop:TopicNamespaceType"))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->wstop__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", -1, &a->wstop__TopicNamespaceType::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wstop__TopicNamespaceType::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__TopicNamespaceType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__TopicNamespaceType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__TopicNamespaceType * SOAP_FMAC4 soap_in_wstop__TopicNamespaceType(struct soap *soap, const char *tag, wstop__TopicNamespaceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__TopicNamespaceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(wstop__TopicNamespaceType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__TopicNamespaceType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__TopicNamespaceType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "name", 5, 0);
		if (t)
		{
			if (!(((wstop__TopicNamespaceType*)a)->name = soap_new_xsd__NCName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__NCName(soap, t, ((wstop__TopicNamespaceType*)a)->name))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "targetNamespace", 4, 1), &((wstop__TopicNamespaceType*)a)->targetNamespace))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 5, 0), &((wstop__TopicNamespaceType*)a)->final_))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wstop__ExtensibleDocumented*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_documentation2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->wstop__ExtensibleDocumented::documentation, "wstop:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", &a->wstop__TopicNamespaceType::Topic, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wstop__TopicNamespaceType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__TopicNamespaceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicNamespaceType, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(wstop__TopicNamespaceType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__TopicNamespaceType * SOAP_FMAC2 imageing_instantiate_wstop__TopicNamespaceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wstop__TopicNamespaceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__TopicNamespaceType *p;
	size_t k = sizeof(wstop__TopicNamespaceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__TopicNamespaceType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__TopicNamespaceType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__TopicNamespaceType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__TopicNamespaceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__TopicNamespaceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__TopicNamespaceType(soap, tag ? tag : "wstop:TopicNamespaceType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__TopicNamespaceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__TopicNamespaceType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__TopicNamespaceType * SOAP_FMAC4 soap_get_wstop__TopicNamespaceType(struct soap *soap, wstop__TopicNamespaceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicNamespaceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__QueryExpressionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->wstop__QueryExpressionType::__any = NULL;
	soap_default_xsd__anyURI(soap, &this->wstop__QueryExpressionType::Dialect);
	this->wstop__QueryExpressionType::__mixed = NULL;
}

void wstop__QueryExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wstop__QueryExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__QueryExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__QueryExpressionType(struct soap *soap, const char *tag, int id, const wstop__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, ((wstop__QueryExpressionType*)a)->Dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__QueryExpressionType), type ? type : "wstop:QueryExpressionType"))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->wstop__QueryExpressionType::__any, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->wstop__QueryExpressionType::__mixed, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__QueryExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__QueryExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__QueryExpressionType * SOAP_FMAC4 soap_in_wstop__QueryExpressionType(struct soap *soap, const char *tag, wstop__QueryExpressionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__QueryExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(wstop__QueryExpressionType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__QueryExpressionType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__QueryExpressionType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &((wstop__QueryExpressionType*)a)->Dialect))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->wstop__QueryExpressionType::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->wstop__QueryExpressionType::__mixed))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__QueryExpressionType, SOAP_TYPE_wstop__QueryExpressionType, sizeof(wstop__QueryExpressionType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__QueryExpressionType * SOAP_FMAC2 imageing_instantiate_wstop__QueryExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wstop__QueryExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__QueryExpressionType *p;
	size_t k = sizeof(wstop__QueryExpressionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__QueryExpressionType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__QueryExpressionType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__QueryExpressionType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__QueryExpressionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__QueryExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__QueryExpressionType(soap, tag ? tag : "wstop:QueryExpressionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__QueryExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__QueryExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__QueryExpressionType * SOAP_FMAC4 soap_get_wstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__ExtensibleDocumented::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->wstop__ExtensibleDocumented::documentation = NULL;
	this->wstop__ExtensibleDocumented::__anyAttribute = NULL;
}

void wstop__ExtensibleDocumented::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &this->wstop__ExtensibleDocumented::documentation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wstop__ExtensibleDocumented::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__ExtensibleDocumented(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, int id, const wstop__ExtensibleDocumented *a, const char *type)
{
	if (((wstop__ExtensibleDocumented*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wstop__ExtensibleDocumented*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__ExtensibleDocumented), type ? type : "wstop:ExtensibleDocumented"))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->wstop__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__ExtensibleDocumented::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__ExtensibleDocumented(soap, tag, this, type);
}

SOAP_FMAC3 wstop__ExtensibleDocumented * SOAP_FMAC4 soap_in_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, wstop__ExtensibleDocumented *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__ExtensibleDocumented*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(wstop__ExtensibleDocumented), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__ExtensibleDocumented)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__ExtensibleDocumented *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wstop__ExtensibleDocumented*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_documentation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->wstop__ExtensibleDocumented::documentation, "wstop:Documentation"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__ExtensibleDocumented *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__ExtensibleDocumented, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(wstop__ExtensibleDocumented), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__ExtensibleDocumented * SOAP_FMAC2 imageing_instantiate_wstop__ExtensibleDocumented(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wstop__ExtensibleDocumented(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicNamespaceType"))
		return imageing_instantiate_wstop__TopicNamespaceType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicType"))
		return imageing_instantiate_wstop__TopicType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicSetType"))
		return imageing_instantiate_wstop__TopicSetType(soap, n, NULL, NULL, size);
	wstop__ExtensibleDocumented *p;
	size_t k = sizeof(wstop__ExtensibleDocumented);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__ExtensibleDocumented, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__ExtensibleDocumented);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__ExtensibleDocumented, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__ExtensibleDocumented location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__ExtensibleDocumented::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__ExtensibleDocumented(soap, tag ? tag : "wstop:ExtensibleDocumented", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__ExtensibleDocumented::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__ExtensibleDocumented(soap, this, tag, type);
}

SOAP_FMAC3 wstop__ExtensibleDocumented * SOAP_FMAC4 soap_get_wstop__ExtensibleDocumented(struct soap *soap, wstop__ExtensibleDocumented *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ExtensibleDocumented(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__Documentation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->wstop__Documentation::__any);
	this->wstop__Documentation::__mixed = NULL;
}

void wstop__Documentation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wstop__Documentation::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wstop__Documentation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__Documentation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__Documentation(struct soap *soap, const char *tag, int id, const wstop__Documentation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__Documentation), type ? type : "wstop:Documentation"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wstop__Documentation::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->wstop__Documentation::__mixed, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__Documentation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__Documentation(soap, tag, this, type);
}

SOAP_FMAC3 wstop__Documentation * SOAP_FMAC4 soap_in_wstop__Documentation(struct soap *soap, const char *tag, wstop__Documentation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__Documentation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__Documentation, sizeof(wstop__Documentation), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__Documentation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__Documentation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wstop__Documentation::__any, ""))
					continue;
			}
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->wstop__Documentation::__mixed))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__Documentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__Documentation, SOAP_TYPE_wstop__Documentation, sizeof(wstop__Documentation), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__Documentation * SOAP_FMAC2 imageing_instantiate_wstop__Documentation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wstop__Documentation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__Documentation *p;
	size_t k = sizeof(wstop__Documentation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__Documentation, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__Documentation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__Documentation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__Documentation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__Documentation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__Documentation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__Documentation(soap, this, tag, type);
}

SOAP_FMAC3 wstop__Documentation * SOAP_FMAC4 soap_get_wstop__Documentation(struct soap *soap, wstop__Documentation *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsrfbf__BaseFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_dateTime(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	soap_default_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, &this->wsrfbf__BaseFaultType::Description);
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	this->wsrfbf__BaseFaultType::__anyAttribute = NULL;
}

void wsrfbf__BaseFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	soap_serialize_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, &this->wsrfbf__BaseFaultType::Description);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wsrfbf__BaseFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsrfbf__BaseFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, int id, const wsrfbf__BaseFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfbf__BaseFaultType), type ? type : "wsrfbf:BaseFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsrfbf__BaseFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsrfbf__BaseFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsrfbf__BaseFaultType * SOAP_FMAC4 soap_in_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, wsrfbf__BaseFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsrfbf__BaseFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(wsrfbf__BaseFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsrfbf__BaseFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsrfbf__BaseFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Originator1 = 1;
	size_t soap_flag_ErrorCode1 = 1;
	size_t soap_flag_FaultCause1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			}
			if (soap_flag_Originator1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator1--;
					continue;
				}
			}
			if (soap_flag_ErrorCode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsrfbf__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfbf__BaseFaultType, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(wsrfbf__BaseFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsrfbf__BaseFaultType * SOAP_FMAC2 imageing_instantiate_wsrfbf__BaseFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsrfbf__BaseFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "wsnt:SubscribeCreationFailedFaultType"))
		return imageing_instantiate_wsnt__SubscribeCreationFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidFilterFaultType"))
		return imageing_instantiate_wsnt__InvalidFilterFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:TopicExpressionDialectUnknownFaultType"))
		return imageing_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidTopicExpressionFaultType"))
		return imageing_instantiate_wsnt__InvalidTopicExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:TopicNotSupportedFaultType"))
		return imageing_instantiate_wsnt__TopicNotSupportedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:MultipleTopicsSpecifiedFaultType"))
		return imageing_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidProducerPropertiesExpressionFaultType"))
		return imageing_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidMessageContentExpressionFaultType"))
		return imageing_instantiate_wsnt__InvalidMessageContentExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnrecognizedPolicyRequestFaultType"))
		return imageing_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnsupportedPolicyRequestFaultType"))
		return imageing_instantiate_wsnt__UnsupportedPolicyRequestFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:NotifyMessageNotSupportedFaultType"))
		return imageing_instantiate_wsnt__NotifyMessageNotSupportedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnacceptableInitialTerminationTimeFaultType"))
		return imageing_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:NoCurrentMessageOnTopicFaultType"))
		return imageing_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToGetMessagesFaultType"))
		return imageing_instantiate_wsnt__UnableToGetMessagesFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToDestroyPullPointFaultType"))
		return imageing_instantiate_wsnt__UnableToDestroyPullPointFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToCreatePullPointFaultType"))
		return imageing_instantiate_wsnt__UnableToCreatePullPointFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnacceptableTerminationTimeFaultType"))
		return imageing_instantiate_wsnt__UnacceptableTerminationTimeFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToDestroySubscriptionFaultType"))
		return imageing_instantiate_wsnt__UnableToDestroySubscriptionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:PauseFailedFaultType"))
		return imageing_instantiate_wsnt__PauseFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:ResumeFailedFaultType"))
		return imageing_instantiate_wsnt__ResumeFailedFaultType(soap, n, NULL, NULL, size);
	wsrfbf__BaseFaultType *p;
	size_t k = sizeof(wsrfbf__BaseFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrfbf__BaseFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsrfbf__BaseFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsrfbf__BaseFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsrfbf__BaseFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsrfbf__BaseFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsrfbf__BaseFaultType(soap, tag ? tag : "wsrfbf:BaseFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsrfbf__BaseFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsrfbf__BaseFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsrfbf__BaseFaultType * SOAP_FMAC4 soap_get_wsrfbf__BaseFaultType(struct soap *soap, wsrfbf__BaseFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfbf__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__ResumeSubscriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__ResumeSubscriptionResponse::__any);
}

void _wsnt__ResumeSubscriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__ResumeSubscriptionResponse::__any);
#endif
}

int _wsnt__ResumeSubscriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__ResumeSubscriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, int id, const _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__ResumeSubscriptionResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__ResumeSubscriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__ResumeSubscriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__ResumeSubscriptionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(_wsnt__ResumeSubscriptionResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__ResumeSubscriptionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__ResumeSubscriptionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__ResumeSubscriptionResponse::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__ResumeSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(_wsnt__ResumeSubscriptionResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC2 imageing_instantiate__wsnt__ResumeSubscriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__ResumeSubscriptionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__ResumeSubscriptionResponse *p;
	size_t k = sizeof(_wsnt__ResumeSubscriptionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__ResumeSubscriptionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__ResumeSubscriptionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__ResumeSubscriptionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__ResumeSubscriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__ResumeSubscriptionResponse(soap, tag ? tag : "wsnt:ResumeSubscriptionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__ResumeSubscriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__ResumeSubscriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__ResumeSubscriptionResponse(struct soap *soap, _wsnt__ResumeSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__ResumeSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__ResumeSubscription::__any);
}

void _wsnt__ResumeSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__ResumeSubscription::__any);
#endif
}

int _wsnt__ResumeSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__ResumeSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscription(struct soap *soap, const char *tag, int id, const _wsnt__ResumeSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__ResumeSubscription::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__ResumeSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__ResumeSubscription(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__ResumeSubscription * SOAP_FMAC4 soap_in__wsnt__ResumeSubscription(struct soap *soap, const char *tag, _wsnt__ResumeSubscription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__ResumeSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(_wsnt__ResumeSubscription), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__ResumeSubscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__ResumeSubscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__ResumeSubscription::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__ResumeSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscription, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(_wsnt__ResumeSubscription), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__ResumeSubscription * SOAP_FMAC2 imageing_instantiate__wsnt__ResumeSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__ResumeSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__ResumeSubscription *p;
	size_t k = sizeof(_wsnt__ResumeSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__ResumeSubscription, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__ResumeSubscription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__ResumeSubscription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__ResumeSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__ResumeSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__ResumeSubscription(soap, tag ? tag : "wsnt:ResumeSubscription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__ResumeSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__ResumeSubscription(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__ResumeSubscription * SOAP_FMAC4 soap_get__wsnt__ResumeSubscription(struct soap *soap, _wsnt__ResumeSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__PauseSubscriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__PauseSubscriptionResponse::__any);
}

void _wsnt__PauseSubscriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__PauseSubscriptionResponse::__any);
#endif
}

int _wsnt__PauseSubscriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__PauseSubscriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, int id, const _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__PauseSubscriptionResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__PauseSubscriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__PauseSubscriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__PauseSubscriptionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(_wsnt__PauseSubscriptionResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__PauseSubscriptionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__PauseSubscriptionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__PauseSubscriptionResponse::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__PauseSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscriptionResponse, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(_wsnt__PauseSubscriptionResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__PauseSubscriptionResponse * SOAP_FMAC2 imageing_instantiate__wsnt__PauseSubscriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__PauseSubscriptionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__PauseSubscriptionResponse *p;
	size_t k = sizeof(_wsnt__PauseSubscriptionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__PauseSubscriptionResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__PauseSubscriptionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__PauseSubscriptionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__PauseSubscriptionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__PauseSubscriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__PauseSubscriptionResponse(soap, tag ? tag : "wsnt:PauseSubscriptionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__PauseSubscriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__PauseSubscriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__PauseSubscriptionResponse(struct soap *soap, _wsnt__PauseSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__PauseSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__PauseSubscription::__any);
}

void _wsnt__PauseSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__PauseSubscription::__any);
#endif
}

int _wsnt__PauseSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__PauseSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscription(struct soap *soap, const char *tag, int id, const _wsnt__PauseSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__PauseSubscription::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__PauseSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__PauseSubscription(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__PauseSubscription * SOAP_FMAC4 soap_in__wsnt__PauseSubscription(struct soap *soap, const char *tag, _wsnt__PauseSubscription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__PauseSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscription, sizeof(_wsnt__PauseSubscription), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__PauseSubscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__PauseSubscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__PauseSubscription::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__PauseSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscription, SOAP_TYPE__wsnt__PauseSubscription, sizeof(_wsnt__PauseSubscription), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__PauseSubscription * SOAP_FMAC2 imageing_instantiate__wsnt__PauseSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__PauseSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__PauseSubscription *p;
	size_t k = sizeof(_wsnt__PauseSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__PauseSubscription, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__PauseSubscription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__PauseSubscription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__PauseSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__PauseSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__PauseSubscription(soap, tag ? tag : "wsnt:PauseSubscription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__PauseSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__PauseSubscription(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__PauseSubscription * SOAP_FMAC4 soap_get__wsnt__PauseSubscription(struct soap *soap, _wsnt__PauseSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__UnsubscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__UnsubscribeResponse::__any);
}

void _wsnt__UnsubscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__UnsubscribeResponse::__any);
#endif
}

int _wsnt__UnsubscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__UnsubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, int id, const _wsnt__UnsubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsubscribeResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__UnsubscribeResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__UnsubscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__UnsubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_in__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, _wsnt__UnsubscribeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__UnsubscribeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(_wsnt__UnsubscribeResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__UnsubscribeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__UnsubscribeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__UnsubscribeResponse::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsubscribeResponse, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(_wsnt__UnsubscribeResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__UnsubscribeResponse * SOAP_FMAC2 imageing_instantiate__wsnt__UnsubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__UnsubscribeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__UnsubscribeResponse *p;
	size_t k = sizeof(_wsnt__UnsubscribeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__UnsubscribeResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__UnsubscribeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__UnsubscribeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__UnsubscribeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__UnsubscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__UnsubscribeResponse(soap, tag ? tag : "wsnt:UnsubscribeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__UnsubscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__UnsubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_get__wsnt__UnsubscribeResponse(struct soap *soap, _wsnt__UnsubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Unsubscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__Unsubscribe::__any);
}

void _wsnt__Unsubscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__Unsubscribe::__any);
#endif
}

int _wsnt__Unsubscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Unsubscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Unsubscribe(struct soap *soap, const char *tag, int id, const _wsnt__Unsubscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Unsubscribe), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__Unsubscribe::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Unsubscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__Unsubscribe(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Unsubscribe * SOAP_FMAC4 soap_in__wsnt__Unsubscribe(struct soap *soap, const char *tag, _wsnt__Unsubscribe *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Unsubscribe*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Unsubscribe, sizeof(_wsnt__Unsubscribe), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Unsubscribe)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Unsubscribe *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__Unsubscribe::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Unsubscribe, SOAP_TYPE__wsnt__Unsubscribe, sizeof(_wsnt__Unsubscribe), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Unsubscribe * SOAP_FMAC2 imageing_instantiate__wsnt__Unsubscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__Unsubscribe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Unsubscribe *p;
	size_t k = sizeof(_wsnt__Unsubscribe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Unsubscribe, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Unsubscribe);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Unsubscribe, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Unsubscribe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Unsubscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Unsubscribe(soap, tag ? tag : "wsnt:Unsubscribe", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Unsubscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Unsubscribe(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Unsubscribe * SOAP_FMAC4 soap_get__wsnt__Unsubscribe(struct soap *soap, _wsnt__Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__RenewResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dateTime(soap, &this->_wsnt__RenewResponse::TerminationTime);
	this->_wsnt__RenewResponse::CurrentTime = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__RenewResponse::__any);
}

void _wsnt__RenewResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__RenewResponse::TerminationTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &this->_wsnt__RenewResponse::CurrentTime);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__RenewResponse::__any);
#endif
}

int _wsnt__RenewResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__RenewResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__RenewResponse(struct soap *soap, const char *tag, int id, const _wsnt__RenewResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__RenewResponse), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:TerminationTime", -1, &a->_wsnt__RenewResponse::TerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CurrentTime", -1, &a->_wsnt__RenewResponse::CurrentTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__RenewResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__RenewResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__RenewResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__RenewResponse * SOAP_FMAC4 soap_in__wsnt__RenewResponse(struct soap *soap, const char *tag, _wsnt__RenewResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__RenewResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__RenewResponse, sizeof(_wsnt__RenewResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__RenewResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__RenewResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TerminationTime1 = 1;
	size_t soap_flag_CurrentTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:TerminationTime", &a->_wsnt__RenewResponse::TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap_flag_CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CurrentTime", &a->_wsnt__RenewResponse::CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__RenewResponse::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__RenewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__RenewResponse, SOAP_TYPE__wsnt__RenewResponse, sizeof(_wsnt__RenewResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__RenewResponse * SOAP_FMAC2 imageing_instantiate__wsnt__RenewResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__RenewResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__RenewResponse *p;
	size_t k = sizeof(_wsnt__RenewResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__RenewResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__RenewResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__RenewResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__RenewResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__RenewResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__RenewResponse(soap, tag ? tag : "wsnt:RenewResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__RenewResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__RenewResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__RenewResponse * SOAP_FMAC4 soap_get__wsnt__RenewResponse(struct soap *soap, _wsnt__RenewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__RenewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Renew::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_wsnt__Renew::TerminationTime = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__Renew::__any);
}

void _wsnt__Renew::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, &this->_wsnt__Renew::TerminationTime);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__Renew::__any);
#endif
}

int _wsnt__Renew::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Renew(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Renew(struct soap *soap, const char *tag, int id, const _wsnt__Renew *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Renew), type))
		return soap->error;
	if (!a->_wsnt__Renew::TerminationTime)
	{	if (soap_element_nil(soap, "wsnt:TerminationTime"))
			return soap->error;
	}
	else if (soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", -1, &a->_wsnt__Renew::TerminationTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__Renew::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Renew::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__Renew(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Renew * SOAP_FMAC4 soap_in__wsnt__Renew(struct soap *soap, const char *tag, _wsnt__Renew *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Renew*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Renew, sizeof(_wsnt__Renew), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Renew)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Renew *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TerminationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", &a->_wsnt__Renew::TerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__Renew::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__Renew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Renew, SOAP_TYPE__wsnt__Renew, sizeof(_wsnt__Renew), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Renew * SOAP_FMAC2 imageing_instantiate__wsnt__Renew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__Renew(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Renew *p;
	size_t k = sizeof(_wsnt__Renew);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Renew, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Renew);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Renew, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Renew location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Renew::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Renew(soap, tag ? tag : "wsnt:Renew", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Renew::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Renew(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Renew * SOAP_FMAC4 soap_get__wsnt__Renew(struct soap *soap, _wsnt__Renew *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__CreatePullPointResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnt__CreatePullPointResponse::PullPoint);
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__CreatePullPointResponse::__any);
	this->_wsnt__CreatePullPointResponse::__anyAttribute = NULL;
}

void _wsnt__CreatePullPointResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__CreatePullPointResponse::PullPoint, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnt__CreatePullPointResponse::PullPoint);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__CreatePullPointResponse::__any);
#endif
}

int _wsnt__CreatePullPointResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__CreatePullPointResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, int id, const _wsnt__CreatePullPointResponse *a, const char *type)
{
	if (((_wsnt__CreatePullPointResponse*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wsnt__CreatePullPointResponse*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPointResponse), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", -1, &a->_wsnt__CreatePullPointResponse::PullPoint, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__CreatePullPointResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__CreatePullPointResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__CreatePullPointResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_in__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, _wsnt__CreatePullPointResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__CreatePullPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(_wsnt__CreatePullPointResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__CreatePullPointResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__CreatePullPointResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wsnt__CreatePullPointResponse*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_PullPoint1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PullPoint1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", &a->_wsnt__CreatePullPointResponse::PullPoint, "wsa5:EndpointReferenceType"))
				{	soap_flag_PullPoint1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__CreatePullPointResponse::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PullPoint1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__CreatePullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPointResponse, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(_wsnt__CreatePullPointResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__CreatePullPointResponse * SOAP_FMAC2 imageing_instantiate__wsnt__CreatePullPointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__CreatePullPointResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__CreatePullPointResponse *p;
	size_t k = sizeof(_wsnt__CreatePullPointResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__CreatePullPointResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__CreatePullPointResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__CreatePullPointResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__CreatePullPointResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__CreatePullPointResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__CreatePullPointResponse(soap, tag ? tag : "wsnt:CreatePullPointResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__CreatePullPointResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__CreatePullPointResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_get__wsnt__CreatePullPointResponse(struct soap *soap, _wsnt__CreatePullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__CreatePullPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__CreatePullPoint::__any);
	this->_wsnt__CreatePullPoint::__anyAttribute = NULL;
}

void _wsnt__CreatePullPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__CreatePullPoint::__any);
#endif
}

int _wsnt__CreatePullPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__CreatePullPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPoint(struct soap *soap, const char *tag, int id, const _wsnt__CreatePullPoint *a, const char *type)
{
	if (((_wsnt__CreatePullPoint*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wsnt__CreatePullPoint*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPoint), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__CreatePullPoint::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__CreatePullPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__CreatePullPoint(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__CreatePullPoint * SOAP_FMAC4 soap_in__wsnt__CreatePullPoint(struct soap *soap, const char *tag, _wsnt__CreatePullPoint *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__CreatePullPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(_wsnt__CreatePullPoint), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__CreatePullPoint)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__CreatePullPoint *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wsnt__CreatePullPoint*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__CreatePullPoint::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__CreatePullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPoint, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(_wsnt__CreatePullPoint), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__CreatePullPoint * SOAP_FMAC2 imageing_instantiate__wsnt__CreatePullPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__CreatePullPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__CreatePullPoint *p;
	size_t k = sizeof(_wsnt__CreatePullPoint);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__CreatePullPoint, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__CreatePullPoint);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__CreatePullPoint, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__CreatePullPoint location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__CreatePullPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__CreatePullPoint(soap, tag ? tag : "wsnt:CreatePullPoint", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__CreatePullPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__CreatePullPoint(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__CreatePullPoint * SOAP_FMAC4 soap_get__wsnt__CreatePullPoint(struct soap *soap, _wsnt__CreatePullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__DestroyPullPointResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__DestroyPullPointResponse::__any);
	this->_wsnt__DestroyPullPointResponse::__anyAttribute = NULL;
}

void _wsnt__DestroyPullPointResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__DestroyPullPointResponse::__any);
#endif
}

int _wsnt__DestroyPullPointResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__DestroyPullPointResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, int id, const _wsnt__DestroyPullPointResponse *a, const char *type)
{
	if (((_wsnt__DestroyPullPointResponse*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wsnt__DestroyPullPointResponse*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__DestroyPullPointResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__DestroyPullPointResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__DestroyPullPointResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_in__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, _wsnt__DestroyPullPointResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__DestroyPullPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(_wsnt__DestroyPullPointResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__DestroyPullPointResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__DestroyPullPointResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wsnt__DestroyPullPointResponse*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__DestroyPullPointResponse::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__DestroyPullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPointResponse, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(_wsnt__DestroyPullPointResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__DestroyPullPointResponse * SOAP_FMAC2 imageing_instantiate__wsnt__DestroyPullPointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__DestroyPullPointResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__DestroyPullPointResponse *p;
	size_t k = sizeof(_wsnt__DestroyPullPointResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__DestroyPullPointResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__DestroyPullPointResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__DestroyPullPointResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__DestroyPullPointResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__DestroyPullPointResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__DestroyPullPointResponse(soap, tag ? tag : "wsnt:DestroyPullPointResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__DestroyPullPointResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__DestroyPullPointResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_get__wsnt__DestroyPullPointResponse(struct soap *soap, _wsnt__DestroyPullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__DestroyPullPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__DestroyPullPoint::__any);
	this->_wsnt__DestroyPullPoint::__anyAttribute = NULL;
}

void _wsnt__DestroyPullPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__DestroyPullPoint::__any);
#endif
}

int _wsnt__DestroyPullPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__DestroyPullPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, int id, const _wsnt__DestroyPullPoint *a, const char *type)
{
	if (((_wsnt__DestroyPullPoint*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wsnt__DestroyPullPoint*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPoint), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__DestroyPullPoint::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__DestroyPullPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__DestroyPullPoint(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_in__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, _wsnt__DestroyPullPoint *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__DestroyPullPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(_wsnt__DestroyPullPoint), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__DestroyPullPoint)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__DestroyPullPoint *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wsnt__DestroyPullPoint*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__DestroyPullPoint::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__DestroyPullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPoint, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(_wsnt__DestroyPullPoint), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__DestroyPullPoint * SOAP_FMAC2 imageing_instantiate__wsnt__DestroyPullPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__DestroyPullPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__DestroyPullPoint *p;
	size_t k = sizeof(_wsnt__DestroyPullPoint);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__DestroyPullPoint, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__DestroyPullPoint);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__DestroyPullPoint, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__DestroyPullPoint location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__DestroyPullPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__DestroyPullPoint(soap, tag ? tag : "wsnt:DestroyPullPoint", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__DestroyPullPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__DestroyPullPoint(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_get__wsnt__DestroyPullPoint(struct soap *soap, _wsnt__DestroyPullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__GetMessagesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_wsnt__GetMessagesResponse::NotificationMessage);
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetMessagesResponse::__any);
	this->_wsnt__GetMessagesResponse::__anyAttribute = NULL;
}

void _wsnt__GetMessagesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_wsnt__GetMessagesResponse::NotificationMessage);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetMessagesResponse::__any);
#endif
}

int _wsnt__GetMessagesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__GetMessagesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, int id, const _wsnt__GetMessagesResponse *a, const char *type)
{
	if (((_wsnt__GetMessagesResponse*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wsnt__GetMessagesResponse*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessagesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, &a->_wsnt__GetMessagesResponse::NotificationMessage, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__GetMessagesResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__GetMessagesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__GetMessagesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_in__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, _wsnt__GetMessagesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__GetMessagesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(_wsnt__GetMessagesResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__GetMessagesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__GetMessagesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wsnt__GetMessagesResponse*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", &a->_wsnt__GetMessagesResponse::NotificationMessage, "wsnt:NotificationMessageHolderType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__GetMessagesResponse::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__GetMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessagesResponse, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(_wsnt__GetMessagesResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__GetMessagesResponse * SOAP_FMAC2 imageing_instantiate__wsnt__GetMessagesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__GetMessagesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__GetMessagesResponse *p;
	size_t k = sizeof(_wsnt__GetMessagesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__GetMessagesResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__GetMessagesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__GetMessagesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__GetMessagesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__GetMessagesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__GetMessagesResponse(soap, tag ? tag : "wsnt:GetMessagesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__GetMessagesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__GetMessagesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_get__wsnt__GetMessagesResponse(struct soap *soap, _wsnt__GetMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__GetMessages::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_wsnt__GetMessages::MaximumNumber = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetMessages::__any);
	this->_wsnt__GetMessages::__anyAttribute = NULL;
}

void _wsnt__GetMessages::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->_wsnt__GetMessages::MaximumNumber);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetMessages::__any);
#endif
}

int _wsnt__GetMessages::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__GetMessages(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessages(struct soap *soap, const char *tag, int id, const _wsnt__GetMessages *a, const char *type)
{
	if (((_wsnt__GetMessages*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wsnt__GetMessages*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessages), type))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "wsnt:MaximumNumber", -1, &a->_wsnt__GetMessages::MaximumNumber, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__GetMessages::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__GetMessages::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__GetMessages(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__GetMessages * SOAP_FMAC4 soap_in__wsnt__GetMessages(struct soap *soap, const char *tag, _wsnt__GetMessages *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__GetMessages*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessages, sizeof(_wsnt__GetMessages), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__GetMessages)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__GetMessages *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wsnt__GetMessages*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_MaximumNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__nonNegativeInteger(soap, "wsnt:MaximumNumber", &a->_wsnt__GetMessages::MaximumNumber, "xsd:nonNegativeInteger"))
				{	soap_flag_MaximumNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__GetMessages::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__GetMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessages, SOAP_TYPE__wsnt__GetMessages, sizeof(_wsnt__GetMessages), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__GetMessages * SOAP_FMAC2 imageing_instantiate__wsnt__GetMessages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__GetMessages(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__GetMessages *p;
	size_t k = sizeof(_wsnt__GetMessages);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__GetMessages, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__GetMessages);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__GetMessages, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__GetMessages location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__GetMessages::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__GetMessages(soap, tag ? tag : "wsnt:GetMessages", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__GetMessages::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__GetMessages(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__GetMessages * SOAP_FMAC4 soap_get__wsnt__GetMessages(struct soap *soap, _wsnt__GetMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__GetCurrentMessageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetCurrentMessageResponse::__any);
}

void _wsnt__GetCurrentMessageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetCurrentMessageResponse::__any);
#endif
}

int _wsnt__GetCurrentMessageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__GetCurrentMessageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, int id, const _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__GetCurrentMessageResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__GetCurrentMessageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__GetCurrentMessageResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__GetCurrentMessageResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(_wsnt__GetCurrentMessageResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__GetCurrentMessageResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__GetCurrentMessageResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__GetCurrentMessageResponse::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__GetCurrentMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessageResponse, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(_wsnt__GetCurrentMessageResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__GetCurrentMessageResponse * SOAP_FMAC2 imageing_instantiate__wsnt__GetCurrentMessageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__GetCurrentMessageResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__GetCurrentMessageResponse *p;
	size_t k = sizeof(_wsnt__GetCurrentMessageResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__GetCurrentMessageResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__GetCurrentMessageResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__GetCurrentMessageResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__GetCurrentMessageResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__GetCurrentMessageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__GetCurrentMessageResponse(soap, tag ? tag : "wsnt:GetCurrentMessageResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__GetCurrentMessageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__GetCurrentMessageResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessageResponse(struct soap *soap, _wsnt__GetCurrentMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__GetCurrentMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_wsnt__GetCurrentMessage::Topic = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetCurrentMessage::__any);
}

void _wsnt__GetCurrentMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &this->_wsnt__GetCurrentMessage::Topic);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetCurrentMessage::__any);
#endif
}

int _wsnt__GetCurrentMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__GetCurrentMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, int id, const _wsnt__GetCurrentMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessage), type))
		return soap->error;
	if (!a->_wsnt__GetCurrentMessage::Topic)
	{	if (soap_element_empty(soap, "wsnt:Topic", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", -1, &a->_wsnt__GetCurrentMessage::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__GetCurrentMessage::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__GetCurrentMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__GetCurrentMessage(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, _wsnt__GetCurrentMessage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__GetCurrentMessage*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(_wsnt__GetCurrentMessage), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__GetCurrentMessage)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__GetCurrentMessage *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Topic1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Topic1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", &a->_wsnt__GetCurrentMessage::Topic, "wsnt:TopicExpressionType"))
				{	soap_flag_Topic1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__GetCurrentMessage::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_wsnt__GetCurrentMessage::Topic))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__GetCurrentMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessage, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(_wsnt__GetCurrentMessage), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__GetCurrentMessage * SOAP_FMAC2 imageing_instantiate__wsnt__GetCurrentMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__GetCurrentMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__GetCurrentMessage *p;
	size_t k = sizeof(_wsnt__GetCurrentMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__GetCurrentMessage, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__GetCurrentMessage);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__GetCurrentMessage, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__GetCurrentMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__GetCurrentMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__GetCurrentMessage(soap, tag ? tag : "wsnt:GetCurrentMessage", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__GetCurrentMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__GetCurrentMessage(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessage(struct soap *soap, _wsnt__GetCurrentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__SubscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnt__SubscribeResponse::SubscriptionReference);
	this->_wsnt__SubscribeResponse::CurrentTime = NULL;
	this->_wsnt__SubscribeResponse::TerminationTime = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__SubscribeResponse::__any);
}

void _wsnt__SubscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__SubscribeResponse::SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnt__SubscribeResponse::SubscriptionReference);
	soap_serialize_PointerTodateTime(soap, &this->_wsnt__SubscribeResponse::CurrentTime);
	soap_serialize_PointerTodateTime(soap, &this->_wsnt__SubscribeResponse::TerminationTime);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__SubscribeResponse::__any);
#endif
}

int _wsnt__SubscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__SubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeResponse(struct soap *soap, const char *tag, int id, const _wsnt__SubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeResponse), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->_wsnt__SubscribeResponse::SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CurrentTime", -1, &a->_wsnt__SubscribeResponse::CurrentTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:TerminationTime", -1, &a->_wsnt__SubscribeResponse::TerminationTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__SubscribeResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__SubscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__SubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__SubscribeResponse * SOAP_FMAC4 soap_in__wsnt__SubscribeResponse(struct soap *soap, const char *tag, _wsnt__SubscribeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__SubscribeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(_wsnt__SubscribeResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__SubscribeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__SubscribeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SubscriptionReference1 = 1;
	size_t soap_flag_CurrentTime1 = 1;
	size_t soap_flag_TerminationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->_wsnt__SubscribeResponse::SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference1--;
					continue;
				}
			}
			if (soap_flag_CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CurrentTime", &a->_wsnt__SubscribeResponse::CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime1--;
					continue;
				}
			}
			if (soap_flag_TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:TerminationTime", &a->_wsnt__SubscribeResponse::TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__SubscribeResponse::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeResponse, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(_wsnt__SubscribeResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__SubscribeResponse * SOAP_FMAC2 imageing_instantiate__wsnt__SubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__SubscribeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__SubscribeResponse *p;
	size_t k = sizeof(_wsnt__SubscribeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__SubscribeResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__SubscribeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__SubscribeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__SubscribeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__SubscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__SubscribeResponse(soap, tag ? tag : "wsnt:SubscribeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__SubscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__SubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__SubscribeResponse * SOAP_FMAC4 soap_get__wsnt__SubscribeResponse(struct soap *soap, _wsnt__SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Subscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnt__Subscribe::ConsumerReference);
	this->_wsnt__Subscribe::Filter = NULL;
	this->_wsnt__Subscribe::InitialTerminationTime = NULL;
	this->_wsnt__Subscribe::SubscriptionPolicy = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__Subscribe::__any);
}

void _wsnt__Subscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__Subscribe::ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnt__Subscribe::ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &this->_wsnt__Subscribe::Filter);
	soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, &this->_wsnt__Subscribe::InitialTerminationTime);
	soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, &this->_wsnt__Subscribe::SubscriptionPolicy);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__Subscribe::__any);
#endif
}

int _wsnt__Subscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Subscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe(struct soap *soap, const char *tag, int id, const _wsnt__Subscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Subscribe), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->_wsnt__Subscribe::ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->_wsnt__Subscribe::Filter, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", -1, &a->_wsnt__Subscribe::InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", -1, &a->_wsnt__Subscribe::SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__Subscribe::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Subscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__Subscribe(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Subscribe * SOAP_FMAC4 soap_in__wsnt__Subscribe(struct soap *soap, const char *tag, _wsnt__Subscribe *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Subscribe*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe, sizeof(_wsnt__Subscribe), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Subscribe)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Subscribe *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ConsumerReference1 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_InitialTerminationTime1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->_wsnt__Subscribe::ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference1--;
					continue;
				}
			}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->_wsnt__Subscribe::Filter, "wsnt:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			}
			if (soap_flag_InitialTerminationTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", &a->_wsnt__Subscribe::InitialTerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime1--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", &a->_wsnt__Subscribe::SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__Subscribe::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe, SOAP_TYPE__wsnt__Subscribe, sizeof(_wsnt__Subscribe), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Subscribe * SOAP_FMAC2 imageing_instantiate__wsnt__Subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__Subscribe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Subscribe *p;
	size_t k = sizeof(_wsnt__Subscribe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Subscribe, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Subscribe);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Subscribe, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Subscribe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Subscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Subscribe(soap, tag ? tag : "wsnt:Subscribe", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Subscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Subscribe(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Subscribe * SOAP_FMAC4 soap_get__wsnt__Subscribe(struct soap *soap, _wsnt__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__UseRaw::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _wsnt__UseRaw::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _wsnt__UseRaw::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__UseRaw(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UseRaw(struct soap *soap, const char *tag, int id, const _wsnt__UseRaw *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UseRaw), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__UseRaw::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__UseRaw(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__UseRaw * SOAP_FMAC4 soap_in__wsnt__UseRaw(struct soap *soap, const char *tag, _wsnt__UseRaw *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__UseRaw*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UseRaw, sizeof(_wsnt__UseRaw), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__UseRaw)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__UseRaw *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__UseRaw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UseRaw, SOAP_TYPE__wsnt__UseRaw, sizeof(_wsnt__UseRaw), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__UseRaw * SOAP_FMAC2 imageing_instantiate__wsnt__UseRaw(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__UseRaw(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__UseRaw *p;
	size_t k = sizeof(_wsnt__UseRaw);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__UseRaw, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__UseRaw);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__UseRaw, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__UseRaw location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__UseRaw::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__UseRaw(soap, tag ? tag : "wsnt:UseRaw", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__UseRaw::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__UseRaw(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__UseRaw * SOAP_FMAC4 soap_get__wsnt__UseRaw(struct soap *soap, _wsnt__UseRaw *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UseRaw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Notify::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_wsnt__Notify::NotificationMessage);
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__Notify::__any);
}

void _wsnt__Notify::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_wsnt__Notify::NotificationMessage);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__Notify::__any);
#endif
}

int _wsnt__Notify::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Notify(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Notify(struct soap *soap, const char *tag, int id, const _wsnt__Notify *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Notify), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, &a->_wsnt__Notify::NotificationMessage, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__Notify::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Notify::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__Notify(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Notify * SOAP_FMAC4 soap_in__wsnt__Notify(struct soap *soap, const char *tag, _wsnt__Notify *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Notify*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Notify, sizeof(_wsnt__Notify), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Notify)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Notify *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", &a->_wsnt__Notify::NotificationMessage, "wsnt:NotificationMessageHolderType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__Notify::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_wsnt__Notify::NotificationMessage.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__Notify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Notify, SOAP_TYPE__wsnt__Notify, sizeof(_wsnt__Notify), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Notify * SOAP_FMAC2 imageing_instantiate__wsnt__Notify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__Notify(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Notify *p;
	size_t k = sizeof(_wsnt__Notify);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Notify, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Notify);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Notify, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Notify location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Notify::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Notify(soap, tag ? tag : "wsnt:Notify", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Notify::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Notify(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Notify * SOAP_FMAC4 soap_get__wsnt__Notify(struct soap *soap, _wsnt__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__SubscriptionManagerRP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnt__SubscriptionManagerRP::ConsumerReference);
	this->_wsnt__SubscriptionManagerRP::Filter = NULL;
	this->_wsnt__SubscriptionManagerRP::SubscriptionPolicy = NULL;
	this->_wsnt__SubscriptionManagerRP::CreationTime = NULL;
}

void _wsnt__SubscriptionManagerRP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__SubscriptionManagerRP::ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnt__SubscriptionManagerRP::ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &this->_wsnt__SubscriptionManagerRP::Filter);
	soap_serialize_PointerTowsnt__SubscriptionPolicyType(soap, &this->_wsnt__SubscriptionManagerRP::SubscriptionPolicy);
	soap_serialize_PointerTodateTime(soap, &this->_wsnt__SubscriptionManagerRP::CreationTime);
#endif
}

int _wsnt__SubscriptionManagerRP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__SubscriptionManagerRP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, int id, const _wsnt__SubscriptionManagerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->_wsnt__SubscriptionManagerRP::ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->_wsnt__SubscriptionManagerRP::Filter, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", -1, &a->_wsnt__SubscriptionManagerRP::SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CreationTime", -1, &a->_wsnt__SubscriptionManagerRP::CreationTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__SubscriptionManagerRP::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__SubscriptionManagerRP(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_in__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, _wsnt__SubscriptionManagerRP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__SubscriptionManagerRP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(_wsnt__SubscriptionManagerRP), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__SubscriptionManagerRP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__SubscriptionManagerRP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ConsumerReference1 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	size_t soap_flag_CreationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->_wsnt__SubscriptionManagerRP::ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference1--;
					continue;
				}
			}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->_wsnt__SubscriptionManagerRP::Filter, "wsnt:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", &a->_wsnt__SubscriptionManagerRP::SubscriptionPolicy, "wsnt:SubscriptionPolicyType"))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			}
			if (soap_flag_CreationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CreationTime", &a->_wsnt__SubscriptionManagerRP::CreationTime, "xsd:dateTime"))
				{	soap_flag_CreationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__SubscriptionManagerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscriptionManagerRP, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(_wsnt__SubscriptionManagerRP), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__SubscriptionManagerRP * SOAP_FMAC2 imageing_instantiate__wsnt__SubscriptionManagerRP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__SubscriptionManagerRP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__SubscriptionManagerRP *p;
	size_t k = sizeof(_wsnt__SubscriptionManagerRP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__SubscriptionManagerRP, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__SubscriptionManagerRP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__SubscriptionManagerRP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__SubscriptionManagerRP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__SubscriptionManagerRP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__SubscriptionManagerRP(soap, tag ? tag : "wsnt:SubscriptionManagerRP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__SubscriptionManagerRP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__SubscriptionManagerRP(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_get__wsnt__SubscriptionManagerRP(struct soap *soap, _wsnt__SubscriptionManagerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscriptionManagerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__NotificationProducerRP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap, &this->_wsnt__NotificationProducerRP::TopicExpression);
	this->_wsnt__NotificationProducerRP::FixedTopicSet = NULL;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_wsnt__NotificationProducerRP::TopicExpressionDialect);
	this->_wsnt__NotificationProducerRP::wstop__TopicSet = NULL;
}

void _wsnt__NotificationProducerRP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap, &this->_wsnt__NotificationProducerRP::TopicExpression);
	soap_serialize_PointerTobool(soap, &this->_wsnt__NotificationProducerRP::FixedTopicSet);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_wsnt__NotificationProducerRP::TopicExpressionDialect);
	soap_serialize_PointerTowstop__TopicSetType(soap, &this->_wsnt__NotificationProducerRP::wstop__TopicSet);
#endif
}

int _wsnt__NotificationProducerRP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__NotificationProducerRP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, int id, const _wsnt__NotificationProducerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotificationProducerRP), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap, "wsnt:TopicExpression", -1, &a->_wsnt__NotificationProducerRP::TopicExpression, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "wsnt:FixedTopicSet", -1, &a->_wsnt__NotificationProducerRP::FixedTopicSet, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "wsnt:TopicExpressionDialect", -1, &a->_wsnt__NotificationProducerRP::TopicExpressionDialect, ""))
		return soap->error;
	if (soap_out_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", -1, &a->_wsnt__NotificationProducerRP::wstop__TopicSet, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__NotificationProducerRP::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__NotificationProducerRP(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_in__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, _wsnt__NotificationProducerRP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__NotificationProducerRP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(_wsnt__NotificationProducerRP), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__NotificationProducerRP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__NotificationProducerRP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FixedTopicSet1 = 1;
	size_t soap_flag_wstop__TopicSet1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap, "wsnt:TopicExpression", &a->_wsnt__NotificationProducerRP::TopicExpression, "wsnt:TopicExpressionType"))
					continue;
			}
			if (soap_flag_FixedTopicSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "wsnt:FixedTopicSet", &a->_wsnt__NotificationProducerRP::FixedTopicSet, "xsd:boolean"))
				{	soap_flag_FixedTopicSet1--;
					continue;
				}
				if (soap->error == SOAP_EMPTY)
				{	if (!(a->_wsnt__NotificationProducerRP::FixedTopicSet = (bool *)soap_malloc(soap, sizeof(bool))))
						return NULL;
					*a->_wsnt__NotificationProducerRP::FixedTopicSet = (bool)1;
					soap->error = SOAP_OK;
					soap_flag_FixedTopicSet1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "wsnt:TopicExpressionDialect", &a->_wsnt__NotificationProducerRP::TopicExpressionDialect, "xsd:anyURI"))
					continue;
			}
			if (soap_flag_wstop__TopicSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", &a->_wsnt__NotificationProducerRP::wstop__TopicSet, "wstop:TopicSetType"))
				{	soap_flag_wstop__TopicSet1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__NotificationProducerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationProducerRP, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(_wsnt__NotificationProducerRP), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__NotificationProducerRP * SOAP_FMAC2 imageing_instantiate__wsnt__NotificationProducerRP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__wsnt__NotificationProducerRP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__NotificationProducerRP *p;
	size_t k = sizeof(_wsnt__NotificationProducerRP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__NotificationProducerRP, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__NotificationProducerRP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__NotificationProducerRP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__NotificationProducerRP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__NotificationProducerRP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__NotificationProducerRP(soap, tag ? tag : "wsnt:NotificationProducerRP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__NotificationProducerRP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__NotificationProducerRP(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_get__wsnt__NotificationProducerRP(struct soap *soap, _wsnt__NotificationProducerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotificationProducerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__ResumeFailedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__ResumeFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__ResumeFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__ResumeFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, const wsnt__ResumeFailedFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType), type ? type : "wsnt:ResumeFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__ResumeFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__ResumeFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_in_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, wsnt__ResumeFailedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__ResumeFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(wsnt__ResumeFailedFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__ResumeFailedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__ResumeFailedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__ResumeFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__ResumeFailedFaultType, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(wsnt__ResumeFailedFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__ResumeFailedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__ResumeFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__ResumeFailedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__ResumeFailedFaultType *p;
	size_t k = sizeof(wsnt__ResumeFailedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__ResumeFailedFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__ResumeFailedFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__ResumeFailedFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__ResumeFailedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__ResumeFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__ResumeFailedFaultType(soap, tag ? tag : "wsnt:ResumeFailedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__ResumeFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__ResumeFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_get_wsnt__ResumeFailedFaultType(struct soap *soap, wsnt__ResumeFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__PauseFailedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__PauseFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__PauseFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__PauseFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, int id, const wsnt__PauseFailedFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__PauseFailedFaultType), type ? type : "wsnt:PauseFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__PauseFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__PauseFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_in_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, wsnt__PauseFailedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__PauseFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(wsnt__PauseFailedFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__PauseFailedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__PauseFailedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__PauseFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__PauseFailedFaultType, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(wsnt__PauseFailedFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__PauseFailedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__PauseFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__PauseFailedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__PauseFailedFaultType *p;
	size_t k = sizeof(wsnt__PauseFailedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__PauseFailedFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__PauseFailedFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__PauseFailedFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__PauseFailedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__PauseFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__PauseFailedFaultType(soap, tag ? tag : "wsnt:PauseFailedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__PauseFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__PauseFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_get_wsnt__PauseFailedFaultType(struct soap *soap, wsnt__PauseFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnableToDestroySubscriptionFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__UnableToDestroySubscriptionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnableToDestroySubscriptionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType), type ? type : "wsnt:UnableToDestroySubscriptionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnableToDestroySubscriptionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnableToDestroySubscriptionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(wsnt__UnableToDestroySubscriptionFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnableToDestroySubscriptionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnableToDestroySubscriptionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(wsnt__UnableToDestroySubscriptionFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__UnableToDestroySubscriptionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnableToDestroySubscriptionFaultType *p;
	size_t k = sizeof(wsnt__UnableToDestroySubscriptionFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnableToDestroySubscriptionFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnableToDestroySubscriptionFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnableToDestroySubscriptionFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnableToDestroySubscriptionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnableToDestroySubscriptionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnableToDestroySubscriptionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, wsnt__UnableToDestroySubscriptionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnacceptableTerminationTimeFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_dateTime(soap, &this->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime);
	this->wsnt__UnacceptableTerminationTimeFaultType::MaximumTime = NULL;
}

void wsnt__UnacceptableTerminationTimeFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &this->wsnt__UnacceptableTerminationTimeFaultType::MaximumTime);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnacceptableTerminationTimeFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType), type ? type : "wsnt:UnacceptableTerminationTimeFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:MinimumTime", -1, &a->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:MaximumTime", -1, &a->wsnt__UnacceptableTerminationTimeFaultType::MaximumTime, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnacceptableTerminationTimeFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnacceptableTerminationTimeFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(wsnt__UnacceptableTerminationTimeFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnacceptableTerminationTimeFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	size_t soap_flag_MinimumTime1 = 1;
	size_t soap_flag_MaximumTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap_flag_MinimumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:MinimumTime", &a->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime1--;
					continue;
				}
			}
			if (soap_flag_MaximumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:MaximumTime", &a->wsnt__UnacceptableTerminationTimeFaultType::MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || soap_flag_MinimumTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnacceptableTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(wsnt__UnacceptableTerminationTimeFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__UnacceptableTerminationTimeFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnacceptableTerminationTimeFaultType *p;
	size_t k = sizeof(wsnt__UnacceptableTerminationTimeFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnacceptableTerminationTimeFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnacceptableTerminationTimeFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnacceptableTerminationTimeFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnacceptableTerminationTimeFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnacceptableTerminationTimeFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnacceptableTerminationTimeFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnableToCreatePullPointFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__UnableToCreatePullPointFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnableToCreatePullPointFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType), type ? type : "wsnt:UnableToCreatePullPointFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnableToCreatePullPointFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnableToCreatePullPointFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(wsnt__UnableToCreatePullPointFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnableToCreatePullPointFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnableToCreatePullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(wsnt__UnableToCreatePullPointFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__UnableToCreatePullPointFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnableToCreatePullPointFaultType *p;
	size_t k = sizeof(wsnt__UnableToCreatePullPointFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnableToCreatePullPointFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnableToCreatePullPointFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnableToCreatePullPointFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnableToCreatePullPointFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnableToCreatePullPointFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnableToCreatePullPointFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, wsnt__UnableToCreatePullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnableToDestroyPullPointFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__UnableToDestroyPullPointFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnableToDestroyPullPointFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnableToDestroyPullPointFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnableToDestroyPullPointFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType), type ? type : "wsnt:UnableToDestroyPullPointFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnableToDestroyPullPointFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, wsnt__UnableToDestroyPullPointFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnableToDestroyPullPointFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(wsnt__UnableToDestroyPullPointFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnableToDestroyPullPointFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnableToDestroyPullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(wsnt__UnableToDestroyPullPointFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__UnableToDestroyPullPointFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnableToDestroyPullPointFaultType *p;
	size_t k = sizeof(wsnt__UnableToDestroyPullPointFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnableToDestroyPullPointFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnableToDestroyPullPointFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnableToDestroyPullPointFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnableToDestroyPullPointFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnableToDestroyPullPointFaultType(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnableToDestroyPullPointFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnableToDestroyPullPointFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, wsnt__UnableToDestroyPullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnableToGetMessagesFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__UnableToGetMessagesFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnableToGetMessagesFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnableToGetMessagesFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnableToGetMessagesFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType), type ? type : "wsnt:UnableToGetMessagesFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnableToGetMessagesFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, wsnt__UnableToGetMessagesFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnableToGetMessagesFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(wsnt__UnableToGetMessagesFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnableToGetMessagesFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnableToGetMessagesFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnableToGetMessagesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(wsnt__UnableToGetMessagesFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnableToGetMessagesFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__UnableToGetMessagesFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnableToGetMessagesFaultType *p;
	size_t k = sizeof(wsnt__UnableToGetMessagesFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnableToGetMessagesFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnableToGetMessagesFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnableToGetMessagesFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnableToGetMessagesFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnableToGetMessagesFaultType(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnableToGetMessagesFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnableToGetMessagesFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToGetMessagesFaultType(struct soap *soap, wsnt__UnableToGetMessagesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__NoCurrentMessageOnTopicFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__NoCurrentMessageOnTopicFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__NoCurrentMessageOnTopicFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, const wsnt__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType), type ? type : "wsnt:NoCurrentMessageOnTopicFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__NoCurrentMessageOnTopicFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_in_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, wsnt__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__NoCurrentMessageOnTopicFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(wsnt__NoCurrentMessageOnTopicFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__NoCurrentMessageOnTopicFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__NoCurrentMessageOnTopicFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(wsnt__NoCurrentMessageOnTopicFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__NoCurrentMessageOnTopicFaultType *p;
	size_t k = sizeof(wsnt__NoCurrentMessageOnTopicFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__NoCurrentMessageOnTopicFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__NoCurrentMessageOnTopicFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__NoCurrentMessageOnTopicFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__NoCurrentMessageOnTopicFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__NoCurrentMessageOnTopicFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__NoCurrentMessageOnTopicFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_get_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, wsnt__NoCurrentMessageOnTopicFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnacceptableInitialTerminationTimeFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_dateTime(soap, &this->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime);
	this->wsnt__UnacceptableInitialTerminationTimeFaultType::MaximumTime = NULL;
}

void wsnt__UnacceptableInitialTerminationTimeFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &this->wsnt__UnacceptableInitialTerminationTimeFaultType::MaximumTime);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnacceptableInitialTerminationTimeFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType), type ? type : "wsnt:UnacceptableInitialTerminationTimeFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:MinimumTime", -1, &a->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:MaximumTime", -1, &a->wsnt__UnacceptableInitialTerminationTimeFaultType::MaximumTime, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnacceptableInitialTerminationTimeFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnacceptableInitialTerminationTimeFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(wsnt__UnacceptableInitialTerminationTimeFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnacceptableInitialTerminationTimeFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	size_t soap_flag_MinimumTime1 = 1;
	size_t soap_flag_MaximumTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap_flag_MinimumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:MinimumTime", &a->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime1--;
					continue;
				}
			}
			if (soap_flag_MaximumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:MaximumTime", &a->wsnt__UnacceptableInitialTerminationTimeFaultType::MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || soap_flag_MinimumTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnacceptableInitialTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(wsnt__UnacceptableInitialTerminationTimeFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnacceptableInitialTerminationTimeFaultType *p;
	size_t k = sizeof(wsnt__UnacceptableInitialTerminationTimeFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnacceptableInitialTerminationTimeFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnacceptableInitialTerminationTimeFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnacceptableInitialTerminationTimeFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnacceptableInitialTerminationTimeFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnacceptableInitialTerminationTimeFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableInitialTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__NotifyMessageNotSupportedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__NotifyMessageNotSupportedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__NotifyMessageNotSupportedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, const wsnt__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType), type ? type : "wsnt:NotifyMessageNotSupportedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__NotifyMessageNotSupportedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, wsnt__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__NotifyMessageNotSupportedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(wsnt__NotifyMessageNotSupportedFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__NotifyMessageNotSupportedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__NotifyMessageNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(wsnt__NotifyMessageNotSupportedFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__NotifyMessageNotSupportedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__NotifyMessageNotSupportedFaultType *p;
	size_t k = sizeof(wsnt__NotifyMessageNotSupportedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__NotifyMessageNotSupportedFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__NotifyMessageNotSupportedFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__NotifyMessageNotSupportedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__NotifyMessageNotSupportedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__NotifyMessageNotSupportedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__NotifyMessageNotSupportedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, wsnt__NotifyMessageNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnsupportedPolicyRequestFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__UnsupportedPolicyRequestFaultType::UnsupportedPolicy);
}

void wsnt__UnsupportedPolicyRequestFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__UnsupportedPolicyRequestFaultType::UnsupportedPolicy);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnsupportedPolicyRequestFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType), type ? type : "wsnt:UnsupportedPolicyRequestFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnsupportedPolicy", -1, &a->wsnt__UnsupportedPolicyRequestFaultType::UnsupportedPolicy, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnsupportedPolicyRequestFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnsupportedPolicyRequestFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(wsnt__UnsupportedPolicyRequestFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnsupportedPolicyRequestFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnsupportedPolicy", &a->wsnt__UnsupportedPolicyRequestFaultType::UnsupportedPolicy, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnsupportedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(wsnt__UnsupportedPolicyRequestFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__UnsupportedPolicyRequestFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnsupportedPolicyRequestFaultType *p;
	size_t k = sizeof(wsnt__UnsupportedPolicyRequestFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnsupportedPolicyRequestFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnsupportedPolicyRequestFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnsupportedPolicyRequestFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnsupportedPolicyRequestFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnsupportedPolicyRequestFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnsupportedPolicyRequestFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, wsnt__UnsupportedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnrecognizedPolicyRequestFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy);
}

void wsnt__UnrecognizedPolicyRequestFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnrecognizedPolicyRequestFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType), type ? type : "wsnt:UnrecognizedPolicyRequestFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnrecognizedPolicy", -1, &a->wsnt__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnrecognizedPolicyRequestFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnrecognizedPolicyRequestFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(wsnt__UnrecognizedPolicyRequestFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnrecognizedPolicyRequestFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnrecognizedPolicy", &a->wsnt__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnrecognizedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(wsnt__UnrecognizedPolicyRequestFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnrecognizedPolicyRequestFaultType *p;
	size_t k = sizeof(wsnt__UnrecognizedPolicyRequestFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnrecognizedPolicyRequestFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnrecognizedPolicyRequestFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnrecognizedPolicyRequestFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnrecognizedPolicyRequestFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnrecognizedPolicyRequestFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnrecognizedPolicyRequestFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, wsnt__UnrecognizedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__InvalidMessageContentExpressionFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__InvalidMessageContentExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__InvalidMessageContentExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, const wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType), type ? type : "wsnt:InvalidMessageContentExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__InvalidMessageContentExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__InvalidMessageContentExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(wsnt__InvalidMessageContentExpressionFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__InvalidMessageContentExpressionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__InvalidMessageContentExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(wsnt__InvalidMessageContentExpressionFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__InvalidMessageContentExpressionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__InvalidMessageContentExpressionFaultType *p;
	size_t k = sizeof(wsnt__InvalidMessageContentExpressionFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__InvalidMessageContentExpressionFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__InvalidMessageContentExpressionFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__InvalidMessageContentExpressionFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__InvalidMessageContentExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__InvalidMessageContentExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__InvalidMessageContentExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, wsnt__InvalidMessageContentExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__InvalidProducerPropertiesExpressionFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__InvalidProducerPropertiesExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__InvalidProducerPropertiesExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, const wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType), type ? type : "wsnt:InvalidProducerPropertiesExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__InvalidProducerPropertiesExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__InvalidProducerPropertiesExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(wsnt__InvalidProducerPropertiesExpressionFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__InvalidProducerPropertiesExpressionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__InvalidProducerPropertiesExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(wsnt__InvalidProducerPropertiesExpressionFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__InvalidProducerPropertiesExpressionFaultType *p;
	size_t k = sizeof(wsnt__InvalidProducerPropertiesExpressionFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__InvalidProducerPropertiesExpressionFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__InvalidProducerPropertiesExpressionFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__InvalidProducerPropertiesExpressionFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__InvalidProducerPropertiesExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__InvalidProducerPropertiesExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, wsnt__InvalidProducerPropertiesExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__MultipleTopicsSpecifiedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__MultipleTopicsSpecifiedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__MultipleTopicsSpecifiedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, const wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType), type ? type : "wsnt:MultipleTopicsSpecifiedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__MultipleTopicsSpecifiedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_in_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__MultipleTopicsSpecifiedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(wsnt__MultipleTopicsSpecifiedFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__MultipleTopicsSpecifiedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__MultipleTopicsSpecifiedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(wsnt__MultipleTopicsSpecifiedFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__MultipleTopicsSpecifiedFaultType *p;
	size_t k = sizeof(wsnt__MultipleTopicsSpecifiedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__MultipleTopicsSpecifiedFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__MultipleTopicsSpecifiedFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__MultipleTopicsSpecifiedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__MultipleTopicsSpecifiedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__MultipleTopicsSpecifiedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__MultipleTopicsSpecifiedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_get_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, wsnt__MultipleTopicsSpecifiedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__TopicNotSupportedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__TopicNotSupportedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__TopicNotSupportedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__TopicNotSupportedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, const wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType), type ? type : "wsnt:TopicNotSupportedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__TopicNotSupportedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__TopicNotSupportedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(wsnt__TopicNotSupportedFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__TopicNotSupportedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__TopicNotSupportedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__TopicNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(wsnt__TopicNotSupportedFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__TopicNotSupportedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__TopicNotSupportedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__TopicNotSupportedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__TopicNotSupportedFaultType *p;
	size_t k = sizeof(wsnt__TopicNotSupportedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__TopicNotSupportedFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__TopicNotSupportedFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__TopicNotSupportedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__TopicNotSupportedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__TopicNotSupportedFaultType(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__TopicNotSupportedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__TopicNotSupportedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__TopicNotSupportedFaultType(struct soap *soap, wsnt__TopicNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__InvalidTopicExpressionFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__InvalidTopicExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__InvalidTopicExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, const wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType), type ? type : "wsnt:InvalidTopicExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__InvalidTopicExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__InvalidTopicExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(wsnt__InvalidTopicExpressionFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__InvalidTopicExpressionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__InvalidTopicExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(wsnt__InvalidTopicExpressionFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__InvalidTopicExpressionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__InvalidTopicExpressionFaultType *p;
	size_t k = sizeof(wsnt__InvalidTopicExpressionFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__InvalidTopicExpressionFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__InvalidTopicExpressionFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__InvalidTopicExpressionFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__InvalidTopicExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__InvalidTopicExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__InvalidTopicExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, wsnt__InvalidTopicExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__TopicExpressionDialectUnknownFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__TopicExpressionDialectUnknownFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__TopicExpressionDialectUnknownFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, const wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType), type ? type : "wsnt:TopicExpressionDialectUnknownFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__TopicExpressionDialectUnknownFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__TopicExpressionDialectUnknownFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(wsnt__TopicExpressionDialectUnknownFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__TopicExpressionDialectUnknownFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(wsnt__TopicExpressionDialectUnknownFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__TopicExpressionDialectUnknownFaultType *p;
	size_t k = sizeof(wsnt__TopicExpressionDialectUnknownFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__TopicExpressionDialectUnknownFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__TopicExpressionDialectUnknownFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__TopicExpressionDialectUnknownFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__TopicExpressionDialectUnknownFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__TopicExpressionDialectUnknownFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__TopicExpressionDialectUnknownFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, wsnt__TopicExpressionDialectUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__InvalidFilterFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__InvalidFilterFaultType::UnknownFilter);
}

void wsnt__InvalidFilterFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__InvalidFilterFaultType::UnknownFilter);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__InvalidFilterFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__InvalidFilterFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, const wsnt__InvalidFilterFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType), type ? type : "wsnt:InvalidFilterFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnknownFilter", -1, &a->wsnt__InvalidFilterFaultType::UnknownFilter, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__InvalidFilterFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__InvalidFilterFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, wsnt__InvalidFilterFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__InvalidFilterFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(wsnt__InvalidFilterFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__InvalidFilterFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__InvalidFilterFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnknownFilter", &a->wsnt__InvalidFilterFaultType::UnknownFilter, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || a->wsnt__InvalidFilterFaultType::UnknownFilter.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidFilterFaultType, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(wsnt__InvalidFilterFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__InvalidFilterFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__InvalidFilterFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__InvalidFilterFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__InvalidFilterFaultType *p;
	size_t k = sizeof(wsnt__InvalidFilterFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__InvalidFilterFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__InvalidFilterFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__InvalidFilterFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__InvalidFilterFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__InvalidFilterFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__InvalidFilterFaultType(soap, tag ? tag : "wsnt:InvalidFilterFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__InvalidFilterFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__InvalidFilterFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidFilterFaultType(struct soap *soap, wsnt__InvalidFilterFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__SubscribeCreationFailedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__SubscribeCreationFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__SubscribeCreationFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, const wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType), type ? type : "wsnt:SubscribeCreationFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__SubscribeCreationFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__SubscribeCreationFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(wsnt__SubscribeCreationFailedFaultType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__SubscribeCreationFailedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(wsnt__SubscribeCreationFailedFaultType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__SubscribeCreationFailedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__SubscribeCreationFailedFaultType *p;
	size_t k = sizeof(wsnt__SubscribeCreationFailedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__SubscribeCreationFailedFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__SubscribeCreationFailedFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__SubscribeCreationFailedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__SubscribeCreationFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__SubscribeCreationFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__SubscribeCreationFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, wsnt__SubscribeCreationFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__NotificationMessageHolderType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->wsnt__NotificationMessageHolderType::SubscriptionReference = NULL;
	this->wsnt__NotificationMessageHolderType::Topic = NULL;
	this->wsnt__NotificationMessageHolderType::ProducerReference = NULL;
	this->wsnt__NotificationMessageHolderType::Message._wsnt__NotificationMessageHolderType_Message::soap_default(soap);
}

void wsnt__NotificationMessageHolderType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsnt__NotificationMessageHolderType::SubscriptionReference);
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &this->wsnt__NotificationMessageHolderType::Topic);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsnt__NotificationMessageHolderType::ProducerReference);
	this->wsnt__NotificationMessageHolderType::Message.soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wsnt__NotificationMessageHolderType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__NotificationMessageHolderType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const wsnt__NotificationMessageHolderType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType), type ? type : "wsnt:NotificationMessageHolderType"))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->wsnt__NotificationMessageHolderType::SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", -1, &a->wsnt__NotificationMessageHolderType::Topic, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", -1, &a->wsnt__NotificationMessageHolderType::ProducerReference, ""))
		return soap->error;
	if ((a->wsnt__NotificationMessageHolderType::Message).soap_out(soap, "wsnt:Message", -1, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__NotificationMessageHolderType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__NotificationMessageHolderType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_in_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, wsnt__NotificationMessageHolderType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__NotificationMessageHolderType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__NotificationMessageHolderType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__NotificationMessageHolderType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_SubscriptionReference1 = 1;
	size_t soap_flag_Topic1 = 1;
	size_t soap_flag_ProducerReference1 = 1;
	size_t soap_flag_Message1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->wsnt__NotificationMessageHolderType::SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference1--;
					continue;
				}
			}
			if (soap_flag_Topic1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", &a->wsnt__NotificationMessageHolderType::Topic, "wsnt:TopicExpressionType"))
				{	soap_flag_Topic1--;
					continue;
				}
			}
			if (soap_flag_ProducerReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", &a->wsnt__NotificationMessageHolderType::ProducerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ProducerReference1--;
					continue;
				}
			}
			if (soap_flag_Message1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->wsnt__NotificationMessageHolderType::Message).soap_in(soap, "wsnt:Message", ""))
				{	soap_flag_Message1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotificationMessageHolderType, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__NotificationMessageHolderType * SOAP_FMAC2 imageing_instantiate_wsnt__NotificationMessageHolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__NotificationMessageHolderType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__NotificationMessageHolderType *p;
	size_t k = sizeof(wsnt__NotificationMessageHolderType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__NotificationMessageHolderType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__NotificationMessageHolderType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__NotificationMessageHolderType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__NotificationMessageHolderType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__NotificationMessageHolderType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__NotificationMessageHolderType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__NotificationMessageHolderType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_get_wsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__SubscriptionPolicyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->wsnt__SubscriptionPolicyType::__any);
}

void wsnt__SubscriptionPolicyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wsnt__SubscriptionPolicyType::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wsnt__SubscriptionPolicyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__SubscriptionPolicyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, const wsnt__SubscriptionPolicyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType), type ? type : "wsnt:SubscriptionPolicyType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsnt__SubscriptionPolicyType::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__SubscriptionPolicyType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__SubscriptionPolicyType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_in_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, wsnt__SubscriptionPolicyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__SubscriptionPolicyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(wsnt__SubscriptionPolicyType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__SubscriptionPolicyType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__SubscriptionPolicyType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsnt__SubscriptionPolicyType::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnt__SubscriptionPolicyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscriptionPolicyType, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(wsnt__SubscriptionPolicyType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__SubscriptionPolicyType * SOAP_FMAC2 imageing_instantiate_wsnt__SubscriptionPolicyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__SubscriptionPolicyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__SubscriptionPolicyType *p;
	size_t k = sizeof(wsnt__SubscriptionPolicyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__SubscriptionPolicyType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__SubscriptionPolicyType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__SubscriptionPolicyType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__SubscriptionPolicyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__SubscriptionPolicyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__SubscriptionPolicyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__SubscriptionPolicyType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_get_wsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__FilterType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->wsnt__FilterType::__any);
}

void wsnt__FilterType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wsnt__FilterType::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wsnt__FilterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__FilterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__FilterType(struct soap *soap, const char *tag, int id, const wsnt__FilterType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__FilterType), type ? type : "wsnt:FilterType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsnt__FilterType::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__FilterType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__FilterType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__FilterType * SOAP_FMAC4 soap_in_wsnt__FilterType(struct soap *soap, const char *tag, wsnt__FilterType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__FilterType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__FilterType, sizeof(wsnt__FilterType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__FilterType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__FilterType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsnt__FilterType::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnt__FilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__FilterType, SOAP_TYPE_wsnt__FilterType, sizeof(wsnt__FilterType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__FilterType * SOAP_FMAC2 imageing_instantiate_wsnt__FilterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__FilterType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__FilterType *p;
	size_t k = sizeof(wsnt__FilterType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__FilterType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__FilterType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__FilterType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__FilterType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__FilterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__FilterType(soap, tag ? tag : "wsnt:FilterType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__FilterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__FilterType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__FilterType * SOAP_FMAC4 soap_get_wsnt__FilterType(struct soap *soap, wsnt__FilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__TopicExpressionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->wsnt__TopicExpressionType::__any = NULL;
	soap_default_xsd__anyURI(soap, &this->wsnt__TopicExpressionType::Dialect);
	this->wsnt__TopicExpressionType::__anyAttribute = NULL;
	this->wsnt__TopicExpressionType::__mixed = NULL;
}

void wsnt__TopicExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wsnt__TopicExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__TopicExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, const wsnt__TopicExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, ((wsnt__TopicExpressionType*)a)->Dialect), 1);
	if (((wsnt__TopicExpressionType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsnt__TopicExpressionType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionType), type ? type : "wsnt:TopicExpressionType"))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->wsnt__TopicExpressionType::__any, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->wsnt__TopicExpressionType::__mixed, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__TopicExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__TopicExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__TopicExpressionType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionType(struct soap *soap, const char *tag, wsnt__TopicExpressionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__TopicExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(wsnt__TopicExpressionType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__TopicExpressionType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__TopicExpressionType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &((wsnt__TopicExpressionType*)a)->Dialect))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsnt__TopicExpressionType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->wsnt__TopicExpressionType::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->wsnt__TopicExpressionType::__mixed))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnt__TopicExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionType, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(wsnt__TopicExpressionType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__TopicExpressionType * SOAP_FMAC2 imageing_instantiate_wsnt__TopicExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__TopicExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__TopicExpressionType *p;
	size_t k = sizeof(wsnt__TopicExpressionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__TopicExpressionType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__TopicExpressionType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__TopicExpressionType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__TopicExpressionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__TopicExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__TopicExpressionType(soap, tag ? tag : "wsnt:TopicExpressionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__TopicExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__TopicExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__TopicExpressionType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__QueryExpressionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->wsnt__QueryExpressionType::__any = NULL;
	soap_default_xsd__anyURI(soap, &this->wsnt__QueryExpressionType::Dialect);
	this->wsnt__QueryExpressionType::__mixed = NULL;
}

void wsnt__QueryExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wsnt__QueryExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__QueryExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__QueryExpressionType(struct soap *soap, const char *tag, int id, const wsnt__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, ((wsnt__QueryExpressionType*)a)->Dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__QueryExpressionType), type ? type : "wsnt:QueryExpressionType"))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->wsnt__QueryExpressionType::__any, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->wsnt__QueryExpressionType::__mixed, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__QueryExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__QueryExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__QueryExpressionType * SOAP_FMAC4 soap_in_wsnt__QueryExpressionType(struct soap *soap, const char *tag, wsnt__QueryExpressionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__QueryExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(wsnt__QueryExpressionType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__QueryExpressionType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__QueryExpressionType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &((wsnt__QueryExpressionType*)a)->Dialect))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->wsnt__QueryExpressionType::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->wsnt__QueryExpressionType::__mixed))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnt__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__QueryExpressionType, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(wsnt__QueryExpressionType), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__QueryExpressionType * SOAP_FMAC2 imageing_instantiate_wsnt__QueryExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsnt__QueryExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__QueryExpressionType *p;
	size_t k = sizeof(wsnt__QueryExpressionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__QueryExpressionType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__QueryExpressionType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__QueryExpressionType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__QueryExpressionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__QueryExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__QueryExpressionType(soap, tag ? tag : "wsnt:QueryExpressionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__QueryExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__QueryExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__QueryExpressionType * SOAP_FMAC4 soap_get_wsnt__QueryExpressionType(struct soap *soap, wsnt__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tt__Message::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tt__Message::Source = NULL;
	this->_tt__Message::Key = NULL;
	this->_tt__Message::Data = NULL;
	this->_tt__Message::Extension = NULL;
	soap_default_dateTime(soap, &this->_tt__Message::UtcTime);
	this->_tt__Message::PropertyOperation = NULL;
	this->_tt__Message::__anyAttribute = NULL;
}

void _tt__Message::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemList(soap, &this->_tt__Message::Source);
	soap_serialize_PointerTott__ItemList(soap, &this->_tt__Message::Key);
	soap_serialize_PointerTott__ItemList(soap, &this->_tt__Message::Data);
	soap_serialize_PointerTott__MessageExtension(soap, &this->_tt__Message::Extension);
#endif
}

int _tt__Message::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__Message(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Message(struct soap *soap, const char *tag, int id, const _tt__Message *a, const char *type)
{
	soap_set_attr(soap, "UtcTime", soap_dateTime2s(soap, ((_tt__Message*)a)->UtcTime), 1);
	if (((_tt__Message*)a)->PropertyOperation)
	{	soap_set_attr(soap, "PropertyOperation", soap_tt__PropertyOperation2s(soap, *((_tt__Message*)a)->PropertyOperation), 1);
	}
	if (((_tt__Message*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_tt__Message*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Message), type))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Source", -1, &a->_tt__Message::Source, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Key", -1, &a->_tt__Message::Key, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Data", -1, &a->_tt__Message::Data, ""))
		return soap->error;
	if (soap_out_PointerTott__MessageExtension(soap, "tt:Extension", -1, &a->_tt__Message::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__Message::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tt__Message(soap, tag, this, type);
}

SOAP_FMAC3 _tt__Message * SOAP_FMAC4 soap_in__tt__Message(struct soap *soap, const char *tag, _tt__Message *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__Message*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Message, sizeof(_tt__Message), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tt__Message)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tt__Message *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "UtcTime", 5, 1), &((_tt__Message*)a)->UtcTime))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "PropertyOperation", 5, 0);
		if (t)
		{
			if (!(((_tt__Message*)a)->PropertyOperation = (enum tt__PropertyOperation *)soap_malloc(soap, sizeof(enum tt__PropertyOperation))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__PropertyOperation(soap, t, ((_tt__Message*)a)->PropertyOperation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_tt__Message*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Source1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Data1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Source", &a->_tt__Message::Source, "tt:ItemList"))
				{	soap_flag_Source1--;
					continue;
				}
			}
			if (soap_flag_Key1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Key", &a->_tt__Message::Key, "tt:ItemList"))
				{	soap_flag_Key1--;
					continue;
				}
			}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Data", &a->_tt__Message::Data, "tt:ItemList"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageExtension(soap, "tt:Extension", &a->_tt__Message::Extension, "tt:MessageExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Message, SOAP_TYPE__tt__Message, sizeof(_tt__Message), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tt__Message * SOAP_FMAC2 imageing_instantiate__tt__Message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__tt__Message(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tt__Message *p;
	size_t k = sizeof(_tt__Message);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tt__Message, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tt__Message);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tt__Message, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tt__Message location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tt__Message::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tt__Message(soap, tag ? tag : "tt:Message", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__Message::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__Message(soap, this, tag, type);
}

SOAP_FMAC3 _tt__Message * SOAP_FMAC4 soap_get__tt__Message(struct soap *soap, _tt__Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tt__StringItems::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_tt__StringItems::Item);
}

void _tt__StringItems::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_tt__StringItems::Item);
#endif
}

int _tt__StringItems::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__StringItems(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__StringItems(struct soap *soap, const char *tag, int id, const _tt__StringItems *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__StringItems), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:Item", -1, &a->_tt__StringItems::Item, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__StringItems::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tt__StringItems(soap, tag, this, type);
}

SOAP_FMAC3 _tt__StringItems * SOAP_FMAC4 soap_in__tt__StringItems(struct soap *soap, const char *tag, _tt__StringItems *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__StringItems*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__StringItems, sizeof(_tt__StringItems), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tt__StringItems)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tt__StringItems *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:Item", &a->_tt__StringItems::Item, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tt__StringItems::Item.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tt__StringItems *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__StringItems, SOAP_TYPE__tt__StringItems, sizeof(_tt__StringItems), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tt__StringItems * SOAP_FMAC2 imageing_instantiate__tt__StringItems(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__tt__StringItems(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tt__StringItems *p;
	size_t k = sizeof(_tt__StringItems);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tt__StringItems, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tt__StringItems);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tt__StringItems, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tt__StringItems location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tt__StringItems::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tt__StringItems(soap, tag ? tag : "tt:StringItems", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__StringItems::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__StringItems(soap, this, tag, type);
}

SOAP_FMAC3 _tt__StringItems * SOAP_FMAC4 soap_get__tt__StringItems(struct soap *soap, _tt__StringItems *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__StringItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Polygon::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polygon::Point);
}

void tt__Polygon::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polygon::Point);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Polygon::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Polygon(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polygon(struct soap *soap, const char *tag, int id, const tt__Polygon *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polygon), type ? type : "tt:Polygon"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", -1, &a->tt__Polygon::Point, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Polygon::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Polygon(soap, tag, this, type);
}

SOAP_FMAC3 tt__Polygon * SOAP_FMAC4 soap_in_tt__Polygon(struct soap *soap, const char *tag, tt__Polygon *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Polygon*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polygon, sizeof(tt__Polygon), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Polygon)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Polygon *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", &a->tt__Polygon::Point, "tt:Vector"))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Polygon::Point.size() < 3))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Polygon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polygon, SOAP_TYPE_tt__Polygon, sizeof(tt__Polygon), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Polygon * SOAP_FMAC2 imageing_instantiate_tt__Polygon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Polygon(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Polygon *p;
	size_t k = sizeof(tt__Polygon);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Polygon, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Polygon);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Polygon, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Polygon location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Polygon::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Polygon(soap, tag ? tag : "tt:Polygon", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Polygon::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Polygon(soap, this, tag, type);
}

SOAP_FMAC3 tt__Polygon * SOAP_FMAC4 soap_get_tt__Polygon(struct soap *soap, tt__Polygon *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Rectangle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__Rectangle::bottom = NULL;
	this->tt__Rectangle::top = NULL;
	this->tt__Rectangle::right = NULL;
	this->tt__Rectangle::left = NULL;
}

void tt__Rectangle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Rectangle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Rectangle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rectangle(struct soap *soap, const char *tag, int id, const tt__Rectangle *a, const char *type)
{
	if (((tt__Rectangle*)a)->bottom)
	{	soap_set_attr(soap, "bottom", soap_float2s(soap, *((tt__Rectangle*)a)->bottom), 1);
	}
	if (((tt__Rectangle*)a)->top)
	{	soap_set_attr(soap, "top", soap_float2s(soap, *((tt__Rectangle*)a)->top), 1);
	}
	if (((tt__Rectangle*)a)->right)
	{	soap_set_attr(soap, "right", soap_float2s(soap, *((tt__Rectangle*)a)->right), 1);
	}
	if (((tt__Rectangle*)a)->left)
	{	soap_set_attr(soap, "left", soap_float2s(soap, *((tt__Rectangle*)a)->left), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Rectangle");
}

void *tt__Rectangle::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Rectangle(soap, tag, this, type);
}

SOAP_FMAC3 tt__Rectangle * SOAP_FMAC4 soap_in_tt__Rectangle(struct soap *soap, const char *tag, tt__Rectangle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Rectangle*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rectangle, sizeof(tt__Rectangle), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Rectangle)
		return (tt__Rectangle *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "bottom", 5, 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->bottom = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->bottom))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "top", 5, 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->top = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->top))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "right", 5, 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->right = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->right))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "left", 5, 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->left = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->left))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Rectangle * SOAP_FMAC2 imageing_instantiate_tt__Rectangle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Rectangle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Rectangle *p;
	size_t k = sizeof(tt__Rectangle);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Rectangle, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Rectangle);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Rectangle, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Rectangle location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Rectangle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Rectangle(soap, tag ? tag : "tt:Rectangle", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Rectangle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Rectangle(soap, this, tag, type);
}

SOAP_FMAC3 tt__Rectangle * SOAP_FMAC4 soap_get_tt__Rectangle(struct soap *soap, tt__Rectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Vector::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__Vector::x = NULL;
	this->tt__Vector::y = NULL;
}

void tt__Vector::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Vector::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector(struct soap *soap, const char *tag, int id, const tt__Vector *a, const char *type)
{
	if (((tt__Vector*)a)->x)
	{	soap_set_attr(soap, "x", soap_float2s(soap, *((tt__Vector*)a)->x), 1);
	}
	if (((tt__Vector*)a)->y)
	{	soap_set_attr(soap, "y", soap_float2s(soap, *((tt__Vector*)a)->y), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Vector");
}

void *tt__Vector::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Vector(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector * SOAP_FMAC4 soap_in_tt__Vector(struct soap *soap, const char *tag, tt__Vector *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Vector*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector, sizeof(tt__Vector), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Vector)
		return (tt__Vector *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "x", 5, 0);
		if (t)
		{
			if (!(((tt__Vector*)a)->x = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Vector*)a)->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "y", 5, 0);
		if (t)
		{
			if (!(((tt__Vector*)a)->y = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Vector*)a)->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Vector * SOAP_FMAC2 imageing_instantiate_tt__Vector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Vector(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Vector *p;
	size_t k = sizeof(tt__Vector);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Vector, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Vector);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Vector, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Vector location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Vector::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Vector(soap, tag ? tag : "tt:Vector", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector * SOAP_FMAC4 soap_get_tt__Vector(struct soap *soap, tt__Vector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Vector1D::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__Vector1D::x);
	this->tt__Vector1D::space = NULL;
}

void tt__Vector1D::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Vector1D::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector1D(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector1D(struct soap *soap, const char *tag, int id, const tt__Vector1D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, ((tt__Vector1D*)a)->x), 1);
	if (((tt__Vector1D*)a)->space)
	{	soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, *((tt__Vector1D*)a)->space), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Vector1D");
}

void *tt__Vector1D::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Vector1D(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector1D * SOAP_FMAC4 soap_in_tt__Vector1D(struct soap *soap, const char *tag, tt__Vector1D *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Vector1D*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector1D, sizeof(tt__Vector1D), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Vector1D)
		return (tt__Vector1D *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 5, 1), &((tt__Vector1D*)a)->x))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "space", 4, 0);
		if (t)
		{
			if (!(((tt__Vector1D*)a)->space = soap_new_xsd__anyURI(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__anyURI(soap, t, ((tt__Vector1D*)a)->space))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Vector1D * SOAP_FMAC2 imageing_instantiate_tt__Vector1D(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Vector1D(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Vector1D *p;
	size_t k = sizeof(tt__Vector1D);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Vector1D, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Vector1D);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Vector1D, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Vector1D location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Vector1D::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Vector1D(soap, tag ? tag : "tt:Vector1D", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector1D::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector1D(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector1D * SOAP_FMAC4 soap_get_tt__Vector1D(struct soap *soap, tt__Vector1D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Vector2D::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__Vector2D::x);
	soap_default_float(soap, &this->tt__Vector2D::y);
	this->tt__Vector2D::space = NULL;
}

void tt__Vector2D::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Vector2D::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector2D(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector2D(struct soap *soap, const char *tag, int id, const tt__Vector2D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, ((tt__Vector2D*)a)->x), 1);
	soap_set_attr(soap, "y", soap_float2s(soap, ((tt__Vector2D*)a)->y), 1);
	if (((tt__Vector2D*)a)->space)
	{	soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, *((tt__Vector2D*)a)->space), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Vector2D");
}

void *tt__Vector2D::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Vector2D(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector2D * SOAP_FMAC4 soap_in_tt__Vector2D(struct soap *soap, const char *tag, tt__Vector2D *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Vector2D*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector2D, sizeof(tt__Vector2D), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Vector2D)
		return (tt__Vector2D *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 5, 1), &((tt__Vector2D*)a)->x))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "y", 5, 1), &((tt__Vector2D*)a)->y))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "space", 4, 0);
		if (t)
		{
			if (!(((tt__Vector2D*)a)->space = soap_new_xsd__anyURI(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__anyURI(soap, t, ((tt__Vector2D*)a)->space))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Vector2D * SOAP_FMAC2 imageing_instantiate_tt__Vector2D(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Vector2D(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Vector2D *p;
	size_t k = sizeof(tt__Vector2D);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Vector2D, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Vector2D);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Vector2D, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Vector2D location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Vector2D::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Vector2D(soap, tag ? tag : "tt:Vector2D", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector2D::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector2D(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector2D * SOAP_FMAC4 soap_get_tt__Vector2D(struct soap *soap, tt__Vector2D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IntRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__IntRange::Min);
	soap_default_int(soap, &this->tt__IntRange::Max);
}

void tt__IntRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IntRange::Min, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__IntRange::Max, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IntRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRange(struct soap *soap, const char *tag, int id, const tt__IntRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRange), type ? type : "tt:IntRange"))
		return soap->error;
	if (soap_out_int(soap, "tt:Min", -1, &a->tt__IntRange::Min, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Max", -1, &a->tt__IntRange::Max, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IntRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IntRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_in_tt__IntRange(struct soap *soap, const char *tag, tt__IntRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IntRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IntRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Min", &a->tt__IntRange::Min, "xsd:int"))
				{	soap_flag_Min1--;
					continue;
				}
			}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Max", &a->tt__IntRange::Max, "xsd:int"))
				{	soap_flag_Max1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IntRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRange, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 imageing_instantiate_tt__IntRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__IntRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IntRange *p;
	size_t k = sizeof(tt__IntRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IntRange, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IntRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IntRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IntRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IntRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IntRange(soap, tag ? tag : "tt:IntRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_get_tt__IntRange(struct soap *soap, tt__IntRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PolygonOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__PolygonOptions::RectangleOnly = NULL;
	this->tt__PolygonOptions::VertexLimits = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__PolygonOptions::__any);
	this->tt__PolygonOptions::__anyAttribute = NULL;
}

void tt__PolygonOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__PolygonOptions::RectangleOnly);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__PolygonOptions::VertexLimits);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__PolygonOptions::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PolygonOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PolygonOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolygonOptions(struct soap *soap, const char *tag, int id, const tt__PolygonOptions *a, const char *type)
{
	if (((tt__PolygonOptions*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__PolygonOptions*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolygonOptions), type ? type : "tt:PolygonOptions"))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RectangleOnly", -1, &a->tt__PolygonOptions::RectangleOnly, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tt:VertexLimits", -1, &a->tt__PolygonOptions::VertexLimits, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__PolygonOptions::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PolygonOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PolygonOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PolygonOptions * SOAP_FMAC4 soap_in_tt__PolygonOptions(struct soap *soap, const char *tag, tt__PolygonOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PolygonOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolygonOptions, sizeof(tt__PolygonOptions), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PolygonOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PolygonOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__PolygonOptions*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_RectangleOnly1 = 1;
	size_t soap_flag_VertexLimits1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RectangleOnly1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RectangleOnly", &a->tt__PolygonOptions::RectangleOnly, "xsd:boolean"))
				{	soap_flag_RectangleOnly1--;
					continue;
				}
			}
			if (soap_flag_VertexLimits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:VertexLimits", &a->tt__PolygonOptions::VertexLimits, "tt:IntRange"))
				{	soap_flag_VertexLimits1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__PolygonOptions::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PolygonOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolygonOptions, SOAP_TYPE_tt__PolygonOptions, sizeof(tt__PolygonOptions), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PolygonOptions * SOAP_FMAC2 imageing_instantiate_tt__PolygonOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__PolygonOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PolygonOptions *p;
	size_t k = sizeof(tt__PolygonOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PolygonOptions, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PolygonOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PolygonOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PolygonOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PolygonOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PolygonOptions(soap, tag ? tag : "tt:PolygonOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PolygonOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PolygonOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PolygonOptions * SOAP_FMAC4 soap_get_tt__PolygonOptions(struct soap *soap, tt__PolygonOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolygonOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Config::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__Config::Parameters = NULL;
	soap_default_std__string(soap, &this->tt__Config::Name);
	soap_default_xsd__QName(soap, &this->tt__Config::Type);
}

void tt__Config::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemList(soap, &this->tt__Config::Parameters);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Config::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Config(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Config(struct soap *soap, const char *tag, int id, const tt__Config *a, const char *type)
{
	soap_set_attr(soap, "Name", soap_std__string2s(soap, ((tt__Config*)a)->Name), 1);
	soap_set_attr(soap, "Type", soap_xsd__QName2s(soap, ((tt__Config*)a)->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Config), type ? type : "tt:Config"))
		return soap->error;
	if (!a->tt__Config::Parameters)
	{	if (soap_element_empty(soap, "tt:Parameters", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ItemList(soap, "tt:Parameters", -1, &a->tt__Config::Parameters, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Config::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Config(soap, tag, this, type);
}

SOAP_FMAC3 tt__Config * SOAP_FMAC4 soap_in_tt__Config(struct soap *soap, const char *tag, tt__Config *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Config*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Config, sizeof(tt__Config), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Config)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Config *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2std__string(soap, soap_attr_value(soap, "Name", 1, 1), &((tt__Config*)a)->Name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "Type", 2, 1), &((tt__Config*)a)->Type))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Parameters1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Parameters", &a->tt__Config::Parameters, "tt:ItemList"))
				{	soap_flag_Parameters1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__Config::Parameters))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Config *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Config, SOAP_TYPE_tt__Config, sizeof(tt__Config), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Config * SOAP_FMAC2 imageing_instantiate_tt__Config(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Config(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Config *p;
	size_t k = sizeof(tt__Config);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Config, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Config);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Config, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Config location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Config::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Config(soap, tag ? tag : "tt:Config", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Config::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Config(soap, this, tag, type);
}

SOAP_FMAC3 tt__Config * SOAP_FMAC4 soap_get_tt__Config(struct soap *soap, tt__Config *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RuleEngineConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__RuleEngineConfigurationExtension::__any);
}

void tt__RuleEngineConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__RuleEngineConfigurationExtension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RuleEngineConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RuleEngineConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__RuleEngineConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension), type ? type : "tt:RuleEngineConfigurationExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__RuleEngineConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RuleEngineConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RuleEngineConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, tt__RuleEngineConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RuleEngineConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(tt__RuleEngineConfigurationExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RuleEngineConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RuleEngineConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__RuleEngineConfigurationExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RuleEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfigurationExtension, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(tt__RuleEngineConfigurationExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RuleEngineConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__RuleEngineConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__RuleEngineConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RuleEngineConfigurationExtension *p;
	size_t k = sizeof(tt__RuleEngineConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RuleEngineConfigurationExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RuleEngineConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RuleEngineConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RuleEngineConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RuleEngineConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RuleEngineConfigurationExtension(soap, tag ? tag : "tt:RuleEngineConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RuleEngineConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RuleEngineConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RuleEngineConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__RuleEngineConfiguration::Rule);
	this->tt__RuleEngineConfiguration::Extension = NULL;
	this->tt__RuleEngineConfiguration::__anyAttribute = NULL;
}

void tt__RuleEngineConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__RuleEngineConfiguration::Rule);
	soap_serialize_PointerTott__RuleEngineConfigurationExtension(soap, &this->tt__RuleEngineConfiguration::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RuleEngineConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RuleEngineConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, const tt__RuleEngineConfiguration *a, const char *type)
{
	if (((tt__RuleEngineConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__RuleEngineConfiguration*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RuleEngineConfiguration), type ? type : "tt:RuleEngineConfiguration"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tt:Rule", -1, &a->tt__RuleEngineConfiguration::Rule, ""))
		return soap->error;
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", -1, &a->tt__RuleEngineConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RuleEngineConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RuleEngineConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__RuleEngineConfiguration * SOAP_FMAC4 soap_in_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, tt__RuleEngineConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RuleEngineConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(tt__RuleEngineConfiguration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RuleEngineConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RuleEngineConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__RuleEngineConfiguration*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tt:Rule", &a->tt__RuleEngineConfiguration::Rule, "tt:Config"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", &a->tt__RuleEngineConfiguration::Extension, "tt:RuleEngineConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RuleEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfiguration, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(tt__RuleEngineConfiguration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RuleEngineConfiguration * SOAP_FMAC2 imageing_instantiate_tt__RuleEngineConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__RuleEngineConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RuleEngineConfiguration *p;
	size_t k = sizeof(tt__RuleEngineConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RuleEngineConfiguration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RuleEngineConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RuleEngineConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RuleEngineConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RuleEngineConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RuleEngineConfiguration(soap, tag ? tag : "tt:RuleEngineConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RuleEngineConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RuleEngineConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__RuleEngineConfiguration * SOAP_FMAC4 soap_get_tt__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsEngineConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__AnalyticsEngineConfigurationExtension::__any);
}

void tt__AnalyticsEngineConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__AnalyticsEngineConfigurationExtension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AnalyticsEngineConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsEngineConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension), type ? type : "tt:AnalyticsEngineConfigurationExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__AnalyticsEngineConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsEngineConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsEngineConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(tt__AnalyticsEngineConfigurationExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsEngineConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__AnalyticsEngineConfigurationExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnalyticsEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(tt__AnalyticsEngineConfigurationExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__AnalyticsEngineConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsEngineConfigurationExtension *p;
	size_t k = sizeof(tt__AnalyticsEngineConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsEngineConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsEngineConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsEngineConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsEngineConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsEngineConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsEngineConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsEngineConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsEngineConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__AnalyticsEngineConfiguration::AnalyticsModule);
	this->tt__AnalyticsEngineConfiguration::Extension = NULL;
	this->tt__AnalyticsEngineConfiguration::__anyAttribute = NULL;
}

void tt__AnalyticsEngineConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__AnalyticsEngineConfiguration::AnalyticsModule);
	soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(soap, &this->tt__AnalyticsEngineConfiguration::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AnalyticsEngineConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsEngineConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, const tt__AnalyticsEngineConfiguration *a, const char *type)
{
	if (((tt__AnalyticsEngineConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__AnalyticsEngineConfiguration*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration), type ? type : "tt:AnalyticsEngineConfiguration"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tt:AnalyticsModule", -1, &a->tt__AnalyticsEngineConfiguration::AnalyticsModule, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", -1, &a->tt__AnalyticsEngineConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsEngineConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsEngineConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, tt__AnalyticsEngineConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsEngineConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(tt__AnalyticsEngineConfiguration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsEngineConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsEngineConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__AnalyticsEngineConfiguration*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tt:AnalyticsModule", &a->tt__AnalyticsEngineConfiguration::AnalyticsModule, "tt:Config"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", &a->tt__AnalyticsEngineConfiguration::Extension, "tt:AnalyticsEngineConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnalyticsEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfiguration, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(tt__AnalyticsEngineConfiguration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsEngineConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AnalyticsEngineConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__AnalyticsEngineConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsEngineConfiguration *p;
	size_t k = sizeof(tt__AnalyticsEngineConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsEngineConfiguration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsEngineConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsEngineConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsEngineConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsEngineConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsEngineConfiguration(soap, tag ? tag : "tt:AnalyticsEngineConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsEngineConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsEngineConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Polyline::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polyline::Point);
}

void tt__Polyline::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polyline::Point);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Polyline::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Polyline(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polyline(struct soap *soap, const char *tag, int id, const tt__Polyline *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polyline), type ? type : "tt:Polyline"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", -1, &a->tt__Polyline::Point, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Polyline::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Polyline(soap, tag, this, type);
}

SOAP_FMAC3 tt__Polyline * SOAP_FMAC4 soap_in_tt__Polyline(struct soap *soap, const char *tag, tt__Polyline *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Polyline*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polyline, sizeof(tt__Polyline), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Polyline)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Polyline *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", &a->tt__Polyline::Point, "tt:Vector"))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Polyline::Point.size() < 2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Polyline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polyline, SOAP_TYPE_tt__Polyline, sizeof(tt__Polyline), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Polyline * SOAP_FMAC2 imageing_instantiate_tt__Polyline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Polyline(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Polyline *p;
	size_t k = sizeof(tt__Polyline);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Polyline, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Polyline);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Polyline, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Polyline location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Polyline::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Polyline(soap, tag ? tag : "tt:Polyline", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Polyline::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Polyline(soap, this, tag, type);
}

SOAP_FMAC3 tt__Polyline * SOAP_FMAC4 soap_get_tt__Polyline(struct soap *soap, tt__Polyline *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polyline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ItemListExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__ItemListExtension::__any);
}

void tt__ItemListExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__ItemListExtension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ItemListExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ItemListExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListExtension(struct soap *soap, const char *tag, int id, const tt__ItemListExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListExtension), type ? type : "tt:ItemListExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__ItemListExtension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ItemListExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ItemListExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ItemListExtension * SOAP_FMAC4 soap_in_tt__ItemListExtension(struct soap *soap, const char *tag, tt__ItemListExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ItemListExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListExtension, sizeof(tt__ItemListExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ItemListExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ItemListExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__ItemListExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ItemListExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListExtension, SOAP_TYPE_tt__ItemListExtension, sizeof(tt__ItemListExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ItemListExtension * SOAP_FMAC2 imageing_instantiate_tt__ItemListExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ItemListExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ItemListExtension *p;
	size_t k = sizeof(tt__ItemListExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ItemListExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ItemListExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ItemListExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ItemListExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ItemListExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ItemListExtension(soap, tag ? tag : "tt:ItemListExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ItemListExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ItemListExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ItemListExtension * SOAP_FMAC4 soap_get_tt__ItemListExtension(struct soap *soap, tt__ItemListExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, &this->tt__ItemList::SimpleItem);
	soap_default_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, &this->tt__ItemList::ElementItem);
	this->tt__ItemList::Extension = NULL;
	this->tt__ItemList::__anyAttribute = NULL;
}

void tt__ItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, &this->tt__ItemList::SimpleItem);
	soap_serialize_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, &this->tt__ItemList::ElementItem);
	soap_serialize_PointerTott__ItemListExtension(soap, &this->tt__ItemList::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemList(struct soap *soap, const char *tag, int id, const tt__ItemList *a, const char *type)
{
	if (((tt__ItemList*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__ItemList*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemList), type ? type : "tt:ItemList"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, "tt:SimpleItem", -1, &a->tt__ItemList::SimpleItem, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, "tt:ElementItem", -1, &a->tt__ItemList::ElementItem, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListExtension(soap, "tt:Extension", -1, &a->tt__ItemList::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ItemList(soap, tag, this, type);
}

SOAP_FMAC3 tt__ItemList * SOAP_FMAC4 soap_in_tt__ItemList(struct soap *soap, const char *tag, tt__ItemList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ItemList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemList, sizeof(tt__ItemList), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ItemList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ItemList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__ItemList*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, "tt:SimpleItem", &a->tt__ItemList::SimpleItem, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, "tt:ElementItem", &a->tt__ItemList::ElementItem, ""))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListExtension(soap, "tt:Extension", &a->tt__ItemList::Extension, "tt:ItemListExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemList, SOAP_TYPE_tt__ItemList, sizeof(tt__ItemList), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ItemList * SOAP_FMAC2 imageing_instantiate_tt__ItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ItemList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ItemList *p;
	size_t k = sizeof(tt__ItemList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ItemList, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ItemList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ItemList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ItemList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ItemList(soap, tag ? tag : "tt:ItemList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ItemList(soap, this, tag, type);
}

SOAP_FMAC3 tt__ItemList * SOAP_FMAC4 soap_get_tt__ItemList(struct soap *soap, tt__ItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MessageExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__MessageExtension::__any);
}

void tt__MessageExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__MessageExtension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MessageExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MessageExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageExtension(struct soap *soap, const char *tag, int id, const tt__MessageExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageExtension), type ? type : "tt:MessageExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__MessageExtension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MessageExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MessageExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MessageExtension * SOAP_FMAC4 soap_in_tt__MessageExtension(struct soap *soap, const char *tag, tt__MessageExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MessageExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageExtension, sizeof(tt__MessageExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MessageExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MessageExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__MessageExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MessageExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageExtension, SOAP_TYPE_tt__MessageExtension, sizeof(tt__MessageExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MessageExtension * SOAP_FMAC2 imageing_instantiate_tt__MessageExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__MessageExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MessageExtension *p;
	size_t k = sizeof(tt__MessageExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MessageExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MessageExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MessageExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MessageExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MessageExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MessageExtension(soap, tag ? tag : "tt:MessageExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MessageExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MessageExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MessageExtension * SOAP_FMAC4 soap_get_tt__MessageExtension(struct soap *soap, tt__MessageExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NoiseReductionOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__NoiseReductionOptions::Level);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__NoiseReductionOptions::__any);
	this->tt__NoiseReductionOptions::__anyAttribute = NULL;
}

void tt__NoiseReductionOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NoiseReductionOptions::Level, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__NoiseReductionOptions::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NoiseReductionOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NoiseReductionOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NoiseReductionOptions(struct soap *soap, const char *tag, int id, const tt__NoiseReductionOptions *a, const char *type)
{
	if (((tt__NoiseReductionOptions*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__NoiseReductionOptions*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NoiseReductionOptions), type ? type : "tt:NoiseReductionOptions"))
		return soap->error;
	if (soap_out_bool(soap, "tt:Level", -1, &a->tt__NoiseReductionOptions::Level, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__NoiseReductionOptions::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NoiseReductionOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NoiseReductionOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__NoiseReductionOptions * SOAP_FMAC4 soap_in_tt__NoiseReductionOptions(struct soap *soap, const char *tag, tt__NoiseReductionOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NoiseReductionOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(tt__NoiseReductionOptions), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NoiseReductionOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NoiseReductionOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__NoiseReductionOptions*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Level", &a->tt__NoiseReductionOptions::Level, "xsd:boolean"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__NoiseReductionOptions::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NoiseReductionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NoiseReductionOptions, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(tt__NoiseReductionOptions), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NoiseReductionOptions * SOAP_FMAC2 imageing_instantiate_tt__NoiseReductionOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__NoiseReductionOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NoiseReductionOptions *p;
	size_t k = sizeof(tt__NoiseReductionOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NoiseReductionOptions, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NoiseReductionOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NoiseReductionOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NoiseReductionOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NoiseReductionOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NoiseReductionOptions(soap, tag ? tag : "tt:NoiseReductionOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NoiseReductionOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NoiseReductionOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__NoiseReductionOptions * SOAP_FMAC4 soap_get_tt__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NoiseReductionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DefoggingOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__DefoggingOptions::Mode);
	soap_default_bool(soap, &this->tt__DefoggingOptions::Level);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__DefoggingOptions::__any);
	this->tt__DefoggingOptions::__anyAttribute = NULL;
}

void tt__DefoggingOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__DefoggingOptions::Mode);
	soap_embedded(soap, &this->tt__DefoggingOptions::Level, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__DefoggingOptions::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DefoggingOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DefoggingOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingOptions(struct soap *soap, const char *tag, int id, const tt__DefoggingOptions *a, const char *type)
{
	if (((tt__DefoggingOptions*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__DefoggingOptions*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DefoggingOptions), type ? type : "tt:DefoggingOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:Mode", -1, &a->tt__DefoggingOptions::Mode, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Level", -1, &a->tt__DefoggingOptions::Level, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__DefoggingOptions::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DefoggingOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DefoggingOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__DefoggingOptions * SOAP_FMAC4 soap_in_tt__DefoggingOptions(struct soap *soap, const char *tag, tt__DefoggingOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DefoggingOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingOptions, sizeof(tt__DefoggingOptions), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DefoggingOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DefoggingOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__DefoggingOptions*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:Mode", &a->tt__DefoggingOptions::Mode, "xsd:string"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Level", &a->tt__DefoggingOptions::Level, "xsd:boolean"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__DefoggingOptions::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__DefoggingOptions::Mode.size() < 1 || soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DefoggingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DefoggingOptions, SOAP_TYPE_tt__DefoggingOptions, sizeof(tt__DefoggingOptions), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DefoggingOptions * SOAP_FMAC2 imageing_instantiate_tt__DefoggingOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__DefoggingOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DefoggingOptions *p;
	size_t k = sizeof(tt__DefoggingOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DefoggingOptions, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DefoggingOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DefoggingOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DefoggingOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DefoggingOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DefoggingOptions(soap, tag ? tag : "tt:DefoggingOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DefoggingOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DefoggingOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__DefoggingOptions * SOAP_FMAC4 soap_get_tt__DefoggingOptions(struct soap *soap, tt__DefoggingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DefoggingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ToneCompensationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__ToneCompensationOptions::Mode);
	soap_default_bool(soap, &this->tt__ToneCompensationOptions::Level);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__ToneCompensationOptions::__any);
	this->tt__ToneCompensationOptions::__anyAttribute = NULL;
}

void tt__ToneCompensationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__ToneCompensationOptions::Mode);
	soap_embedded(soap, &this->tt__ToneCompensationOptions::Level, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__ToneCompensationOptions::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ToneCompensationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ToneCompensationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationOptions(struct soap *soap, const char *tag, int id, const tt__ToneCompensationOptions *a, const char *type)
{
	if (((tt__ToneCompensationOptions*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__ToneCompensationOptions*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensationOptions), type ? type : "tt:ToneCompensationOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:Mode", -1, &a->tt__ToneCompensationOptions::Mode, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Level", -1, &a->tt__ToneCompensationOptions::Level, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__ToneCompensationOptions::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ToneCompensationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ToneCompensationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ToneCompensationOptions * SOAP_FMAC4 soap_in_tt__ToneCompensationOptions(struct soap *soap, const char *tag, tt__ToneCompensationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ToneCompensationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(tt__ToneCompensationOptions), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ToneCompensationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ToneCompensationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__ToneCompensationOptions*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:Mode", &a->tt__ToneCompensationOptions::Mode, "xsd:string"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Level", &a->tt__ToneCompensationOptions::Level, "xsd:boolean"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__ToneCompensationOptions::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__ToneCompensationOptions::Mode.size() < 1 || soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ToneCompensationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensationOptions, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(tt__ToneCompensationOptions), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ToneCompensationOptions * SOAP_FMAC2 imageing_instantiate_tt__ToneCompensationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ToneCompensationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ToneCompensationOptions *p;
	size_t k = sizeof(tt__ToneCompensationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ToneCompensationOptions, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ToneCompensationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ToneCompensationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ToneCompensationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ToneCompensationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ToneCompensationOptions(soap, tag ? tag : "tt:ToneCompensationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ToneCompensationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ToneCompensationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ToneCompensationOptions * SOAP_FMAC4 soap_get_tt__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusOptions20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__FocusOptions20Extension::__any);
	this->tt__FocusOptions20Extension::AFModes = NULL;
}

void tt__FocusOptions20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__FocusOptions20Extension::__any);
	soap_serialize_PointerTott__StringAttrList(soap, &this->tt__FocusOptions20Extension::AFModes);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusOptions20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusOptions20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20Extension(struct soap *soap, const char *tag, int id, const tt__FocusOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20Extension), type ? type : "tt:FocusOptions20Extension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__FocusOptions20Extension::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__StringAttrList(soap, "tt:AFModes", -1, &a->tt__FocusOptions20Extension::AFModes, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusOptions20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusOptions20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusOptions20Extension * SOAP_FMAC4 soap_in_tt__FocusOptions20Extension(struct soap *soap, const char *tag, tt__FocusOptions20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusOptions20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(tt__FocusOptions20Extension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusOptions20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusOptions20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AFModes1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AFModes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__StringAttrList(soap, "tt:AFModes", &a->tt__FocusOptions20Extension::AFModes, "tt:StringAttrList"))
				{	soap_flag_AFModes1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__FocusOptions20Extension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20Extension, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(tt__FocusOptions20Extension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusOptions20Extension * SOAP_FMAC2 imageing_instantiate_tt__FocusOptions20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__FocusOptions20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusOptions20Extension *p;
	size_t k = sizeof(tt__FocusOptions20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusOptions20Extension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusOptions20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusOptions20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusOptions20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusOptions20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusOptions20Extension(soap, tag ? tag : "tt:FocusOptions20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusOptions20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusOptions20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusOptions20Extension * SOAP_FMAC4 soap_get_tt__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__AutoFocusMode(soap, &this->tt__FocusOptions20::AutoFocusModes);
	this->tt__FocusOptions20::DefaultSpeed = NULL;
	this->tt__FocusOptions20::NearLimit = NULL;
	this->tt__FocusOptions20::FarLimit = NULL;
	this->tt__FocusOptions20::Extension = NULL;
}

void tt__FocusOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__AutoFocusMode(soap, &this->tt__FocusOptions20::AutoFocusModes);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions20::DefaultSpeed);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions20::NearLimit);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions20::FarLimit);
	soap_serialize_PointerTott__FocusOptions20Extension(soap, &this->tt__FocusOptions20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20(struct soap *soap, const char *tag, int id, const tt__FocusOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20), type ? type : "tt:FocusOptions20"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__AutoFocusMode(soap, "tt:AutoFocusModes", -1, &a->tt__FocusOptions20::AutoFocusModes, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:DefaultSpeed", -1, &a->tt__FocusOptions20::DefaultSpeed, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:NearLimit", -1, &a->tt__FocusOptions20::NearLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:FarLimit", -1, &a->tt__FocusOptions20::FarLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20Extension(soap, "tt:Extension", -1, &a->tt__FocusOptions20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusOptions20 * SOAP_FMAC4 soap_in_tt__FocusOptions20(struct soap *soap, const char *tag, tt__FocusOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20, sizeof(tt__FocusOptions20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_DefaultSpeed1 = 1;
	size_t soap_flag_NearLimit1 = 1;
	size_t soap_flag_FarLimit1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__AutoFocusMode(soap, "tt:AutoFocusModes", &a->tt__FocusOptions20::AutoFocusModes, "tt:AutoFocusMode"))
					continue;
			}
			if (soap_flag_DefaultSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:DefaultSpeed", &a->tt__FocusOptions20::DefaultSpeed, "tt:FloatRange"))
				{	soap_flag_DefaultSpeed1--;
					continue;
				}
			}
			if (soap_flag_NearLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:NearLimit", &a->tt__FocusOptions20::NearLimit, "tt:FloatRange"))
				{	soap_flag_NearLimit1--;
					continue;
				}
			}
			if (soap_flag_FarLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:FarLimit", &a->tt__FocusOptions20::FarLimit, "tt:FloatRange"))
				{	soap_flag_FarLimit1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusOptions20Extension(soap, "tt:Extension", &a->tt__FocusOptions20::Extension, "tt:FocusOptions20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20, SOAP_TYPE_tt__FocusOptions20, sizeof(tt__FocusOptions20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusOptions20 * SOAP_FMAC2 imageing_instantiate_tt__FocusOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__FocusOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusOptions20 *p;
	size_t k = sizeof(tt__FocusOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusOptions20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusOptions20(soap, tag ? tag : "tt:FocusOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusOptions20 * SOAP_FMAC4 soap_get_tt__FocusOptions20(struct soap *soap, tt__FocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalanceOptions20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__WhiteBalanceOptions20Extension::__any);
}

void tt__WhiteBalanceOptions20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__WhiteBalanceOptions20Extension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WhiteBalanceOptions20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalanceOptions20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, const tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension), type ? type : "tt:WhiteBalanceOptions20Extension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__WhiteBalanceOptions20Extension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalanceOptions20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalanceOptions20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(tt__WhiteBalanceOptions20Extension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalanceOptions20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WhiteBalanceOptions20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__WhiteBalanceOptions20Extension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WhiteBalanceOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(tt__WhiteBalanceOptions20Extension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalanceOptions20Extension * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalanceOptions20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__WhiteBalanceOptions20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalanceOptions20Extension *p;
	size_t k = sizeof(tt__WhiteBalanceOptions20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalanceOptions20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalanceOptions20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalanceOptions20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalanceOptions20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalanceOptions20Extension(soap, tag ? tag : "tt:WhiteBalanceOptions20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalanceOptions20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalanceOptions20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalanceOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceOptions20::Mode);
	this->tt__WhiteBalanceOptions20::YrGain = NULL;
	this->tt__WhiteBalanceOptions20::YbGain = NULL;
	this->tt__WhiteBalanceOptions20::Extension = NULL;
}

void tt__WhiteBalanceOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceOptions20::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WhiteBalanceOptions20::YrGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WhiteBalanceOptions20::YbGain);
	soap_serialize_PointerTott__WhiteBalanceOptions20Extension(soap, &this->tt__WhiteBalanceOptions20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WhiteBalanceOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalanceOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, const tt__WhiteBalanceOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions20), type ? type : "tt:WhiteBalanceOptions20"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->tt__WhiteBalanceOptions20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:YrGain", -1, &a->tt__WhiteBalanceOptions20::YrGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:YbGain", -1, &a->tt__WhiteBalanceOptions20::YbGain, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", -1, &a->tt__WhiteBalanceOptions20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalanceOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalanceOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalanceOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(tt__WhiteBalanceOptions20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalanceOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WhiteBalanceOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_YrGain1 = 1;
	size_t soap_flag_YbGain1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__WhiteBalanceMode(soap, "tt:Mode", &a->tt__WhiteBalanceOptions20::Mode, "tt:WhiteBalanceMode"))
					continue;
			}
			if (soap_flag_YrGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YrGain", &a->tt__WhiteBalanceOptions20::YrGain, "tt:FloatRange"))
				{	soap_flag_YrGain1--;
					continue;
				}
			}
			if (soap_flag_YbGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YbGain", &a->tt__WhiteBalanceOptions20::YbGain, "tt:FloatRange"))
				{	soap_flag_YbGain1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", &a->tt__WhiteBalanceOptions20::Extension, "tt:WhiteBalanceOptions20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__WhiteBalanceOptions20::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WhiteBalanceOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(tt__WhiteBalanceOptions20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalanceOptions20 * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalanceOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__WhiteBalanceOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalanceOptions20 *p;
	size_t k = sizeof(tt__WhiteBalanceOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalanceOptions20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalanceOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalanceOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalanceOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalanceOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalanceOptions20(soap, tag ? tag : "tt:WhiteBalanceOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalanceOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalanceOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusConfiguration20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__FocusConfiguration20Extension::__any);
}

void tt__FocusConfiguration20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__FocusConfiguration20Extension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusConfiguration20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusConfiguration20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, const tt__FocusConfiguration20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20Extension), type ? type : "tt:FocusConfiguration20Extension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__FocusConfiguration20Extension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusConfiguration20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusConfiguration20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_in_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, tt__FocusConfiguration20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusConfiguration20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(tt__FocusConfiguration20Extension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusConfiguration20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusConfiguration20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__FocusConfiguration20Extension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusConfiguration20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20Extension, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(tt__FocusConfiguration20Extension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusConfiguration20Extension * SOAP_FMAC2 imageing_instantiate_tt__FocusConfiguration20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__FocusConfiguration20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusConfiguration20Extension *p;
	size_t k = sizeof(tt__FocusConfiguration20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusConfiguration20Extension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusConfiguration20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusConfiguration20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusConfiguration20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusConfiguration20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusConfiguration20Extension(soap, tag ? tag : "tt:FocusConfiguration20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusConfiguration20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusConfiguration20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_get_tt__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusConfiguration20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__AutoFocusMode(soap, &this->tt__FocusConfiguration20::AutoFocusMode);
	this->tt__FocusConfiguration20::DefaultSpeed = NULL;
	this->tt__FocusConfiguration20::NearLimit = NULL;
	this->tt__FocusConfiguration20::FarLimit = NULL;
	this->tt__FocusConfiguration20::Extension = NULL;
	this->tt__FocusConfiguration20::AFMode = NULL;
	this->tt__FocusConfiguration20::__anyAttribute = NULL;
}

void tt__FocusConfiguration20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__FocusConfiguration20::DefaultSpeed);
	soap_serialize_PointerTofloat(soap, &this->tt__FocusConfiguration20::NearLimit);
	soap_serialize_PointerTofloat(soap, &this->tt__FocusConfiguration20::FarLimit);
	soap_serialize_PointerTott__FocusConfiguration20Extension(soap, &this->tt__FocusConfiguration20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusConfiguration20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusConfiguration20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20(struct soap *soap, const char *tag, int id, const tt__FocusConfiguration20 *a, const char *type)
{
	if (((tt__FocusConfiguration20*)a)->AFMode)
	{	soap_set_attr(soap, "AFMode", soap_tt__StringAttrList2s(soap, *((tt__FocusConfiguration20*)a)->AFMode), 1);
	}
	if (((tt__FocusConfiguration20*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__FocusConfiguration20*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20), type ? type : "tt:FocusConfiguration20"))
		return soap->error;
	if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusMode", -1, &a->tt__FocusConfiguration20::AutoFocusMode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:DefaultSpeed", -1, &a->tt__FocusConfiguration20::DefaultSpeed, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:NearLimit", -1, &a->tt__FocusConfiguration20::NearLimit, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:FarLimit", -1, &a->tt__FocusConfiguration20::FarLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", -1, &a->tt__FocusConfiguration20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusConfiguration20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusConfiguration20(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusConfiguration20 * SOAP_FMAC4 soap_in_tt__FocusConfiguration20(struct soap *soap, const char *tag, tt__FocusConfiguration20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusConfiguration20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(tt__FocusConfiguration20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusConfiguration20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusConfiguration20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "AFMode", 1, 0);
		if (t)
		{
			if (!(((tt__FocusConfiguration20*)a)->AFMode = soap_new_tt__StringAttrList(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__StringAttrList(soap, t, ((tt__FocusConfiguration20*)a)->AFMode))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__FocusConfiguration20*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AutoFocusMode1 = 1;
	size_t soap_flag_DefaultSpeed1 = 1;
	size_t soap_flag_NearLimit1 = 1;
	size_t soap_flag_FarLimit1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusMode", &a->tt__FocusConfiguration20::AutoFocusMode, "tt:AutoFocusMode"))
				{	soap_flag_AutoFocusMode1--;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:DefaultSpeed", &a->tt__FocusConfiguration20::DefaultSpeed, "xsd:float"))
				{	soap_flag_DefaultSpeed1--;
					continue;
				}
			}
			if (soap_flag_NearLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:NearLimit", &a->tt__FocusConfiguration20::NearLimit, "xsd:float"))
				{	soap_flag_NearLimit1--;
					continue;
				}
			}
			if (soap_flag_FarLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:FarLimit", &a->tt__FocusConfiguration20::FarLimit, "xsd:float"))
				{	soap_flag_FarLimit1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", &a->tt__FocusConfiguration20::Extension, "tt:FocusConfiguration20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FocusConfiguration20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20, SOAP_TYPE_tt__FocusConfiguration20, sizeof(tt__FocusConfiguration20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusConfiguration20 * SOAP_FMAC2 imageing_instantiate_tt__FocusConfiguration20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__FocusConfiguration20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusConfiguration20 *p;
	size_t k = sizeof(tt__FocusConfiguration20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusConfiguration20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusConfiguration20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusConfiguration20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusConfiguration20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusConfiguration20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusConfiguration20(soap, tag ? tag : "tt:FocusConfiguration20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusConfiguration20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusConfiguration20(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusConfiguration20 * SOAP_FMAC4 soap_get_tt__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalance20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__WhiteBalance20Extension::__any);
}

void tt__WhiteBalance20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__WhiteBalance20Extension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WhiteBalance20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalance20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, const tt__WhiteBalance20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20Extension), type ? type : "tt:WhiteBalance20Extension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__WhiteBalance20Extension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalance20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalance20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalance20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, tt__WhiteBalance20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalance20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(tt__WhiteBalance20Extension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalance20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WhiteBalance20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__WhiteBalance20Extension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WhiteBalance20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20Extension, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(tt__WhiteBalance20Extension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalance20Extension * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalance20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__WhiteBalance20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalance20Extension *p;
	size_t k = sizeof(tt__WhiteBalance20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalance20Extension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalance20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalance20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalance20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalance20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalance20Extension(soap, tag ? tag : "tt:WhiteBalance20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalance20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalance20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalance20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalance20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__WhiteBalanceMode(soap, &this->tt__WhiteBalance20::Mode);
	this->tt__WhiteBalance20::CrGain = NULL;
	this->tt__WhiteBalance20::CbGain = NULL;
	this->tt__WhiteBalance20::Extension = NULL;
	this->tt__WhiteBalance20::__anyAttribute = NULL;
}

void tt__WhiteBalance20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__WhiteBalance20::CrGain);
	soap_serialize_PointerTofloat(soap, &this->tt__WhiteBalance20::CbGain);
	soap_serialize_PointerTott__WhiteBalance20Extension(soap, &this->tt__WhiteBalance20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WhiteBalance20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalance20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20(struct soap *soap, const char *tag, int id, const tt__WhiteBalance20 *a, const char *type)
{
	if (((tt__WhiteBalance20*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__WhiteBalance20*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20), type ? type : "tt:WhiteBalance20"))
		return soap->error;
	if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->tt__WhiteBalance20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:CrGain", -1, &a->tt__WhiteBalance20::CrGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:CbGain", -1, &a->tt__WhiteBalance20::CbGain, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", -1, &a->tt__WhiteBalance20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalance20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalance20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalance20 * SOAP_FMAC4 soap_in_tt__WhiteBalance20(struct soap *soap, const char *tag, tt__WhiteBalance20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalance20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20, sizeof(tt__WhiteBalance20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalance20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WhiteBalance20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__WhiteBalance20*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_CrGain1 = 1;
	size_t soap_flag_CbGain1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", &a->tt__WhiteBalance20::Mode, "tt:WhiteBalanceMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_CrGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:CrGain", &a->tt__WhiteBalance20::CrGain, "xsd:float"))
				{	soap_flag_CrGain1--;
					continue;
				}
			}
			if (soap_flag_CbGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:CbGain", &a->tt__WhiteBalance20::CbGain, "xsd:float"))
				{	soap_flag_CbGain1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", &a->tt__WhiteBalance20::Extension, "tt:WhiteBalance20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WhiteBalance20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20, SOAP_TYPE_tt__WhiteBalance20, sizeof(tt__WhiteBalance20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalance20 * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalance20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__WhiteBalance20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalance20 *p;
	size_t k = sizeof(tt__WhiteBalance20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalance20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalance20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalance20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalance20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalance20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalance20(soap, tag ? tag : "tt:WhiteBalance20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalance20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalance20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalance20 * SOAP_FMAC4 soap_get_tt__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelativeFocusOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__RelativeFocusOptions20::Distance = NULL;
	this->tt__RelativeFocusOptions20::Speed = NULL;
}

void tt__RelativeFocusOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__RelativeFocusOptions20::Distance);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__RelativeFocusOptions20::Speed);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RelativeFocusOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelativeFocusOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, const tt__RelativeFocusOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocusOptions20), type ? type : "tt:RelativeFocusOptions20"))
		return soap->error;
	if (!a->tt__RelativeFocusOptions20::Distance)
	{	if (soap_element_empty(soap, "tt:Distance", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Distance", -1, &a->tt__RelativeFocusOptions20::Distance, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->tt__RelativeFocusOptions20::Speed, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelativeFocusOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelativeFocusOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_in_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, tt__RelativeFocusOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelativeFocusOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(tt__RelativeFocusOptions20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelativeFocusOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RelativeFocusOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Distance1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Distance", &a->tt__RelativeFocusOptions20::Distance, "tt:FloatRange"))
				{	soap_flag_Distance1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->tt__RelativeFocusOptions20::Speed, "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__RelativeFocusOptions20::Distance))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RelativeFocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocusOptions20, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(tt__RelativeFocusOptions20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelativeFocusOptions20 * SOAP_FMAC2 imageing_instantiate_tt__RelativeFocusOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__RelativeFocusOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelativeFocusOptions20 *p;
	size_t k = sizeof(tt__RelativeFocusOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelativeFocusOptions20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelativeFocusOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelativeFocusOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelativeFocusOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelativeFocusOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelativeFocusOptions20(soap, tag ? tag : "tt:RelativeFocusOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelativeFocusOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelativeFocusOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_get_tt__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MoveOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__MoveOptions20::Absolute = NULL;
	this->tt__MoveOptions20::Relative = NULL;
	this->tt__MoveOptions20::Continuous = NULL;
}

void tt__MoveOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AbsoluteFocusOptions(soap, &this->tt__MoveOptions20::Absolute);
	soap_serialize_PointerTott__RelativeFocusOptions20(soap, &this->tt__MoveOptions20::Relative);
	soap_serialize_PointerTott__ContinuousFocusOptions(soap, &this->tt__MoveOptions20::Continuous);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MoveOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MoveOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveOptions20(struct soap *soap, const char *tag, int id, const tt__MoveOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveOptions20), type ? type : "tt:MoveOptions20"))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", -1, &a->tt__MoveOptions20::Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", -1, &a->tt__MoveOptions20::Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", -1, &a->tt__MoveOptions20::Continuous, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MoveOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MoveOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__MoveOptions20 * SOAP_FMAC4 soap_in_tt__MoveOptions20(struct soap *soap, const char *tag, tt__MoveOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MoveOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveOptions20, sizeof(tt__MoveOptions20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MoveOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MoveOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Absolute1 = 1;
	size_t soap_flag_Relative1 = 1;
	size_t soap_flag_Continuous1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", &a->tt__MoveOptions20::Absolute, "tt:AbsoluteFocusOptions"))
				{	soap_flag_Absolute1--;
					continue;
				}
			}
			if (soap_flag_Relative1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", &a->tt__MoveOptions20::Relative, "tt:RelativeFocusOptions20"))
				{	soap_flag_Relative1--;
					continue;
				}
			}
			if (soap_flag_Continuous1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", &a->tt__MoveOptions20::Continuous, "tt:ContinuousFocusOptions"))
				{	soap_flag_Continuous1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MoveOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveOptions20, SOAP_TYPE_tt__MoveOptions20, sizeof(tt__MoveOptions20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MoveOptions20 * SOAP_FMAC2 imageing_instantiate_tt__MoveOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__MoveOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MoveOptions20 *p;
	size_t k = sizeof(tt__MoveOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MoveOptions20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MoveOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MoveOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MoveOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MoveOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MoveOptions20(soap, tag ? tag : "tt:MoveOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MoveOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MoveOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__MoveOptions20 * SOAP_FMAC4 soap_get_tt__MoveOptions20(struct soap *soap, tt__MoveOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ExposureOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__ExposureMode(soap, &this->tt__ExposureOptions20::Mode);
	soap_default_std__vectorTemplateOftt__ExposurePriority(soap, &this->tt__ExposureOptions20::Priority);
	this->tt__ExposureOptions20::MinExposureTime = NULL;
	this->tt__ExposureOptions20::MaxExposureTime = NULL;
	this->tt__ExposureOptions20::MinGain = NULL;
	this->tt__ExposureOptions20::MaxGain = NULL;
	this->tt__ExposureOptions20::MinIris = NULL;
	this->tt__ExposureOptions20::MaxIris = NULL;
	this->tt__ExposureOptions20::ExposureTime = NULL;
	this->tt__ExposureOptions20::Gain = NULL;
	this->tt__ExposureOptions20::Iris = NULL;
}

void tt__ExposureOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ExposureMode(soap, &this->tt__ExposureOptions20::Mode);
	soap_serialize_std__vectorTemplateOftt__ExposurePriority(soap, &this->tt__ExposureOptions20::Priority);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MinExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MaxExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MinGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MaxGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MinIris);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MaxIris);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::ExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::Gain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::Iris);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ExposureOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ExposureOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureOptions20(struct soap *soap, const char *tag, int id, const tt__ExposureOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureOptions20), type ? type : "tt:ExposureOptions20"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ExposureMode(soap, "tt:Mode", -1, &a->tt__ExposureOptions20::Mode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ExposurePriority(soap, "tt:Priority", -1, &a->tt__ExposureOptions20::Priority, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinExposureTime", -1, &a->tt__ExposureOptions20::MinExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxExposureTime", -1, &a->tt__ExposureOptions20::MaxExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinGain", -1, &a->tt__ExposureOptions20::MinGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxGain", -1, &a->tt__ExposureOptions20::MaxGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinIris", -1, &a->tt__ExposureOptions20::MinIris, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxIris", -1, &a->tt__ExposureOptions20::MaxIris, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ExposureTime", -1, &a->tt__ExposureOptions20::ExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Gain", -1, &a->tt__ExposureOptions20::Gain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Iris", -1, &a->tt__ExposureOptions20::Iris, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ExposureOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ExposureOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ExposureOptions20 * SOAP_FMAC4 soap_in_tt__ExposureOptions20(struct soap *soap, const char *tag, tt__ExposureOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ExposureOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureOptions20, sizeof(tt__ExposureOptions20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ExposureOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ExposureOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_MinExposureTime1 = 1;
	size_t soap_flag_MaxExposureTime1 = 1;
	size_t soap_flag_MinGain1 = 1;
	size_t soap_flag_MaxGain1 = 1;
	size_t soap_flag_MinIris1 = 1;
	size_t soap_flag_MaxIris1 = 1;
	size_t soap_flag_ExposureTime1 = 1;
	size_t soap_flag_Gain1 = 1;
	size_t soap_flag_Iris1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ExposureMode(soap, "tt:Mode", &a->tt__ExposureOptions20::Mode, "tt:ExposureMode"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ExposurePriority(soap, "tt:Priority", &a->tt__ExposureOptions20::Priority, "tt:ExposurePriority"))
					continue;
			}
			if (soap_flag_MinExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinExposureTime", &a->tt__ExposureOptions20::MinExposureTime, "tt:FloatRange"))
				{	soap_flag_MinExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MaxExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxExposureTime", &a->tt__ExposureOptions20::MaxExposureTime, "tt:FloatRange"))
				{	soap_flag_MaxExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MinGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinGain", &a->tt__ExposureOptions20::MinGain, "tt:FloatRange"))
				{	soap_flag_MinGain1--;
					continue;
				}
			}
			if (soap_flag_MaxGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxGain", &a->tt__ExposureOptions20::MaxGain, "tt:FloatRange"))
				{	soap_flag_MaxGain1--;
					continue;
				}
			}
			if (soap_flag_MinIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinIris", &a->tt__ExposureOptions20::MinIris, "tt:FloatRange"))
				{	soap_flag_MinIris1--;
					continue;
				}
			}
			if (soap_flag_MaxIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxIris", &a->tt__ExposureOptions20::MaxIris, "tt:FloatRange"))
				{	soap_flag_MaxIris1--;
					continue;
				}
			}
			if (soap_flag_ExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:ExposureTime", &a->tt__ExposureOptions20::ExposureTime, "tt:FloatRange"))
				{	soap_flag_ExposureTime1--;
					continue;
				}
			}
			if (soap_flag_Gain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Gain", &a->tt__ExposureOptions20::Gain, "tt:FloatRange"))
				{	soap_flag_Gain1--;
					continue;
				}
			}
			if (soap_flag_Iris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Iris", &a->tt__ExposureOptions20::Iris, "tt:FloatRange"))
				{	soap_flag_Iris1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__ExposureOptions20::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ExposureOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureOptions20, SOAP_TYPE_tt__ExposureOptions20, sizeof(tt__ExposureOptions20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ExposureOptions20 * SOAP_FMAC2 imageing_instantiate_tt__ExposureOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ExposureOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ExposureOptions20 *p;
	size_t k = sizeof(tt__ExposureOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ExposureOptions20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ExposureOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ExposureOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ExposureOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ExposureOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ExposureOptions20(soap, tag ? tag : "tt:ExposureOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ExposureOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ExposureOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ExposureOptions20 * SOAP_FMAC4 soap_get_tt__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BacklightCompensationOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__BacklightCompensationMode(soap, &this->tt__BacklightCompensationOptions20::Mode);
	this->tt__BacklightCompensationOptions20::Level = NULL;
}

void tt__BacklightCompensationOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__BacklightCompensationMode(soap, &this->tt__BacklightCompensationOptions20::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__BacklightCompensationOptions20::Level);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__BacklightCompensationOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensationOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, const tt__BacklightCompensationOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationOptions20), type ? type : "tt:BacklightCompensationOptions20"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__BacklightCompensationMode(soap, "tt:Mode", -1, &a->tt__BacklightCompensationOptions20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->tt__BacklightCompensationOptions20::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BacklightCompensationOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BacklightCompensationOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_in_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, tt__BacklightCompensationOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BacklightCompensationOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(tt__BacklightCompensationOptions20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BacklightCompensationOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BacklightCompensationOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__BacklightCompensationMode(soap, "tt:Mode", &a->tt__BacklightCompensationOptions20::Mode, "tt:BacklightCompensationMode"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->tt__BacklightCompensationOptions20::Level, "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__BacklightCompensationOptions20::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BacklightCompensationOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationOptions20, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(tt__BacklightCompensationOptions20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BacklightCompensationOptions20 * SOAP_FMAC2 imageing_instantiate_tt__BacklightCompensationOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__BacklightCompensationOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BacklightCompensationOptions20 *p;
	size_t k = sizeof(tt__BacklightCompensationOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BacklightCompensationOptions20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BacklightCompensationOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BacklightCompensationOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BacklightCompensationOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BacklightCompensationOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BacklightCompensationOptions20(soap, tag ? tag : "tt:BacklightCompensationOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensationOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensationOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_get_tt__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WideDynamicRangeOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__WideDynamicRangeOptions20::Mode);
	this->tt__WideDynamicRangeOptions20::Level = NULL;
}

void tt__WideDynamicRangeOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__WideDynamicRangeOptions20::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WideDynamicRangeOptions20::Level);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WideDynamicRangeOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicRangeOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, const tt__WideDynamicRangeOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20), type ? type : "tt:WideDynamicRangeOptions20"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", -1, &a->tt__WideDynamicRangeOptions20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->tt__WideDynamicRangeOptions20::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WideDynamicRangeOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WideDynamicRangeOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_in_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, tt__WideDynamicRangeOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WideDynamicRangeOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(tt__WideDynamicRangeOptions20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WideDynamicRangeOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WideDynamicRangeOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", &a->tt__WideDynamicRangeOptions20::Mode, "tt:WideDynamicMode"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->tt__WideDynamicRangeOptions20::Level, "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__WideDynamicRangeOptions20::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WideDynamicRangeOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRangeOptions20, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(tt__WideDynamicRangeOptions20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WideDynamicRangeOptions20 * SOAP_FMAC2 imageing_instantiate_tt__WideDynamicRangeOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__WideDynamicRangeOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WideDynamicRangeOptions20 *p;
	size_t k = sizeof(tt__WideDynamicRangeOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WideDynamicRangeOptions20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WideDynamicRangeOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WideDynamicRangeOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WideDynamicRangeOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WideDynamicRangeOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WideDynamicRangeOptions20(soap, tag ? tag : "tt:WideDynamicRangeOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicRangeOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicRangeOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_get_tt__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__IrCutFilterAutoAdjustmentOptionsExtension::__any);
}

void tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__IrCutFilterAutoAdjustmentOptionsExtension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, int id, const tt__IrCutFilterAutoAdjustmentOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension), type ? type : "tt:IrCutFilterAutoAdjustmentOptionsExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__IrCutFilterAutoAdjustmentOptionsExtension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IrCutFilterAutoAdjustmentOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(tt__IrCutFilterAutoAdjustmentOptionsExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IrCutFilterAutoAdjustmentOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__IrCutFilterAutoAdjustmentOptionsExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustmentOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(tt__IrCutFilterAutoAdjustmentOptionsExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterAutoAdjustmentOptionsExtension *p;
	size_t k = sizeof(tt__IrCutFilterAutoAdjustmentOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterAutoAdjustmentOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterAutoAdjustmentOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterAutoAdjustmentOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterAutoAdjustmentOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType);
	this->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset = NULL;
	this->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange = NULL;
	this->tt__IrCutFilterAutoAdjustmentOptions::Extension = NULL;
	this->tt__IrCutFilterAutoAdjustmentOptions::__anyAttribute = NULL;
}

void tt__IrCutFilterAutoAdjustmentOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType);
	soap_serialize_PointerTobool(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset);
	soap_serialize_PointerTott__DurationRange(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange);
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IrCutFilterAutoAdjustmentOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, int id, const tt__IrCutFilterAutoAdjustmentOptions *a, const char *type)
{
	if (((tt__IrCutFilterAutoAdjustmentOptions*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__IrCutFilterAutoAdjustmentOptions*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions), type ? type : "tt:IrCutFilterAutoAdjustmentOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:BoundaryType", -1, &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:BoundaryOffset", -1, &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset, ""))
		return soap->error;
	if (soap_out_PointerTott__DurationRange(soap, "tt:ResponseTimeRange", -1, &a->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, "tt:Extension", -1, &a->tt__IrCutFilterAutoAdjustmentOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IrCutFilterAutoAdjustmentOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IrCutFilterAutoAdjustmentOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(tt__IrCutFilterAutoAdjustmentOptions), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IrCutFilterAutoAdjustmentOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__IrCutFilterAutoAdjustmentOptions*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BoundaryOffset1 = 1;
	size_t soap_flag_ResponseTimeRange1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:BoundaryType", &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType, "xsd:string"))
					continue;
			}
			if (soap_flag_BoundaryOffset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:BoundaryOffset", &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset, "xsd:boolean"))
				{	soap_flag_BoundaryOffset1--;
					continue;
				}
			}
			if (soap_flag_ResponseTimeRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DurationRange(soap, "tt:ResponseTimeRange", &a->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange, "tt:DurationRange"))
				{	soap_flag_ResponseTimeRange1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, "tt:Extension", &a->tt__IrCutFilterAutoAdjustmentOptions::Extension, "tt:IrCutFilterAutoAdjustmentOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustmentOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(tt__IrCutFilterAutoAdjustmentOptions), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterAutoAdjustmentOptions *p;
	size_t k = sizeof(tt__IrCutFilterAutoAdjustmentOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterAutoAdjustmentOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterAutoAdjustmentOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterAutoAdjustmentOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterAutoAdjustmentOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentOptions(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterAutoAdjustmentOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterAutoAdjustmentOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilizationOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__ImageStabilizationOptionsExtension::__any);
}

void tt__ImageStabilizationOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__ImageStabilizationOptionsExtension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImageStabilizationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilizationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__ImageStabilizationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension), type ? type : "tt:ImageStabilizationOptionsExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__ImageStabilizationOptionsExtension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImageStabilizationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilizationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_in_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, tt__ImageStabilizationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImageStabilizationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(tt__ImageStabilizationOptionsExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilizationOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImageStabilizationOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__ImageStabilizationOptionsExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImageStabilizationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(tt__ImageStabilizationOptionsExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationOptionsExtension * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilizationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImageStabilizationOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilizationOptionsExtension *p;
	size_t k = sizeof(tt__ImageStabilizationOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilizationOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilizationOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilizationOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilizationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilizationOptionsExtension(soap, tag ? tag : "tt:ImageStabilizationOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilizationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilizationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_get_tt__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilizationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__ImageStabilizationMode(soap, &this->tt__ImageStabilizationOptions::Mode);
	this->tt__ImageStabilizationOptions::Level = NULL;
	this->tt__ImageStabilizationOptions::Extension = NULL;
	this->tt__ImageStabilizationOptions::__anyAttribute = NULL;
}

void tt__ImageStabilizationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ImageStabilizationMode(soap, &this->tt__ImageStabilizationOptions::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImageStabilizationOptions::Level);
	soap_serialize_PointerTott__ImageStabilizationOptionsExtension(soap, &this->tt__ImageStabilizationOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImageStabilizationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilizationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationOptions(struct soap *soap, const char *tag, int id, const tt__ImageStabilizationOptions *a, const char *type)
{
	if (((tt__ImageStabilizationOptions*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__ImageStabilizationOptions*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationOptions), type ? type : "tt:ImageStabilizationOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ImageStabilizationMode(soap, "tt:Mode", -1, &a->tt__ImageStabilizationOptions::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->tt__ImageStabilizationOptions::Level, ""))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationOptionsExtension(soap, "tt:Extension", -1, &a->tt__ImageStabilizationOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImageStabilizationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilizationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilizationOptions * SOAP_FMAC4 soap_in_tt__ImageStabilizationOptions(struct soap *soap, const char *tag, tt__ImageStabilizationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImageStabilizationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(tt__ImageStabilizationOptions), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilizationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImageStabilizationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__ImageStabilizationOptions*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ImageStabilizationMode(soap, "tt:Mode", &a->tt__ImageStabilizationOptions::Mode, "tt:ImageStabilizationMode"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->tt__ImageStabilizationOptions::Level, "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilizationOptionsExtension(soap, "tt:Extension", &a->tt__ImageStabilizationOptions::Extension, "tt:ImageStabilizationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__ImageStabilizationOptions::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ImageStabilizationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationOptions, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(tt__ImageStabilizationOptions), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationOptions * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilizationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImageStabilizationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilizationOptions *p;
	size_t k = sizeof(tt__ImageStabilizationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilizationOptions, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilizationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilizationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilizationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilizationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilizationOptions(soap, tag ? tag : "tt:ImageStabilizationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilizationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilizationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilizationOptions * SOAP_FMAC4 soap_get_tt__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20Extension4::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__ImagingOptions20Extension4::__any);
}

void tt__ImagingOptions20Extension4::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__ImagingOptions20Extension4::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingOptions20Extension4::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20Extension4(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension4(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20Extension4 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension4), type ? type : "tt:ImagingOptions20Extension4"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__ImagingOptions20Extension4::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20Extension4::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20Extension4(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension4(struct soap *soap, const char *tag, tt__ImagingOptions20Extension4 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20Extension4*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(tt__ImagingOptions20Extension4), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20Extension4)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20Extension4 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__ImagingOptions20Extension4::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20Extension4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension4, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(tt__ImagingOptions20Extension4), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension4 * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20Extension4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImagingOptions20Extension4(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20Extension4 *p;
	size_t k = sizeof(tt__ImagingOptions20Extension4);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20Extension4, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20Extension4);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20Extension4, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20Extension4 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20Extension4::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20Extension4(soap, tag ? tag : "tt:ImagingOptions20Extension4", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20Extension4::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20Extension4(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20Extension3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingOptions20Extension3::ToneCompensationOptions = NULL;
	this->tt__ImagingOptions20Extension3::DefoggingOptions = NULL;
	this->tt__ImagingOptions20Extension3::NoiseReductionOptions = NULL;
	this->tt__ImagingOptions20Extension3::Extension = NULL;
}

void tt__ImagingOptions20Extension3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ToneCompensationOptions(soap, &this->tt__ImagingOptions20Extension3::ToneCompensationOptions);
	soap_serialize_PointerTott__DefoggingOptions(soap, &this->tt__ImagingOptions20Extension3::DefoggingOptions);
	soap_serialize_PointerTott__NoiseReductionOptions(soap, &this->tt__ImagingOptions20Extension3::NoiseReductionOptions);
	soap_serialize_PointerTott__ImagingOptions20Extension4(soap, &this->tt__ImagingOptions20Extension3::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingOptions20Extension3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20Extension3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension3(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20Extension3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension3), type ? type : "tt:ImagingOptions20Extension3"))
		return soap->error;
	if (soap_out_PointerTott__ToneCompensationOptions(soap, "tt:ToneCompensationOptions", -1, &a->tt__ImagingOptions20Extension3::ToneCompensationOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__DefoggingOptions(soap, "tt:DefoggingOptions", -1, &a->tt__ImagingOptions20Extension3::DefoggingOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__NoiseReductionOptions(soap, "tt:NoiseReductionOptions", -1, &a->tt__ImagingOptions20Extension3::NoiseReductionOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension4(soap, "tt:Extension", -1, &a->tt__ImagingOptions20Extension3::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20Extension3::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20Extension3(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension3(struct soap *soap, const char *tag, tt__ImagingOptions20Extension3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20Extension3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(tt__ImagingOptions20Extension3), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20Extension3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20Extension3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ToneCompensationOptions1 = 1;
	size_t soap_flag_DefoggingOptions1 = 1;
	size_t soap_flag_NoiseReductionOptions1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToneCompensationOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ToneCompensationOptions(soap, "tt:ToneCompensationOptions", &a->tt__ImagingOptions20Extension3::ToneCompensationOptions, "tt:ToneCompensationOptions"))
				{	soap_flag_ToneCompensationOptions1--;
					continue;
				}
			}
			if (soap_flag_DefoggingOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DefoggingOptions(soap, "tt:DefoggingOptions", &a->tt__ImagingOptions20Extension3::DefoggingOptions, "tt:DefoggingOptions"))
				{	soap_flag_DefoggingOptions1--;
					continue;
				}
			}
			if (soap_flag_NoiseReductionOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NoiseReductionOptions(soap, "tt:NoiseReductionOptions", &a->tt__ImagingOptions20Extension3::NoiseReductionOptions, "tt:NoiseReductionOptions"))
				{	soap_flag_NoiseReductionOptions1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension4(soap, "tt:Extension", &a->tt__ImagingOptions20Extension3::Extension, "tt:ImagingOptions20Extension4"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20Extension3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension3, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(tt__ImagingOptions20Extension3), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension3 * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20Extension3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImagingOptions20Extension3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20Extension3 *p;
	size_t k = sizeof(tt__ImagingOptions20Extension3);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20Extension3, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20Extension3);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20Extension3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20Extension3 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20Extension3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20Extension3(soap, tag ? tag : "tt:ImagingOptions20Extension3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20Extension3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20Extension3(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20Extension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment = NULL;
	this->tt__ImagingOptions20Extension2::Extension = NULL;
}

void tt__ImagingOptions20Extension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, &this->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment);
	soap_serialize_PointerTott__ImagingOptions20Extension3(soap, &this->tt__ImagingOptions20Extension2::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingOptions20Extension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20Extension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension2(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20Extension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension2), type ? type : "tt:ImagingOptions20Extension2"))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, "tt:IrCutFilterAutoAdjustment", -1, &a->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension3(soap, "tt:Extension", -1, &a->tt__ImagingOptions20Extension2::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20Extension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20Extension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension2(struct soap *soap, const char *tag, tt__ImagingOptions20Extension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20Extension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(tt__ImagingOptions20Extension2), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20Extension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20Extension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_IrCutFilterAutoAdjustment1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IrCutFilterAutoAdjustment1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, "tt:IrCutFilterAutoAdjustment", &a->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment, "tt:IrCutFilterAutoAdjustmentOptions"))
				{	soap_flag_IrCutFilterAutoAdjustment1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension3(soap, "tt:Extension", &a->tt__ImagingOptions20Extension2::Extension, "tt:ImagingOptions20Extension3"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20Extension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension2, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(tt__ImagingOptions20Extension2), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension2 * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20Extension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImagingOptions20Extension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20Extension2 *p;
	size_t k = sizeof(tt__ImagingOptions20Extension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20Extension2, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20Extension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20Extension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20Extension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20Extension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20Extension2(soap, tag ? tag : "tt:ImagingOptions20Extension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20Extension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20Extension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__ImagingOptions20Extension::__any);
	this->tt__ImagingOptions20Extension::ImageStabilization = NULL;
	this->tt__ImagingOptions20Extension::Extension = NULL;
}

void tt__ImagingOptions20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__ImagingOptions20Extension::__any);
	soap_serialize_PointerTott__ImageStabilizationOptions(soap, &this->tt__ImagingOptions20Extension::ImageStabilization);
	soap_serialize_PointerTott__ImagingOptions20Extension2(soap, &this->tt__ImagingOptions20Extension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingOptions20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension), type ? type : "tt:ImagingOptions20Extension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__ImagingOptions20Extension::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationOptions(soap, "tt:ImageStabilization", -1, &a->tt__ImagingOptions20Extension::ImageStabilization, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension2(soap, "tt:Extension", -1, &a->tt__ImagingOptions20Extension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, tt__ImagingOptions20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(tt__ImagingOptions20Extension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ImageStabilization1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImageStabilization1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilizationOptions(soap, "tt:ImageStabilization", &a->tt__ImagingOptions20Extension::ImageStabilization, "tt:ImageStabilizationOptions"))
				{	soap_flag_ImageStabilization1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension2(soap, "tt:Extension", &a->tt__ImagingOptions20Extension::Extension, "tt:ImagingOptions20Extension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__ImagingOptions20Extension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(tt__ImagingOptions20Extension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImagingOptions20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20Extension *p;
	size_t k = sizeof(tt__ImagingOptions20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20Extension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20Extension(soap, tag ? tag : "tt:ImagingOptions20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingOptions20::BacklightCompensation = NULL;
	this->tt__ImagingOptions20::Brightness = NULL;
	this->tt__ImagingOptions20::ColorSaturation = NULL;
	this->tt__ImagingOptions20::Contrast = NULL;
	this->tt__ImagingOptions20::Exposure = NULL;
	this->tt__ImagingOptions20::Focus = NULL;
	soap_default_std__vectorTemplateOftt__IrCutFilterMode(soap, &this->tt__ImagingOptions20::IrCutFilterModes);
	this->tt__ImagingOptions20::Sharpness = NULL;
	this->tt__ImagingOptions20::WideDynamicRange = NULL;
	this->tt__ImagingOptions20::WhiteBalance = NULL;
	this->tt__ImagingOptions20::Extension = NULL;
	this->tt__ImagingOptions20::__anyAttribute = NULL;
}

void tt__ImagingOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensationOptions20(soap, &this->tt__ImagingOptions20::BacklightCompensation);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::Brightness);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::ColorSaturation);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::Contrast);
	soap_serialize_PointerTott__ExposureOptions20(soap, &this->tt__ImagingOptions20::Exposure);
	soap_serialize_PointerTott__FocusOptions20(soap, &this->tt__ImagingOptions20::Focus);
	soap_serialize_std__vectorTemplateOftt__IrCutFilterMode(soap, &this->tt__ImagingOptions20::IrCutFilterModes);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::Sharpness);
	soap_serialize_PointerTott__WideDynamicRangeOptions20(soap, &this->tt__ImagingOptions20::WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalanceOptions20(soap, &this->tt__ImagingOptions20::WhiteBalance);
	soap_serialize_PointerTott__ImagingOptions20Extension(soap, &this->tt__ImagingOptions20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20 *a, const char *type)
{
	if (((tt__ImagingOptions20*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__ImagingOptions20*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20), type ? type : "tt:ImagingOptions20"))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", -1, &a->tt__ImagingOptions20::BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Brightness", -1, &a->tt__ImagingOptions20::Brightness, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ColorSaturation", -1, &a->tt__ImagingOptions20::ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Contrast", -1, &a->tt__ImagingOptions20::Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__ExposureOptions20(soap, "tt:Exposure", -1, &a->tt__ImagingOptions20::Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20(soap, "tt:Focus", -1, &a->tt__ImagingOptions20::Focus, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IrCutFilterMode(soap, "tt:IrCutFilterModes", -1, &a->tt__ImagingOptions20::IrCutFilterModes, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Sharpness", -1, &a->tt__ImagingOptions20::Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", -1, &a->tt__ImagingOptions20::WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", -1, &a->tt__ImagingOptions20::WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", -1, &a->tt__ImagingOptions20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20 * SOAP_FMAC4 soap_in_tt__ImagingOptions20(struct soap *soap, const char *tag, tt__ImagingOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20, sizeof(tt__ImagingOptions20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__ImagingOptions20*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BacklightCompensation1 = 1;
	size_t soap_flag_Brightness1 = 1;
	size_t soap_flag_ColorSaturation1 = 1;
	size_t soap_flag_Contrast1 = 1;
	size_t soap_flag_Exposure1 = 1;
	size_t soap_flag_Focus1 = 1;
	size_t soap_flag_Sharpness1 = 1;
	size_t soap_flag_WideDynamicRange1 = 1;
	size_t soap_flag_WhiteBalance1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", &a->tt__ImagingOptions20::BacklightCompensation, "tt:BacklightCompensationOptions20"))
				{	soap_flag_BacklightCompensation1--;
					continue;
				}
			}
			if (soap_flag_Brightness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Brightness", &a->tt__ImagingOptions20::Brightness, "tt:FloatRange"))
				{	soap_flag_Brightness1--;
					continue;
				}
			}
			if (soap_flag_ColorSaturation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:ColorSaturation", &a->tt__ImagingOptions20::ColorSaturation, "tt:FloatRange"))
				{	soap_flag_ColorSaturation1--;
					continue;
				}
			}
			if (soap_flag_Contrast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Contrast", &a->tt__ImagingOptions20::Contrast, "tt:FloatRange"))
				{	soap_flag_Contrast1--;
					continue;
				}
			}
			if (soap_flag_Exposure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ExposureOptions20(soap, "tt:Exposure", &a->tt__ImagingOptions20::Exposure, "tt:ExposureOptions20"))
				{	soap_flag_Exposure1--;
					continue;
				}
			}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusOptions20(soap, "tt:Focus", &a->tt__ImagingOptions20::Focus, "tt:FocusOptions20"))
				{	soap_flag_Focus1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IrCutFilterMode(soap, "tt:IrCutFilterModes", &a->tt__ImagingOptions20::IrCutFilterModes, "tt:IrCutFilterMode"))
					continue;
			}
			if (soap_flag_Sharpness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Sharpness", &a->tt__ImagingOptions20::Sharpness, "tt:FloatRange"))
				{	soap_flag_Sharpness1--;
					continue;
				}
			}
			if (soap_flag_WideDynamicRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", &a->tt__ImagingOptions20::WideDynamicRange, "tt:WideDynamicRangeOptions20"))
				{	soap_flag_WideDynamicRange1--;
					continue;
				}
			}
			if (soap_flag_WhiteBalance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", &a->tt__ImagingOptions20::WhiteBalance, "tt:WhiteBalanceOptions20"))
				{	soap_flag_WhiteBalance1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", &a->tt__ImagingOptions20::Extension, "tt:ImagingOptions20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20, SOAP_TYPE_tt__ImagingOptions20, sizeof(tt__ImagingOptions20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20 * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImagingOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20 *p;
	size_t k = sizeof(tt__ImagingOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20(soap, tag ? tag : "tt:ImagingOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20 * SOAP_FMAC4 soap_get_tt__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NoiseReduction::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__NoiseReduction::Level);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__NoiseReduction::__any);
	this->tt__NoiseReduction::__anyAttribute = NULL;
}

void tt__NoiseReduction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NoiseReduction::Level, SOAP_TYPE_float);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__NoiseReduction::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NoiseReduction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NoiseReduction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NoiseReduction(struct soap *soap, const char *tag, int id, const tt__NoiseReduction *a, const char *type)
{
	if (((tt__NoiseReduction*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__NoiseReduction*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NoiseReduction), type ? type : "tt:NoiseReduction"))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &a->tt__NoiseReduction::Level, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__NoiseReduction::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NoiseReduction::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NoiseReduction(soap, tag, this, type);
}

SOAP_FMAC3 tt__NoiseReduction * SOAP_FMAC4 soap_in_tt__NoiseReduction(struct soap *soap, const char *tag, tt__NoiseReduction *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NoiseReduction*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NoiseReduction, sizeof(tt__NoiseReduction), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NoiseReduction)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NoiseReduction *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__NoiseReduction*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Level", &a->tt__NoiseReduction::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__NoiseReduction::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NoiseReduction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NoiseReduction, SOAP_TYPE_tt__NoiseReduction, sizeof(tt__NoiseReduction), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NoiseReduction * SOAP_FMAC2 imageing_instantiate_tt__NoiseReduction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__NoiseReduction(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NoiseReduction *p;
	size_t k = sizeof(tt__NoiseReduction);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NoiseReduction, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NoiseReduction);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NoiseReduction, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NoiseReduction location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NoiseReduction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NoiseReduction(soap, tag ? tag : "tt:NoiseReduction", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NoiseReduction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NoiseReduction(soap, this, tag, type);
}

SOAP_FMAC3 tt__NoiseReduction * SOAP_FMAC4 soap_get_tt__NoiseReduction(struct soap *soap, tt__NoiseReduction *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NoiseReduction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DefoggingExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__DefoggingExtension::__any);
}

void tt__DefoggingExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__DefoggingExtension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DefoggingExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DefoggingExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingExtension(struct soap *soap, const char *tag, int id, const tt__DefoggingExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DefoggingExtension), type ? type : "tt:DefoggingExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__DefoggingExtension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DefoggingExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DefoggingExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DefoggingExtension * SOAP_FMAC4 soap_in_tt__DefoggingExtension(struct soap *soap, const char *tag, tt__DefoggingExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DefoggingExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingExtension, sizeof(tt__DefoggingExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DefoggingExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DefoggingExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__DefoggingExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DefoggingExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DefoggingExtension, SOAP_TYPE_tt__DefoggingExtension, sizeof(tt__DefoggingExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DefoggingExtension * SOAP_FMAC2 imageing_instantiate_tt__DefoggingExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__DefoggingExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DefoggingExtension *p;
	size_t k = sizeof(tt__DefoggingExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DefoggingExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DefoggingExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DefoggingExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DefoggingExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DefoggingExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DefoggingExtension(soap, tag ? tag : "tt:DefoggingExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DefoggingExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DefoggingExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DefoggingExtension * SOAP_FMAC4 soap_get_tt__DefoggingExtension(struct soap *soap, tt__DefoggingExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DefoggingExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Defogging::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__Defogging::Mode);
	this->tt__Defogging::Level = NULL;
	this->tt__Defogging::Extension = NULL;
	this->tt__Defogging::__anyAttribute = NULL;
}

void tt__Defogging::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Defogging::Mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__Defogging::Mode);
	soap_serialize_PointerTofloat(soap, &this->tt__Defogging::Level);
	soap_serialize_PointerTott__DefoggingExtension(soap, &this->tt__Defogging::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Defogging::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Defogging(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Defogging(struct soap *soap, const char *tag, int id, const tt__Defogging *a, const char *type)
{
	if (((tt__Defogging*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__Defogging*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Defogging), type ? type : "tt:Defogging"))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Mode", -1, &a->tt__Defogging::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__Defogging::Level, ""))
		return soap->error;
	if (soap_out_PointerTott__DefoggingExtension(soap, "tt:Extension", -1, &a->tt__Defogging::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Defogging::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Defogging(soap, tag, this, type);
}

SOAP_FMAC3 tt__Defogging * SOAP_FMAC4 soap_in_tt__Defogging(struct soap *soap, const char *tag, tt__Defogging *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Defogging*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Defogging, sizeof(tt__Defogging), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Defogging)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Defogging *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__Defogging*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Mode", &a->tt__Defogging::Mode, "xsd:string"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__Defogging::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DefoggingExtension(soap, "tt:Extension", &a->tt__Defogging::Extension, "tt:DefoggingExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Defogging *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Defogging, SOAP_TYPE_tt__Defogging, sizeof(tt__Defogging), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Defogging * SOAP_FMAC2 imageing_instantiate_tt__Defogging(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Defogging(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Defogging *p;
	size_t k = sizeof(tt__Defogging);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Defogging, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Defogging);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Defogging, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Defogging location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Defogging::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Defogging(soap, tag ? tag : "tt:Defogging", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Defogging::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Defogging(soap, this, tag, type);
}

SOAP_FMAC3 tt__Defogging * SOAP_FMAC4 soap_get_tt__Defogging(struct soap *soap, tt__Defogging *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Defogging(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ToneCompensationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__ToneCompensationExtension::__any);
}

void tt__ToneCompensationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__ToneCompensationExtension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ToneCompensationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ToneCompensationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationExtension(struct soap *soap, const char *tag, int id, const tt__ToneCompensationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensationExtension), type ? type : "tt:ToneCompensationExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__ToneCompensationExtension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ToneCompensationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ToneCompensationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ToneCompensationExtension * SOAP_FMAC4 soap_in_tt__ToneCompensationExtension(struct soap *soap, const char *tag, tt__ToneCompensationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ToneCompensationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(tt__ToneCompensationExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ToneCompensationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ToneCompensationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__ToneCompensationExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ToneCompensationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensationExtension, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(tt__ToneCompensationExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ToneCompensationExtension * SOAP_FMAC2 imageing_instantiate_tt__ToneCompensationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ToneCompensationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ToneCompensationExtension *p;
	size_t k = sizeof(tt__ToneCompensationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ToneCompensationExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ToneCompensationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ToneCompensationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ToneCompensationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ToneCompensationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ToneCompensationExtension(soap, tag ? tag : "tt:ToneCompensationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ToneCompensationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ToneCompensationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ToneCompensationExtension * SOAP_FMAC4 soap_get_tt__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ToneCompensation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__ToneCompensation::Mode);
	this->tt__ToneCompensation::Level = NULL;
	this->tt__ToneCompensation::Extension = NULL;
	this->tt__ToneCompensation::__anyAttribute = NULL;
}

void tt__ToneCompensation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ToneCompensation::Mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__ToneCompensation::Mode);
	soap_serialize_PointerTofloat(soap, &this->tt__ToneCompensation::Level);
	soap_serialize_PointerTott__ToneCompensationExtension(soap, &this->tt__ToneCompensation::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ToneCompensation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ToneCompensation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensation(struct soap *soap, const char *tag, int id, const tt__ToneCompensation *a, const char *type)
{
	if (((tt__ToneCompensation*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__ToneCompensation*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensation), type ? type : "tt:ToneCompensation"))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Mode", -1, &a->tt__ToneCompensation::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__ToneCompensation::Level, ""))
		return soap->error;
	if (soap_out_PointerTott__ToneCompensationExtension(soap, "tt:Extension", -1, &a->tt__ToneCompensation::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ToneCompensation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ToneCompensation(soap, tag, this, type);
}

SOAP_FMAC3 tt__ToneCompensation * SOAP_FMAC4 soap_in_tt__ToneCompensation(struct soap *soap, const char *tag, tt__ToneCompensation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ToneCompensation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensation, sizeof(tt__ToneCompensation), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ToneCompensation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ToneCompensation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__ToneCompensation*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Mode", &a->tt__ToneCompensation::Mode, "xsd:string"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__ToneCompensation::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ToneCompensationExtension(soap, "tt:Extension", &a->tt__ToneCompensation::Extension, "tt:ToneCompensationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ToneCompensation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensation, SOAP_TYPE_tt__ToneCompensation, sizeof(tt__ToneCompensation), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ToneCompensation * SOAP_FMAC2 imageing_instantiate_tt__ToneCompensation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ToneCompensation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ToneCompensation *p;
	size_t k = sizeof(tt__ToneCompensation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ToneCompensation, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ToneCompensation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ToneCompensation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ToneCompensation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ToneCompensation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ToneCompensation(soap, tag ? tag : "tt:ToneCompensation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ToneCompensation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ToneCompensation(soap, this, tag, type);
}

SOAP_FMAC3 tt__ToneCompensation * SOAP_FMAC4 soap_get_tt__ToneCompensation(struct soap *soap, tt__ToneCompensation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Exposure20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ExposureMode(soap, &this->tt__Exposure20::Mode);
	this->tt__Exposure20::Priority = NULL;
	this->tt__Exposure20::Window = NULL;
	this->tt__Exposure20::MinExposureTime = NULL;
	this->tt__Exposure20::MaxExposureTime = NULL;
	this->tt__Exposure20::MinGain = NULL;
	this->tt__Exposure20::MaxGain = NULL;
	this->tt__Exposure20::MinIris = NULL;
	this->tt__Exposure20::MaxIris = NULL;
	this->tt__Exposure20::ExposureTime = NULL;
	this->tt__Exposure20::Gain = NULL;
	this->tt__Exposure20::Iris = NULL;
}

void tt__Exposure20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ExposurePriority(soap, &this->tt__Exposure20::Priority);
	soap_serialize_PointerTott__Rectangle(soap, &this->tt__Exposure20::Window);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MinExposureTime);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MaxExposureTime);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MinGain);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MaxGain);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MinIris);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MaxIris);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::ExposureTime);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::Gain);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::Iris);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Exposure20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Exposure20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Exposure20(struct soap *soap, const char *tag, int id, const tt__Exposure20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Exposure20), type ? type : "tt:Exposure20"))
		return soap->error;
	if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, &a->tt__Exposure20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__ExposurePriority(soap, "tt:Priority", -1, &a->tt__Exposure20::Priority, ""))
		return soap->error;
	if (soap_out_PointerTott__Rectangle(soap, "tt:Window", -1, &a->tt__Exposure20::Window, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinExposureTime", -1, &a->tt__Exposure20::MinExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxExposureTime", -1, &a->tt__Exposure20::MaxExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinGain", -1, &a->tt__Exposure20::MinGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxGain", -1, &a->tt__Exposure20::MaxGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinIris", -1, &a->tt__Exposure20::MinIris, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxIris", -1, &a->tt__Exposure20::MaxIris, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ExposureTime", -1, &a->tt__Exposure20::ExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Gain", -1, &a->tt__Exposure20::Gain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Iris", -1, &a->tt__Exposure20::Iris, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Exposure20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Exposure20(soap, tag, this, type);
}

SOAP_FMAC3 tt__Exposure20 * SOAP_FMAC4 soap_in_tt__Exposure20(struct soap *soap, const char *tag, tt__Exposure20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Exposure20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure20, sizeof(tt__Exposure20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Exposure20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Exposure20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Priority1 = 1;
	size_t soap_flag_Window1 = 1;
	size_t soap_flag_MinExposureTime1 = 1;
	size_t soap_flag_MaxExposureTime1 = 1;
	size_t soap_flag_MinGain1 = 1;
	size_t soap_flag_MaxGain1 = 1;
	size_t soap_flag_MinIris1 = 1;
	size_t soap_flag_MaxIris1 = 1;
	size_t soap_flag_ExposureTime1 = 1;
	size_t soap_flag_Gain1 = 1;
	size_t soap_flag_Iris1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ExposureMode(soap, "tt:Mode", &a->tt__Exposure20::Mode, "tt:ExposureMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Priority1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ExposurePriority(soap, "tt:Priority", &a->tt__Exposure20::Priority, "tt:ExposurePriority"))
				{	soap_flag_Priority1--;
					continue;
				}
			}
			if (soap_flag_Window1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Rectangle(soap, "tt:Window", &a->tt__Exposure20::Window, "tt:Rectangle"))
				{	soap_flag_Window1--;
					continue;
				}
			}
			if (soap_flag_MinExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MinExposureTime", &a->tt__Exposure20::MinExposureTime, "xsd:float"))
				{	soap_flag_MinExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MaxExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MaxExposureTime", &a->tt__Exposure20::MaxExposureTime, "xsd:float"))
				{	soap_flag_MaxExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MinGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MinGain", &a->tt__Exposure20::MinGain, "xsd:float"))
				{	soap_flag_MinGain1--;
					continue;
				}
			}
			if (soap_flag_MaxGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MaxGain", &a->tt__Exposure20::MaxGain, "xsd:float"))
				{	soap_flag_MaxGain1--;
					continue;
				}
			}
			if (soap_flag_MinIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MinIris", &a->tt__Exposure20::MinIris, "xsd:float"))
				{	soap_flag_MinIris1--;
					continue;
				}
			}
			if (soap_flag_MaxIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MaxIris", &a->tt__Exposure20::MaxIris, "xsd:float"))
				{	soap_flag_MaxIris1--;
					continue;
				}
			}
			if (soap_flag_ExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:ExposureTime", &a->tt__Exposure20::ExposureTime, "xsd:float"))
				{	soap_flag_ExposureTime1--;
					continue;
				}
			}
			if (soap_flag_Gain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Gain", &a->tt__Exposure20::Gain, "xsd:float"))
				{	soap_flag_Gain1--;
					continue;
				}
			}
			if (soap_flag_Iris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Iris", &a->tt__Exposure20::Iris, "xsd:float"))
				{	soap_flag_Iris1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Exposure20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure20, SOAP_TYPE_tt__Exposure20, sizeof(tt__Exposure20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Exposure20 * SOAP_FMAC2 imageing_instantiate_tt__Exposure20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Exposure20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Exposure20 *p;
	size_t k = sizeof(tt__Exposure20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Exposure20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Exposure20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Exposure20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Exposure20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Exposure20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Exposure20(soap, tag ? tag : "tt:Exposure20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Exposure20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Exposure20(soap, this, tag, type);
}

SOAP_FMAC3 tt__Exposure20 * SOAP_FMAC4 soap_get_tt__Exposure20(struct soap *soap, tt__Exposure20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Exposure20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BacklightCompensation20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__BacklightCompensationMode(soap, &this->tt__BacklightCompensation20::Mode);
	this->tt__BacklightCompensation20::Level = NULL;
}

void tt__BacklightCompensation20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__BacklightCompensation20::Level);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__BacklightCompensation20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensation20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensation20(struct soap *soap, const char *tag, int id, const tt__BacklightCompensation20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensation20), type ? type : "tt:BacklightCompensation20"))
		return soap->error;
	if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, &a->tt__BacklightCompensation20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__BacklightCompensation20::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BacklightCompensation20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BacklightCompensation20(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensation20 * SOAP_FMAC4 soap_in_tt__BacklightCompensation20(struct soap *soap, const char *tag, tt__BacklightCompensation20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BacklightCompensation20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(tt__BacklightCompensation20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BacklightCompensation20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BacklightCompensation20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", &a->tt__BacklightCompensation20::Mode, "tt:BacklightCompensationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__BacklightCompensation20::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BacklightCompensation20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation20, SOAP_TYPE_tt__BacklightCompensation20, sizeof(tt__BacklightCompensation20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BacklightCompensation20 * SOAP_FMAC2 imageing_instantiate_tt__BacklightCompensation20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__BacklightCompensation20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BacklightCompensation20 *p;
	size_t k = sizeof(tt__BacklightCompensation20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BacklightCompensation20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BacklightCompensation20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BacklightCompensation20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BacklightCompensation20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BacklightCompensation20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BacklightCompensation20(soap, tag ? tag : "tt:BacklightCompensation20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensation20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensation20(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensation20 * SOAP_FMAC4 soap_get_tt__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensation20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WideDynamicRange20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__WideDynamicMode(soap, &this->tt__WideDynamicRange20::Mode);
	this->tt__WideDynamicRange20::Level = NULL;
}

void tt__WideDynamicRange20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__WideDynamicRange20::Level);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WideDynamicRange20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicRange20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRange20(struct soap *soap, const char *tag, int id, const tt__WideDynamicRange20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRange20), type ? type : "tt:WideDynamicRange20"))
		return soap->error;
	if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, &a->tt__WideDynamicRange20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__WideDynamicRange20::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WideDynamicRange20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WideDynamicRange20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicRange20 * SOAP_FMAC4 soap_in_tt__WideDynamicRange20(struct soap *soap, const char *tag, tt__WideDynamicRange20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WideDynamicRange20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(tt__WideDynamicRange20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WideDynamicRange20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WideDynamicRange20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", &a->tt__WideDynamicRange20::Mode, "tt:WideDynamicMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__WideDynamicRange20::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WideDynamicRange20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange20, SOAP_TYPE_tt__WideDynamicRange20, sizeof(tt__WideDynamicRange20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WideDynamicRange20 * SOAP_FMAC2 imageing_instantiate_tt__WideDynamicRange20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__WideDynamicRange20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WideDynamicRange20 *p;
	size_t k = sizeof(tt__WideDynamicRange20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WideDynamicRange20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WideDynamicRange20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WideDynamicRange20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WideDynamicRange20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WideDynamicRange20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WideDynamicRange20(soap, tag ? tag : "tt:WideDynamicRange20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicRange20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicRange20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicRange20 * SOAP_FMAC4 soap_get_tt__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRange20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterAutoAdjustmentExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__IrCutFilterAutoAdjustmentExtension::__any);
}

void tt__IrCutFilterAutoAdjustmentExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__IrCutFilterAutoAdjustmentExtension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IrCutFilterAutoAdjustmentExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, int id, const tt__IrCutFilterAutoAdjustmentExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension), type ? type : "tt:IrCutFilterAutoAdjustmentExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__IrCutFilterAutoAdjustmentExtension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IrCutFilterAutoAdjustmentExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IrCutFilterAutoAdjustmentExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(tt__IrCutFilterAutoAdjustmentExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IrCutFilterAutoAdjustmentExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__IrCutFilterAutoAdjustmentExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustmentExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(tt__IrCutFilterAutoAdjustmentExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__IrCutFilterAutoAdjustmentExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterAutoAdjustmentExtension *p;
	size_t k = sizeof(tt__IrCutFilterAutoAdjustmentExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterAutoAdjustmentExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterAutoAdjustmentExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterAutoAdjustmentExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterAutoAdjustmentExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterAutoAdjustmentExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterAutoAdjustmentExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterAutoAdjustment::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__IrCutFilterAutoAdjustment::BoundaryType);
	this->tt__IrCutFilterAutoAdjustment::BoundaryOffset = NULL;
	this->tt__IrCutFilterAutoAdjustment::ResponseTime = NULL;
	this->tt__IrCutFilterAutoAdjustment::Extension = NULL;
	this->tt__IrCutFilterAutoAdjustment::__anyAttribute = NULL;
}

void tt__IrCutFilterAutoAdjustment::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IrCutFilterAutoAdjustment::BoundaryType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__IrCutFilterAutoAdjustment::BoundaryType);
	soap_serialize_PointerTofloat(soap, &this->tt__IrCutFilterAutoAdjustment::BoundaryOffset);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__IrCutFilterAutoAdjustment::ResponseTime);
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, &this->tt__IrCutFilterAutoAdjustment::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IrCutFilterAutoAdjustment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterAutoAdjustment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, int id, const tt__IrCutFilterAutoAdjustment *a, const char *type)
{
	if (((tt__IrCutFilterAutoAdjustment*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__IrCutFilterAutoAdjustment*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment), type ? type : "tt:IrCutFilterAutoAdjustment"))
		return soap->error;
	if (soap_out_std__string(soap, "tt:BoundaryType", -1, &a->tt__IrCutFilterAutoAdjustment::BoundaryType, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:BoundaryOffset", -1, &a->tt__IrCutFilterAutoAdjustment::BoundaryOffset, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:ResponseTime", -1, &a->tt__IrCutFilterAutoAdjustment::ResponseTime, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, "tt:Extension", -1, &a->tt__IrCutFilterAutoAdjustment::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IrCutFilterAutoAdjustment::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterAutoAdjustment(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustment * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IrCutFilterAutoAdjustment*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(tt__IrCutFilterAutoAdjustment), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterAutoAdjustment)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IrCutFilterAutoAdjustment *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__IrCutFilterAutoAdjustment*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BoundaryType1 = 1;
	size_t soap_flag_BoundaryOffset1 = 1;
	size_t soap_flag_ResponseTime1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundaryType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:BoundaryType", &a->tt__IrCutFilterAutoAdjustment::BoundaryType, "xsd:string"))
				{	soap_flag_BoundaryType1--;
					continue;
				}
			}
			if (soap_flag_BoundaryOffset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:BoundaryOffset", &a->tt__IrCutFilterAutoAdjustment::BoundaryOffset, "xsd:float"))
				{	soap_flag_BoundaryOffset1--;
					continue;
				}
			}
			if (soap_flag_ResponseTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "tt:ResponseTime", &a->tt__IrCutFilterAutoAdjustment::ResponseTime, "xsd:duration"))
				{	soap_flag_ResponseTime1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, "tt:Extension", &a->tt__IrCutFilterAutoAdjustment::Extension, "tt:IrCutFilterAutoAdjustmentExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BoundaryType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(tt__IrCutFilterAutoAdjustment), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustment * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterAutoAdjustment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__IrCutFilterAutoAdjustment(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterAutoAdjustment *p;
	size_t k = sizeof(tt__IrCutFilterAutoAdjustment);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterAutoAdjustment);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterAutoAdjustment, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterAutoAdjustment location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterAutoAdjustment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterAutoAdjustment(soap, tag ? tag : "tt:IrCutFilterAutoAdjustment", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterAutoAdjustment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterAutoAdjustment(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustment * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilizationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__ImageStabilizationExtension::__any);
}

void tt__ImageStabilizationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__ImageStabilizationExtension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImageStabilizationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilizationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationExtension(struct soap *soap, const char *tag, int id, const tt__ImageStabilizationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationExtension), type ? type : "tt:ImageStabilizationExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__ImageStabilizationExtension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImageStabilizationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilizationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilizationExtension * SOAP_FMAC4 soap_in_tt__ImageStabilizationExtension(struct soap *soap, const char *tag, tt__ImageStabilizationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImageStabilizationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(tt__ImageStabilizationExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilizationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImageStabilizationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__ImageStabilizationExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImageStabilizationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationExtension, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(tt__ImageStabilizationExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationExtension * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilizationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImageStabilizationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilizationExtension *p;
	size_t k = sizeof(tt__ImageStabilizationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilizationExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilizationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilizationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilizationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilizationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilizationExtension(soap, tag ? tag : "tt:ImageStabilizationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilizationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilizationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilizationExtension * SOAP_FMAC4 soap_get_tt__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilization::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ImageStabilizationMode(soap, &this->tt__ImageStabilization::Mode);
	this->tt__ImageStabilization::Level = NULL;
	this->tt__ImageStabilization::Extension = NULL;
	this->tt__ImageStabilization::__anyAttribute = NULL;
}

void tt__ImageStabilization::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__ImageStabilization::Level);
	soap_serialize_PointerTott__ImageStabilizationExtension(soap, &this->tt__ImageStabilization::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImageStabilization::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilization(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilization(struct soap *soap, const char *tag, int id, const tt__ImageStabilization *a, const char *type)
{
	if (((tt__ImageStabilization*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__ImageStabilization*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilization), type ? type : "tt:ImageStabilization"))
		return soap->error;
	if (soap_out_tt__ImageStabilizationMode(soap, "tt:Mode", -1, &a->tt__ImageStabilization::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__ImageStabilization::Level, ""))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationExtension(soap, "tt:Extension", -1, &a->tt__ImageStabilization::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImageStabilization::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilization(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilization * SOAP_FMAC4 soap_in_tt__ImageStabilization(struct soap *soap, const char *tag, tt__ImageStabilization *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImageStabilization*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilization, sizeof(tt__ImageStabilization), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilization)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImageStabilization *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__ImageStabilization*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ImageStabilizationMode(soap, "tt:Mode", &a->tt__ImageStabilization::Mode, "tt:ImageStabilizationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__ImageStabilization::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilizationExtension(soap, "tt:Extension", &a->tt__ImageStabilization::Extension, "tt:ImageStabilizationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ImageStabilization *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilization, SOAP_TYPE_tt__ImageStabilization, sizeof(tt__ImageStabilization), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilization * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilization(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImageStabilization(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilization *p;
	size_t k = sizeof(tt__ImageStabilization);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilization, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilization);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilization, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilization location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilization::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilization(soap, tag ? tag : "tt:ImageStabilization", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilization::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilization(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilization * SOAP_FMAC4 soap_get_tt__ImageStabilization(struct soap *soap, tt__ImageStabilization *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettingsExtension204::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__ImagingSettingsExtension204::__any);
}

void tt__ImagingSettingsExtension204::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__ImagingSettingsExtension204::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingSettingsExtension204::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension204(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension204(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension204 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension204), type ? type : "tt:ImagingSettingsExtension204"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__ImagingSettingsExtension204::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension204::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension204(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension204 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension204(struct soap *soap, const char *tag, tt__ImagingSettingsExtension204 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension204*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension204, sizeof(tt__ImagingSettingsExtension204), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension204)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettingsExtension204 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__ImagingSettingsExtension204::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension204 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension204, SOAP_TYPE_tt__ImagingSettingsExtension204, sizeof(tt__ImagingSettingsExtension204), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension204 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettingsExtension204(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImagingSettingsExtension204(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension204 *p;
	size_t k = sizeof(tt__ImagingSettingsExtension204);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension204, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension204);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension204, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension204 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension204::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension204(soap, tag ? tag : "tt:ImagingSettingsExtension204", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension204::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension204(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension204 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension204(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettingsExtension203::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingSettingsExtension203::ToneCompensation = NULL;
	this->tt__ImagingSettingsExtension203::Defogging = NULL;
	this->tt__ImagingSettingsExtension203::NoiseReduction = NULL;
	this->tt__ImagingSettingsExtension203::Extension = NULL;
}

void tt__ImagingSettingsExtension203::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ToneCompensation(soap, &this->tt__ImagingSettingsExtension203::ToneCompensation);
	soap_serialize_PointerTott__Defogging(soap, &this->tt__ImagingSettingsExtension203::Defogging);
	soap_serialize_PointerTott__NoiseReduction(soap, &this->tt__ImagingSettingsExtension203::NoiseReduction);
	soap_serialize_PointerTott__ImagingSettingsExtension204(soap, &this->tt__ImagingSettingsExtension203::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingSettingsExtension203::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension203(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension203(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension203 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension203), type ? type : "tt:ImagingSettingsExtension203"))
		return soap->error;
	if (soap_out_PointerTott__ToneCompensation(soap, "tt:ToneCompensation", -1, &a->tt__ImagingSettingsExtension203::ToneCompensation, ""))
		return soap->error;
	if (soap_out_PointerTott__Defogging(soap, "tt:Defogging", -1, &a->tt__ImagingSettingsExtension203::Defogging, ""))
		return soap->error;
	if (soap_out_PointerTott__NoiseReduction(soap, "tt:NoiseReduction", -1, &a->tt__ImagingSettingsExtension203::NoiseReduction, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension204(soap, "tt:Extension", -1, &a->tt__ImagingSettingsExtension203::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension203::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension203(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension203 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension203(struct soap *soap, const char *tag, tt__ImagingSettingsExtension203 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension203*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(tt__ImagingSettingsExtension203), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension203)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettingsExtension203 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ToneCompensation1 = 1;
	size_t soap_flag_Defogging1 = 1;
	size_t soap_flag_NoiseReduction1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToneCompensation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ToneCompensation(soap, "tt:ToneCompensation", &a->tt__ImagingSettingsExtension203::ToneCompensation, "tt:ToneCompensation"))
				{	soap_flag_ToneCompensation1--;
					continue;
				}
			}
			if (soap_flag_Defogging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Defogging(soap, "tt:Defogging", &a->tt__ImagingSettingsExtension203::Defogging, "tt:Defogging"))
				{	soap_flag_Defogging1--;
					continue;
				}
			}
			if (soap_flag_NoiseReduction1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NoiseReduction(soap, "tt:NoiseReduction", &a->tt__ImagingSettingsExtension203::NoiseReduction, "tt:NoiseReduction"))
				{	soap_flag_NoiseReduction1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension204(soap, "tt:Extension", &a->tt__ImagingSettingsExtension203::Extension, "tt:ImagingSettingsExtension204"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension203 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension203, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(tt__ImagingSettingsExtension203), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension203 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettingsExtension203(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImagingSettingsExtension203(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension203 *p;
	size_t k = sizeof(tt__ImagingSettingsExtension203);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension203, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension203);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension203, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension203 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension203::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension203(soap, tag ? tag : "tt:ImagingSettingsExtension203", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension203::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension203(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension203 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension203(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettingsExtension202::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, &this->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment);
	this->tt__ImagingSettingsExtension202::Extension = NULL;
}

void tt__ImagingSettingsExtension202::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, &this->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment);
	soap_serialize_PointerTott__ImagingSettingsExtension203(soap, &this->tt__ImagingSettingsExtension202::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingSettingsExtension202::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension202(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension202(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension202 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension202), type ? type : "tt:ImagingSettingsExtension202"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, "tt:IrCutFilterAutoAdjustment", -1, &a->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension203(soap, "tt:Extension", -1, &a->tt__ImagingSettingsExtension202::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension202::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension202(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension202 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension202(struct soap *soap, const char *tag, tt__ImagingSettingsExtension202 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension202*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(tt__ImagingSettingsExtension202), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension202)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettingsExtension202 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, "tt:IrCutFilterAutoAdjustment", &a->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment, "tt:IrCutFilterAutoAdjustment"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension203(soap, "tt:Extension", &a->tt__ImagingSettingsExtension202::Extension, "tt:ImagingSettingsExtension203"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension202 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension202, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(tt__ImagingSettingsExtension202), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension202 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettingsExtension202(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImagingSettingsExtension202(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension202 *p;
	size_t k = sizeof(tt__ImagingSettingsExtension202);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension202, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension202);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension202, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension202 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension202::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension202(soap, tag ? tag : "tt:ImagingSettingsExtension202", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension202::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension202(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension202 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension202(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettingsExtension20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__ImagingSettingsExtension20::__any);
	this->tt__ImagingSettingsExtension20::ImageStabilization = NULL;
	this->tt__ImagingSettingsExtension20::Extension = NULL;
}

void tt__ImagingSettingsExtension20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__ImagingSettingsExtension20::__any);
	soap_serialize_PointerTott__ImageStabilization(soap, &this->tt__ImagingSettingsExtension20::ImageStabilization);
	soap_serialize_PointerTott__ImagingSettingsExtension202(soap, &this->tt__ImagingSettingsExtension20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingSettingsExtension20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension20), type ? type : "tt:ImagingSettingsExtension20"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__ImagingSettingsExtension20::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilization(soap, "tt:ImageStabilization", -1, &a->tt__ImagingSettingsExtension20::ImageStabilization, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension202(soap, "tt:Extension", -1, &a->tt__ImagingSettingsExtension20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, tt__ImagingSettingsExtension20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(tt__ImagingSettingsExtension20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettingsExtension20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ImageStabilization1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImageStabilization1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilization(soap, "tt:ImageStabilization", &a->tt__ImagingSettingsExtension20::ImageStabilization, "tt:ImageStabilization"))
				{	soap_flag_ImageStabilization1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension202(soap, "tt:Extension", &a->tt__ImagingSettingsExtension20::Extension, "tt:ImagingSettingsExtension202"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__ImagingSettingsExtension20::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension20, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(tt__ImagingSettingsExtension20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension20 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettingsExtension20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImagingSettingsExtension20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension20 *p;
	size_t k = sizeof(tt__ImagingSettingsExtension20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension20(soap, tag ? tag : "tt:ImagingSettingsExtension20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettings20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingSettings20::BacklightCompensation = NULL;
	this->tt__ImagingSettings20::Brightness = NULL;
	this->tt__ImagingSettings20::ColorSaturation = NULL;
	this->tt__ImagingSettings20::Contrast = NULL;
	this->tt__ImagingSettings20::Exposure = NULL;
	this->tt__ImagingSettings20::Focus = NULL;
	this->tt__ImagingSettings20::IrCutFilter = NULL;
	this->tt__ImagingSettings20::Sharpness = NULL;
	this->tt__ImagingSettings20::WideDynamicRange = NULL;
	this->tt__ImagingSettings20::WhiteBalance = NULL;
	this->tt__ImagingSettings20::Extension = NULL;
	this->tt__ImagingSettings20::__anyAttribute = NULL;
}

void tt__ImagingSettings20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensation20(soap, &this->tt__ImagingSettings20::BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::Brightness);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::ColorSaturation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::Contrast);
	soap_serialize_PointerTott__Exposure20(soap, &this->tt__ImagingSettings20::Exposure);
	soap_serialize_PointerTott__FocusConfiguration20(soap, &this->tt__ImagingSettings20::Focus);
	soap_serialize_PointerTott__IrCutFilterMode(soap, &this->tt__ImagingSettings20::IrCutFilter);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::Sharpness);
	soap_serialize_PointerTott__WideDynamicRange20(soap, &this->tt__ImagingSettings20::WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalance20(soap, &this->tt__ImagingSettings20::WhiteBalance);
	soap_serialize_PointerTott__ImagingSettingsExtension20(soap, &this->tt__ImagingSettings20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingSettings20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettings20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettings20(struct soap *soap, const char *tag, int id, const tt__ImagingSettings20 *a, const char *type)
{
	if (((tt__ImagingSettings20*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__ImagingSettings20*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettings20), type ? type : "tt:ImagingSettings20"))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", -1, &a->tt__ImagingSettings20::BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Brightness", -1, &a->tt__ImagingSettings20::Brightness, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ColorSaturation", -1, &a->tt__ImagingSettings20::ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Contrast", -1, &a->tt__ImagingSettings20::Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__Exposure20(soap, "tt:Exposure", -1, &a->tt__ImagingSettings20::Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration20(soap, "tt:Focus", -1, &a->tt__ImagingSettings20::Focus, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", -1, &a->tt__ImagingSettings20::IrCutFilter, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Sharpness", -1, &a->tt__ImagingSettings20::Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", -1, &a->tt__ImagingSettings20::WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", -1, &a->tt__ImagingSettings20::WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", -1, &a->tt__ImagingSettings20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettings20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettings20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettings20 * SOAP_FMAC4 soap_in_tt__ImagingSettings20(struct soap *soap, const char *tag, tt__ImagingSettings20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettings20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings20, sizeof(tt__ImagingSettings20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettings20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettings20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__ImagingSettings20*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BacklightCompensation1 = 1;
	size_t soap_flag_Brightness1 = 1;
	size_t soap_flag_ColorSaturation1 = 1;
	size_t soap_flag_Contrast1 = 1;
	size_t soap_flag_Exposure1 = 1;
	size_t soap_flag_Focus1 = 1;
	size_t soap_flag_IrCutFilter1 = 1;
	size_t soap_flag_Sharpness1 = 1;
	size_t soap_flag_WideDynamicRange1 = 1;
	size_t soap_flag_WhiteBalance1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", &a->tt__ImagingSettings20::BacklightCompensation, "tt:BacklightCompensation20"))
				{	soap_flag_BacklightCompensation1--;
					continue;
				}
			}
			if (soap_flag_Brightness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Brightness", &a->tt__ImagingSettings20::Brightness, "xsd:float"))
				{	soap_flag_Brightness1--;
					continue;
				}
			}
			if (soap_flag_ColorSaturation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:ColorSaturation", &a->tt__ImagingSettings20::ColorSaturation, "xsd:float"))
				{	soap_flag_ColorSaturation1--;
					continue;
				}
			}
			if (soap_flag_Contrast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Contrast", &a->tt__ImagingSettings20::Contrast, "xsd:float"))
				{	soap_flag_Contrast1--;
					continue;
				}
			}
			if (soap_flag_Exposure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Exposure20(soap, "tt:Exposure", &a->tt__ImagingSettings20::Exposure, "tt:Exposure20"))
				{	soap_flag_Exposure1--;
					continue;
				}
			}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusConfiguration20(soap, "tt:Focus", &a->tt__ImagingSettings20::Focus, "tt:FocusConfiguration20"))
				{	soap_flag_Focus1--;
					continue;
				}
			}
			if (soap_flag_IrCutFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", &a->tt__ImagingSettings20::IrCutFilter, "tt:IrCutFilterMode"))
				{	soap_flag_IrCutFilter1--;
					continue;
				}
			}
			if (soap_flag_Sharpness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Sharpness", &a->tt__ImagingSettings20::Sharpness, "xsd:float"))
				{	soap_flag_Sharpness1--;
					continue;
				}
			}
			if (soap_flag_WideDynamicRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", &a->tt__ImagingSettings20::WideDynamicRange, "tt:WideDynamicRange20"))
				{	soap_flag_WideDynamicRange1--;
					continue;
				}
			}
			if (soap_flag_WhiteBalance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", &a->tt__ImagingSettings20::WhiteBalance, "tt:WhiteBalance20"))
				{	soap_flag_WhiteBalance1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", &a->tt__ImagingSettings20::Extension, "tt:ImagingSettingsExtension20"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettings20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings20, SOAP_TYPE_tt__ImagingSettings20, sizeof(tt__ImagingSettings20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettings20 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettings20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImagingSettings20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettings20 *p;
	size_t k = sizeof(tt__ImagingSettings20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettings20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettings20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettings20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettings20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettings20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettings20(soap, tag ? tag : "tt:ImagingSettings20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettings20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettings20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettings20 * SOAP_FMAC4 soap_get_tt__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettings20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusStatus20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__FocusStatus20Extension::__any);
}

void tt__FocusStatus20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__FocusStatus20Extension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusStatus20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusStatus20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20Extension(struct soap *soap, const char *tag, int id, const tt__FocusStatus20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus20Extension), type ? type : "tt:FocusStatus20Extension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__FocusStatus20Extension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusStatus20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusStatus20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusStatus20Extension * SOAP_FMAC4 soap_in_tt__FocusStatus20Extension(struct soap *soap, const char *tag, tt__FocusStatus20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusStatus20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(tt__FocusStatus20Extension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusStatus20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusStatus20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__FocusStatus20Extension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus20Extension, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(tt__FocusStatus20Extension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusStatus20Extension * SOAP_FMAC2 imageing_instantiate_tt__FocusStatus20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__FocusStatus20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusStatus20Extension *p;
	size_t k = sizeof(tt__FocusStatus20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusStatus20Extension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusStatus20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusStatus20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusStatus20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusStatus20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusStatus20Extension(soap, tag ? tag : "tt:FocusStatus20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusStatus20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusStatus20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusStatus20Extension * SOAP_FMAC4 soap_get_tt__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusStatus20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__FocusStatus20::Position);
	soap_default_tt__MoveStatus(soap, &this->tt__FocusStatus20::MoveStatus);
	this->tt__FocusStatus20::Error = NULL;
	this->tt__FocusStatus20::Extension = NULL;
	this->tt__FocusStatus20::__anyAttribute = NULL;
}

void tt__FocusStatus20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__FocusStatus20::Position, SOAP_TYPE_float);
	soap_serialize_PointerTostd__string(soap, &this->tt__FocusStatus20::Error);
	soap_serialize_PointerTott__FocusStatus20Extension(soap, &this->tt__FocusStatus20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusStatus20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusStatus20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20(struct soap *soap, const char *tag, int id, const tt__FocusStatus20 *a, const char *type)
{
	if (((tt__FocusStatus20*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__FocusStatus20*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus20), type ? type : "tt:FocusStatus20"))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &a->tt__FocusStatus20::Position, ""))
		return soap->error;
	if (soap_out_tt__MoveStatus(soap, "tt:MoveStatus", -1, &a->tt__FocusStatus20::MoveStatus, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Error", -1, &a->tt__FocusStatus20::Error, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusStatus20Extension(soap, "tt:Extension", -1, &a->tt__FocusStatus20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusStatus20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusStatus20(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusStatus20 * SOAP_FMAC4 soap_in_tt__FocusStatus20(struct soap *soap, const char *tag, tt__FocusStatus20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusStatus20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20, sizeof(tt__FocusStatus20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusStatus20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusStatus20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__FocusStatus20*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_MoveStatus1 = 1;
	size_t soap_flag_Error1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Position", &a->tt__FocusStatus20::Position, "xsd:float"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_MoveStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__MoveStatus(soap, "tt:MoveStatus", &a->tt__FocusStatus20::MoveStatus, "tt:MoveStatus"))
				{	soap_flag_MoveStatus1--;
					continue;
				}
			}
			if (soap_flag_Error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Error", &a->tt__FocusStatus20::Error, "xsd:string"))
				{	soap_flag_Error1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusStatus20Extension(soap, "tt:Extension", &a->tt__FocusStatus20::Extension, "tt:FocusStatus20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position1 > 0 || soap_flag_MoveStatus1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FocusStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus20, SOAP_TYPE_tt__FocusStatus20, sizeof(tt__FocusStatus20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusStatus20 * SOAP_FMAC2 imageing_instantiate_tt__FocusStatus20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__FocusStatus20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusStatus20 *p;
	size_t k = sizeof(tt__FocusStatus20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusStatus20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusStatus20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusStatus20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusStatus20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusStatus20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusStatus20(soap, tag ? tag : "tt:FocusStatus20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusStatus20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusStatus20(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusStatus20 * SOAP_FMAC4 soap_get_tt__FocusStatus20(struct soap *soap, tt__FocusStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingStatus20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__ImagingStatus20Extension::__any);
}

void tt__ImagingStatus20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__ImagingStatus20Extension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingStatus20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingStatus20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20Extension(struct soap *soap, const char *tag, int id, const tt__ImagingStatus20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus20Extension), type ? type : "tt:ImagingStatus20Extension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__ImagingStatus20Extension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingStatus20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingStatus20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingStatus20Extension * SOAP_FMAC4 soap_in_tt__ImagingStatus20Extension(struct soap *soap, const char *tag, tt__ImagingStatus20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingStatus20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(tt__ImagingStatus20Extension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingStatus20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingStatus20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__ImagingStatus20Extension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus20Extension, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(tt__ImagingStatus20Extension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingStatus20Extension * SOAP_FMAC2 imageing_instantiate_tt__ImagingStatus20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImagingStatus20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingStatus20Extension *p;
	size_t k = sizeof(tt__ImagingStatus20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingStatus20Extension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingStatus20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingStatus20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingStatus20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingStatus20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingStatus20Extension(soap, tag ? tag : "tt:ImagingStatus20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingStatus20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingStatus20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingStatus20Extension * SOAP_FMAC4 soap_get_tt__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingStatus20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingStatus20::FocusStatus20 = NULL;
	this->tt__ImagingStatus20::Extension = NULL;
	this->tt__ImagingStatus20::__anyAttribute = NULL;
}

void tt__ImagingStatus20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FocusStatus20(soap, &this->tt__ImagingStatus20::FocusStatus20);
	soap_serialize_PointerTott__ImagingStatus20Extension(soap, &this->tt__ImagingStatus20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingStatus20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingStatus20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20(struct soap *soap, const char *tag, int id, const tt__ImagingStatus20 *a, const char *type)
{
	if (((tt__ImagingStatus20*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__ImagingStatus20*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus20), type ? type : "tt:ImagingStatus20"))
		return soap->error;
	if (soap_out_PointerTott__FocusStatus20(soap, "tt:FocusStatus20", -1, &a->tt__ImagingStatus20::FocusStatus20, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingStatus20Extension(soap, "tt:Extension", -1, &a->tt__ImagingStatus20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingStatus20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingStatus20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingStatus20 * SOAP_FMAC4 soap_in_tt__ImagingStatus20(struct soap *soap, const char *tag, tt__ImagingStatus20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingStatus20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20, sizeof(tt__ImagingStatus20), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingStatus20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingStatus20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__ImagingStatus20*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_FocusStatus201 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FocusStatus201 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusStatus20(soap, "tt:FocusStatus20", &a->tt__ImagingStatus20::FocusStatus20, "tt:FocusStatus20"))
				{	soap_flag_FocusStatus201--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingStatus20Extension(soap, "tt:Extension", &a->tt__ImagingStatus20::Extension, "tt:ImagingStatus20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus20, SOAP_TYPE_tt__ImagingStatus20, sizeof(tt__ImagingStatus20), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingStatus20 * SOAP_FMAC2 imageing_instantiate_tt__ImagingStatus20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ImagingStatus20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingStatus20 *p;
	size_t k = sizeof(tt__ImagingStatus20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingStatus20, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingStatus20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingStatus20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingStatus20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingStatus20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingStatus20(soap, tag ? tag : "tt:ImagingStatus20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingStatus20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingStatus20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingStatus20 * SOAP_FMAC4 soap_get_tt__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ContinuousFocusOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ContinuousFocusOptions::Speed = NULL;
}

void tt__ContinuousFocusOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ContinuousFocusOptions::Speed);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ContinuousFocusOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ContinuousFocusOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocusOptions(struct soap *soap, const char *tag, int id, const tt__ContinuousFocusOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ContinuousFocusOptions), type ? type : "tt:ContinuousFocusOptions"))
		return soap->error;
	if (!a->tt__ContinuousFocusOptions::Speed)
	{	if (soap_element_empty(soap, "tt:Speed", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->tt__ContinuousFocusOptions::Speed, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ContinuousFocusOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ContinuousFocusOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ContinuousFocusOptions * SOAP_FMAC4 soap_in_tt__ContinuousFocusOptions(struct soap *soap, const char *tag, tt__ContinuousFocusOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ContinuousFocusOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(tt__ContinuousFocusOptions), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ContinuousFocusOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ContinuousFocusOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->tt__ContinuousFocusOptions::Speed, "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__ContinuousFocusOptions::Speed))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ContinuousFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocusOptions, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(tt__ContinuousFocusOptions), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ContinuousFocusOptions * SOAP_FMAC2 imageing_instantiate_tt__ContinuousFocusOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ContinuousFocusOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ContinuousFocusOptions *p;
	size_t k = sizeof(tt__ContinuousFocusOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ContinuousFocusOptions, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ContinuousFocusOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ContinuousFocusOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ContinuousFocusOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ContinuousFocusOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ContinuousFocusOptions(soap, tag ? tag : "tt:ContinuousFocusOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ContinuousFocusOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ContinuousFocusOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ContinuousFocusOptions * SOAP_FMAC4 soap_get_tt__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ContinuousFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AbsoluteFocusOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__AbsoluteFocusOptions::Position = NULL;
	this->tt__AbsoluteFocusOptions::Speed = NULL;
}

void tt__AbsoluteFocusOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__AbsoluteFocusOptions::Position);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__AbsoluteFocusOptions::Speed);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AbsoluteFocusOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AbsoluteFocusOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocusOptions(struct soap *soap, const char *tag, int id, const tt__AbsoluteFocusOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AbsoluteFocusOptions), type ? type : "tt:AbsoluteFocusOptions"))
		return soap->error;
	if (!a->tt__AbsoluteFocusOptions::Position)
	{	if (soap_element_empty(soap, "tt:Position", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Position", -1, &a->tt__AbsoluteFocusOptions::Position, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->tt__AbsoluteFocusOptions::Speed, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AbsoluteFocusOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AbsoluteFocusOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_in_tt__AbsoluteFocusOptions(struct soap *soap, const char *tag, tt__AbsoluteFocusOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AbsoluteFocusOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(tt__AbsoluteFocusOptions), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AbsoluteFocusOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AbsoluteFocusOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Position", &a->tt__AbsoluteFocusOptions::Position, "tt:FloatRange"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->tt__AbsoluteFocusOptions::Speed, "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__AbsoluteFocusOptions::Position))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AbsoluteFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocusOptions, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(tt__AbsoluteFocusOptions), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AbsoluteFocusOptions * SOAP_FMAC2 imageing_instantiate_tt__AbsoluteFocusOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__AbsoluteFocusOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AbsoluteFocusOptions *p;
	size_t k = sizeof(tt__AbsoluteFocusOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AbsoluteFocusOptions, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AbsoluteFocusOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AbsoluteFocusOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AbsoluteFocusOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AbsoluteFocusOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AbsoluteFocusOptions(soap, tag ? tag : "tt:AbsoluteFocusOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AbsoluteFocusOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AbsoluteFocusOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_get_tt__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AbsoluteFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ContinuousFocus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__ContinuousFocus::Speed);
}

void tt__ContinuousFocus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ContinuousFocus::Speed, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ContinuousFocus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ContinuousFocus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocus(struct soap *soap, const char *tag, int id, const tt__ContinuousFocus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ContinuousFocus), type ? type : "tt:ContinuousFocus"))
		return soap->error;
	if (soap_out_float(soap, "tt:Speed", -1, &a->tt__ContinuousFocus::Speed, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ContinuousFocus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ContinuousFocus(soap, tag, this, type);
}

SOAP_FMAC3 tt__ContinuousFocus * SOAP_FMAC4 soap_in_tt__ContinuousFocus(struct soap *soap, const char *tag, tt__ContinuousFocus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ContinuousFocus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocus, sizeof(tt__ContinuousFocus), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ContinuousFocus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ContinuousFocus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Speed", &a->tt__ContinuousFocus::Speed, "xsd:float"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Speed1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ContinuousFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocus, SOAP_TYPE_tt__ContinuousFocus, sizeof(tt__ContinuousFocus), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ContinuousFocus * SOAP_FMAC2 imageing_instantiate_tt__ContinuousFocus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ContinuousFocus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ContinuousFocus *p;
	size_t k = sizeof(tt__ContinuousFocus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ContinuousFocus, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ContinuousFocus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ContinuousFocus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ContinuousFocus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ContinuousFocus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ContinuousFocus(soap, tag ? tag : "tt:ContinuousFocus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ContinuousFocus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ContinuousFocus(soap, this, tag, type);
}

SOAP_FMAC3 tt__ContinuousFocus * SOAP_FMAC4 soap_get_tt__ContinuousFocus(struct soap *soap, tt__ContinuousFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ContinuousFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelativeFocus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__RelativeFocus::Distance);
	this->tt__RelativeFocus::Speed = NULL;
}

void tt__RelativeFocus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RelativeFocus::Distance, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &this->tt__RelativeFocus::Speed);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RelativeFocus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelativeFocus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocus(struct soap *soap, const char *tag, int id, const tt__RelativeFocus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocus), type ? type : "tt:RelativeFocus"))
		return soap->error;
	if (soap_out_float(soap, "tt:Distance", -1, &a->tt__RelativeFocus::Distance, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Speed", -1, &a->tt__RelativeFocus::Speed, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelativeFocus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelativeFocus(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelativeFocus * SOAP_FMAC4 soap_in_tt__RelativeFocus(struct soap *soap, const char *tag, tt__RelativeFocus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelativeFocus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocus, sizeof(tt__RelativeFocus), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelativeFocus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RelativeFocus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Distance1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Distance", &a->tt__RelativeFocus::Distance, "xsd:float"))
				{	soap_flag_Distance1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Speed", &a->tt__RelativeFocus::Speed, "xsd:float"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RelativeFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocus, SOAP_TYPE_tt__RelativeFocus, sizeof(tt__RelativeFocus), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelativeFocus * SOAP_FMAC2 imageing_instantiate_tt__RelativeFocus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__RelativeFocus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelativeFocus *p;
	size_t k = sizeof(tt__RelativeFocus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelativeFocus, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelativeFocus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelativeFocus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelativeFocus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelativeFocus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelativeFocus(soap, tag ? tag : "tt:RelativeFocus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelativeFocus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelativeFocus(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelativeFocus * SOAP_FMAC4 soap_get_tt__RelativeFocus(struct soap *soap, tt__RelativeFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AbsoluteFocus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__AbsoluteFocus::Position);
	this->tt__AbsoluteFocus::Speed = NULL;
}

void tt__AbsoluteFocus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AbsoluteFocus::Position, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &this->tt__AbsoluteFocus::Speed);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AbsoluteFocus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AbsoluteFocus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocus(struct soap *soap, const char *tag, int id, const tt__AbsoluteFocus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AbsoluteFocus), type ? type : "tt:AbsoluteFocus"))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &a->tt__AbsoluteFocus::Position, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Speed", -1, &a->tt__AbsoluteFocus::Speed, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AbsoluteFocus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AbsoluteFocus(soap, tag, this, type);
}

SOAP_FMAC3 tt__AbsoluteFocus * SOAP_FMAC4 soap_in_tt__AbsoluteFocus(struct soap *soap, const char *tag, tt__AbsoluteFocus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AbsoluteFocus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocus, sizeof(tt__AbsoluteFocus), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AbsoluteFocus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AbsoluteFocus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Position", &a->tt__AbsoluteFocus::Position, "xsd:float"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Speed", &a->tt__AbsoluteFocus::Speed, "xsd:float"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AbsoluteFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocus, SOAP_TYPE_tt__AbsoluteFocus, sizeof(tt__AbsoluteFocus), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AbsoluteFocus * SOAP_FMAC2 imageing_instantiate_tt__AbsoluteFocus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__AbsoluteFocus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AbsoluteFocus *p;
	size_t k = sizeof(tt__AbsoluteFocus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AbsoluteFocus, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AbsoluteFocus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AbsoluteFocus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AbsoluteFocus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AbsoluteFocus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AbsoluteFocus(soap, tag ? tag : "tt:AbsoluteFocus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AbsoluteFocus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AbsoluteFocus(soap, this, tag, type);
}

SOAP_FMAC3 tt__AbsoluteFocus * SOAP_FMAC4 soap_get_tt__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AbsoluteFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusMove::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__FocusMove::Absolute = NULL;
	this->tt__FocusMove::Relative = NULL;
	this->tt__FocusMove::Continuous = NULL;
}

void tt__FocusMove::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AbsoluteFocus(soap, &this->tt__FocusMove::Absolute);
	soap_serialize_PointerTott__RelativeFocus(soap, &this->tt__FocusMove::Relative);
	soap_serialize_PointerTott__ContinuousFocus(soap, &this->tt__FocusMove::Continuous);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusMove::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusMove(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusMove(struct soap *soap, const char *tag, int id, const tt__FocusMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusMove), type ? type : "tt:FocusMove"))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocus(soap, "tt:Absolute", -1, &a->tt__FocusMove::Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocus(soap, "tt:Relative", -1, &a->tt__FocusMove::Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocus(soap, "tt:Continuous", -1, &a->tt__FocusMove::Continuous, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusMove::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusMove(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusMove * SOAP_FMAC4 soap_in_tt__FocusMove(struct soap *soap, const char *tag, tt__FocusMove *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusMove*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusMove, sizeof(tt__FocusMove), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusMove)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusMove *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Absolute1 = 1;
	size_t soap_flag_Relative1 = 1;
	size_t soap_flag_Continuous1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AbsoluteFocus(soap, "tt:Absolute", &a->tt__FocusMove::Absolute, "tt:AbsoluteFocus"))
				{	soap_flag_Absolute1--;
					continue;
				}
			}
			if (soap_flag_Relative1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelativeFocus(soap, "tt:Relative", &a->tt__FocusMove::Relative, "tt:RelativeFocus"))
				{	soap_flag_Relative1--;
					continue;
				}
			}
			if (soap_flag_Continuous1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ContinuousFocus(soap, "tt:Continuous", &a->tt__FocusMove::Continuous, "tt:ContinuousFocus"))
				{	soap_flag_Continuous1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusMove, SOAP_TYPE_tt__FocusMove, sizeof(tt__FocusMove), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusMove * SOAP_FMAC2 imageing_instantiate_tt__FocusMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__FocusMove(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusMove *p;
	size_t k = sizeof(tt__FocusMove);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusMove, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusMove);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusMove, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusMove location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusMove::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusMove(soap, tag ? tag : "tt:FocusMove", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusMove::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusMove(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusMove * SOAP_FMAC4 soap_get_tt__FocusMove(struct soap *soap, tt__FocusMove *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZSpeed::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__PTZSpeed::PanTilt = NULL;
	this->tt__PTZSpeed::Zoom = NULL;
}

void tt__PTZSpeed::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector2D(soap, &this->tt__PTZSpeed::PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &this->tt__PTZSpeed::Zoom);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTZSpeed::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZSpeed(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpeed(struct soap *soap, const char *tag, int id, const tt__PTZSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpeed), type ? type : "tt:PTZSpeed"))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->tt__PTZSpeed::PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->tt__PTZSpeed::Zoom, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZSpeed::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZSpeed(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZSpeed * SOAP_FMAC4 soap_in_tt__PTZSpeed(struct soap *soap, const char *tag, tt__PTZSpeed *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZSpeed*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpeed, sizeof(tt__PTZSpeed), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZSpeed)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZSpeed *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_PanTilt1 = 1;
	size_t soap_flag_Zoom1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->tt__PTZSpeed::PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt1--;
					continue;
				}
			}
			if (soap_flag_Zoom1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->tt__PTZSpeed::Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpeed, SOAP_TYPE_tt__PTZSpeed, sizeof(tt__PTZSpeed), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZSpeed * SOAP_FMAC2 imageing_instantiate_tt__PTZSpeed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__PTZSpeed(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZSpeed *p;
	size_t k = sizeof(tt__PTZSpeed);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZSpeed, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZSpeed);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZSpeed, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZSpeed location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZSpeed::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZSpeed(soap, tag ? tag : "tt:PTZSpeed", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZSpeed::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZSpeed(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZSpeed * SOAP_FMAC4 soap_get_tt__PTZSpeed(struct soap *soap, tt__PTZSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Space1DDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__Space1DDescription::URI);
	this->tt__Space1DDescription::XRange = NULL;
}

void tt__Space1DDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Space1DDescription::URI, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Space1DDescription::URI);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space1DDescription::XRange);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Space1DDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Space1DDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space1DDescription(struct soap *soap, const char *tag, int id, const tt__Space1DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space1DDescription), type ? type : "tt:Space1DDescription"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:URI", -1, &a->tt__Space1DDescription::URI, ""))
		return soap->error;
	if (!a->tt__Space1DDescription::XRange)
	{	if (soap_element_empty(soap, "tt:XRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->tt__Space1DDescription::XRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Space1DDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Space1DDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__Space1DDescription * SOAP_FMAC4 soap_in_tt__Space1DDescription(struct soap *soap, const char *tag, tt__Space1DDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Space1DDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space1DDescription, sizeof(tt__Space1DDescription), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Space1DDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Space1DDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_URI1 = 1;
	size_t soap_flag_XRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:URI", &a->tt__Space1DDescription::URI, "xsd:anyURI"))
				{	soap_flag_URI1--;
					continue;
				}
			}
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->tt__Space1DDescription::XRange, "tt:FloatRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI1 > 0 || !a->tt__Space1DDescription::XRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Space1DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space1DDescription, SOAP_TYPE_tt__Space1DDescription, sizeof(tt__Space1DDescription), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Space1DDescription * SOAP_FMAC2 imageing_instantiate_tt__Space1DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Space1DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Space1DDescription *p;
	size_t k = sizeof(tt__Space1DDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Space1DDescription, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Space1DDescription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Space1DDescription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Space1DDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Space1DDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Space1DDescription(soap, tag ? tag : "tt:Space1DDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Space1DDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Space1DDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__Space1DDescription * SOAP_FMAC4 soap_get_tt__Space1DDescription(struct soap *soap, tt__Space1DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Space2DDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__Space2DDescription::URI);
	this->tt__Space2DDescription::XRange = NULL;
	this->tt__Space2DDescription::YRange = NULL;
}

void tt__Space2DDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Space2DDescription::URI, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Space2DDescription::URI);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space2DDescription::XRange);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space2DDescription::YRange);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Space2DDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Space2DDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space2DDescription(struct soap *soap, const char *tag, int id, const tt__Space2DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space2DDescription), type ? type : "tt:Space2DDescription"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:URI", -1, &a->tt__Space2DDescription::URI, ""))
		return soap->error;
	if (!a->tt__Space2DDescription::XRange)
	{	if (soap_element_empty(soap, "tt:XRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->tt__Space2DDescription::XRange, ""))
		return soap->error;
	if (!a->tt__Space2DDescription::YRange)
	{	if (soap_element_empty(soap, "tt:YRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:YRange", -1, &a->tt__Space2DDescription::YRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Space2DDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Space2DDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__Space2DDescription * SOAP_FMAC4 soap_in_tt__Space2DDescription(struct soap *soap, const char *tag, tt__Space2DDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Space2DDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space2DDescription, sizeof(tt__Space2DDescription), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Space2DDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Space2DDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_URI1 = 1;
	size_t soap_flag_XRange1 = 1;
	size_t soap_flag_YRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:URI", &a->tt__Space2DDescription::URI, "xsd:anyURI"))
				{	soap_flag_URI1--;
					continue;
				}
			}
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->tt__Space2DDescription::XRange, "tt:FloatRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			}
			if (soap_flag_YRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YRange", &a->tt__Space2DDescription::YRange, "tt:FloatRange"))
				{	soap_flag_YRange1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI1 > 0 || !a->tt__Space2DDescription::XRange || !a->tt__Space2DDescription::YRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Space2DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space2DDescription, SOAP_TYPE_tt__Space2DDescription, sizeof(tt__Space2DDescription), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Space2DDescription * SOAP_FMAC2 imageing_instantiate_tt__Space2DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Space2DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Space2DDescription *p;
	size_t k = sizeof(tt__Space2DDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Space2DDescription, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Space2DDescription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Space2DDescription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Space2DDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Space2DDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Space2DDescription(soap, tag ? tag : "tt:Space2DDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Space2DDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Space2DDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__Space2DDescription * SOAP_FMAC4 soap_get_tt__Space2DDescription(struct soap *soap, tt__Space2DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ZoomLimits::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ZoomLimits::Range = NULL;
}

void tt__ZoomLimits::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space1DDescription(soap, &this->tt__ZoomLimits::Range);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ZoomLimits::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ZoomLimits(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ZoomLimits(struct soap *soap, const char *tag, int id, const tt__ZoomLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ZoomLimits), type ? type : "tt:ZoomLimits"))
		return soap->error;
	if (!a->tt__ZoomLimits::Range)
	{	if (soap_element_empty(soap, "tt:Range", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Space1DDescription(soap, "tt:Range", -1, &a->tt__ZoomLimits::Range, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ZoomLimits::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ZoomLimits(soap, tag, this, type);
}

SOAP_FMAC3 tt__ZoomLimits * SOAP_FMAC4 soap_in_tt__ZoomLimits(struct soap *soap, const char *tag, tt__ZoomLimits *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ZoomLimits*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ZoomLimits)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ZoomLimits *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Range1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space1DDescription(soap, "tt:Range", &a->tt__ZoomLimits::Range, "tt:Space1DDescription"))
				{	soap_flag_Range1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__ZoomLimits::Range))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ZoomLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ZoomLimits, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ZoomLimits * SOAP_FMAC2 imageing_instantiate_tt__ZoomLimits(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ZoomLimits(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ZoomLimits *p;
	size_t k = sizeof(tt__ZoomLimits);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ZoomLimits, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ZoomLimits);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ZoomLimits, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ZoomLimits location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ZoomLimits::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ZoomLimits(soap, tag ? tag : "tt:ZoomLimits", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ZoomLimits::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ZoomLimits(soap, this, tag, type);
}

SOAP_FMAC3 tt__ZoomLimits * SOAP_FMAC4 soap_get_tt__ZoomLimits(struct soap *soap, tt__ZoomLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PanTiltLimits::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__PanTiltLimits::Range = NULL;
}

void tt__PanTiltLimits::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space2DDescription(soap, &this->tt__PanTiltLimits::Range);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PanTiltLimits::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PanTiltLimits(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PanTiltLimits(struct soap *soap, const char *tag, int id, const tt__PanTiltLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PanTiltLimits), type ? type : "tt:PanTiltLimits"))
		return soap->error;
	if (!a->tt__PanTiltLimits::Range)
	{	if (soap_element_empty(soap, "tt:Range", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Space2DDescription(soap, "tt:Range", -1, &a->tt__PanTiltLimits::Range, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PanTiltLimits::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PanTiltLimits(soap, tag, this, type);
}

SOAP_FMAC3 tt__PanTiltLimits * SOAP_FMAC4 soap_in_tt__PanTiltLimits(struct soap *soap, const char *tag, tt__PanTiltLimits *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PanTiltLimits*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PanTiltLimits)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PanTiltLimits *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Range1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space2DDescription(soap, "tt:Range", &a->tt__PanTiltLimits::Range, "tt:Space2DDescription"))
				{	soap_flag_Range1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PanTiltLimits::Range))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PanTiltLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PanTiltLimits, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PanTiltLimits * SOAP_FMAC2 imageing_instantiate_tt__PanTiltLimits(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__PanTiltLimits(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PanTiltLimits *p;
	size_t k = sizeof(tt__PanTiltLimits);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PanTiltLimits, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PanTiltLimits);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PanTiltLimits, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PanTiltLimits location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PanTiltLimits::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PanTiltLimits(soap, tag ? tag : "tt:PanTiltLimits", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PanTiltLimits::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PanTiltLimits(soap, this, tag, type);
}

SOAP_FMAC3 tt__PanTiltLimits * SOAP_FMAC4 soap_get_tt__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Reverse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ReverseMode(soap, &this->tt__Reverse::Mode);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__Reverse::__any);
	this->tt__Reverse::__anyAttribute = NULL;
}

void tt__Reverse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__Reverse::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Reverse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Reverse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Reverse(struct soap *soap, const char *tag, int id, const tt__Reverse *a, const char *type)
{
	if (((tt__Reverse*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__Reverse*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Reverse), type ? type : "tt:Reverse"))
		return soap->error;
	if (soap_out_tt__ReverseMode(soap, "tt:Mode", -1, &a->tt__Reverse::Mode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__Reverse::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Reverse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Reverse(soap, tag, this, type);
}

SOAP_FMAC3 tt__Reverse * SOAP_FMAC4 soap_in_tt__Reverse(struct soap *soap, const char *tag, tt__Reverse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Reverse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Reverse, sizeof(tt__Reverse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Reverse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Reverse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__Reverse*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ReverseMode(soap, "tt:Mode", &a->tt__Reverse::Mode, "tt:ReverseMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__Reverse::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Reverse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Reverse, SOAP_TYPE_tt__Reverse, sizeof(tt__Reverse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Reverse * SOAP_FMAC2 imageing_instantiate_tt__Reverse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Reverse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Reverse *p;
	size_t k = sizeof(tt__Reverse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Reverse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Reverse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Reverse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Reverse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Reverse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Reverse(soap, tag ? tag : "tt:Reverse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Reverse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Reverse(soap, this, tag, type);
}

SOAP_FMAC3 tt__Reverse * SOAP_FMAC4 soap_get_tt__Reverse(struct soap *soap, tt__Reverse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Reverse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EFlip::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__EFlipMode(soap, &this->tt__EFlip::Mode);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__EFlip::__any);
	this->tt__EFlip::__anyAttribute = NULL;
}

void tt__EFlip::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__EFlip::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__EFlip::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EFlip(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlip(struct soap *soap, const char *tag, int id, const tt__EFlip *a, const char *type)
{
	if (((tt__EFlip*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__EFlip*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlip), type ? type : "tt:EFlip"))
		return soap->error;
	if (soap_out_tt__EFlipMode(soap, "tt:Mode", -1, &a->tt__EFlip::Mode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__EFlip::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EFlip::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EFlip(soap, tag, this, type);
}

SOAP_FMAC3 tt__EFlip * SOAP_FMAC4 soap_in_tt__EFlip(struct soap *soap, const char *tag, tt__EFlip *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EFlip*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlip, sizeof(tt__EFlip), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EFlip)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EFlip *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__EFlip*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__EFlipMode(soap, "tt:Mode", &a->tt__EFlip::Mode, "tt:EFlipMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__EFlip::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__EFlip *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlip, SOAP_TYPE_tt__EFlip, sizeof(tt__EFlip), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EFlip * SOAP_FMAC2 imageing_instantiate_tt__EFlip(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__EFlip(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EFlip *p;
	size_t k = sizeof(tt__EFlip);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EFlip, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EFlip);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EFlip, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EFlip location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EFlip::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EFlip(soap, tag ? tag : "tt:EFlip", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EFlip::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EFlip(soap, this, tag, type);
}

SOAP_FMAC3 tt__EFlip * SOAP_FMAC4 soap_get_tt__EFlip(struct soap *soap, tt__EFlip *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlip(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTControlDirectionExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__PTControlDirectionExtension::__any);
	this->tt__PTControlDirectionExtension::__anyAttribute = NULL;
}

void tt__PTControlDirectionExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__PTControlDirectionExtension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTControlDirectionExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTControlDirectionExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionExtension(struct soap *soap, const char *tag, int id, const tt__PTControlDirectionExtension *a, const char *type)
{
	if (((tt__PTControlDirectionExtension*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__PTControlDirectionExtension*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirectionExtension), type ? type : "tt:PTControlDirectionExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__PTControlDirectionExtension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTControlDirectionExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTControlDirectionExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTControlDirectionExtension * SOAP_FMAC4 soap_in_tt__PTControlDirectionExtension(struct soap *soap, const char *tag, tt__PTControlDirectionExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTControlDirectionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(tt__PTControlDirectionExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTControlDirectionExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTControlDirectionExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__PTControlDirectionExtension*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__PTControlDirectionExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTControlDirectionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionExtension, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(tt__PTControlDirectionExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTControlDirectionExtension * SOAP_FMAC2 imageing_instantiate_tt__PTControlDirectionExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__PTControlDirectionExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTControlDirectionExtension *p;
	size_t k = sizeof(tt__PTControlDirectionExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTControlDirectionExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTControlDirectionExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTControlDirectionExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTControlDirectionExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTControlDirectionExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTControlDirectionExtension(soap, tag ? tag : "tt:PTControlDirectionExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTControlDirectionExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTControlDirectionExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTControlDirectionExtension * SOAP_FMAC4 soap_get_tt__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTControlDirection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__PTControlDirection::EFlip = NULL;
	this->tt__PTControlDirection::Reverse = NULL;
	this->tt__PTControlDirection::Extension = NULL;
	this->tt__PTControlDirection::__anyAttribute = NULL;
}

void tt__PTControlDirection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__EFlip(soap, &this->tt__PTControlDirection::EFlip);
	soap_serialize_PointerTott__Reverse(soap, &this->tt__PTControlDirection::Reverse);
	soap_serialize_PointerTott__PTControlDirectionExtension(soap, &this->tt__PTControlDirection::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTControlDirection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTControlDirection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirection(struct soap *soap, const char *tag, int id, const tt__PTControlDirection *a, const char *type)
{
	if (((tt__PTControlDirection*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__PTControlDirection*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirection), type ? type : "tt:PTControlDirection"))
		return soap->error;
	if (soap_out_PointerTott__EFlip(soap, "tt:EFlip", -1, &a->tt__PTControlDirection::EFlip, ""))
		return soap->error;
	if (soap_out_PointerTott__Reverse(soap, "tt:Reverse", -1, &a->tt__PTControlDirection::Reverse, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionExtension(soap, "tt:Extension", -1, &a->tt__PTControlDirection::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTControlDirection::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTControlDirection(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTControlDirection * SOAP_FMAC4 soap_in_tt__PTControlDirection(struct soap *soap, const char *tag, tt__PTControlDirection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTControlDirection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirection, sizeof(tt__PTControlDirection), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTControlDirection)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTControlDirection *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__PTControlDirection*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_EFlip1 = 1;
	size_t soap_flag_Reverse1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EFlip1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EFlip(soap, "tt:EFlip", &a->tt__PTControlDirection::EFlip, "tt:EFlip"))
				{	soap_flag_EFlip1--;
					continue;
				}
			}
			if (soap_flag_Reverse1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Reverse(soap, "tt:Reverse", &a->tt__PTControlDirection::Reverse, "tt:Reverse"))
				{	soap_flag_Reverse1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirectionExtension(soap, "tt:Extension", &a->tt__PTControlDirection::Extension, "tt:PTControlDirectionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTControlDirection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirection, SOAP_TYPE_tt__PTControlDirection, sizeof(tt__PTControlDirection), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTControlDirection * SOAP_FMAC2 imageing_instantiate_tt__PTControlDirection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__PTControlDirection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTControlDirection *p;
	size_t k = sizeof(tt__PTControlDirection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTControlDirection, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTControlDirection);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTControlDirection, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTControlDirection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTControlDirection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTControlDirection(soap, tag ? tag : "tt:PTControlDirection", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTControlDirection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTControlDirection(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTControlDirection * SOAP_FMAC4 soap_get_tt__PTControlDirection(struct soap *soap, tt__PTControlDirection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfigurationExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__PTZConfigurationExtension2::__any);
}

void tt__PTZConfigurationExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__PTZConfigurationExtension2::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTZConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension2), type ? type : "tt:PTZConfigurationExtension2"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__PTZConfigurationExtension2::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension2(struct soap *soap, const char *tag, tt__PTZConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(tt__PTZConfigurationExtension2), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfigurationExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfigurationExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__PTZConfigurationExtension2::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension2, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(tt__PTZConfigurationExtension2), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationExtension2 * SOAP_FMAC2 imageing_instantiate_tt__PTZConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__PTZConfigurationExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfigurationExtension2 *p;
	size_t k = sizeof(tt__PTZConfigurationExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfigurationExtension2, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfigurationExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfigurationExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfigurationExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfigurationExtension2(soap, tag ? tag : "tt:PTZConfigurationExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__PTZConfigurationExtension::__any);
	this->tt__PTZConfigurationExtension::PTControlDirection = NULL;
	this->tt__PTZConfigurationExtension::Extension = NULL;
}

void tt__PTZConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__PTZConfigurationExtension::__any);
	soap_serialize_PointerTott__PTControlDirection(soap, &this->tt__PTZConfigurationExtension::PTControlDirection);
	soap_serialize_PointerTott__PTZConfigurationExtension2(soap, &this->tt__PTZConfigurationExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTZConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension), type ? type : "tt:PTZConfigurationExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__PTZConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirection(soap, "tt:PTControlDirection", -1, &a->tt__PTZConfigurationExtension::PTControlDirection, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationExtension2(soap, "tt:Extension", -1, &a->tt__PTZConfigurationExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, tt__PTZConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_PTControlDirection1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTControlDirection1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirection(soap, "tt:PTControlDirection", &a->tt__PTZConfigurationExtension::PTControlDirection, "tt:PTControlDirection"))
				{	soap_flag_PTControlDirection1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationExtension2(soap, "tt:Extension", &a->tt__PTZConfigurationExtension::Extension, "tt:PTZConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__PTZConfigurationExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__PTZConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__PTZConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfigurationExtension *p;
	size_t k = sizeof(tt__PTZConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfigurationExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfigurationExtension(soap, tag ? tag : "tt:PTZConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__PTZConfiguration::NodeToken);
	this->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace = NULL;
	this->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace = NULL;
	this->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace = NULL;
	this->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace = NULL;
	this->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace = NULL;
	this->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace = NULL;
	this->tt__PTZConfiguration::DefaultPTZSpeed = NULL;
	this->tt__PTZConfiguration::DefaultPTZTimeout = NULL;
	this->tt__PTZConfiguration::PanTiltLimits = NULL;
	this->tt__PTZConfiguration::ZoomLimits = NULL;
	this->tt__PTZConfiguration::Extension = NULL;
	this->tt__PTZConfiguration::MoveRamp = NULL;
	this->tt__PTZConfiguration::PresetRamp = NULL;
	this->tt__PTZConfiguration::PresetTourRamp = NULL;
	this->tt__PTZConfiguration::__anyAttribute = NULL;
}

void tt__PTZConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->tt__PTZConfiguration::NodeToken);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->tt__PTZConfiguration::DefaultPTZSpeed);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__PTZConfiguration::DefaultPTZTimeout);
	soap_serialize_PointerTott__PanTiltLimits(soap, &this->tt__PTZConfiguration::PanTiltLimits);
	soap_serialize_PointerTott__ZoomLimits(soap, &this->tt__PTZConfiguration::ZoomLimits);
	soap_serialize_PointerTott__PTZConfigurationExtension(soap, &this->tt__PTZConfiguration::Extension);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__PTZConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfiguration(struct soap *soap, const char *tag, int id, const tt__PTZConfiguration *a, const char *type)
{
	if (((tt__PTZConfiguration*)a)->MoveRamp)
	{	soap_set_attr(soap, "MoveRamp", soap_int2s(soap, *((tt__PTZConfiguration*)a)->MoveRamp), 1);
	}
	if (((tt__PTZConfiguration*)a)->PresetRamp)
	{	soap_set_attr(soap, "PresetRamp", soap_int2s(soap, *((tt__PTZConfiguration*)a)->PresetRamp), 1);
	}
	if (((tt__PTZConfiguration*)a)->PresetTourRamp)
	{	soap_set_attr(soap, "PresetTourRamp", soap_int2s(soap, *((tt__PTZConfiguration*)a)->PresetTourRamp), 1);
	}
	if (((tt__PTZConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__PTZConfiguration*)a)->__anyAttribute, 1);
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfiguration), type ? type : "tt:PTZConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:NodeToken", -1, &a->tt__PTZConfiguration::NodeToken, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultAbsolutePantTiltPositionSpace", -1, &a->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultAbsoluteZoomPositionSpace", -1, &a->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultRelativePanTiltTranslationSpace", -1, &a->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultRelativeZoomTranslationSpace", -1, &a->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultContinuousPanTiltVelocitySpace", -1, &a->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultContinuousZoomVelocitySpace", -1, &a->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", -1, &a->tt__PTZConfiguration::DefaultPTZSpeed, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:DefaultPTZTimeout", -1, &a->tt__PTZConfiguration::DefaultPTZTimeout, ""))
		return soap->error;
	if (soap_out_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", -1, &a->tt__PTZConfiguration::PanTiltLimits, ""))
		return soap->error;
	if (soap_out_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", -1, &a->tt__PTZConfiguration::ZoomLimits, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", -1, &a->tt__PTZConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfiguration * SOAP_FMAC4 soap_in_tt__PTZConfiguration(struct soap *soap, const char *tag, tt__PTZConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfiguration, sizeof(tt__PTZConfiguration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "MoveRamp", 5, 0);
		if (t)
		{
			if (!(((tt__PTZConfiguration*)a)->MoveRamp = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__PTZConfiguration*)a)->MoveRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PresetRamp", 5, 0);
		if (t)
		{
			if (!(((tt__PTZConfiguration*)a)->PresetRamp = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__PTZConfiguration*)a)->PresetRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PresetTourRamp", 5, 0);
		if (t)
		{
			if (!(((tt__PTZConfiguration*)a)->PresetTourRamp = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__PTZConfiguration*)a)->PresetTourRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__PTZConfiguration*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_NodeToken1 = 1;
	size_t soap_flag_DefaultAbsolutePantTiltPositionSpace1 = 1;
	size_t soap_flag_DefaultAbsoluteZoomPositionSpace1 = 1;
	size_t soap_flag_DefaultRelativePanTiltTranslationSpace1 = 1;
	size_t soap_flag_DefaultRelativeZoomTranslationSpace1 = 1;
	size_t soap_flag_DefaultContinuousPanTiltVelocitySpace1 = 1;
	size_t soap_flag_DefaultContinuousZoomVelocitySpace1 = 1;
	size_t soap_flag_DefaultPTZSpeed1 = 1;
	size_t soap_flag_DefaultPTZTimeout1 = 1;
	size_t soap_flag_PanTiltLimits1 = 1;
	size_t soap_flag_ZoomLimits1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_NodeToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:NodeToken", &a->tt__PTZConfiguration::NodeToken, "tt:ReferenceToken"))
				{	soap_flag_NodeToken1--;
					continue;
				}
			}
			if (soap_flag_DefaultAbsolutePantTiltPositionSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultAbsolutePantTiltPositionSpace", &a->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace, "xsd:anyURI"))
				{	soap_flag_DefaultAbsolutePantTiltPositionSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultAbsoluteZoomPositionSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultAbsoluteZoomPositionSpace", &a->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace, "xsd:anyURI"))
				{	soap_flag_DefaultAbsoluteZoomPositionSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultRelativePanTiltTranslationSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultRelativePanTiltTranslationSpace", &a->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace, "xsd:anyURI"))
				{	soap_flag_DefaultRelativePanTiltTranslationSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultRelativeZoomTranslationSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultRelativeZoomTranslationSpace", &a->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace, "xsd:anyURI"))
				{	soap_flag_DefaultRelativeZoomTranslationSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultContinuousPanTiltVelocitySpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultContinuousPanTiltVelocitySpace", &a->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace, "xsd:anyURI"))
				{	soap_flag_DefaultContinuousPanTiltVelocitySpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultContinuousZoomVelocitySpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultContinuousZoomVelocitySpace", &a->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace, "xsd:anyURI"))
				{	soap_flag_DefaultContinuousZoomVelocitySpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultPTZSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", &a->tt__PTZConfiguration::DefaultPTZSpeed, "tt:PTZSpeed"))
				{	soap_flag_DefaultPTZSpeed1--;
					continue;
				}
			}
			if (soap_flag_DefaultPTZTimeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "tt:DefaultPTZTimeout", &a->tt__PTZConfiguration::DefaultPTZTimeout, "xsd:duration"))
				{	soap_flag_DefaultPTZTimeout1--;
					continue;
				}
			}
			if (soap_flag_PanTiltLimits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", &a->tt__PTZConfiguration::PanTiltLimits, "tt:PanTiltLimits"))
				{	soap_flag_PanTiltLimits1--;
					continue;
				}
			}
			if (soap_flag_ZoomLimits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", &a->tt__PTZConfiguration::ZoomLimits, "tt:ZoomLimits"))
				{	soap_flag_ZoomLimits1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", &a->tt__PTZConfiguration::Extension, "tt:PTZConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_NodeToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfiguration, SOAP_TYPE_tt__PTZConfiguration, sizeof(tt__PTZConfiguration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfiguration * SOAP_FMAC2 imageing_instantiate_tt__PTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__PTZConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfiguration *p;
	size_t k = sizeof(tt__PTZConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfiguration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfiguration(soap, tag ? tag : "tt:PTZConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfiguration * SOAP_FMAC4 soap_get_tt__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPAddress::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__IPType(soap, &this->tt__IPAddress::Type);
	this->tt__IPAddress::IPv4Address = NULL;
	this->tt__IPAddress::IPv6Address = NULL;
}

void tt__IPAddress::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPv4Address(soap, &this->tt__IPAddress::IPv4Address);
	soap_serialize_PointerTott__IPv6Address(soap, &this->tt__IPAddress::IPv6Address);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPAddress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddress(struct soap *soap, const char *tag, int id, const tt__IPAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddress), type ? type : "tt:IPAddress"))
		return soap->error;
	if (soap_out_tt__IPType(soap, "tt:Type", -1, &a->tt__IPAddress::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4Address(soap, "tt:IPv4Address", -1, &a->tt__IPAddress::IPv4Address, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Address(soap, "tt:IPv6Address", -1, &a->tt__IPAddress::IPv6Address, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPAddress::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPAddress(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddress * SOAP_FMAC4 soap_in_tt__IPAddress(struct soap *soap, const char *tag, tt__IPAddress *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPAddress*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddress, sizeof(tt__IPAddress), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPAddress)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPAddress *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_IPv4Address1 = 1;
	size_t soap_flag_IPv6Address1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IPType(soap, "tt:Type", &a->tt__IPAddress::Type, "tt:IPType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_IPv4Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv4Address(soap, "tt:IPv4Address", &a->tt__IPAddress::IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address1--;
					continue;
				}
			}
			if (soap_flag_IPv6Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv6Address(soap, "tt:IPv6Address", &a->tt__IPAddress::IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddress, SOAP_TYPE_tt__IPAddress, sizeof(tt__IPAddress), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPAddress * SOAP_FMAC2 imageing_instantiate_tt__IPAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__IPAddress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPAddress *p;
	size_t k = sizeof(tt__IPAddress);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPAddress, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPAddress);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPAddress, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPAddress location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPAddress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPAddress(soap, tag ? tag : "tt:IPAddress", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddress(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddress * SOAP_FMAC4 soap_get_tt__IPAddress(struct soap *soap, tt__IPAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MulticastConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__MulticastConfiguration::Address = NULL;
	soap_default_int(soap, &this->tt__MulticastConfiguration::Port);
	soap_default_int(soap, &this->tt__MulticastConfiguration::TTL);
	soap_default_bool(soap, &this->tt__MulticastConfiguration::AutoStart);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__MulticastConfiguration::__any);
	this->tt__MulticastConfiguration::__anyAttribute = NULL;
}

void tt__MulticastConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddress(soap, &this->tt__MulticastConfiguration::Address);
	soap_embedded(soap, &this->tt__MulticastConfiguration::Port, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__MulticastConfiguration::TTL, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__MulticastConfiguration::AutoStart, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__MulticastConfiguration::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MulticastConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MulticastConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MulticastConfiguration(struct soap *soap, const char *tag, int id, const tt__MulticastConfiguration *a, const char *type)
{
	if (((tt__MulticastConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__MulticastConfiguration*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MulticastConfiguration), type ? type : "tt:MulticastConfiguration"))
		return soap->error;
	if (!a->tt__MulticastConfiguration::Address)
	{	if (soap_element_empty(soap, "tt:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddress(soap, "tt:Address", -1, &a->tt__MulticastConfiguration::Address, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Port", -1, &a->tt__MulticastConfiguration::Port, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:TTL", -1, &a->tt__MulticastConfiguration::TTL, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AutoStart", -1, &a->tt__MulticastConfiguration::AutoStart, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__MulticastConfiguration::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MulticastConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MulticastConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__MulticastConfiguration * SOAP_FMAC4 soap_in_tt__MulticastConfiguration(struct soap *soap, const char *tag, tt__MulticastConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MulticastConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(tt__MulticastConfiguration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MulticastConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MulticastConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__MulticastConfiguration*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_Port1 = 1;
	size_t soap_flag_TTL1 = 1;
	size_t soap_flag_AutoStart1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddress(soap, "tt:Address", &a->tt__MulticastConfiguration::Address, "tt:IPAddress"))
				{	soap_flag_Address1--;
					continue;
				}
			}
			if (soap_flag_Port1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Port", &a->tt__MulticastConfiguration::Port, "xsd:int"))
				{	soap_flag_Port1--;
					continue;
				}
			}
			if (soap_flag_TTL1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:TTL", &a->tt__MulticastConfiguration::TTL, "xsd:int"))
				{	soap_flag_TTL1--;
					continue;
				}
			}
			if (soap_flag_AutoStart1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AutoStart", &a->tt__MulticastConfiguration::AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__MulticastConfiguration::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__MulticastConfiguration::Address || soap_flag_Port1 > 0 || soap_flag_TTL1 > 0 || soap_flag_AutoStart1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MulticastConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MulticastConfiguration, SOAP_TYPE_tt__MulticastConfiguration, sizeof(tt__MulticastConfiguration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MulticastConfiguration * SOAP_FMAC2 imageing_instantiate_tt__MulticastConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__MulticastConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MulticastConfiguration *p;
	size_t k = sizeof(tt__MulticastConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MulticastConfiguration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MulticastConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MulticastConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MulticastConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MulticastConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MulticastConfiguration(soap, tag ? tag : "tt:MulticastConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MulticastConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MulticastConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__MulticastConfiguration * SOAP_FMAC4 soap_get_tt__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioDecoderConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__AudioDecoderConfiguration::__any);
	this->tt__AudioDecoderConfiguration::__anyAttribute = NULL;
}

void tt__AudioDecoderConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__AudioDecoderConfiguration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AudioDecoderConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioDecoderConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioDecoderConfiguration *a, const char *type)
{
	if (((tt__AudioDecoderConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__AudioDecoderConfiguration*)a)->__anyAttribute, 1);
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDecoderConfiguration), type ? type : "tt:AudioDecoderConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__AudioDecoderConfiguration::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioDecoderConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioDecoderConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioDecoderConfiguration(struct soap *soap, const char *tag, tt__AudioDecoderConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioDecoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(tt__AudioDecoderConfiguration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioDecoderConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioDecoderConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__AudioDecoderConfiguration*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__AudioDecoderConfiguration::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfiguration, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(tt__AudioDecoderConfiguration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioDecoderConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AudioDecoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__AudioDecoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioDecoderConfiguration *p;
	size_t k = sizeof(tt__AudioDecoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioDecoderConfiguration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioDecoderConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioDecoderConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioDecoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioDecoderConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioDecoderConfiguration(soap, tag ? tag : "tt:AudioDecoderConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioDecoderConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioDecoderConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioOutputConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__AudioOutputConfiguration::OutputToken);
	this->tt__AudioOutputConfiguration::SendPrimacy = NULL;
	soap_default_int(soap, &this->tt__AudioOutputConfiguration::OutputLevel);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__AudioOutputConfiguration::__any);
	this->tt__AudioOutputConfiguration::__anyAttribute = NULL;
}

void tt__AudioOutputConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->tt__AudioOutputConfiguration::OutputToken);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__AudioOutputConfiguration::SendPrimacy);
	soap_embedded(soap, &this->tt__AudioOutputConfiguration::OutputLevel, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__AudioOutputConfiguration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AudioOutputConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioOutputConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioOutputConfiguration *a, const char *type)
{
	if (((tt__AudioOutputConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__AudioOutputConfiguration*)a)->__anyAttribute, 1);
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutputConfiguration), type ? type : "tt:AudioOutputConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:OutputToken", -1, &a->tt__AudioOutputConfiguration::OutputToken, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:SendPrimacy", -1, &a->tt__AudioOutputConfiguration::SendPrimacy, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:OutputLevel", -1, &a->tt__AudioOutputConfiguration::OutputLevel, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__AudioOutputConfiguration::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioOutputConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioOutputConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioOutputConfiguration * SOAP_FMAC4 soap_in_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, tt__AudioOutputConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioOutputConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(tt__AudioOutputConfiguration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioOutputConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioOutputConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__AudioOutputConfiguration*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_OutputToken1 = 1;
	size_t soap_flag_SendPrimacy1 = 1;
	size_t soap_flag_OutputLevel1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_OutputToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:OutputToken", &a->tt__AudioOutputConfiguration::OutputToken, "tt:ReferenceToken"))
				{	soap_flag_OutputToken1--;
					continue;
				}
			}
			if (soap_flag_SendPrimacy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:SendPrimacy", &a->tt__AudioOutputConfiguration::SendPrimacy, "xsd:anyURI"))
				{	soap_flag_SendPrimacy1--;
					continue;
				}
			}
			if (soap_flag_OutputLevel1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:OutputLevel", &a->tt__AudioOutputConfiguration::OutputLevel, "xsd:int"))
				{	soap_flag_OutputLevel1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__AudioOutputConfiguration::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_OutputToken1 > 0 || soap_flag_OutputLevel1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfiguration, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(tt__AudioOutputConfiguration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioOutputConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AudioOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__AudioOutputConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioOutputConfiguration *p;
	size_t k = sizeof(tt__AudioOutputConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioOutputConfiguration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioOutputConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioOutputConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioOutputConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioOutputConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioOutputConfiguration(soap, tag ? tag : "tt:AudioOutputConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioOutputConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioOutputConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioOutputConfiguration * SOAP_FMAC4 soap_get_tt__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EventSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__EventSubscription::Filter = NULL;
	this->tt__EventSubscription::SubscriptionPolicy = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__EventSubscription::__any);
	this->tt__EventSubscription::__anyAttribute = NULL;
}

void tt__EventSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__FilterType(soap, &this->tt__EventSubscription::Filter);
	soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, &this->tt__EventSubscription::SubscriptionPolicy);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__EventSubscription::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__EventSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EventSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventSubscription(struct soap *soap, const char *tag, int id, const tt__EventSubscription *a, const char *type)
{
	if (((tt__EventSubscription*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__EventSubscription*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventSubscription), type ? type : "tt:EventSubscription"))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tt:Filter", -1, &a->tt__EventSubscription::Filter, ""))
		return soap->error;
	if (soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, "tt:SubscriptionPolicy", -1, &a->tt__EventSubscription::SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__EventSubscription::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EventSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EventSubscription(soap, tag, this, type);
}

SOAP_FMAC3 tt__EventSubscription * SOAP_FMAC4 soap_in_tt__EventSubscription(struct soap *soap, const char *tag, tt__EventSubscription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EventSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventSubscription, sizeof(tt__EventSubscription), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EventSubscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EventSubscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__EventSubscription*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "tt:Filter", &a->tt__EventSubscription::Filter, "wsnt:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, "tt:SubscriptionPolicy", &a->tt__EventSubscription::SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__EventSubscription::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EventSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventSubscription, SOAP_TYPE_tt__EventSubscription, sizeof(tt__EventSubscription), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EventSubscription * SOAP_FMAC2 imageing_instantiate_tt__EventSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__EventSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EventSubscription *p;
	size_t k = sizeof(tt__EventSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EventSubscription, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EventSubscription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EventSubscription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EventSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EventSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EventSubscription(soap, tag ? tag : "tt:EventSubscription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EventSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EventSubscription(soap, this, tag, type);
}

SOAP_FMAC3 tt__EventSubscription * SOAP_FMAC4 soap_get_tt__EventSubscription(struct soap *soap, tt__EventSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__PTZFilter::Status);
	soap_default_bool(soap, &this->tt__PTZFilter::Position);
	this->tt__PTZFilter::__anyAttribute = NULL;
}

void tt__PTZFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZFilter::Status, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__PTZFilter::Position, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTZFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZFilter(struct soap *soap, const char *tag, int id, const tt__PTZFilter *a, const char *type)
{
	if (((tt__PTZFilter*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__PTZFilter*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZFilter), type ? type : "tt:PTZFilter"))
		return soap->error;
	if (soap_out_bool(soap, "tt:Status", -1, &a->tt__PTZFilter::Status, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Position", -1, &a->tt__PTZFilter::Position, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZFilter(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZFilter * SOAP_FMAC4 soap_in_tt__PTZFilter(struct soap *soap, const char *tag, tt__PTZFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZFilter, sizeof(tt__PTZFilter), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__PTZFilter*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_Position1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Status", &a->tt__PTZFilter::Status, "xsd:boolean"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Position", &a->tt__PTZFilter::Position, "xsd:boolean"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status1 > 0 || soap_flag_Position1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZFilter, SOAP_TYPE_tt__PTZFilter, sizeof(tt__PTZFilter), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZFilter * SOAP_FMAC2 imageing_instantiate_tt__PTZFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__PTZFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZFilter *p;
	size_t k = sizeof(tt__PTZFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZFilter, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZFilter(soap, tag ? tag : "tt:PTZFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZFilter(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZFilter * SOAP_FMAC4 soap_get_tt__PTZFilter(struct soap *soap, tt__PTZFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__MetadataConfigurationExtension::__any);
}

void tt__MetadataConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__MetadataConfigurationExtension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MetadataConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__MetadataConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationExtension), type ? type : "tt:MetadataConfigurationExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__MetadataConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension * SOAP_FMAC4 soap_in_tt__MetadataConfigurationExtension(struct soap *soap, const char *tag, tt__MetadataConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(tt__MetadataConfigurationExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__MetadataConfigurationExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MetadataConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationExtension, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(tt__MetadataConfigurationExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__MetadataConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__MetadataConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataConfigurationExtension *p;
	size_t k = sizeof(tt__MetadataConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataConfigurationExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataConfigurationExtension(soap, tag ? tag : "tt:MetadataConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension * SOAP_FMAC4 soap_get_tt__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	this->tt__MetadataConfiguration::PTZStatus = NULL;
	this->tt__MetadataConfiguration::Events = NULL;
	this->tt__MetadataConfiguration::Analytics = NULL;
	this->tt__MetadataConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__MetadataConfiguration::SessionTimeout);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__MetadataConfiguration::__any);
	this->tt__MetadataConfiguration::AnalyticsEngineConfiguration = NULL;
	this->tt__MetadataConfiguration::Extension = NULL;
	this->tt__MetadataConfiguration::CompressionType = NULL;
	this->tt__MetadataConfiguration::GeoLocation = NULL;
	this->tt__MetadataConfiguration::ShapePolygon = NULL;
	this->tt__MetadataConfiguration::__anyAttribute = NULL;
}

void tt__MetadataConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZFilter(soap, &this->tt__MetadataConfiguration::PTZStatus);
	soap_serialize_PointerTott__EventSubscription(soap, &this->tt__MetadataConfiguration::Events);
	soap_serialize_PointerTobool(soap, &this->tt__MetadataConfiguration::Analytics);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__MetadataConfiguration::Multicast);
	soap_embedded(soap, &this->tt__MetadataConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__MetadataConfiguration::SessionTimeout);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__MetadataConfiguration::__any);
	soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, &this->tt__MetadataConfiguration::AnalyticsEngineConfiguration);
	soap_serialize_PointerTott__MetadataConfigurationExtension(soap, &this->tt__MetadataConfiguration::Extension);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__MetadataConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfiguration(struct soap *soap, const char *tag, int id, const tt__MetadataConfiguration *a, const char *type)
{
	if (((tt__MetadataConfiguration*)a)->CompressionType)
	{	soap_set_attr(soap, "CompressionType", soap_std__string2s(soap, *((tt__MetadataConfiguration*)a)->CompressionType), 1);
	}
	if (((tt__MetadataConfiguration*)a)->GeoLocation)
	{	soap_set_attr(soap, "GeoLocation", soap_bool2s(soap, *((tt__MetadataConfiguration*)a)->GeoLocation), 1);
	}
	if (((tt__MetadataConfiguration*)a)->ShapePolygon)
	{	soap_set_attr(soap, "ShapePolygon", soap_bool2s(soap, *((tt__MetadataConfiguration*)a)->ShapePolygon), 1);
	}
	if (((tt__MetadataConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__MetadataConfiguration*)a)->__anyAttribute, 1);
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfiguration), type ? type : "tt:MetadataConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZFilter(soap, "tt:PTZStatus", -1, &a->tt__MetadataConfiguration::PTZStatus, ""))
		return soap->error;
	if (soap_out_PointerTott__EventSubscription(soap, "tt:Events", -1, &a->tt__MetadataConfiguration::Events, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Analytics", -1, &a->tt__MetadataConfiguration::Analytics, ""))
		return soap->error;
	if (!a->tt__MetadataConfiguration::Multicast)
	{	if (soap_element_empty(soap, "tt:Multicast", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__MetadataConfiguration::Multicast, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->tt__MetadataConfiguration::SessionTimeout, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__MetadataConfiguration::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->tt__MetadataConfiguration::AnalyticsEngineConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfigurationExtension(soap, "tt:Extension", -1, &a->tt__MetadataConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfiguration * SOAP_FMAC4 soap_in_tt__MetadataConfiguration(struct soap *soap, const char *tag, tt__MetadataConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(tt__MetadataConfiguration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "CompressionType", 1, 0);
		if (t)
		{
			if (!(((tt__MetadataConfiguration*)a)->CompressionType = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((tt__MetadataConfiguration*)a)->CompressionType))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeoLocation", 5, 0);
		if (t)
		{
			if (!(((tt__MetadataConfiguration*)a)->GeoLocation = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__MetadataConfiguration*)a)->GeoLocation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "ShapePolygon", 5, 0);
		if (t)
		{
			if (!(((tt__MetadataConfiguration*)a)->ShapePolygon = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__MetadataConfiguration*)a)->ShapePolygon))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__MetadataConfiguration*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_PTZStatus1 = 1;
	size_t soap_flag_Events1 = 1;
	size_t soap_flag_Analytics1 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	size_t soap_flag_AnalyticsEngineConfiguration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_PTZStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZFilter(soap, "tt:PTZStatus", &a->tt__MetadataConfiguration::PTZStatus, "tt:PTZFilter"))
				{	soap_flag_PTZStatus1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EventSubscription(soap, "tt:Events", &a->tt__MetadataConfiguration::Events, "tt:EventSubscription"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap_flag_Analytics1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Analytics", &a->tt__MetadataConfiguration::Analytics, "xsd:boolean"))
				{	soap_flag_Analytics1--;
					continue;
				}
			}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->tt__MetadataConfiguration::Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			}
			if (soap_flag_SessionTimeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->tt__MetadataConfiguration::SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			}
			if (soap_flag_AnalyticsEngineConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->tt__MetadataConfiguration::AnalyticsEngineConfiguration, "tt:AnalyticsEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataConfigurationExtension(soap, "tt:Extension", &a->tt__MetadataConfiguration::Extension, "tt:MetadataConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__MetadataConfiguration::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || !a->tt__MetadataConfiguration::Multicast || soap_flag_SessionTimeout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfiguration, SOAP_TYPE_tt__MetadataConfiguration, sizeof(tt__MetadataConfiguration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfiguration * SOAP_FMAC2 imageing_instantiate_tt__MetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__MetadataConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataConfiguration *p;
	size_t k = sizeof(tt__MetadataConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataConfiguration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataConfiguration(soap, tag ? tag : "tt:MetadataConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfiguration * SOAP_FMAC4 soap_get_tt__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoAnalyticsConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	this->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration = NULL;
	this->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__VideoAnalyticsConfiguration::__any);
	this->tt__VideoAnalyticsConfiguration::__anyAttribute = NULL;
}

void tt__VideoAnalyticsConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, &this->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration);
	soap_serialize_PointerTott__RuleEngineConfiguration(soap, &this->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__VideoAnalyticsConfiguration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__VideoAnalyticsConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoAnalyticsConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoAnalyticsConfiguration *a, const char *type)
{
	if (((tt__VideoAnalyticsConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__VideoAnalyticsConfiguration*)a)->__anyAttribute, 1);
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration), type ? type : "tt:VideoAnalyticsConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (!a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration)
	{	if (soap_element_empty(soap, "tt:AnalyticsEngineConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration, ""))
		return soap->error;
	if (!a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration)
	{	if (soap_element_empty(soap, "tt:RuleEngineConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", -1, &a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__VideoAnalyticsConfiguration::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoAnalyticsConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoAnalyticsConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_in_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, tt__VideoAnalyticsConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoAnalyticsConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(tt__VideoAnalyticsConfiguration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoAnalyticsConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoAnalyticsConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__VideoAnalyticsConfiguration*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_AnalyticsEngineConfiguration1 = 1;
	size_t soap_flag_RuleEngineConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_AnalyticsEngineConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration, "tt:AnalyticsEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration1--;
					continue;
				}
			}
			if (soap_flag_RuleEngineConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", &a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration, "tt:RuleEngineConfiguration"))
				{	soap_flag_RuleEngineConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__VideoAnalyticsConfiguration::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || !a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration || !a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsConfiguration, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(tt__VideoAnalyticsConfiguration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoAnalyticsConfiguration * SOAP_FMAC2 imageing_instantiate_tt__VideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__VideoAnalyticsConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoAnalyticsConfiguration *p;
	size_t k = sizeof(tt__VideoAnalyticsConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoAnalyticsConfiguration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoAnalyticsConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoAnalyticsConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoAnalyticsConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoAnalyticsConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoAnalyticsConfiguration(soap, tag ? tag : "tt:VideoAnalyticsConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoAnalyticsConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoAnalyticsConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_get_tt__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioEncoderConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__AudioEncoding(soap, &this->tt__AudioEncoderConfiguration::Encoding);
	soap_default_int(soap, &this->tt__AudioEncoderConfiguration::Bitrate);
	soap_default_int(soap, &this->tt__AudioEncoderConfiguration::SampleRate);
	this->tt__AudioEncoderConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__AudioEncoderConfiguration::SessionTimeout);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__AudioEncoderConfiguration::__any);
	this->tt__AudioEncoderConfiguration::__anyAttribute = NULL;
}

void tt__AudioEncoderConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::Bitrate, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::SampleRate, SOAP_TYPE_int);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__AudioEncoderConfiguration::Multicast);
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__AudioEncoderConfiguration::SessionTimeout);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__AudioEncoderConfiguration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AudioEncoderConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoderConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioEncoderConfiguration *a, const char *type)
{
	if (((tt__AudioEncoderConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__AudioEncoderConfiguration*)a)->__anyAttribute, 1);
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfiguration), type ? type : "tt:AudioEncoderConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &a->tt__AudioEncoderConfiguration::Encoding, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Bitrate", -1, &a->tt__AudioEncoderConfiguration::Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SampleRate", -1, &a->tt__AudioEncoderConfiguration::SampleRate, ""))
		return soap->error;
	if (!a->tt__AudioEncoderConfiguration::Multicast)
	{	if (soap_element_empty(soap, "tt:Multicast", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__AudioEncoderConfiguration::Multicast, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->tt__AudioEncoderConfiguration::SessionTimeout, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__AudioEncoderConfiguration::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoderConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioEncoderConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, tt__AudioEncoderConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(tt__AudioEncoderConfiguration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioEncoderConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioEncoderConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__AudioEncoderConfiguration*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_SampleRate1 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &a->tt__AudioEncoderConfiguration::Encoding, "tt:AudioEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Bitrate", &a->tt__AudioEncoderConfiguration::Bitrate, "xsd:int"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			}
			if (soap_flag_SampleRate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:SampleRate", &a->tt__AudioEncoderConfiguration::SampleRate, "xsd:int"))
				{	soap_flag_SampleRate1--;
					continue;
				}
			}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->tt__AudioEncoderConfiguration::Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			}
			if (soap_flag_SessionTimeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->tt__AudioEncoderConfiguration::SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__AudioEncoderConfiguration::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_Encoding1 > 0 || soap_flag_Bitrate1 > 0 || soap_flag_SampleRate1 > 0 || !a->tt__AudioEncoderConfiguration::Multicast || soap_flag_SessionTimeout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfiguration, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(tt__AudioEncoderConfiguration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioEncoderConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__AudioEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioEncoderConfiguration *p;
	size_t k = sizeof(tt__AudioEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioEncoderConfiguration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioEncoderConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioEncoderConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioEncoderConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioEncoderConfiguration(soap, tag ? tag : "tt:AudioEncoderConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoderConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoderConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioSourceConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__AudioSourceConfiguration::SourceToken);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__AudioSourceConfiguration::__any);
	this->tt__AudioSourceConfiguration::__anyAttribute = NULL;
}

void tt__AudioSourceConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->tt__AudioSourceConfiguration::SourceToken);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__AudioSourceConfiguration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AudioSourceConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSourceConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioSourceConfiguration *a, const char *type)
{
	if (((tt__AudioSourceConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__AudioSourceConfiguration*)a)->__anyAttribute, 1);
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfiguration), type ? type : "tt:AudioSourceConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &a->tt__AudioSourceConfiguration::SourceToken, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__AudioSourceConfiguration::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSourceConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioSourceConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSourceConfiguration * SOAP_FMAC4 soap_in_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, tt__AudioSourceConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(tt__AudioSourceConfiguration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioSourceConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioSourceConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__AudioSourceConfiguration*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_SourceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_SourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &a->tt__AudioSourceConfiguration::SourceToken, "tt:ReferenceToken"))
				{	soap_flag_SourceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__AudioSourceConfiguration::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_SourceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfiguration, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(tt__AudioSourceConfiguration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioSourceConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__AudioSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioSourceConfiguration *p;
	size_t k = sizeof(tt__AudioSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioSourceConfiguration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioSourceConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioSourceConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioSourceConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioSourceConfiguration(soap, tag ? tag : "tt:AudioSourceConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSourceConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSourceConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSourceConfiguration * SOAP_FMAC4 soap_get_tt__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__H264Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__H264Configuration::GovLength);
	soap_default_tt__H264Profile(soap, &this->tt__H264Configuration::H264Profile);
}

void tt__H264Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__H264Configuration::GovLength, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__H264Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Configuration(struct soap *soap, const char *tag, int id, const tt__H264Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Configuration), type ? type : "tt:H264Configuration"))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &a->tt__H264Configuration::GovLength, ""))
		return soap->error;
	if (soap_out_tt__H264Profile(soap, "tt:H264Profile", -1, &a->tt__H264Configuration::H264Profile, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__H264Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__H264Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Configuration * SOAP_FMAC4 soap_in_tt__H264Configuration(struct soap *soap, const char *tag, tt__H264Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__H264Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Configuration, sizeof(tt__H264Configuration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__H264Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__H264Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_GovLength1 = 1;
	size_t soap_flag_H264Profile1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:GovLength", &a->tt__H264Configuration::GovLength, "xsd:int"))
				{	soap_flag_GovLength1--;
					continue;
				}
			}
			if (soap_flag_H264Profile1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__H264Profile(soap, "tt:H264Profile", &a->tt__H264Configuration::H264Profile, "tt:H264Profile"))
				{	soap_flag_H264Profile1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength1 > 0 || soap_flag_H264Profile1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__H264Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Configuration, SOAP_TYPE_tt__H264Configuration, sizeof(tt__H264Configuration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__H264Configuration * SOAP_FMAC2 imageing_instantiate_tt__H264Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__H264Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__H264Configuration *p;
	size_t k = sizeof(tt__H264Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__H264Configuration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__H264Configuration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__H264Configuration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__H264Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__H264Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__H264Configuration(soap, tag ? tag : "tt:H264Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Configuration * SOAP_FMAC4 soap_get_tt__H264Configuration(struct soap *soap, tt__H264Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Mpeg4Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__Mpeg4Configuration::GovLength);
	soap_default_tt__Mpeg4Profile(soap, &this->tt__Mpeg4Configuration::Mpeg4Profile);
}

void tt__Mpeg4Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Mpeg4Configuration::GovLength, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Mpeg4Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Configuration(struct soap *soap, const char *tag, int id, const tt__Mpeg4Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Configuration), type ? type : "tt:Mpeg4Configuration"))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &a->tt__Mpeg4Configuration::GovLength, ""))
		return soap->error;
	if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", -1, &a->tt__Mpeg4Configuration::Mpeg4Profile, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Mpeg4Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Mpeg4Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Configuration * SOAP_FMAC4 soap_in_tt__Mpeg4Configuration(struct soap *soap, const char *tag, tt__Mpeg4Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Mpeg4Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(tt__Mpeg4Configuration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Mpeg4Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Mpeg4Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_GovLength1 = 1;
	size_t soap_flag_Mpeg4Profile1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:GovLength", &a->tt__Mpeg4Configuration::GovLength, "xsd:int"))
				{	soap_flag_GovLength1--;
					continue;
				}
			}
			if (soap_flag_Mpeg4Profile1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", &a->tt__Mpeg4Configuration::Mpeg4Profile, "tt:Mpeg4Profile"))
				{	soap_flag_Mpeg4Profile1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength1 > 0 || soap_flag_Mpeg4Profile1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Mpeg4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Configuration, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(tt__Mpeg4Configuration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Mpeg4Configuration * SOAP_FMAC2 imageing_instantiate_tt__Mpeg4Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Mpeg4Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Mpeg4Configuration *p;
	size_t k = sizeof(tt__Mpeg4Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Mpeg4Configuration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Mpeg4Configuration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Mpeg4Configuration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Mpeg4Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Mpeg4Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Mpeg4Configuration(soap, tag ? tag : "tt:Mpeg4Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Configuration * SOAP_FMAC4 soap_get_tt__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoRateControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__VideoRateControl::FrameRateLimit);
	soap_default_int(soap, &this->tt__VideoRateControl::EncodingInterval);
	soap_default_int(soap, &this->tt__VideoRateControl::BitrateLimit);
}

void tt__VideoRateControl::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoRateControl::FrameRateLimit, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoRateControl::EncodingInterval, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoRateControl::BitrateLimit, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoRateControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoRateControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoRateControl(struct soap *soap, const char *tag, int id, const tt__VideoRateControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoRateControl), type ? type : "tt:VideoRateControl"))
		return soap->error;
	if (soap_out_int(soap, "tt:FrameRateLimit", -1, &a->tt__VideoRateControl::FrameRateLimit, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EncodingInterval", -1, &a->tt__VideoRateControl::EncodingInterval, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:BitrateLimit", -1, &a->tt__VideoRateControl::BitrateLimit, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoRateControl::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoRateControl(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoRateControl * SOAP_FMAC4 soap_in_tt__VideoRateControl(struct soap *soap, const char *tag, tt__VideoRateControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoRateControl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoRateControl, sizeof(tt__VideoRateControl), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoRateControl)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoRateControl *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_FrameRateLimit1 = 1;
	size_t soap_flag_EncodingInterval1 = 1;
	size_t soap_flag_BitrateLimit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FrameRateLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:FrameRateLimit", &a->tt__VideoRateControl::FrameRateLimit, "xsd:int"))
				{	soap_flag_FrameRateLimit1--;
					continue;
				}
			}
			if (soap_flag_EncodingInterval1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:EncodingInterval", &a->tt__VideoRateControl::EncodingInterval, "xsd:int"))
				{	soap_flag_EncodingInterval1--;
					continue;
				}
			}
			if (soap_flag_BitrateLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:BitrateLimit", &a->tt__VideoRateControl::BitrateLimit, "xsd:int"))
				{	soap_flag_BitrateLimit1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrameRateLimit1 > 0 || soap_flag_EncodingInterval1 > 0 || soap_flag_BitrateLimit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoRateControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoRateControl, SOAP_TYPE_tt__VideoRateControl, sizeof(tt__VideoRateControl), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoRateControl * SOAP_FMAC2 imageing_instantiate_tt__VideoRateControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__VideoRateControl(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoRateControl *p;
	size_t k = sizeof(tt__VideoRateControl);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoRateControl, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoRateControl);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoRateControl, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoRateControl location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoRateControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoRateControl(soap, tag ? tag : "tt:VideoRateControl", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoRateControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoRateControl(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoRateControl * SOAP_FMAC4 soap_get_tt__VideoRateControl(struct soap *soap, tt__VideoRateControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoResolution::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__VideoResolution::Width);
	soap_default_int(soap, &this->tt__VideoResolution::Height);
}

void tt__VideoResolution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoResolution::Width, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoResolution::Height, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoResolution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoResolution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoResolution(struct soap *soap, const char *tag, int id, const tt__VideoResolution *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoResolution), type ? type : "tt:VideoResolution"))
		return soap->error;
	if (soap_out_int(soap, "tt:Width", -1, &a->tt__VideoResolution::Width, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &a->tt__VideoResolution::Height, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoResolution::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoResolution(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoResolution * SOAP_FMAC4 soap_in_tt__VideoResolution(struct soap *soap, const char *tag, tt__VideoResolution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoResolution*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoResolution, sizeof(tt__VideoResolution), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoResolution)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoResolution *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Width1 = 1;
	size_t soap_flag_Height1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Width", &a->tt__VideoResolution::Width, "xsd:int"))
				{	soap_flag_Width1--;
					continue;
				}
			}
			if (soap_flag_Height1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Height", &a->tt__VideoResolution::Height, "xsd:int"))
				{	soap_flag_Height1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width1 > 0 || soap_flag_Height1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoResolution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoResolution, SOAP_TYPE_tt__VideoResolution, sizeof(tt__VideoResolution), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoResolution * SOAP_FMAC2 imageing_instantiate_tt__VideoResolution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__VideoResolution(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoResolution *p;
	size_t k = sizeof(tt__VideoResolution);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoResolution, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoResolution);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoResolution, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoResolution location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoResolution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoResolution(soap, tag ? tag : "tt:VideoResolution", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoResolution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoResolution(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoResolution * SOAP_FMAC4 soap_get_tt__VideoResolution(struct soap *soap, tt__VideoResolution *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncoderConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__VideoEncoding(soap, &this->tt__VideoEncoderConfiguration::Encoding);
	this->tt__VideoEncoderConfiguration::Resolution = NULL;
	soap_default_float(soap, &this->tt__VideoEncoderConfiguration::Quality);
	this->tt__VideoEncoderConfiguration::RateControl = NULL;
	this->tt__VideoEncoderConfiguration::MPEG4 = NULL;
	this->tt__VideoEncoderConfiguration::H264 = NULL;
	this->tt__VideoEncoderConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__VideoEncoderConfiguration::SessionTimeout);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__VideoEncoderConfiguration::__any);
	this->tt__VideoEncoderConfiguration::GuaranteedFrameRate = NULL;
	this->tt__VideoEncoderConfiguration::__anyAttribute = NULL;
}

void tt__VideoEncoderConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoResolution(soap, &this->tt__VideoEncoderConfiguration::Resolution);
	soap_embedded(soap, &this->tt__VideoEncoderConfiguration::Quality, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoRateControl(soap, &this->tt__VideoEncoderConfiguration::RateControl);
	soap_serialize_PointerTott__Mpeg4Configuration(soap, &this->tt__VideoEncoderConfiguration::MPEG4);
	soap_serialize_PointerTott__H264Configuration(soap, &this->tt__VideoEncoderConfiguration::H264);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__VideoEncoderConfiguration::Multicast);
	soap_embedded(soap, &this->tt__VideoEncoderConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__VideoEncoderConfiguration::SessionTimeout);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__VideoEncoderConfiguration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__VideoEncoderConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoEncoderConfiguration *a, const char *type)
{
	if (((tt__VideoEncoderConfiguration*)a)->GuaranteedFrameRate)
	{	soap_set_attr(soap, "GuaranteedFrameRate", soap_bool2s(soap, *((tt__VideoEncoderConfiguration*)a)->GuaranteedFrameRate), 1);
	}
	if (((tt__VideoEncoderConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__VideoEncoderConfiguration*)a)->__anyAttribute, 1);
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfiguration), type ? type : "tt:VideoEncoderConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__VideoEncoding(soap, "tt:Encoding", -1, &a->tt__VideoEncoderConfiguration::Encoding, ""))
		return soap->error;
	if (!a->tt__VideoEncoderConfiguration::Resolution)
	{	if (soap_element_empty(soap, "tt:Resolution", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->tt__VideoEncoderConfiguration::Resolution, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Quality", -1, &a->tt__VideoEncoderConfiguration::Quality, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoRateControl(soap, "tt:RateControl", -1, &a->tt__VideoEncoderConfiguration::RateControl, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", -1, &a->tt__VideoEncoderConfiguration::MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Configuration(soap, "tt:H264", -1, &a->tt__VideoEncoderConfiguration::H264, ""))
		return soap->error;
	if (!a->tt__VideoEncoderConfiguration::Multicast)
	{	if (soap_element_empty(soap, "tt:Multicast", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__VideoEncoderConfiguration::Multicast, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->tt__VideoEncoderConfiguration::SessionTimeout, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__VideoEncoderConfiguration::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncoderConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_in_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, tt__VideoEncoderConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(tt__VideoEncoderConfiguration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncoderConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoEncoderConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "GuaranteedFrameRate", 5, 0);
		if (t)
		{
			if (!(((tt__VideoEncoderConfiguration*)a)->GuaranteedFrameRate = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__VideoEncoderConfiguration*)a)->GuaranteedFrameRate))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__VideoEncoderConfiguration*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Resolution1 = 1;
	size_t soap_flag_Quality1 = 1;
	size_t soap_flag_RateControl1 = 1;
	size_t soap_flag_MPEG41 = 1;
	size_t soap_flag_H2641 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__VideoEncoding(soap, "tt:Encoding", &a->tt__VideoEncoderConfiguration::Encoding, "tt:VideoEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_Resolution1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->tt__VideoEncoderConfiguration::Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution1--;
					continue;
				}
			}
			if (soap_flag_Quality1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Quality", &a->tt__VideoEncoderConfiguration::Quality, "xsd:float"))
				{	soap_flag_Quality1--;
					continue;
				}
			}
			if (soap_flag_RateControl1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoRateControl(soap, "tt:RateControl", &a->tt__VideoEncoderConfiguration::RateControl, "tt:VideoRateControl"))
				{	soap_flag_RateControl1--;
					continue;
				}
			}
			if (soap_flag_MPEG41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", &a->tt__VideoEncoderConfiguration::MPEG4, "tt:Mpeg4Configuration"))
				{	soap_flag_MPEG41--;
					continue;
				}
			}
			if (soap_flag_H2641 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__H264Configuration(soap, "tt:H264", &a->tt__VideoEncoderConfiguration::H264, "tt:H264Configuration"))
				{	soap_flag_H2641--;
					continue;
				}
			}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->tt__VideoEncoderConfiguration::Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			}
			if (soap_flag_SessionTimeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->tt__VideoEncoderConfiguration::SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__VideoEncoderConfiguration::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_Encoding1 > 0 || !a->tt__VideoEncoderConfiguration::Resolution || soap_flag_Quality1 > 0 || !a->tt__VideoEncoderConfiguration::Multicast || soap_flag_SessionTimeout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfiguration, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(tt__VideoEncoderConfiguration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoderConfiguration * SOAP_FMAC2 imageing_instantiate_tt__VideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__VideoEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncoderConfiguration *p;
	size_t k = sizeof(tt__VideoEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncoderConfiguration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncoderConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncoderConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncoderConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncoderConfiguration(soap, tag ? tag : "tt:VideoEncoderConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_get_tt__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SceneOrientation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__SceneOrientationMode(soap, &this->tt__SceneOrientation::Mode);
	this->tt__SceneOrientation::Orientation = NULL;
}

void tt__SceneOrientation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->tt__SceneOrientation::Orientation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SceneOrientation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SceneOrientation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientation(struct soap *soap, const char *tag, int id, const tt__SceneOrientation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SceneOrientation), type ? type : "tt:SceneOrientation"))
		return soap->error;
	if (soap_out_tt__SceneOrientationMode(soap, "tt:Mode", -1, &a->tt__SceneOrientation::Mode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Orientation", -1, &a->tt__SceneOrientation::Orientation, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SceneOrientation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SceneOrientation(soap, tag, this, type);
}

SOAP_FMAC3 tt__SceneOrientation * SOAP_FMAC4 soap_in_tt__SceneOrientation(struct soap *soap, const char *tag, tt__SceneOrientation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SceneOrientation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientation, sizeof(tt__SceneOrientation), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SceneOrientation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SceneOrientation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Orientation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SceneOrientationMode(soap, "tt:Mode", &a->tt__SceneOrientation::Mode, "tt:SceneOrientationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Orientation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Orientation", &a->tt__SceneOrientation::Orientation, "xsd:string"))
				{	soap_flag_Orientation1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SceneOrientation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SceneOrientation, SOAP_TYPE_tt__SceneOrientation, sizeof(tt__SceneOrientation), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SceneOrientation * SOAP_FMAC2 imageing_instantiate_tt__SceneOrientation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__SceneOrientation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SceneOrientation *p;
	size_t k = sizeof(tt__SceneOrientation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SceneOrientation, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SceneOrientation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SceneOrientation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SceneOrientation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SceneOrientation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SceneOrientation(soap, tag ? tag : "tt:SceneOrientation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SceneOrientation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SceneOrientation(soap, this, tag, type);
}

SOAP_FMAC3 tt__SceneOrientation * SOAP_FMAC4 soap_get_tt__SceneOrientation(struct soap *soap, tt__SceneOrientation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SceneOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LensDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__LensDescription::Offset = NULL;
	soap_default_std__vectorTemplateOfPointerTott__LensProjection(soap, &this->tt__LensDescription::Projection);
	soap_default_float(soap, &this->tt__LensDescription::XFactor);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__LensDescription::__any);
	this->tt__LensDescription::FocalLength = NULL;
	this->tt__LensDescription::__anyAttribute = NULL;
}

void tt__LensDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__LensOffset(soap, &this->tt__LensDescription::Offset);
	soap_serialize_std__vectorTemplateOfPointerTott__LensProjection(soap, &this->tt__LensDescription::Projection);
	soap_embedded(soap, &this->tt__LensDescription::XFactor, SOAP_TYPE_float);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__LensDescription::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__LensDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LensDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensDescription(struct soap *soap, const char *tag, int id, const tt__LensDescription *a, const char *type)
{
	if (((tt__LensDescription*)a)->FocalLength)
	{	soap_set_attr(soap, "FocalLength", soap_float2s(soap, *((tt__LensDescription*)a)->FocalLength), 1);
	}
	if (((tt__LensDescription*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__LensDescription*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LensDescription), type ? type : "tt:LensDescription"))
		return soap->error;
	if (!a->tt__LensDescription::Offset)
	{	if (soap_element_empty(soap, "tt:Offset", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__LensOffset(soap, "tt:Offset", -1, &a->tt__LensDescription::Offset, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__LensProjection(soap, "tt:Projection", -1, &a->tt__LensDescription::Projection, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:XFactor", -1, &a->tt__LensDescription::XFactor, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__LensDescription::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LensDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LensDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__LensDescription * SOAP_FMAC4 soap_in_tt__LensDescription(struct soap *soap, const char *tag, tt__LensDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LensDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensDescription, sizeof(tt__LensDescription), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LensDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LensDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "FocalLength", 5, 0);
		if (t)
		{
			if (!(((tt__LensDescription*)a)->FocalLength = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__LensDescription*)a)->FocalLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__LensDescription*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Offset1 = 1;
	size_t soap_flag_XFactor1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Offset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LensOffset(soap, "tt:Offset", &a->tt__LensDescription::Offset, "tt:LensOffset"))
				{	soap_flag_Offset1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LensProjection(soap, "tt:Projection", &a->tt__LensDescription::Projection, "tt:LensProjection"))
					continue;
			}
			if (soap_flag_XFactor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:XFactor", &a->tt__LensDescription::XFactor, "xsd:float"))
				{	soap_flag_XFactor1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__LensDescription::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__LensDescription::Offset || a->tt__LensDescription::Projection.size() < 1 || soap_flag_XFactor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__LensDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LensDescription, SOAP_TYPE_tt__LensDescription, sizeof(tt__LensDescription), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LensDescription * SOAP_FMAC2 imageing_instantiate_tt__LensDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__LensDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LensDescription *p;
	size_t k = sizeof(tt__LensDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LensDescription, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LensDescription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LensDescription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LensDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LensDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LensDescription(soap, tag ? tag : "tt:LensDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LensDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LensDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__LensDescription * SOAP_FMAC4 soap_get_tt__LensDescription(struct soap *soap, tt__LensDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LensDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LensOffset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__LensOffset::x = NULL;
	this->tt__LensOffset::y = NULL;
	this->tt__LensOffset::__anyAttribute = NULL;
}

void tt__LensOffset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__LensOffset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LensOffset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensOffset(struct soap *soap, const char *tag, int id, const tt__LensOffset *a, const char *type)
{
	if (((tt__LensOffset*)a)->x)
	{	soap_set_attr(soap, "x", soap_float2s(soap, *((tt__LensOffset*)a)->x), 1);
	}
	if (((tt__LensOffset*)a)->y)
	{	soap_set_attr(soap, "y", soap_float2s(soap, *((tt__LensOffset*)a)->y), 1);
	}
	if (((tt__LensOffset*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__LensOffset*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:LensOffset");
}

void *tt__LensOffset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LensOffset(soap, tag, this, type);
}

SOAP_FMAC3 tt__LensOffset * SOAP_FMAC4 soap_in_tt__LensOffset(struct soap *soap, const char *tag, tt__LensOffset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__LensOffset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensOffset, sizeof(tt__LensOffset), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LensOffset)
		return (tt__LensOffset *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "x", 5, 0);
		if (t)
		{
			if (!(((tt__LensOffset*)a)->x = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__LensOffset*)a)->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "y", 5, 0);
		if (t)
		{
			if (!(((tt__LensOffset*)a)->y = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__LensOffset*)a)->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__LensOffset*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__LensOffset * SOAP_FMAC2 imageing_instantiate_tt__LensOffset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__LensOffset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LensOffset *p;
	size_t k = sizeof(tt__LensOffset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LensOffset, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LensOffset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LensOffset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LensOffset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LensOffset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LensOffset(soap, tag ? tag : "tt:LensOffset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LensOffset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LensOffset(soap, this, tag, type);
}

SOAP_FMAC3 tt__LensOffset * SOAP_FMAC4 soap_get_tt__LensOffset(struct soap *soap, tt__LensOffset *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LensOffset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LensProjection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__LensProjection::Angle);
	soap_default_float(soap, &this->tt__LensProjection::Radius);
	this->tt__LensProjection::Transmittance = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__LensProjection::__any);
	this->tt__LensProjection::__anyAttribute = NULL;
}

void tt__LensProjection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__LensProjection::Angle, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__LensProjection::Radius, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &this->tt__LensProjection::Transmittance);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__LensProjection::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__LensProjection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LensProjection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensProjection(struct soap *soap, const char *tag, int id, const tt__LensProjection *a, const char *type)
{
	if (((tt__LensProjection*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__LensProjection*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LensProjection), type ? type : "tt:LensProjection"))
		return soap->error;
	if (soap_out_float(soap, "tt:Angle", -1, &a->tt__LensProjection::Angle, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Radius", -1, &a->tt__LensProjection::Radius, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Transmittance", -1, &a->tt__LensProjection::Transmittance, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__LensProjection::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LensProjection::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LensProjection(soap, tag, this, type);
}

SOAP_FMAC3 tt__LensProjection * SOAP_FMAC4 soap_in_tt__LensProjection(struct soap *soap, const char *tag, tt__LensProjection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LensProjection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensProjection, sizeof(tt__LensProjection), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LensProjection)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LensProjection *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__LensProjection*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Angle1 = 1;
	size_t soap_flag_Radius1 = 1;
	size_t soap_flag_Transmittance1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Angle1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Angle", &a->tt__LensProjection::Angle, "xsd:float"))
				{	soap_flag_Angle1--;
					continue;
				}
			}
			if (soap_flag_Radius1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Radius", &a->tt__LensProjection::Radius, "xsd:float"))
				{	soap_flag_Radius1--;
					continue;
				}
			}
			if (soap_flag_Transmittance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Transmittance", &a->tt__LensProjection::Transmittance, "xsd:float"))
				{	soap_flag_Transmittance1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__LensProjection::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Angle1 > 0 || soap_flag_Radius1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__LensProjection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LensProjection, SOAP_TYPE_tt__LensProjection, sizeof(tt__LensProjection), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LensProjection * SOAP_FMAC2 imageing_instantiate_tt__LensProjection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__LensProjection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LensProjection *p;
	size_t k = sizeof(tt__LensProjection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LensProjection, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LensProjection);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LensProjection, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LensProjection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LensProjection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LensProjection(soap, tag ? tag : "tt:LensProjection", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LensProjection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LensProjection(soap, this, tag, type);
}

SOAP_FMAC3 tt__LensProjection * SOAP_FMAC4 soap_get_tt__LensProjection(struct soap *soap, tt__LensProjection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LensProjection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RotateExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__RotateExtension::__any);
}

void tt__RotateExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__RotateExtension::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RotateExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RotateExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateExtension(struct soap *soap, const char *tag, int id, const tt__RotateExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateExtension), type ? type : "tt:RotateExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__RotateExtension::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RotateExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RotateExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RotateExtension * SOAP_FMAC4 soap_in_tt__RotateExtension(struct soap *soap, const char *tag, tt__RotateExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RotateExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateExtension, sizeof(tt__RotateExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RotateExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RotateExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__RotateExtension::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RotateExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateExtension, SOAP_TYPE_tt__RotateExtension, sizeof(tt__RotateExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RotateExtension * SOAP_FMAC2 imageing_instantiate_tt__RotateExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__RotateExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RotateExtension *p;
	size_t k = sizeof(tt__RotateExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RotateExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RotateExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RotateExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RotateExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RotateExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RotateExtension(soap, tag ? tag : "tt:RotateExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RotateExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RotateExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RotateExtension * SOAP_FMAC4 soap_get_tt__RotateExtension(struct soap *soap, tt__RotateExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Rotate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__RotateMode(soap, &this->tt__Rotate::Mode);
	this->tt__Rotate::Degree = NULL;
	this->tt__Rotate::Extension = NULL;
	this->tt__Rotate::__anyAttribute = NULL;
}

void tt__Rotate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->tt__Rotate::Degree);
	soap_serialize_PointerTott__RotateExtension(soap, &this->tt__Rotate::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Rotate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Rotate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rotate(struct soap *soap, const char *tag, int id, const tt__Rotate *a, const char *type)
{
	if (((tt__Rotate*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__Rotate*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rotate), type ? type : "tt:Rotate"))
		return soap->error;
	if (soap_out_tt__RotateMode(soap, "tt:Mode", -1, &a->tt__Rotate::Mode, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:Degree", -1, &a->tt__Rotate::Degree, ""))
		return soap->error;
	if (soap_out_PointerTott__RotateExtension(soap, "tt:Extension", -1, &a->tt__Rotate::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Rotate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Rotate(soap, tag, this, type);
}

SOAP_FMAC3 tt__Rotate * SOAP_FMAC4 soap_in_tt__Rotate(struct soap *soap, const char *tag, tt__Rotate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Rotate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rotate, sizeof(tt__Rotate), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Rotate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Rotate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__Rotate*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Degree1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RotateMode(soap, "tt:Mode", &a->tt__Rotate::Mode, "tt:RotateMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Degree1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:Degree", &a->tt__Rotate::Degree, "xsd:int"))
				{	soap_flag_Degree1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RotateExtension(soap, "tt:Extension", &a->tt__Rotate::Extension, "tt:RotateExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Rotate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rotate, SOAP_TYPE_tt__Rotate, sizeof(tt__Rotate), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Rotate * SOAP_FMAC2 imageing_instantiate_tt__Rotate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__Rotate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Rotate *p;
	size_t k = sizeof(tt__Rotate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Rotate, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Rotate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Rotate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Rotate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Rotate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Rotate(soap, tag ? tag : "tt:Rotate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Rotate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Rotate(soap, this, tag, type);
}

SOAP_FMAC3 tt__Rotate * SOAP_FMAC4 soap_get_tt__Rotate(struct soap *soap, tt__Rotate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rotate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfigurationExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__LensDescription(soap, &this->tt__VideoSourceConfigurationExtension2::LensDescription);
	this->tt__VideoSourceConfigurationExtension2::SceneOrientation = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__VideoSourceConfigurationExtension2::__any);
}

void tt__VideoSourceConfigurationExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__LensDescription(soap, &this->tt__VideoSourceConfigurationExtension2::LensDescription);
	soap_serialize_PointerTott__SceneOrientation(soap, &this->tt__VideoSourceConfigurationExtension2::SceneOrientation);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__VideoSourceConfigurationExtension2::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2), type ? type : "tt:VideoSourceConfigurationExtension2"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__LensDescription(soap, "tt:LensDescription", -1, &a->tt__VideoSourceConfigurationExtension2::LensDescription, ""))
		return soap->error;
	if (soap_out_PointerTott__SceneOrientation(soap, "tt:SceneOrientation", -1, &a->tt__VideoSourceConfigurationExtension2::SceneOrientation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__VideoSourceConfigurationExtension2::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(tt__VideoSourceConfigurationExtension2), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfigurationExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfigurationExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_SceneOrientation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LensDescription(soap, "tt:LensDescription", &a->tt__VideoSourceConfigurationExtension2::LensDescription, "tt:LensDescription"))
					continue;
			}
			if (soap_flag_SceneOrientation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SceneOrientation(soap, "tt:SceneOrientation", &a->tt__VideoSourceConfigurationExtension2::SceneOrientation, "tt:SceneOrientation"))
				{	soap_flag_SceneOrientation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__VideoSourceConfigurationExtension2::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(tt__VideoSourceConfigurationExtension2), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC2 imageing_instantiate_tt__VideoSourceConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__VideoSourceConfigurationExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfigurationExtension2 *p;
	size_t k = sizeof(tt__VideoSourceConfigurationExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfigurationExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfigurationExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfigurationExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfigurationExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoSourceConfigurationExtension::Rotate = NULL;
	this->tt__VideoSourceConfigurationExtension::Extension = NULL;
}

void tt__VideoSourceConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Rotate(soap, &this->tt__VideoSourceConfigurationExtension::Rotate);
	soap_serialize_PointerTott__VideoSourceConfigurationExtension2(soap, &this->tt__VideoSourceConfigurationExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension), type ? type : "tt:VideoSourceConfigurationExtension"))
		return soap->error;
	if (soap_out_PointerTott__Rotate(soap, "tt:Rotate", -1, &a->tt__VideoSourceConfigurationExtension::Rotate, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationExtension2(soap, "tt:Extension", -1, &a->tt__VideoSourceConfigurationExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(tt__VideoSourceConfigurationExtension), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Rotate1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Rotate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Rotate(soap, "tt:Rotate", &a->tt__VideoSourceConfigurationExtension::Rotate, "tt:Rotate"))
				{	soap_flag_Rotate1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationExtension2(soap, "tt:Extension", &a->tt__VideoSourceConfigurationExtension::Extension, "tt:VideoSourceConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationExtension, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(tt__VideoSourceConfigurationExtension), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__VideoSourceConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__VideoSourceConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfigurationExtension *p;
	size_t k = sizeof(tt__VideoSourceConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfigurationExtension, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfigurationExtension(soap, tag ? tag : "tt:VideoSourceConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__VideoSourceConfiguration::SourceToken);
	this->tt__VideoSourceConfiguration::Bounds = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->tt__VideoSourceConfiguration::__any);
	this->tt__VideoSourceConfiguration::Extension = NULL;
	this->tt__VideoSourceConfiguration::ViewMode = NULL;
	this->tt__VideoSourceConfiguration::__anyAttribute = NULL;
}

void tt__VideoSourceConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->tt__VideoSourceConfiguration::SourceToken);
	soap_serialize_PointerTott__IntRectangle(soap, &this->tt__VideoSourceConfiguration::Bounds);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tt__VideoSourceConfiguration::__any);
	soap_serialize_PointerTott__VideoSourceConfigurationExtension(soap, &this->tt__VideoSourceConfiguration::Extension);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfiguration *a, const char *type)
{
	if (((tt__VideoSourceConfiguration*)a)->ViewMode)
	{	soap_set_attr(soap, "ViewMode", soap_std__string2s(soap, *((tt__VideoSourceConfiguration*)a)->ViewMode), 1);
	}
	if (((tt__VideoSourceConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__VideoSourceConfiguration*)a)->__anyAttribute, 1);
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfiguration), type ? type : "tt:VideoSourceConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &a->tt__VideoSourceConfiguration::SourceToken, ""))
		return soap->error;
	if (!a->tt__VideoSourceConfiguration::Bounds)
	{	if (soap_element_empty(soap, "tt:Bounds", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRectangle(soap, "tt:Bounds", -1, &a->tt__VideoSourceConfiguration::Bounds, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tt__VideoSourceConfiguration::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationExtension(soap, "tt:Extension", -1, &a->tt__VideoSourceConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfiguration * SOAP_FMAC4 soap_in_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, tt__VideoSourceConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(tt__VideoSourceConfiguration), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "ViewMode", 1, 0);
		if (t)
		{
			if (!(((tt__VideoSourceConfiguration*)a)->ViewMode = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((tt__VideoSourceConfiguration*)a)->ViewMode))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tt__VideoSourceConfiguration*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_SourceToken1 = 1;
	size_t soap_flag_Bounds1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_SourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &a->tt__VideoSourceConfiguration::SourceToken, "tt:ReferenceToken"))
				{	soap_flag_SourceToken1--;
					continue;
				}
			}
			if (soap_flag_Bounds1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRectangle(soap, "tt:Bounds", &a->tt__VideoSourceConfiguration::Bounds, "tt:IntRectangle"))
				{	soap_flag_Bounds1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationExtension(soap, "tt:Extension", &a->tt__VideoSourceConfiguration::Extension, "tt:VideoSourceConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tt__VideoSourceConfiguration::__any, ""))
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_SourceToken1 > 0 || !a->tt__VideoSourceConfiguration::Bounds))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfiguration, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(tt__VideoSourceConfiguration), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfiguration * SOAP_FMAC2 imageing_instantiate_tt__VideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__VideoSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfiguration *p;
	size_t k = sizeof(tt__VideoSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfiguration, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfiguration(soap, tag ? tag : "tt:VideoSourceConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfiguration * SOAP_FMAC4 soap_get_tt__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ConfigurationEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_default_int(soap, &this->tt__ConfigurationEntity::UseCount);
	soap_default_tt__ReferenceToken(soap, &this->tt__ConfigurationEntity::token);
}

void tt__ConfigurationEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_embedded(soap, &this->tt__ConfigurationEntity::UseCount, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ConfigurationEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ConfigurationEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigurationEntity(struct soap *soap, const char *tag, int id, const tt__ConfigurationEntity *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigurationEntity), type ? type : "tt:ConfigurationEntity"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ConfigurationEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ConfigurationEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_in_tt__ConfigurationEntity(struct soap *soap, const char *tag, tt__ConfigurationEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ConfigurationEntity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigurationEntity, sizeof(tt__ConfigurationEntity), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ConfigurationEntity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ConfigurationEntity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_UseCount1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_UseCount1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_UseCount1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ConfigurationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigurationEntity, SOAP_TYPE_tt__ConfigurationEntity, sizeof(tt__ConfigurationEntity), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 imageing_instantiate_tt__ConfigurationEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__ConfigurationEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceConfiguration"))
		return imageing_instantiate_tt__VideoSourceConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoEncoderConfiguration"))
		return imageing_instantiate_tt__VideoEncoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioSourceConfiguration"))
		return imageing_instantiate_tt__AudioSourceConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioEncoderConfiguration"))
		return imageing_instantiate_tt__AudioEncoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoAnalyticsConfiguration"))
		return imageing_instantiate_tt__VideoAnalyticsConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MetadataConfiguration"))
		return imageing_instantiate_tt__MetadataConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioOutputConfiguration"))
		return imageing_instantiate_tt__AudioOutputConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioDecoderConfiguration"))
		return imageing_instantiate_tt__AudioDecoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZConfiguration"))
		return imageing_instantiate_tt__PTZConfiguration(soap, n, NULL, NULL, size);
	tt__ConfigurationEntity *p;
	size_t k = sizeof(tt__ConfigurationEntity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ConfigurationEntity, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ConfigurationEntity);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ConfigurationEntity, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ConfigurationEntity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ConfigurationEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ConfigurationEntity(soap, tag ? tag : "tt:ConfigurationEntity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ConfigurationEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ConfigurationEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_get_tt__ConfigurationEntity(struct soap *soap, tt__ConfigurationEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigurationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DurationRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__duration(soap, &this->tt__DurationRange::Min);
	soap_default_xsd__duration(soap, &this->tt__DurationRange::Max);
}

void tt__DurationRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DurationRange::Min, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__DurationRange::Min);
	soap_embedded(soap, &this->tt__DurationRange::Max, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__DurationRange::Max);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DurationRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DurationRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DurationRange(struct soap *soap, const char *tag, int id, const tt__DurationRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DurationRange), type ? type : "tt:DurationRange"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Min", -1, &a->tt__DurationRange::Min, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Max", -1, &a->tt__DurationRange::Max, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DurationRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DurationRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_in_tt__DurationRange(struct soap *soap, const char *tag, tt__DurationRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DurationRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DurationRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DurationRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:Min", &a->tt__DurationRange::Min, "xsd:duration"))
				{	soap_flag_Min1--;
					continue;
				}
			}
			if (soap_flag_Max1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:Max", &a->tt__DurationRange::Max, "xsd:duration"))
				{	soap_flag_Max1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DurationRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DurationRange, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 imageing_instantiate_tt__DurationRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__DurationRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DurationRange *p;
	size_t k = sizeof(tt__DurationRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DurationRange, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DurationRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DurationRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DurationRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DurationRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DurationRange(soap, tag ? tag : "tt:DurationRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DurationRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DurationRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_get_tt__DurationRange(struct soap *soap, tt__DurationRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FloatRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__FloatRange::Min);
	soap_default_float(soap, &this->tt__FloatRange::Max);
}

void tt__FloatRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__FloatRange::Min, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FloatRange::Max, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FloatRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FloatRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatRange(struct soap *soap, const char *tag, int id, const tt__FloatRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatRange), type ? type : "tt:FloatRange"))
		return soap->error;
	if (soap_out_float(soap, "tt:Min", -1, &a->tt__FloatRange::Min, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Max", -1, &a->tt__FloatRange::Max, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FloatRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FloatRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_in_tt__FloatRange(struct soap *soap, const char *tag, tt__FloatRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FloatRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FloatRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FloatRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Min", &a->tt__FloatRange::Min, "xsd:float"))
				{	soap_flag_Min1--;
					continue;
				}
			}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Max", &a->tt__FloatRange::Max, "xsd:float"))
				{	soap_flag_Max1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FloatRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatRange, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 imageing_instantiate_tt__FloatRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__FloatRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FloatRange *p;
	size_t k = sizeof(tt__FloatRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FloatRange, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FloatRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FloatRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FloatRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FloatRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FloatRange(soap, tag ? tag : "tt:FloatRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FloatRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FloatRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_get_tt__FloatRange(struct soap *soap, tt__FloatRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IntRectangleRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__IntRectangleRange::XRange = NULL;
	this->tt__IntRectangleRange::YRange = NULL;
	this->tt__IntRectangleRange::WidthRange = NULL;
	this->tt__IntRectangleRange::HeightRange = NULL;
}

void tt__IntRectangleRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::XRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::YRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::WidthRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::HeightRange);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IntRectangleRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRectangleRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangleRange(struct soap *soap, const char *tag, int id, const tt__IntRectangleRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangleRange), type ? type : "tt:IntRectangleRange"))
		return soap->error;
	if (!a->tt__IntRectangleRange::XRange)
	{	if (soap_element_empty(soap, "tt:XRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:XRange", -1, &a->tt__IntRectangleRange::XRange, ""))
		return soap->error;
	if (!a->tt__IntRectangleRange::YRange)
	{	if (soap_element_empty(soap, "tt:YRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:YRange", -1, &a->tt__IntRectangleRange::YRange, ""))
		return soap->error;
	if (!a->tt__IntRectangleRange::WidthRange)
	{	if (soap_element_empty(soap, "tt:WidthRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:WidthRange", -1, &a->tt__IntRectangleRange::WidthRange, ""))
		return soap->error;
	if (!a->tt__IntRectangleRange::HeightRange)
	{	if (soap_element_empty(soap, "tt:HeightRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:HeightRange", -1, &a->tt__IntRectangleRange::HeightRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IntRectangleRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IntRectangleRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRectangleRange * SOAP_FMAC4 soap_in_tt__IntRectangleRange(struct soap *soap, const char *tag, tt__IntRectangleRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRectangleRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangleRange, sizeof(tt__IntRectangleRange), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IntRectangleRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IntRectangleRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XRange1 = 1;
	size_t soap_flag_YRange1 = 1;
	size_t soap_flag_WidthRange1 = 1;
	size_t soap_flag_HeightRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:XRange", &a->tt__IntRectangleRange::XRange, "tt:IntRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			}
			if (soap_flag_YRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:YRange", &a->tt__IntRectangleRange::YRange, "tt:IntRange"))
				{	soap_flag_YRange1--;
					continue;
				}
			}
			if (soap_flag_WidthRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:WidthRange", &a->tt__IntRectangleRange::WidthRange, "tt:IntRange"))
				{	soap_flag_WidthRange1--;
					continue;
				}
			}
			if (soap_flag_HeightRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:HeightRange", &a->tt__IntRectangleRange::HeightRange, "tt:IntRange"))
				{	soap_flag_HeightRange1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__IntRectangleRange::XRange || !a->tt__IntRectangleRange::YRange || !a->tt__IntRectangleRange::WidthRange || !a->tt__IntRectangleRange::HeightRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IntRectangleRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangleRange, SOAP_TYPE_tt__IntRectangleRange, sizeof(tt__IntRectangleRange), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntRectangleRange * SOAP_FMAC2 imageing_instantiate_tt__IntRectangleRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__IntRectangleRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IntRectangleRange *p;
	size_t k = sizeof(tt__IntRectangleRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IntRectangleRange, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IntRectangleRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IntRectangleRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IntRectangleRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IntRectangleRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IntRectangleRange(soap, tag ? tag : "tt:IntRectangleRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRectangleRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRectangleRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRectangleRange * SOAP_FMAC4 soap_get_tt__IntRectangleRange(struct soap *soap, tt__IntRectangleRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IntRectangle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__IntRectangle::x);
	soap_default_int(soap, &this->tt__IntRectangle::y);
	soap_default_int(soap, &this->tt__IntRectangle::width);
	soap_default_int(soap, &this->tt__IntRectangle::height);
}

void tt__IntRectangle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IntRectangle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRectangle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangle(struct soap *soap, const char *tag, int id, const tt__IntRectangle *a, const char *type)
{
	soap_set_attr(soap, "x", soap_int2s(soap, ((tt__IntRectangle*)a)->x), 1);
	soap_set_attr(soap, "y", soap_int2s(soap, ((tt__IntRectangle*)a)->y), 1);
	soap_set_attr(soap, "width", soap_int2s(soap, ((tt__IntRectangle*)a)->width), 1);
	soap_set_attr(soap, "height", soap_int2s(soap, ((tt__IntRectangle*)a)->height), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:IntRectangle");
}

void *tt__IntRectangle::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IntRectangle(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRectangle * SOAP_FMAC4 soap_in_tt__IntRectangle(struct soap *soap, const char *tag, tt__IntRectangle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IntRectangle*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangle, sizeof(tt__IntRectangle), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IntRectangle)
		return (tt__IntRectangle *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2int(soap, soap_attr_value(soap, "x", 5, 1), &((tt__IntRectangle*)a)->x))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "y", 5, 1), &((tt__IntRectangle*)a)->y))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "width", 5, 1), &((tt__IntRectangle*)a)->width))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "height", 5, 1), &((tt__IntRectangle*)a)->height))
		return NULL;
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IntRectangle * SOAP_FMAC2 imageing_instantiate_tt__IntRectangle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_tt__IntRectangle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IntRectangle *p;
	size_t k = sizeof(tt__IntRectangle);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IntRectangle, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IntRectangle);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IntRectangle, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IntRectangle location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IntRectangle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IntRectangle(soap, tag ? tag : "tt:IntRectangle", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRectangle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRectangle(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRectangle * SOAP_FMAC4 soap_get_tt__IntRectangle(struct soap *soap, tt__IntRectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__SetCurrentPresetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _timg__SetCurrentPresetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _timg__SetCurrentPresetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__SetCurrentPresetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetCurrentPresetResponse(struct soap *soap, const char *tag, int id, const _timg__SetCurrentPresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetCurrentPresetResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__SetCurrentPresetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__SetCurrentPresetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _timg__SetCurrentPresetResponse * SOAP_FMAC4 soap_in__timg__SetCurrentPresetResponse(struct soap *soap, const char *tag, _timg__SetCurrentPresetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__SetCurrentPresetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetCurrentPresetResponse, sizeof(_timg__SetCurrentPresetResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__SetCurrentPresetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__SetCurrentPresetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_timg__SetCurrentPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetCurrentPresetResponse, SOAP_TYPE__timg__SetCurrentPresetResponse, sizeof(_timg__SetCurrentPresetResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__SetCurrentPresetResponse * SOAP_FMAC2 imageing_instantiate__timg__SetCurrentPresetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__SetCurrentPresetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__SetCurrentPresetResponse *p;
	size_t k = sizeof(_timg__SetCurrentPresetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__SetCurrentPresetResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__SetCurrentPresetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__SetCurrentPresetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__SetCurrentPresetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__SetCurrentPresetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__SetCurrentPresetResponse(soap, tag ? tag : "timg:SetCurrentPresetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__SetCurrentPresetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__SetCurrentPresetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _timg__SetCurrentPresetResponse * SOAP_FMAC4 soap_get__timg__SetCurrentPresetResponse(struct soap *soap, _timg__SetCurrentPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetCurrentPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__SetCurrentPreset::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_timg__SetCurrentPreset::VideoSourceToken);
	soap_default_tt__ReferenceToken(soap, &this->_timg__SetCurrentPreset::PresetToken);
}

void _timg__SetCurrentPreset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->_timg__SetCurrentPreset::VideoSourceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_timg__SetCurrentPreset::PresetToken);
#endif
}

int _timg__SetCurrentPreset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__SetCurrentPreset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetCurrentPreset(struct soap *soap, const char *tag, int id, const _timg__SetCurrentPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetCurrentPreset), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->_timg__SetCurrentPreset::VideoSourceToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "timg:PresetToken", -1, &a->_timg__SetCurrentPreset::PresetToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__SetCurrentPreset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__SetCurrentPreset(soap, tag, this, type);
}

SOAP_FMAC3 _timg__SetCurrentPreset * SOAP_FMAC4 soap_in__timg__SetCurrentPreset(struct soap *soap, const char *tag, _timg__SetCurrentPreset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__SetCurrentPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetCurrentPreset, sizeof(_timg__SetCurrentPreset), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__SetCurrentPreset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__SetCurrentPreset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_VideoSourceToken1 = 1;
	size_t soap_flag_PresetToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->_timg__SetCurrentPreset::VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken1--;
					continue;
				}
			}
			if (soap_flag_PresetToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:PresetToken", &a->_timg__SetCurrentPreset::PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken1 > 0 || soap_flag_PresetToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__SetCurrentPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetCurrentPreset, SOAP_TYPE__timg__SetCurrentPreset, sizeof(_timg__SetCurrentPreset), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__SetCurrentPreset * SOAP_FMAC2 imageing_instantiate__timg__SetCurrentPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__SetCurrentPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__SetCurrentPreset *p;
	size_t k = sizeof(_timg__SetCurrentPreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__SetCurrentPreset, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__SetCurrentPreset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__SetCurrentPreset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__SetCurrentPreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__SetCurrentPreset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__SetCurrentPreset(soap, tag ? tag : "timg:SetCurrentPreset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__SetCurrentPreset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__SetCurrentPreset(soap, this, tag, type);
}

SOAP_FMAC3 _timg__SetCurrentPreset * SOAP_FMAC4 soap_get__timg__SetCurrentPreset(struct soap *soap, _timg__SetCurrentPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetCurrentPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetCurrentPresetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_timg__GetCurrentPresetResponse::Preset = NULL;
}

void _timg__GetCurrentPresetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotimg__ImagingPreset(soap, &this->_timg__GetCurrentPresetResponse::Preset);
#endif
}

int _timg__GetCurrentPresetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetCurrentPresetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetCurrentPresetResponse(struct soap *soap, const char *tag, int id, const _timg__GetCurrentPresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetCurrentPresetResponse), type))
		return soap->error;
	if (a->Preset)
		soap_element_result(soap, "timg:Preset");
	if (soap_out_PointerTotimg__ImagingPreset(soap, "timg:Preset", -1, &a->_timg__GetCurrentPresetResponse::Preset, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetCurrentPresetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetCurrentPresetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetCurrentPresetResponse * SOAP_FMAC4 soap_in__timg__GetCurrentPresetResponse(struct soap *soap, const char *tag, _timg__GetCurrentPresetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetCurrentPresetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetCurrentPresetResponse, sizeof(_timg__GetCurrentPresetResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetCurrentPresetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetCurrentPresetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Preset1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Preset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotimg__ImagingPreset(soap, "timg:Preset", &a->_timg__GetCurrentPresetResponse::Preset, "timg:ImagingPreset"))
				{	soap_flag_Preset1--;
					continue;
				}
			}
			soap_check_result(soap, "timg:Preset");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_timg__GetCurrentPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetCurrentPresetResponse, SOAP_TYPE__timg__GetCurrentPresetResponse, sizeof(_timg__GetCurrentPresetResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetCurrentPresetResponse * SOAP_FMAC2 imageing_instantiate__timg__GetCurrentPresetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetCurrentPresetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetCurrentPresetResponse *p;
	size_t k = sizeof(_timg__GetCurrentPresetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetCurrentPresetResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetCurrentPresetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetCurrentPresetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetCurrentPresetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetCurrentPresetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetCurrentPresetResponse(soap, tag ? tag : "timg:GetCurrentPresetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetCurrentPresetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetCurrentPresetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetCurrentPresetResponse * SOAP_FMAC4 soap_get__timg__GetCurrentPresetResponse(struct soap *soap, _timg__GetCurrentPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetCurrentPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetCurrentPreset::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_timg__GetCurrentPreset::VideoSourceToken);
}

void _timg__GetCurrentPreset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->_timg__GetCurrentPreset::VideoSourceToken);
#endif
}

int _timg__GetCurrentPreset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetCurrentPreset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetCurrentPreset(struct soap *soap, const char *tag, int id, const _timg__GetCurrentPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetCurrentPreset), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->_timg__GetCurrentPreset::VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetCurrentPreset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetCurrentPreset(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetCurrentPreset * SOAP_FMAC4 soap_in__timg__GetCurrentPreset(struct soap *soap, const char *tag, _timg__GetCurrentPreset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetCurrentPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetCurrentPreset, sizeof(_timg__GetCurrentPreset), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetCurrentPreset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetCurrentPreset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_VideoSourceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->_timg__GetCurrentPreset::VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__GetCurrentPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetCurrentPreset, SOAP_TYPE__timg__GetCurrentPreset, sizeof(_timg__GetCurrentPreset), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetCurrentPreset * SOAP_FMAC2 imageing_instantiate__timg__GetCurrentPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetCurrentPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetCurrentPreset *p;
	size_t k = sizeof(_timg__GetCurrentPreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetCurrentPreset, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetCurrentPreset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetCurrentPreset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetCurrentPreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetCurrentPreset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetCurrentPreset(soap, tag ? tag : "timg:GetCurrentPreset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetCurrentPreset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetCurrentPreset(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetCurrentPreset * SOAP_FMAC4 soap_get__timg__GetCurrentPreset(struct soap *soap, _timg__GetCurrentPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetCurrentPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetPresetsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotimg__ImagingPreset(soap, &this->_timg__GetPresetsResponse::Preset);
}

void _timg__GetPresetsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTotimg__ImagingPreset(soap, &this->_timg__GetPresetsResponse::Preset);
#endif
}

int _timg__GetPresetsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetPresetsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetPresetsResponse(struct soap *soap, const char *tag, int id, const _timg__GetPresetsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetPresetsResponse), type))
		return soap->error;
	soap_element_result(soap, "timg:Preset");
	if (soap_out_std__vectorTemplateOfPointerTotimg__ImagingPreset(soap, "timg:Preset", -1, &a->_timg__GetPresetsResponse::Preset, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetPresetsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetPresetsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetPresetsResponse * SOAP_FMAC4 soap_in__timg__GetPresetsResponse(struct soap *soap, const char *tag, _timg__GetPresetsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetPresetsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetPresetsResponse, sizeof(_timg__GetPresetsResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetPresetsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetPresetsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTotimg__ImagingPreset(soap, "timg:Preset", &a->_timg__GetPresetsResponse::Preset, "timg:ImagingPreset"))
					continue;
			}
			soap_check_result(soap, "timg:Preset");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_timg__GetPresetsResponse::Preset.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__GetPresetsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetPresetsResponse, SOAP_TYPE__timg__GetPresetsResponse, sizeof(_timg__GetPresetsResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetPresetsResponse * SOAP_FMAC2 imageing_instantiate__timg__GetPresetsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetPresetsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetPresetsResponse *p;
	size_t k = sizeof(_timg__GetPresetsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetPresetsResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetPresetsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetPresetsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetPresetsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetPresetsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetPresetsResponse(soap, tag ? tag : "timg:GetPresetsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetPresetsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetPresetsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetPresetsResponse * SOAP_FMAC4 soap_get__timg__GetPresetsResponse(struct soap *soap, _timg__GetPresetsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetPresetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetPresets::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_timg__GetPresets::VideoSourceToken);
}

void _timg__GetPresets::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->_timg__GetPresets::VideoSourceToken);
#endif
}

int _timg__GetPresets::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetPresets(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetPresets(struct soap *soap, const char *tag, int id, const _timg__GetPresets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetPresets), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->_timg__GetPresets::VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetPresets::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetPresets(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetPresets * SOAP_FMAC4 soap_in__timg__GetPresets(struct soap *soap, const char *tag, _timg__GetPresets *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetPresets*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetPresets, sizeof(_timg__GetPresets), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetPresets)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetPresets *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_VideoSourceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->_timg__GetPresets::VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__GetPresets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetPresets, SOAP_TYPE__timg__GetPresets, sizeof(_timg__GetPresets), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetPresets * SOAP_FMAC2 imageing_instantiate__timg__GetPresets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetPresets(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetPresets *p;
	size_t k = sizeof(_timg__GetPresets);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetPresets, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetPresets);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetPresets, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetPresets location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetPresets::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetPresets(soap, tag ? tag : "timg:GetPresets", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetPresets::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetPresets(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetPresets * SOAP_FMAC4 soap_get__timg__GetPresets(struct soap *soap, _timg__GetPresets *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_timg__GetStatusResponse::Status = NULL;
}

void _timg__GetStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ImagingStatus20(soap, &this->_timg__GetStatusResponse::Status);
#endif
}

int _timg__GetStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetStatusResponse(struct soap *soap, const char *tag, int id, const _timg__GetStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetStatusResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "timg:Status");
	if (!a->_timg__GetStatusResponse::Status)
	{	if (soap_element_empty(soap, "timg:Status", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ImagingStatus20(soap, "timg:Status", -1, &a->_timg__GetStatusResponse::Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetStatusResponse * SOAP_FMAC4 soap_in__timg__GetStatusResponse(struct soap *soap, const char *tag, _timg__GetStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetStatusResponse, sizeof(_timg__GetStatusResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetStatusResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetStatusResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Status1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingStatus20(soap, "timg:Status", &a->_timg__GetStatusResponse::Status, "tt:ImagingStatus20"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			soap_check_result(soap, "timg:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_timg__GetStatusResponse::Status))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetStatusResponse, SOAP_TYPE__timg__GetStatusResponse, sizeof(_timg__GetStatusResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetStatusResponse * SOAP_FMAC2 imageing_instantiate__timg__GetStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetStatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetStatusResponse *p;
	size_t k = sizeof(_timg__GetStatusResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetStatusResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetStatusResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetStatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetStatusResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetStatusResponse(soap, tag ? tag : "timg:GetStatusResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetStatusResponse * SOAP_FMAC4 soap_get__timg__GetStatusResponse(struct soap *soap, _timg__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_timg__GetStatus::VideoSourceToken);
}

void _timg__GetStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->_timg__GetStatus::VideoSourceToken);
#endif
}

int _timg__GetStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetStatus(struct soap *soap, const char *tag, int id, const _timg__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetStatus), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->_timg__GetStatus::VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetStatus(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetStatus * SOAP_FMAC4 soap_in__timg__GetStatus(struct soap *soap, const char *tag, _timg__GetStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetStatus, sizeof(_timg__GetStatus), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_VideoSourceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->_timg__GetStatus::VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetStatus, SOAP_TYPE__timg__GetStatus, sizeof(_timg__GetStatus), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetStatus * SOAP_FMAC2 imageing_instantiate__timg__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetStatus *p;
	size_t k = sizeof(_timg__GetStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetStatus, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetStatus(soap, tag ? tag : "timg:GetStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetStatus(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetStatus * SOAP_FMAC4 soap_get__timg__GetStatus(struct soap *soap, _timg__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__StopResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _timg__StopResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _timg__StopResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__StopResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__StopResponse(struct soap *soap, const char *tag, int id, const _timg__StopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__StopResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__StopResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__StopResponse(soap, tag, this, type);
}

SOAP_FMAC3 _timg__StopResponse * SOAP_FMAC4 soap_in__timg__StopResponse(struct soap *soap, const char *tag, _timg__StopResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__StopResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__StopResponse, sizeof(_timg__StopResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__StopResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__StopResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_timg__StopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__StopResponse, SOAP_TYPE__timg__StopResponse, sizeof(_timg__StopResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__StopResponse * SOAP_FMAC2 imageing_instantiate__timg__StopResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__StopResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__StopResponse *p;
	size_t k = sizeof(_timg__StopResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__StopResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__StopResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__StopResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__StopResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__StopResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__StopResponse(soap, tag ? tag : "timg:StopResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__StopResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__StopResponse(soap, this, tag, type);
}

SOAP_FMAC3 _timg__StopResponse * SOAP_FMAC4 soap_get__timg__StopResponse(struct soap *soap, _timg__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__Stop::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_timg__Stop::VideoSourceToken);
}

void _timg__Stop::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->_timg__Stop::VideoSourceToken);
#endif
}

int _timg__Stop::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__Stop(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__Stop(struct soap *soap, const char *tag, int id, const _timg__Stop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__Stop), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->_timg__Stop::VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__Stop::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__Stop(soap, tag, this, type);
}

SOAP_FMAC3 _timg__Stop * SOAP_FMAC4 soap_in__timg__Stop(struct soap *soap, const char *tag, _timg__Stop *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__Stop*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__Stop, sizeof(_timg__Stop), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__Stop)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__Stop *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_VideoSourceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->_timg__Stop::VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__Stop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__Stop, SOAP_TYPE__timg__Stop, sizeof(_timg__Stop), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__Stop * SOAP_FMAC2 imageing_instantiate__timg__Stop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__Stop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__Stop *p;
	size_t k = sizeof(_timg__Stop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__Stop, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__Stop);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__Stop, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__Stop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__Stop::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__Stop(soap, tag ? tag : "timg:Stop", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__Stop::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__Stop(soap, this, tag, type);
}

SOAP_FMAC3 _timg__Stop * SOAP_FMAC4 soap_get__timg__Stop(struct soap *soap, _timg__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetMoveOptionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_timg__GetMoveOptionsResponse::MoveOptions = NULL;
}

void _timg__GetMoveOptionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MoveOptions20(soap, &this->_timg__GetMoveOptionsResponse::MoveOptions);
#endif
}

int _timg__GetMoveOptionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetMoveOptionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, int id, const _timg__GetMoveOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetMoveOptionsResponse), type))
		return soap->error;
	if (a->MoveOptions)
		soap_element_result(soap, "timg:MoveOptions");
	if (!a->_timg__GetMoveOptionsResponse::MoveOptions)
	{	if (soap_element_empty(soap, "timg:MoveOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MoveOptions20(soap, "timg:MoveOptions", -1, &a->_timg__GetMoveOptionsResponse::MoveOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetMoveOptionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetMoveOptionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetMoveOptionsResponse * SOAP_FMAC4 soap_in__timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, _timg__GetMoveOptionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetMoveOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetMoveOptionsResponse, sizeof(_timg__GetMoveOptionsResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetMoveOptionsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetMoveOptionsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoveOptions1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoveOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MoveOptions20(soap, "timg:MoveOptions", &a->_timg__GetMoveOptionsResponse::MoveOptions, "tt:MoveOptions20"))
				{	soap_flag_MoveOptions1--;
					continue;
				}
			}
			soap_check_result(soap, "timg:MoveOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_timg__GetMoveOptionsResponse::MoveOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__GetMoveOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetMoveOptionsResponse, SOAP_TYPE__timg__GetMoveOptionsResponse, sizeof(_timg__GetMoveOptionsResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetMoveOptionsResponse * SOAP_FMAC2 imageing_instantiate__timg__GetMoveOptionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetMoveOptionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetMoveOptionsResponse *p;
	size_t k = sizeof(_timg__GetMoveOptionsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetMoveOptionsResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetMoveOptionsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetMoveOptionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetMoveOptionsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetMoveOptionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetMoveOptionsResponse(soap, tag ? tag : "timg:GetMoveOptionsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetMoveOptionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetMoveOptionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetMoveOptionsResponse * SOAP_FMAC4 soap_get__timg__GetMoveOptionsResponse(struct soap *soap, _timg__GetMoveOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetMoveOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetMoveOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_timg__GetMoveOptions::VideoSourceToken);
}

void _timg__GetMoveOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->_timg__GetMoveOptions::VideoSourceToken);
#endif
}

int _timg__GetMoveOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetMoveOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetMoveOptions(struct soap *soap, const char *tag, int id, const _timg__GetMoveOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetMoveOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->_timg__GetMoveOptions::VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetMoveOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetMoveOptions(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetMoveOptions * SOAP_FMAC4 soap_in__timg__GetMoveOptions(struct soap *soap, const char *tag, _timg__GetMoveOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetMoveOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetMoveOptions, sizeof(_timg__GetMoveOptions), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetMoveOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetMoveOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_VideoSourceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->_timg__GetMoveOptions::VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__GetMoveOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetMoveOptions, SOAP_TYPE__timg__GetMoveOptions, sizeof(_timg__GetMoveOptions), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetMoveOptions * SOAP_FMAC2 imageing_instantiate__timg__GetMoveOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetMoveOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetMoveOptions *p;
	size_t k = sizeof(_timg__GetMoveOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetMoveOptions, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetMoveOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetMoveOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetMoveOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetMoveOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetMoveOptions(soap, tag ? tag : "timg:GetMoveOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetMoveOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetMoveOptions(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetMoveOptions * SOAP_FMAC4 soap_get__timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetMoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__MoveResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _timg__MoveResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _timg__MoveResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__MoveResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__MoveResponse(struct soap *soap, const char *tag, int id, const _timg__MoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__MoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__MoveResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__MoveResponse(soap, tag, this, type);
}

SOAP_FMAC3 _timg__MoveResponse * SOAP_FMAC4 soap_in__timg__MoveResponse(struct soap *soap, const char *tag, _timg__MoveResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__MoveResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__MoveResponse, sizeof(_timg__MoveResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__MoveResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__MoveResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_timg__MoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__MoveResponse, SOAP_TYPE__timg__MoveResponse, sizeof(_timg__MoveResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__MoveResponse * SOAP_FMAC2 imageing_instantiate__timg__MoveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__MoveResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__MoveResponse *p;
	size_t k = sizeof(_timg__MoveResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__MoveResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__MoveResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__MoveResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__MoveResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__MoveResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__MoveResponse(soap, tag ? tag : "timg:MoveResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__MoveResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__MoveResponse(soap, this, tag, type);
}

SOAP_FMAC3 _timg__MoveResponse * SOAP_FMAC4 soap_get__timg__MoveResponse(struct soap *soap, _timg__MoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__MoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__Move::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_timg__Move::VideoSourceToken);
	this->_timg__Move::Focus = NULL;
}

void _timg__Move::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->_timg__Move::VideoSourceToken);
	soap_serialize_PointerTott__FocusMove(soap, &this->_timg__Move::Focus);
#endif
}

int _timg__Move::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__Move(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__Move(struct soap *soap, const char *tag, int id, const _timg__Move *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__Move), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->_timg__Move::VideoSourceToken, ""))
		return soap->error;
	if (!a->_timg__Move::Focus)
	{	if (soap_element_empty(soap, "timg:Focus", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FocusMove(soap, "timg:Focus", -1, &a->_timg__Move::Focus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__Move::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__Move(soap, tag, this, type);
}

SOAP_FMAC3 _timg__Move * SOAP_FMAC4 soap_in__timg__Move(struct soap *soap, const char *tag, _timg__Move *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__Move*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__Move, sizeof(_timg__Move), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__Move)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__Move *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_VideoSourceToken1 = 1;
	size_t soap_flag_Focus1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->_timg__Move::VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken1--;
					continue;
				}
			}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusMove(soap, "timg:Focus", &a->_timg__Move::Focus, "tt:FocusMove"))
				{	soap_flag_Focus1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken1 > 0 || !a->_timg__Move::Focus))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__Move *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__Move, SOAP_TYPE__timg__Move, sizeof(_timg__Move), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__Move * SOAP_FMAC2 imageing_instantiate__timg__Move(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__Move(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__Move *p;
	size_t k = sizeof(_timg__Move);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__Move, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__Move);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__Move, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__Move location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__Move::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__Move(soap, tag ? tag : "timg:Move", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__Move::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__Move(soap, this, tag, type);
}

SOAP_FMAC3 _timg__Move * SOAP_FMAC4 soap_get__timg__Move(struct soap *soap, _timg__Move *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__Move(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetOptionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_timg__GetOptionsResponse::ImagingOptions = NULL;
}

void _timg__GetOptionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ImagingOptions20(soap, &this->_timg__GetOptionsResponse::ImagingOptions);
#endif
}

int _timg__GetOptionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetOptionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetOptionsResponse(struct soap *soap, const char *tag, int id, const _timg__GetOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetOptionsResponse), type))
		return soap->error;
	if (a->ImagingOptions)
		soap_element_result(soap, "timg:ImagingOptions");
	if (!a->_timg__GetOptionsResponse::ImagingOptions)
	{	if (soap_element_empty(soap, "timg:ImagingOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ImagingOptions20(soap, "timg:ImagingOptions", -1, &a->_timg__GetOptionsResponse::ImagingOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetOptionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetOptionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetOptionsResponse * SOAP_FMAC4 soap_in__timg__GetOptionsResponse(struct soap *soap, const char *tag, _timg__GetOptionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetOptionsResponse, sizeof(_timg__GetOptionsResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetOptionsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetOptionsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ImagingOptions1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImagingOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20(soap, "timg:ImagingOptions", &a->_timg__GetOptionsResponse::ImagingOptions, "tt:ImagingOptions20"))
				{	soap_flag_ImagingOptions1--;
					continue;
				}
			}
			soap_check_result(soap, "timg:ImagingOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_timg__GetOptionsResponse::ImagingOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__GetOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetOptionsResponse, SOAP_TYPE__timg__GetOptionsResponse, sizeof(_timg__GetOptionsResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetOptionsResponse * SOAP_FMAC2 imageing_instantiate__timg__GetOptionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetOptionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetOptionsResponse *p;
	size_t k = sizeof(_timg__GetOptionsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetOptionsResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetOptionsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetOptionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetOptionsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetOptionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetOptionsResponse(soap, tag ? tag : "timg:GetOptionsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetOptionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetOptionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetOptionsResponse * SOAP_FMAC4 soap_get__timg__GetOptionsResponse(struct soap *soap, _timg__GetOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_timg__GetOptions::VideoSourceToken);
}

void _timg__GetOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->_timg__GetOptions::VideoSourceToken);
#endif
}

int _timg__GetOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetOptions(struct soap *soap, const char *tag, int id, const _timg__GetOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->_timg__GetOptions::VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetOptions(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetOptions * SOAP_FMAC4 soap_in__timg__GetOptions(struct soap *soap, const char *tag, _timg__GetOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetOptions, sizeof(_timg__GetOptions), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_VideoSourceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->_timg__GetOptions::VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__GetOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetOptions, SOAP_TYPE__timg__GetOptions, sizeof(_timg__GetOptions), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetOptions * SOAP_FMAC2 imageing_instantiate__timg__GetOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetOptions *p;
	size_t k = sizeof(_timg__GetOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetOptions, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetOptions(soap, tag ? tag : "timg:GetOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetOptions(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetOptions * SOAP_FMAC4 soap_get__timg__GetOptions(struct soap *soap, _timg__GetOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__SetImagingSettingsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _timg__SetImagingSettingsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _timg__SetImagingSettingsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__SetImagingSettingsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, int id, const _timg__SetImagingSettingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetImagingSettingsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__SetImagingSettingsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__SetImagingSettingsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _timg__SetImagingSettingsResponse * SOAP_FMAC4 soap_in__timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, _timg__SetImagingSettingsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__SetImagingSettingsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetImagingSettingsResponse, sizeof(_timg__SetImagingSettingsResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__SetImagingSettingsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__SetImagingSettingsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_timg__SetImagingSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetImagingSettingsResponse, SOAP_TYPE__timg__SetImagingSettingsResponse, sizeof(_timg__SetImagingSettingsResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__SetImagingSettingsResponse * SOAP_FMAC2 imageing_instantiate__timg__SetImagingSettingsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__SetImagingSettingsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__SetImagingSettingsResponse *p;
	size_t k = sizeof(_timg__SetImagingSettingsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__SetImagingSettingsResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__SetImagingSettingsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__SetImagingSettingsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__SetImagingSettingsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__SetImagingSettingsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__SetImagingSettingsResponse(soap, tag ? tag : "timg:SetImagingSettingsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__SetImagingSettingsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__SetImagingSettingsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _timg__SetImagingSettingsResponse * SOAP_FMAC4 soap_get__timg__SetImagingSettingsResponse(struct soap *soap, _timg__SetImagingSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__SetImagingSettings::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_timg__SetImagingSettings::VideoSourceToken);
	this->_timg__SetImagingSettings::ImagingSettings = NULL;
	this->_timg__SetImagingSettings::ForcePersistence = NULL;
}

void _timg__SetImagingSettings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->_timg__SetImagingSettings::VideoSourceToken);
	soap_serialize_PointerTott__ImagingSettings20(soap, &this->_timg__SetImagingSettings::ImagingSettings);
	soap_serialize_PointerTobool(soap, &this->_timg__SetImagingSettings::ForcePersistence);
#endif
}

int _timg__SetImagingSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__SetImagingSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetImagingSettings(struct soap *soap, const char *tag, int id, const _timg__SetImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetImagingSettings), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->_timg__SetImagingSettings::VideoSourceToken, ""))
		return soap->error;
	if (!a->_timg__SetImagingSettings::ImagingSettings)
	{	if (soap_element_empty(soap, "timg:ImagingSettings", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", -1, &a->_timg__SetImagingSettings::ImagingSettings, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "timg:ForcePersistence", -1, &a->_timg__SetImagingSettings::ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__SetImagingSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__SetImagingSettings(soap, tag, this, type);
}

SOAP_FMAC3 _timg__SetImagingSettings * SOAP_FMAC4 soap_in__timg__SetImagingSettings(struct soap *soap, const char *tag, _timg__SetImagingSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__SetImagingSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetImagingSettings, sizeof(_timg__SetImagingSettings), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__SetImagingSettings)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__SetImagingSettings *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_VideoSourceToken1 = 1;
	size_t soap_flag_ImagingSettings1 = 1;
	size_t soap_flag_ForcePersistence1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->_timg__SetImagingSettings::VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken1--;
					continue;
				}
			}
			if (soap_flag_ImagingSettings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", &a->_timg__SetImagingSettings::ImagingSettings, "tt:ImagingSettings20"))
				{	soap_flag_ImagingSettings1--;
					continue;
				}
			}
			if (soap_flag_ForcePersistence1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "timg:ForcePersistence", &a->_timg__SetImagingSettings::ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken1 > 0 || !a->_timg__SetImagingSettings::ImagingSettings))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__SetImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetImagingSettings, SOAP_TYPE__timg__SetImagingSettings, sizeof(_timg__SetImagingSettings), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__SetImagingSettings * SOAP_FMAC2 imageing_instantiate__timg__SetImagingSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__SetImagingSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__SetImagingSettings *p;
	size_t k = sizeof(_timg__SetImagingSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__SetImagingSettings, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__SetImagingSettings);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__SetImagingSettings, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__SetImagingSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__SetImagingSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__SetImagingSettings(soap, tag ? tag : "timg:SetImagingSettings", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__SetImagingSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__SetImagingSettings(soap, this, tag, type);
}

SOAP_FMAC3 _timg__SetImagingSettings * SOAP_FMAC4 soap_get__timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetImagingSettingsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_timg__GetImagingSettingsResponse::ImagingSettings = NULL;
}

void _timg__GetImagingSettingsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ImagingSettings20(soap, &this->_timg__GetImagingSettingsResponse::ImagingSettings);
#endif
}

int _timg__GetImagingSettingsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetImagingSettingsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, int id, const _timg__GetImagingSettingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetImagingSettingsResponse), type))
		return soap->error;
	if (a->ImagingSettings)
		soap_element_result(soap, "timg:ImagingSettings");
	if (!a->_timg__GetImagingSettingsResponse::ImagingSettings)
	{	if (soap_element_empty(soap, "timg:ImagingSettings", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", -1, &a->_timg__GetImagingSettingsResponse::ImagingSettings, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetImagingSettingsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetImagingSettingsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetImagingSettingsResponse * SOAP_FMAC4 soap_in__timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, _timg__GetImagingSettingsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetImagingSettingsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetImagingSettingsResponse, sizeof(_timg__GetImagingSettingsResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetImagingSettingsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetImagingSettingsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ImagingSettings1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImagingSettings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", &a->_timg__GetImagingSettingsResponse::ImagingSettings, "tt:ImagingSettings20"))
				{	soap_flag_ImagingSettings1--;
					continue;
				}
			}
			soap_check_result(soap, "timg:ImagingSettings");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_timg__GetImagingSettingsResponse::ImagingSettings))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__GetImagingSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetImagingSettingsResponse, SOAP_TYPE__timg__GetImagingSettingsResponse, sizeof(_timg__GetImagingSettingsResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetImagingSettingsResponse * SOAP_FMAC2 imageing_instantiate__timg__GetImagingSettingsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetImagingSettingsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetImagingSettingsResponse *p;
	size_t k = sizeof(_timg__GetImagingSettingsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetImagingSettingsResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetImagingSettingsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetImagingSettingsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetImagingSettingsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetImagingSettingsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetImagingSettingsResponse(soap, tag ? tag : "timg:GetImagingSettingsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetImagingSettingsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetImagingSettingsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetImagingSettingsResponse * SOAP_FMAC4 soap_get__timg__GetImagingSettingsResponse(struct soap *soap, _timg__GetImagingSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetImagingSettings::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_timg__GetImagingSettings::VideoSourceToken);
}

void _timg__GetImagingSettings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, &this->_timg__GetImagingSettings::VideoSourceToken);
#endif
}

int _timg__GetImagingSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetImagingSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetImagingSettings(struct soap *soap, const char *tag, int id, const _timg__GetImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetImagingSettings), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->_timg__GetImagingSettings::VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetImagingSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetImagingSettings(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetImagingSettings * SOAP_FMAC4 soap_in__timg__GetImagingSettings(struct soap *soap, const char *tag, _timg__GetImagingSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetImagingSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetImagingSettings, sizeof(_timg__GetImagingSettings), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetImagingSettings)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetImagingSettings *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_VideoSourceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->_timg__GetImagingSettings::VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__GetImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetImagingSettings, SOAP_TYPE__timg__GetImagingSettings, sizeof(_timg__GetImagingSettings), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetImagingSettings * SOAP_FMAC2 imageing_instantiate__timg__GetImagingSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetImagingSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetImagingSettings *p;
	size_t k = sizeof(_timg__GetImagingSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetImagingSettings, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetImagingSettings);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetImagingSettings, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetImagingSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetImagingSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetImagingSettings(soap, tag ? tag : "timg:GetImagingSettings", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetImagingSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetImagingSettings(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetImagingSettings * SOAP_FMAC4 soap_get__timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetServiceCapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_timg__GetServiceCapabilitiesResponse::Capabilities = NULL;
}

void _timg__GetServiceCapabilitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotimg__Capabilities(soap, &this->_timg__GetServiceCapabilitiesResponse::Capabilities);
#endif
}

int _timg__GetServiceCapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetServiceCapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const _timg__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "timg:Capabilities");
	if (!a->_timg__GetServiceCapabilitiesResponse::Capabilities)
	{	if (soap_element_empty(soap, "timg:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotimg__Capabilities(soap, "timg:Capabilities", -1, &a->_timg__GetServiceCapabilitiesResponse::Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetServiceCapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetServiceCapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, _timg__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, sizeof(_timg__GetServiceCapabilitiesResponse), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetServiceCapabilitiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetServiceCapabilitiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotimg__Capabilities(soap, "timg:Capabilities", &a->_timg__GetServiceCapabilitiesResponse::Capabilities, "timg:Capabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			soap_check_result(soap, "timg:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_timg__GetServiceCapabilitiesResponse::Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_timg__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, sizeof(_timg__GetServiceCapabilitiesResponse), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetServiceCapabilitiesResponse * SOAP_FMAC2 imageing_instantiate__timg__GetServiceCapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetServiceCapabilitiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetServiceCapabilitiesResponse *p;
	size_t k = sizeof(_timg__GetServiceCapabilitiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetServiceCapabilitiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetServiceCapabilitiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetServiceCapabilitiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetServiceCapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetServiceCapabilitiesResponse(soap, tag ? tag : "timg:GetServiceCapabilitiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetServiceCapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetServiceCapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__timg__GetServiceCapabilitiesResponse(struct soap *soap, _timg__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _timg__GetServiceCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _timg__GetServiceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _timg__GetServiceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__timg__GetServiceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const _timg__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_timg__GetServiceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__timg__GetServiceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 _timg__GetServiceCapabilities * SOAP_FMAC4 soap_in__timg__GetServiceCapabilities(struct soap *soap, const char *tag, _timg__GetServiceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_timg__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(_timg__GetServiceCapabilities), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__timg__GetServiceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_timg__GetServiceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_timg__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetServiceCapabilities, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(_timg__GetServiceCapabilities), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetServiceCapabilities * SOAP_FMAC2 imageing_instantiate__timg__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__timg__GetServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_timg__GetServiceCapabilities *p;
	size_t k = sizeof(_timg__GetServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__timg__GetServiceCapabilities, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _timg__GetServiceCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _timg__GetServiceCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _timg__GetServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _timg__GetServiceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__timg__GetServiceCapabilities(soap, tag ? tag : "timg:GetServiceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_timg__GetServiceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__timg__GetServiceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 _timg__GetServiceCapabilities * SOAP_FMAC4 soap_get__timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void timg__ImagingPreset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__Name(soap, &this->timg__ImagingPreset::Name);
	soap_default_tt__ReferenceToken(soap, &this->timg__ImagingPreset::token);
	soap_default_std__string(soap, &this->timg__ImagingPreset::type);
	this->timg__ImagingPreset::__anyAttribute = NULL;
}

void timg__ImagingPreset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, &this->timg__ImagingPreset::Name);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int timg__ImagingPreset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_timg__ImagingPreset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_timg__ImagingPreset(struct soap *soap, const char *tag, int id, const timg__ImagingPreset *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((timg__ImagingPreset*)a)->token), 1);
	soap_set_attr(soap, "type", soap_std__string2s(soap, ((timg__ImagingPreset*)a)->type), 1);
	if (((timg__ImagingPreset*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((timg__ImagingPreset*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_timg__ImagingPreset), type ? type : "timg:ImagingPreset"))
		return soap->error;
	if (soap_out_tt__Name(soap, "timg:Name", -1, &a->timg__ImagingPreset::Name, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *timg__ImagingPreset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_timg__ImagingPreset(soap, tag, this, type);
}

SOAP_FMAC3 timg__ImagingPreset * SOAP_FMAC4 soap_in_timg__ImagingPreset(struct soap *soap, const char *tag, timg__ImagingPreset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (timg__ImagingPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_timg__ImagingPreset, sizeof(timg__ImagingPreset), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_timg__ImagingPreset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (timg__ImagingPreset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((timg__ImagingPreset*)a)->token))
		return NULL;
	if (soap_s2std__string(soap, soap_attr_value(soap, "type", 1, 1), &((timg__ImagingPreset*)a)->type))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((timg__ImagingPreset*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Name1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "timg:Name", &a->timg__ImagingPreset::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (timg__ImagingPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_timg__ImagingPreset, SOAP_TYPE_timg__ImagingPreset, sizeof(timg__ImagingPreset), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 timg__ImagingPreset * SOAP_FMAC2 imageing_instantiate_timg__ImagingPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_timg__ImagingPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	timg__ImagingPreset *p;
	size_t k = sizeof(timg__ImagingPreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_timg__ImagingPreset, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, timg__ImagingPreset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, timg__ImagingPreset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated timg__ImagingPreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int timg__ImagingPreset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_timg__ImagingPreset(soap, tag ? tag : "timg:ImagingPreset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *timg__ImagingPreset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_timg__ImagingPreset(soap, this, tag, type);
}

SOAP_FMAC3 timg__ImagingPreset * SOAP_FMAC4 soap_get_timg__ImagingPreset(struct soap *soap, timg__ImagingPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in_timg__ImagingPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void timg__Capabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->timg__Capabilities::__any);
	this->timg__Capabilities::ImageStabilization = NULL;
	this->timg__Capabilities::Presets = NULL;
	this->timg__Capabilities::AdaptablePreset = NULL;
	this->timg__Capabilities::__anyAttribute = NULL;
}

void timg__Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->timg__Capabilities::__any);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int timg__Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_timg__Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_timg__Capabilities(struct soap *soap, const char *tag, int id, const timg__Capabilities *a, const char *type)
{
	if (((timg__Capabilities*)a)->ImageStabilization)
	{	soap_set_attr(soap, "ImageStabilization", soap_bool2s(soap, *((timg__Capabilities*)a)->ImageStabilization), 1);
	}
	if (((timg__Capabilities*)a)->Presets)
	{	soap_set_attr(soap, "Presets", soap_bool2s(soap, *((timg__Capabilities*)a)->Presets), 1);
	}
	if (((timg__Capabilities*)a)->AdaptablePreset)
	{	soap_set_attr(soap, "AdaptablePreset", soap_bool2s(soap, *((timg__Capabilities*)a)->AdaptablePreset), 1);
	}
	if (((timg__Capabilities*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((timg__Capabilities*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_timg__Capabilities), type ? type : "timg:Capabilities"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->timg__Capabilities::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *timg__Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_timg__Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 timg__Capabilities * SOAP_FMAC4 soap_in_timg__Capabilities(struct soap *soap, const char *tag, timg__Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (timg__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_timg__Capabilities, sizeof(timg__Capabilities), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_timg__Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (timg__Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "ImageStabilization", 5, 0);
		if (t)
		{
			if (!(((timg__Capabilities*)a)->ImageStabilization = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((timg__Capabilities*)a)->ImageStabilization))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Presets", 5, 0);
		if (t)
		{
			if (!(((timg__Capabilities*)a)->Presets = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((timg__Capabilities*)a)->Presets))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "AdaptablePreset", 5, 0);
		if (t)
		{
			if (!(((timg__Capabilities*)a)->AdaptablePreset = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((timg__Capabilities*)a)->AdaptablePreset))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((timg__Capabilities*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->timg__Capabilities::__any, ""))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (timg__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_timg__Capabilities, SOAP_TYPE_timg__Capabilities, sizeof(timg__Capabilities), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 timg__Capabilities * SOAP_FMAC2 imageing_instantiate_timg__Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_timg__Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	timg__Capabilities *p;
	size_t k = sizeof(timg__Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_timg__Capabilities, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, timg__Capabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, timg__Capabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated timg__Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int timg__Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_timg__Capabilities(soap, tag ? tag : "timg:Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *timg__Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_timg__Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 timg__Capabilities * SOAP_FMAC4 soap_get_timg__Capabilities(struct soap *soap, timg__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_timg__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xml__lang(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out__xml__lang(soap, tag ? tag : "xml:lang", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

void xsd__token__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__token(soap, &this->xsd__token__::__item);
}

void xsd__token__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, &this->xsd__token__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__token__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__token__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token__(struct soap *soap, const char *tag, int id, const xsd__token__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__token(soap, tag, id, &a->xsd__token__::__item, "xsd:token");
}

void *xsd__token__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__token__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__token__ * SOAP_FMAC4 soap_in_xsd__token__(struct soap *soap, const char *tag, xsd__token__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__token__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__token__, sizeof(xsd__token__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__token__)
		return (xsd__token__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__token(soap, tag, &a->xsd__token__::__item, "xsd:token"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__token__ * SOAP_FMAC2 imageing_instantiate_xsd__token__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__token__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__token__ *p;
	size_t k = sizeof(xsd__token__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__token__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__token__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__token__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__token__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__token__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__token__(soap, tag ? tag : "xsd:token", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__token__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__token__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__token__ * SOAP_FMAC4 soap_get_xsd__token__(struct soap *soap, xsd__token__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__token), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_xsd__token, SOAP_TYPE_xsd__token, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__string_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->xsd__string_::__item);
}

void xsd__string_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__string_::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->xsd__string_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__string_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string_(struct soap *soap, const char *tag, int id, const xsd__string_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_std__string(soap, tag, id, &a->xsd__string_::__item, "xsd:string");
}

void *xsd__string_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__string_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string_ * SOAP_FMAC4 soap_in_xsd__string_(struct soap *soap, const char *tag, xsd__string_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string_, sizeof(xsd__string_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__string_)
		return (xsd__string_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_std__string(soap, tag, &a->xsd__string_::__item, "xsd:string"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__string_ * SOAP_FMAC2 imageing_instantiate_xsd__string_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__string_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__string_ *p;
	size_t k = sizeof(xsd__string_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__string_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__string_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__string_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__string_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__string_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__string_(soap, tag ? tag : "xsd:string", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__string_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string_ * SOAP_FMAC4 soap_get_xsd__string_(struct soap *soap, xsd__string_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__nonNegativeInteger__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__nonNegativeInteger(soap, &this->xsd__nonNegativeInteger__::__item);
}

void xsd__nonNegativeInteger__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__nonNegativeInteger__::__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->xsd__nonNegativeInteger__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__nonNegativeInteger__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__nonNegativeInteger__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger__(struct soap *soap, const char *tag, int id, const xsd__nonNegativeInteger__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->xsd__nonNegativeInteger__::__item, "xsd:nonNegativeInteger");
}

void *xsd__nonNegativeInteger__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__nonNegativeInteger__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__nonNegativeInteger__ * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger__(struct soap *soap, const char *tag, xsd__nonNegativeInteger__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__nonNegativeInteger__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__nonNegativeInteger__, sizeof(xsd__nonNegativeInteger__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__nonNegativeInteger__)
		return (xsd__nonNegativeInteger__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->xsd__nonNegativeInteger__::__item, "xsd:nonNegativeInteger"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__nonNegativeInteger__ * SOAP_FMAC2 imageing_instantiate_xsd__nonNegativeInteger__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__nonNegativeInteger__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__nonNegativeInteger__ *p;
	size_t k = sizeof(xsd__nonNegativeInteger__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__nonNegativeInteger__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__nonNegativeInteger__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__nonNegativeInteger__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__nonNegativeInteger__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__nonNegativeInteger__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__nonNegativeInteger__(soap, tag ? tag : "xsd:nonNegativeInteger", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__nonNegativeInteger__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__nonNegativeInteger__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__nonNegativeInteger__ * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger__(struct soap *soap, xsd__nonNegativeInteger__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "\\+?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_xsd__nonNegativeInteger, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__integer__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__integer(soap, &this->xsd__integer__::__item);
}

void xsd__integer__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, &this->xsd__integer__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__integer__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__integer__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer__(struct soap *soap, const char *tag, int id, const xsd__integer__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__integer(soap, tag, id, &a->xsd__integer__::__item, "xsd:integer");
}

void *xsd__integer__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__integer__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__integer__ * SOAP_FMAC4 soap_in_xsd__integer__(struct soap *soap, const char *tag, xsd__integer__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__integer__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__integer__, sizeof(xsd__integer__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__integer__)
		return (xsd__integer__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__integer(soap, tag, &a->xsd__integer__::__item, "xsd:integer"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__integer__ * SOAP_FMAC2 imageing_instantiate_xsd__integer__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__integer__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__integer__ *p;
	size_t k = sizeof(xsd__integer__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__integer__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__integer__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__integer__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__integer__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__integer__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__integer__(soap, tag ? tag : "xsd:integer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__integer__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__integer__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__integer__ * SOAP_FMAC4 soap_get_xsd__integer__(struct soap *soap, xsd__integer__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_xsd__integer, SOAP_TYPE_xsd__integer, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__int_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->xsd__int_::__item);
}

void xsd__int_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__int_::__item, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__int_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int_(struct soap *soap, const char *tag, int id, const xsd__int_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_int(soap, tag, id, &a->xsd__int_::__item, "xsd:int");
}

void *xsd__int_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__int_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int_ * SOAP_FMAC4 soap_in_xsd__int_(struct soap *soap, const char *tag, xsd__int_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int_, sizeof(xsd__int_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__int_)
		return (xsd__int_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_int(soap, tag, &a->xsd__int_::__item, "xsd:int"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__int_ * SOAP_FMAC2 imageing_instantiate_xsd__int_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__int_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__int_ *p;
	size_t k = sizeof(xsd__int_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__int_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__int_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__int_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__int_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__int_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__int_(soap, tag ? tag : "xsd:int", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__int_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int_ * SOAP_FMAC4 soap_get_xsd__int_(struct soap *soap, xsd__int_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__hexBinary__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->xsd__hexBinary__::__item.xsd__hexBinary::soap_default(soap);
}

void xsd__hexBinary__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__hexBinary__::__item.soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__hexBinary__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__hexBinary__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary__(struct soap *soap, const char *tag, int id, const xsd__hexBinary__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return (a->xsd__hexBinary__::__item).soap_out(soap, tag, id, "xsd:hexBinary");
}

void *xsd__hexBinary__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__hexBinary__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__hexBinary__ * SOAP_FMAC4 soap_in_xsd__hexBinary__(struct soap *soap, const char *tag, xsd__hexBinary__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__hexBinary__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary__, sizeof(xsd__hexBinary__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__hexBinary__)
		return (xsd__hexBinary__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!(a->xsd__hexBinary__::__item).soap_in(soap, tag, "xsd:hexBinary"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__hexBinary__ * SOAP_FMAC2 imageing_instantiate_xsd__hexBinary__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__hexBinary__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__hexBinary__ *p;
	size_t k = sizeof(xsd__hexBinary__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__hexBinary__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__hexBinary__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__hexBinary__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__hexBinary__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__hexBinary__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__hexBinary__(soap, tag ? tag : "xsd:hexBinary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__hexBinary__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__hexBinary__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__hexBinary__ * SOAP_FMAC4 soap_get_xsd__hexBinary__(struct soap *soap, xsd__hexBinary__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__float_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->xsd__float_::__item);
}

void xsd__float_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__float_::__item, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__float_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__float_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__float_(struct soap *soap, const char *tag, int id, const xsd__float_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_float(soap, tag, id, &a->xsd__float_::__item, "xsd:float");
}

void *xsd__float_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__float_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__float_ * SOAP_FMAC4 soap_in_xsd__float_(struct soap *soap, const char *tag, xsd__float_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__float_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__float_, sizeof(xsd__float_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__float_)
		return (xsd__float_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_float(soap, tag, &a->xsd__float_::__item, "xsd:float"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__float_ * SOAP_FMAC2 imageing_instantiate_xsd__float_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__float_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__float_ *p;
	size_t k = sizeof(xsd__float_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__float_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__float_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__float_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__float_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__float_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__float_(soap, tag ? tag : "xsd:float", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__float_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__float_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__float_ * SOAP_FMAC4 soap_get_xsd__float_(struct soap *soap, xsd__float_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__float_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__duration__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__duration(soap, &this->xsd__duration__::__item);
}

void xsd__duration__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__duration__::__item, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->xsd__duration__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__duration__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__duration__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration__(struct soap *soap, const char *tag, int id, const xsd__duration__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__duration(soap, tag, id, &a->xsd__duration__::__item, "xsd:duration");
}

void *xsd__duration__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__duration__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__duration__ * SOAP_FMAC4 soap_in_xsd__duration__(struct soap *soap, const char *tag, xsd__duration__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__duration__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__duration__, sizeof(xsd__duration__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__duration__)
		return (xsd__duration__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__duration(soap, tag, &a->xsd__duration__::__item, "xsd:duration"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__duration__ * SOAP_FMAC2 imageing_instantiate_xsd__duration__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__duration__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__duration__ *p;
	size_t k = sizeof(xsd__duration__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__duration__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__duration__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__duration__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__duration__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__duration__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__duration__(soap, tag ? tag : "xsd:duration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__duration__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__duration__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__duration__ * SOAP_FMAC4 soap_get_xsd__duration__(struct soap *soap, xsd__duration__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__duration), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?P(\\d+Y)?(\\d+M)?(\\d+D)?(T(\\d+H)?(\\d+M)?(\\d+(\\.\\d*)?S)?)?")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_xsd__duration, SOAP_TYPE_xsd__duration, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__double_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_double(soap, &this->xsd__double_::__item);
}

void xsd__double_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__double_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__double_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double_(struct soap *soap, const char *tag, int id, const xsd__double_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_double(soap, tag, id, &a->xsd__double_::__item, "xsd:double");
}

void *xsd__double_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__double_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double_ * SOAP_FMAC4 soap_in_xsd__double_(struct soap *soap, const char *tag, xsd__double_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__double_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__double_, sizeof(xsd__double_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__double_)
		return (xsd__double_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_double(soap, tag, &a->xsd__double_::__item, "xsd:double"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__double_ * SOAP_FMAC2 imageing_instantiate_xsd__double_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__double_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__double_ *p;
	size_t k = sizeof(xsd__double_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__double_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__double_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__double_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__double_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__double_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__double_(soap, tag ? tag : "xsd:double", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__double_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__double_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double_ * SOAP_FMAC4 soap_get_xsd__double_(struct soap *soap, xsd__double_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__dateTime_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_dateTime(soap, &this->xsd__dateTime_::__item);
}

void xsd__dateTime_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__dateTime_::__item, SOAP_TYPE_dateTime);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__dateTime_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime_(struct soap *soap, const char *tag, int id, const xsd__dateTime_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_dateTime(soap, tag, id, &a->xsd__dateTime_::__item, "xsd:dateTime");
}

void *xsd__dateTime_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__dateTime_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime_ * SOAP_FMAC4 soap_in_xsd__dateTime_(struct soap *soap, const char *tag, xsd__dateTime_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime_, sizeof(xsd__dateTime_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__dateTime_)
		return (xsd__dateTime_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_dateTime(soap, tag, &a->xsd__dateTime_::__item, "xsd:dateTime"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__dateTime_ * SOAP_FMAC2 imageing_instantiate_xsd__dateTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__dateTime_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__dateTime_ *p;
	size_t k = sizeof(xsd__dateTime_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__dateTime_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__dateTime_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__dateTime_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__dateTime_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__dateTime_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__dateTime_(soap, tag ? tag : "xsd:dateTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__dateTime_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime_ * SOAP_FMAC4 soap_get_xsd__dateTime_(struct soap *soap, xsd__dateTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__boolean_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->xsd__boolean_::__item);
}

void xsd__boolean_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__boolean_::__item, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__boolean_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean_(struct soap *soap, const char *tag, int id, const xsd__boolean_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_bool(soap, tag, id, &a->xsd__boolean_::__item, "xsd:boolean");
}

void *xsd__boolean_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__boolean_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean_ * SOAP_FMAC4 soap_in_xsd__boolean_(struct soap *soap, const char *tag, xsd__boolean_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean_, sizeof(xsd__boolean_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__boolean_)
		return (xsd__boolean_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_bool(soap, tag, &a->xsd__boolean_::__item, "xsd:boolean"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__boolean_ * SOAP_FMAC2 imageing_instantiate_xsd__boolean_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__boolean_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__boolean_ *p;
	size_t k = sizeof(xsd__boolean_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__boolean_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__boolean_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__boolean_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__boolean_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__boolean_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__boolean_(soap, tag ? tag : "xsd:boolean", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__boolean_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean_ * SOAP_FMAC4 soap_get_xsd__boolean_(struct soap *soap, xsd__boolean_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->xsd__base64Binary__::__item.xsd__base64Binary::soap_default(soap);
}

void xsd__base64Binary__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__base64Binary__::__item.soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__base64Binary__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary__(struct soap *soap, const char *tag, int id, const xsd__base64Binary__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return (a->xsd__base64Binary__::__item).soap_out(soap, tag, id, "xsd:base64Binary");
}

void *xsd__base64Binary__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary__ * SOAP_FMAC4 soap_in_xsd__base64Binary__(struct soap *soap, const char *tag, xsd__base64Binary__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__base64Binary__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary__, sizeof(xsd__base64Binary__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__base64Binary__)
		return (xsd__base64Binary__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!(a->xsd__base64Binary__::__item).soap_in(soap, tag, "xsd:base64Binary"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__base64Binary__ * SOAP_FMAC2 imageing_instantiate_xsd__base64Binary__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__base64Binary__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary__ *p;
	size_t k = sizeof(xsd__base64Binary__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__base64Binary__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__base64Binary__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__base64Binary__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__base64Binary__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary__(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary__ * SOAP_FMAC4 soap_get_xsd__base64Binary__(struct soap *soap, xsd__base64Binary__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__anyURI__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->xsd__anyURI__::__item);
}

void xsd__anyURI__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__anyURI__::__item, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->xsd__anyURI__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__anyURI__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyURI__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI__(struct soap *soap, const char *tag, int id, const xsd__anyURI__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__anyURI(soap, tag, id, &a->xsd__anyURI__::__item, "xsd:anyURI");
}

void *xsd__anyURI__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__anyURI__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyURI__ * SOAP_FMAC4 soap_in_xsd__anyURI__(struct soap *soap, const char *tag, xsd__anyURI__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyURI__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyURI__, sizeof(xsd__anyURI__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__anyURI__)
		return (xsd__anyURI__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__anyURI(soap, tag, &a->xsd__anyURI__::__item, "xsd:anyURI"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__anyURI__ * SOAP_FMAC2 imageing_instantiate_xsd__anyURI__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__anyURI__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__anyURI__ *p;
	size_t k = sizeof(xsd__anyURI__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__anyURI__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__anyURI__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__anyURI__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__anyURI__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__anyURI__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__anyURI__(soap, tag ? tag : "xsd:anyURI", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyURI__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyURI__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyURI__ * SOAP_FMAC4 soap_get_xsd__anyURI__(struct soap *soap, xsd__anyURI__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 4, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__anySimpleType__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anySimpleType(soap, &this->xsd__anySimpleType__::__item);
}

void xsd__anySimpleType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anySimpleType(soap, &this->xsd__anySimpleType__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__anySimpleType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anySimpleType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType__(struct soap *soap, const char *tag, int id, const xsd__anySimpleType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__anySimpleType(soap, tag, id, &a->xsd__anySimpleType__::__item, "xsd:anySimpleType");
}

void *xsd__anySimpleType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__anySimpleType__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anySimpleType__ * SOAP_FMAC4 soap_in_xsd__anySimpleType__(struct soap *soap, const char *tag, xsd__anySimpleType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anySimpleType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anySimpleType__, sizeof(xsd__anySimpleType__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__anySimpleType__)
		return (xsd__anySimpleType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__anySimpleType(soap, tag, &a->xsd__anySimpleType__::__item, "xsd:anySimpleType"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__anySimpleType__ * SOAP_FMAC2 imageing_instantiate_xsd__anySimpleType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__anySimpleType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__anySimpleType__ *p;
	size_t k = sizeof(xsd__anySimpleType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__anySimpleType__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__anySimpleType__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__anySimpleType__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__anySimpleType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__anySimpleType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__anySimpleType__(soap, tag ? tag : "xsd:anySimpleType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anySimpleType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anySimpleType__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anySimpleType__ * SOAP_FMAC4 soap_get_xsd__anySimpleType__(struct soap *soap, xsd__anySimpleType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anySimpleType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anySimpleType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_xsd__anySimpleType, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anySimpleType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anySimpleType(soap, tag ? tag : "xsd:anySimpleType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__QName__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__QName(soap, &this->xsd__QName__::__item);
}

void xsd__QName__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__QName__::__item, SOAP_TYPE_xsd__QName);
	soap_serialize_xsd__QName(soap, &this->xsd__QName__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__QName__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__QName__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName__(struct soap *soap, const char *tag, int id, const xsd__QName__ *a, const char *type)
{
	std::string soap_tmp___item(soap_QName2s(soap, a->__item.c_str()));
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__QName(soap, tag, id, &soap_tmp___item, "xsd:QName");
}

void *xsd__QName__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__QName__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__QName__ * SOAP_FMAC4 soap_in_xsd__QName__(struct soap *soap, const char *tag, xsd__QName__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__QName__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__QName__, sizeof(xsd__QName__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__QName__)
		return (xsd__QName__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__QName(soap, tag, &a->xsd__QName__::__item, "xsd:QName"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__QName__ * SOAP_FMAC2 imageing_instantiate_xsd__QName__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__QName__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__QName__ *p;
	size_t k = sizeof(xsd__QName__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__QName__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__QName__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__QName__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__QName__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__QName__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__QName__(soap, tag ? tag : "xsd:QName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__QName__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__QName__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__QName__ * SOAP_FMAC4 soap_get_xsd__QName__(struct soap *soap, xsd__QName__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__NCName__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__NCName(soap, &this->xsd__NCName__::__item);
}

void xsd__NCName__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__NCName__::__item, SOAP_TYPE_xsd__NCName);
	soap_serialize_xsd__NCName(soap, &this->xsd__NCName__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__NCName__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__NCName__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName__(struct soap *soap, const char *tag, int id, const xsd__NCName__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__NCName(soap, tag, id, &a->xsd__NCName__::__item, "xsd:NCName");
}

void *xsd__NCName__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__NCName__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__NCName__ * SOAP_FMAC4 soap_in_xsd__NCName__(struct soap *soap, const char *tag, xsd__NCName__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__NCName__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__NCName__, sizeof(xsd__NCName__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__NCName__)
		return (xsd__NCName__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__NCName(soap, tag, &a->xsd__NCName__::__item, "xsd:NCName"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__NCName__ * SOAP_FMAC2 imageing_instantiate_xsd__NCName__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__NCName__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__NCName__ *p;
	size_t k = sizeof(xsd__NCName__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__NCName__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__NCName__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__NCName__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__NCName__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__NCName__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__NCName__(soap, tag ? tag : "xsd:NCName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__NCName__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__NCName__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__NCName__ * SOAP_FMAC4 soap_get_xsd__NCName__(struct soap *soap, xsd__NCName__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NCName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[\\i-[:]][\\c-[:]]*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_xsd__NCName, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void SOAP_ENV__Fault_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_SOAP_ENV__Fault(soap, &this->SOAP_ENV__Fault_::__item);
}

void SOAP_ENV__Fault_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_SOAP_ENV__Fault(soap, &this->SOAP_ENV__Fault_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int SOAP_ENV__Fault_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_SOAP_ENV__Fault_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault_(struct soap *soap, const char *tag, int id, const SOAP_ENV__Fault_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_SOAP_ENV__Fault(soap, tag, id, &a->SOAP_ENV__Fault_::__item, "");
}

void *SOAP_ENV__Fault_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_SOAP_ENV__Fault_(soap, tag, this, type);
}

SOAP_FMAC3 SOAP_ENV__Fault_ * SOAP_FMAC4 soap_in_SOAP_ENV__Fault_(struct soap *soap, const char *tag, SOAP_ENV__Fault_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (SOAP_ENV__Fault_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault_, sizeof(SOAP_ENV__Fault_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_SOAP_ENV__Fault_)
		return (SOAP_ENV__Fault_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_SOAP_ENV__Fault(soap, tag, &a->SOAP_ENV__Fault_::__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 SOAP_ENV__Fault_ * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Fault_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_SOAP_ENV__Fault_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	SOAP_ENV__Fault_ *p;
	size_t k = sizeof(SOAP_ENV__Fault_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, SOAP_ENV__Fault_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, SOAP_ENV__Fault_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated SOAP_ENV__Fault_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int SOAP_ENV__Fault_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_SOAP_ENV__Fault_(soap, tag ? tag : "SOAP-ENV:Fault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *SOAP_ENV__Fault_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_SOAP_ENV__Fault_(soap, this, tag, type);
}

SOAP_FMAC3 SOAP_ENV__Fault_ * SOAP_FMAC4 soap_get_SOAP_ENV__Fault_(struct soap *soap, SOAP_ENV__Fault_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void SOAP_ENV__Envelope_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_SOAP_ENV__Envelope(soap, &this->SOAP_ENV__Envelope_::__item);
}

void SOAP_ENV__Envelope_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_SOAP_ENV__Envelope(soap, &this->SOAP_ENV__Envelope_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int SOAP_ENV__Envelope_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_SOAP_ENV__Envelope_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Envelope_(struct soap *soap, const char *tag, int id, const SOAP_ENV__Envelope_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_SOAP_ENV__Envelope(soap, tag, id, &a->SOAP_ENV__Envelope_::__item, "");
}

void *SOAP_ENV__Envelope_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_SOAP_ENV__Envelope_(soap, tag, this, type);
}

SOAP_FMAC3 SOAP_ENV__Envelope_ * SOAP_FMAC4 soap_in_SOAP_ENV__Envelope_(struct soap *soap, const char *tag, SOAP_ENV__Envelope_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (SOAP_ENV__Envelope_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Envelope_, sizeof(SOAP_ENV__Envelope_), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_SOAP_ENV__Envelope_)
		return (SOAP_ENV__Envelope_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_SOAP_ENV__Envelope(soap, tag, &a->SOAP_ENV__Envelope_::__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 SOAP_ENV__Envelope_ * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Envelope_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_SOAP_ENV__Envelope_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	SOAP_ENV__Envelope_ *p;
	size_t k = sizeof(SOAP_ENV__Envelope_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Envelope_, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, SOAP_ENV__Envelope_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, SOAP_ENV__Envelope_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated SOAP_ENV__Envelope_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int SOAP_ENV__Envelope_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_SOAP_ENV__Envelope_(soap, tag ? tag : "SOAP-ENV:Envelope", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *SOAP_ENV__Envelope_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_SOAP_ENV__Envelope_(soap, this, tag, type);
}

SOAP_FMAC3 SOAP_ENV__Envelope_ * SOAP_FMAC4 soap_get_SOAP_ENV__Envelope_(struct soap *soap, SOAP_ENV__Envelope_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Envelope_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsa5__EndpointReferenceType__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_wsa5__EndpointReferenceType(soap, &this->wsa5__EndpointReferenceType__::__item);
}

void wsa5__EndpointReferenceType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsa5__EndpointReferenceType__::__item, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->wsa5__EndpointReferenceType__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wsa5__EndpointReferenceType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsa5__EndpointReferenceType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType__(struct soap *soap, const char *tag, int id, const wsa5__EndpointReferenceType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, &a->wsa5__EndpointReferenceType__::__item, "wsa5:EndpointReferenceType");
}

void *wsa5__EndpointReferenceType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsa5__EndpointReferenceType__(soap, tag, this, type);
}

SOAP_FMAC3 wsa5__EndpointReferenceType__ * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType__(struct soap *soap, const char *tag, wsa5__EndpointReferenceType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsa5__EndpointReferenceType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType__, sizeof(wsa5__EndpointReferenceType__), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsa5__EndpointReferenceType__)
		return (wsa5__EndpointReferenceType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_wsa5__EndpointReferenceType(soap, tag, &a->wsa5__EndpointReferenceType__::__item, "wsa5:EndpointReferenceType"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsa5__EndpointReferenceType__ * SOAP_FMAC2 imageing_instantiate_wsa5__EndpointReferenceType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsa5__EndpointReferenceType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsa5__EndpointReferenceType__ *p;
	size_t k = sizeof(wsa5__EndpointReferenceType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__EndpointReferenceType__, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsa5__EndpointReferenceType__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsa5__EndpointReferenceType__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsa5__EndpointReferenceType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsa5__EndpointReferenceType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsa5__EndpointReferenceType__(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsa5__EndpointReferenceType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsa5__EndpointReferenceType__(soap, this, tag, type);
}

SOAP_FMAC3 wsa5__EndpointReferenceType__ * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType__(struct soap *soap, wsa5__EndpointReferenceType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__hexBinary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
}

void xsd__hexBinary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__hexBinary);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__hexBinary2s(struct soap *soap, xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

int xsd__hexBinary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__hexBinary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__hexBinary, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__hexBinary(struct soap *soap, const char *s, xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__hexBinary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__hexBinary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__hexBinary, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 imageing_instantiate_xsd__hexBinary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__hexBinary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__hexBinary *p;
	size_t k = sizeof(xsd__hexBinary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__hexBinary, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__hexBinary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__hexBinary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__hexBinary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__hexBinary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__hexBinary(soap, tag ? tag : "xsd:hexBinary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__hexBinary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__hexBinary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_attachment_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__base64Binary, this->id, this->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 imageing_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__base64Binary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary *p;
	size_t k = sizeof(xsd__base64Binary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__base64Binary, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__base64Binary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__base64Binary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 2, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_xsd__QName, SOAP_TYPE_xsd__QName, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 imageing_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__QName, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, imageing_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 imageing_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, NULL);
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__anyType)
		return (xsd__anyType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 imageing_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_xsd__anyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "wsa5:EndpointReferenceType"))
		return imageing_instantiate_wsa5__EndpointReferenceType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "SOAP-ENV:Envelope"))
		return imageing_instantiate_SOAP_ENV__Envelope_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "SOAP-ENV:Fault"))
		return imageing_instantiate_SOAP_ENV__Fault_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:NCName"))
		return imageing_instantiate_xsd__NCName__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:QName"))
		return imageing_instantiate_xsd__QName__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:anySimpleType"))
		return imageing_instantiate_xsd__anySimpleType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:anyURI"))
		return imageing_instantiate_xsd__anyURI__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:base64Binary"))
		return imageing_instantiate_xsd__base64Binary__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:boolean"))
		return imageing_instantiate_xsd__boolean_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:dateTime"))
		return imageing_instantiate_xsd__dateTime_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:double"))
		return imageing_instantiate_xsd__double_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:duration"))
		return imageing_instantiate_xsd__duration__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:float"))
		return imageing_instantiate_xsd__float_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:hexBinary"))
		return imageing_instantiate_xsd__hexBinary__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:int"))
		return imageing_instantiate_xsd__int_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:integer"))
		return imageing_instantiate_xsd__integer__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:nonNegativeInteger"))
		return imageing_instantiate_xsd__nonNegativeInteger__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:string"))
		return imageing_instantiate_xsd__string_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:token"))
		return imageing_instantiate_xsd__token__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Name"))
		return imageing_instantiate_tt__Name__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RotateMode"))
		return imageing_instantiate_tt__RotateMode_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SceneOrientationMode"))
		return imageing_instantiate_tt__SceneOrientationMode_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoEncoding"))
		return imageing_instantiate_tt__VideoEncoding_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Mpeg4Profile"))
		return imageing_instantiate_tt__Mpeg4Profile_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:H264Profile"))
		return imageing_instantiate_tt__H264Profile_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioEncoding"))
		return imageing_instantiate_tt__AudioEncoding_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPv4Address"))
		return imageing_instantiate_tt__IPv4Address__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPv6Address"))
		return imageing_instantiate_tt__IPv6Address__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPType"))
		return imageing_instantiate_tt__IPType_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:EFlipMode"))
		return imageing_instantiate_tt__EFlipMode_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ReverseMode"))
		return imageing_instantiate_tt__ReverseMode_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AutoFocusMode"))
		return imageing_instantiate_tt__AutoFocusMode_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WideDynamicMode"))
		return imageing_instantiate_tt__WideDynamicMode_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:BacklightCompensationMode"))
		return imageing_instantiate_tt__BacklightCompensationMode_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ExposurePriority"))
		return imageing_instantiate_tt__ExposurePriority_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ExposureMode"))
		return imageing_instantiate_tt__ExposureMode_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WhiteBalanceMode"))
		return imageing_instantiate_tt__WhiteBalanceMode_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IrCutFilterMode"))
		return imageing_instantiate_tt__IrCutFilterMode_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImageStabilizationMode"))
		return imageing_instantiate_tt__ImageStabilizationMode_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PropertyOperation"))
		return imageing_instantiate_tt__PropertyOperation_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ReferenceToken"))
		return imageing_instantiate_tt__ReferenceToken__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MoveStatus"))
		return imageing_instantiate_tt__MoveStatus_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:ConcreteTopicExpression"))
		return imageing_instantiate_wstop__ConcreteTopicExpression__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "timg:Capabilities"))
		return imageing_instantiate_timg__Capabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "timg:ImagingPreset"))
		return imageing_instantiate_timg__ImagingPreset(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IntRectangle"))
		return imageing_instantiate_tt__IntRectangle(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IntRectangleRange"))
		return imageing_instantiate_tt__IntRectangleRange(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FloatRange"))
		return imageing_instantiate_tt__FloatRange(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DurationRange"))
		return imageing_instantiate_tt__DurationRange(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ConfigurationEntity"))
		return imageing_instantiate_tt__ConfigurationEntity(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceConfigurationExtension"))
		return imageing_instantiate_tt__VideoSourceConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceConfigurationExtension2"))
		return imageing_instantiate_tt__VideoSourceConfigurationExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Rotate"))
		return imageing_instantiate_tt__Rotate(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RotateExtension"))
		return imageing_instantiate_tt__RotateExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:LensProjection"))
		return imageing_instantiate_tt__LensProjection(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:LensOffset"))
		return imageing_instantiate_tt__LensOffset(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:LensDescription"))
		return imageing_instantiate_tt__LensDescription(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SceneOrientation"))
		return imageing_instantiate_tt__SceneOrientation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoResolution"))
		return imageing_instantiate_tt__VideoResolution(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoRateControl"))
		return imageing_instantiate_tt__VideoRateControl(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Mpeg4Configuration"))
		return imageing_instantiate_tt__Mpeg4Configuration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:H264Configuration"))
		return imageing_instantiate_tt__H264Configuration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MetadataConfigurationExtension"))
		return imageing_instantiate_tt__MetadataConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZFilter"))
		return imageing_instantiate_tt__PTZFilter(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:EventSubscription"))
		return imageing_instantiate_tt__EventSubscription(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MulticastConfiguration"))
		return imageing_instantiate_tt__MulticastConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPAddress"))
		return imageing_instantiate_tt__IPAddress(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZConfigurationExtension"))
		return imageing_instantiate_tt__PTZConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZConfigurationExtension2"))
		return imageing_instantiate_tt__PTZConfigurationExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTControlDirection"))
		return imageing_instantiate_tt__PTControlDirection(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTControlDirectionExtension"))
		return imageing_instantiate_tt__PTControlDirectionExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:EFlip"))
		return imageing_instantiate_tt__EFlip(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Reverse"))
		return imageing_instantiate_tt__Reverse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PanTiltLimits"))
		return imageing_instantiate_tt__PanTiltLimits(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ZoomLimits"))
		return imageing_instantiate_tt__ZoomLimits(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Space2DDescription"))
		return imageing_instantiate_tt__Space2DDescription(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Space1DDescription"))
		return imageing_instantiate_tt__Space1DDescription(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZSpeed"))
		return imageing_instantiate_tt__PTZSpeed(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusMove"))
		return imageing_instantiate_tt__FocusMove(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AbsoluteFocus"))
		return imageing_instantiate_tt__AbsoluteFocus(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RelativeFocus"))
		return imageing_instantiate_tt__RelativeFocus(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ContinuousFocus"))
		return imageing_instantiate_tt__ContinuousFocus(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AbsoluteFocusOptions"))
		return imageing_instantiate_tt__AbsoluteFocusOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ContinuousFocusOptions"))
		return imageing_instantiate_tt__ContinuousFocusOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingStatus20"))
		return imageing_instantiate_tt__ImagingStatus20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingStatus20Extension"))
		return imageing_instantiate_tt__ImagingStatus20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusStatus20"))
		return imageing_instantiate_tt__FocusStatus20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusStatus20Extension"))
		return imageing_instantiate_tt__FocusStatus20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingSettings20"))
		return imageing_instantiate_tt__ImagingSettings20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingSettingsExtension20"))
		return imageing_instantiate_tt__ImagingSettingsExtension20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingSettingsExtension202"))
		return imageing_instantiate_tt__ImagingSettingsExtension202(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingSettingsExtension203"))
		return imageing_instantiate_tt__ImagingSettingsExtension203(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingSettingsExtension204"))
		return imageing_instantiate_tt__ImagingSettingsExtension204(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImageStabilization"))
		return imageing_instantiate_tt__ImageStabilization(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImageStabilizationExtension"))
		return imageing_instantiate_tt__ImageStabilizationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IrCutFilterAutoAdjustment"))
		return imageing_instantiate_tt__IrCutFilterAutoAdjustment(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IrCutFilterAutoAdjustmentExtension"))
		return imageing_instantiate_tt__IrCutFilterAutoAdjustmentExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WideDynamicRange20"))
		return imageing_instantiate_tt__WideDynamicRange20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:BacklightCompensation20"))
		return imageing_instantiate_tt__BacklightCompensation20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Exposure20"))
		return imageing_instantiate_tt__Exposure20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ToneCompensation"))
		return imageing_instantiate_tt__ToneCompensation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ToneCompensationExtension"))
		return imageing_instantiate_tt__ToneCompensationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Defogging"))
		return imageing_instantiate_tt__Defogging(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DefoggingExtension"))
		return imageing_instantiate_tt__DefoggingExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NoiseReduction"))
		return imageing_instantiate_tt__NoiseReduction(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingOptions20"))
		return imageing_instantiate_tt__ImagingOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingOptions20Extension"))
		return imageing_instantiate_tt__ImagingOptions20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingOptions20Extension2"))
		return imageing_instantiate_tt__ImagingOptions20Extension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingOptions20Extension3"))
		return imageing_instantiate_tt__ImagingOptions20Extension3(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingOptions20Extension4"))
		return imageing_instantiate_tt__ImagingOptions20Extension4(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImageStabilizationOptions"))
		return imageing_instantiate_tt__ImageStabilizationOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImageStabilizationOptionsExtension"))
		return imageing_instantiate_tt__ImageStabilizationOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IrCutFilterAutoAdjustmentOptions"))
		return imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IrCutFilterAutoAdjustmentOptionsExtension"))
		return imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WideDynamicRangeOptions20"))
		return imageing_instantiate_tt__WideDynamicRangeOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:BacklightCompensationOptions20"))
		return imageing_instantiate_tt__BacklightCompensationOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ExposureOptions20"))
		return imageing_instantiate_tt__ExposureOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MoveOptions20"))
		return imageing_instantiate_tt__MoveOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RelativeFocusOptions20"))
		return imageing_instantiate_tt__RelativeFocusOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WhiteBalance20"))
		return imageing_instantiate_tt__WhiteBalance20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WhiteBalance20Extension"))
		return imageing_instantiate_tt__WhiteBalance20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusConfiguration20"))
		return imageing_instantiate_tt__FocusConfiguration20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusConfiguration20Extension"))
		return imageing_instantiate_tt__FocusConfiguration20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WhiteBalanceOptions20"))
		return imageing_instantiate_tt__WhiteBalanceOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WhiteBalanceOptions20Extension"))
		return imageing_instantiate_tt__WhiteBalanceOptions20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusOptions20"))
		return imageing_instantiate_tt__FocusOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusOptions20Extension"))
		return imageing_instantiate_tt__FocusOptions20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ToneCompensationOptions"))
		return imageing_instantiate_tt__ToneCompensationOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DefoggingOptions"))
		return imageing_instantiate_tt__DefoggingOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NoiseReductionOptions"))
		return imageing_instantiate_tt__NoiseReductionOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MessageExtension"))
		return imageing_instantiate_tt__MessageExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ItemList"))
		return imageing_instantiate_tt__ItemList(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ItemListExtension"))
		return imageing_instantiate_tt__ItemListExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Polyline"))
		return imageing_instantiate_tt__Polyline(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AnalyticsEngineConfiguration"))
		return imageing_instantiate_tt__AnalyticsEngineConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AnalyticsEngineConfigurationExtension"))
		return imageing_instantiate_tt__AnalyticsEngineConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RuleEngineConfiguration"))
		return imageing_instantiate_tt__RuleEngineConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RuleEngineConfigurationExtension"))
		return imageing_instantiate_tt__RuleEngineConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Config"))
		return imageing_instantiate_tt__Config(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PolygonOptions"))
		return imageing_instantiate_tt__PolygonOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IntRange"))
		return imageing_instantiate_tt__IntRange(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Vector2D"))
		return imageing_instantiate_tt__Vector2D(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Vector1D"))
		return imageing_instantiate_tt__Vector1D(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Vector"))
		return imageing_instantiate_tt__Vector(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Rectangle"))
		return imageing_instantiate_tt__Rectangle(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Polygon"))
		return imageing_instantiate_tt__Polygon(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:QueryExpressionType"))
		return imageing_instantiate_wsnt__QueryExpressionType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:TopicExpressionType"))
		return imageing_instantiate_wsnt__TopicExpressionType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:FilterType"))
		return imageing_instantiate_wsnt__FilterType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:SubscriptionPolicyType"))
		return imageing_instantiate_wsnt__SubscriptionPolicyType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:NotificationMessageHolderType"))
		return imageing_instantiate_wsnt__NotificationMessageHolderType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsrfbf:BaseFaultType"))
		return imageing_instantiate_wsrfbf__BaseFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:Documentation"))
		return imageing_instantiate_wstop__Documentation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:ExtensibleDocumented"))
		return imageing_instantiate_wstop__ExtensibleDocumented(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:QueryExpressionType"))
		return imageing_instantiate_wstop__QueryExpressionType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceConfiguration"))
		return imageing_instantiate_tt__VideoSourceConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoEncoderConfiguration"))
		return imageing_instantiate_tt__VideoEncoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioSourceConfiguration"))
		return imageing_instantiate_tt__AudioSourceConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioEncoderConfiguration"))
		return imageing_instantiate_tt__AudioEncoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoAnalyticsConfiguration"))
		return imageing_instantiate_tt__VideoAnalyticsConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MetadataConfiguration"))
		return imageing_instantiate_tt__MetadataConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioOutputConfiguration"))
		return imageing_instantiate_tt__AudioOutputConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioDecoderConfiguration"))
		return imageing_instantiate_tt__AudioDecoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZConfiguration"))
		return imageing_instantiate_tt__PTZConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:SubscribeCreationFailedFaultType"))
		return imageing_instantiate_wsnt__SubscribeCreationFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidFilterFaultType"))
		return imageing_instantiate_wsnt__InvalidFilterFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:TopicExpressionDialectUnknownFaultType"))
		return imageing_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidTopicExpressionFaultType"))
		return imageing_instantiate_wsnt__InvalidTopicExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:TopicNotSupportedFaultType"))
		return imageing_instantiate_wsnt__TopicNotSupportedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:MultipleTopicsSpecifiedFaultType"))
		return imageing_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidProducerPropertiesExpressionFaultType"))
		return imageing_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidMessageContentExpressionFaultType"))
		return imageing_instantiate_wsnt__InvalidMessageContentExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnrecognizedPolicyRequestFaultType"))
		return imageing_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnsupportedPolicyRequestFaultType"))
		return imageing_instantiate_wsnt__UnsupportedPolicyRequestFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:NotifyMessageNotSupportedFaultType"))
		return imageing_instantiate_wsnt__NotifyMessageNotSupportedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnacceptableInitialTerminationTimeFaultType"))
		return imageing_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:NoCurrentMessageOnTopicFaultType"))
		return imageing_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToGetMessagesFaultType"))
		return imageing_instantiate_wsnt__UnableToGetMessagesFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToDestroyPullPointFaultType"))
		return imageing_instantiate_wsnt__UnableToDestroyPullPointFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToCreatePullPointFaultType"))
		return imageing_instantiate_wsnt__UnableToCreatePullPointFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnacceptableTerminationTimeFaultType"))
		return imageing_instantiate_wsnt__UnacceptableTerminationTimeFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToDestroySubscriptionFaultType"))
		return imageing_instantiate_wsnt__UnableToDestroySubscriptionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:PauseFailedFaultType"))
		return imageing_instantiate_wsnt__PauseFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:ResumeFailedFaultType"))
		return imageing_instantiate_wsnt__ResumeFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicNamespaceType"))
		return imageing_instantiate_wstop__TopicNamespaceType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicType"))
		return imageing_instantiate_wstop__TopicType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicSetType"))
		return imageing_instantiate_wstop__TopicSetType(soap, n, NULL, NULL, size);
	xsd__anyType *p;
	size_t k = sizeof(xsd__anyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__anyType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__anyType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__anyType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__anyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__anyType(soap, tag ? tag : "xsd:anyType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__SetCurrentPreset(struct soap *soap, struct __timg__SetCurrentPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__SetCurrentPreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__SetCurrentPreset(struct soap *soap, const struct __timg__SetCurrentPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__SetCurrentPreset(soap, &a->timg__SetCurrentPreset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__SetCurrentPreset(struct soap *soap, const char *tag, int id, const struct __timg__SetCurrentPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__SetCurrentPreset(soap, "timg:SetCurrentPreset", -1, &a->timg__SetCurrentPreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__SetCurrentPreset * SOAP_FMAC4 soap_in___timg__SetCurrentPreset(struct soap *soap, const char *tag, struct __timg__SetCurrentPreset *a, const char *type)
{
	size_t soap_flag_timg__SetCurrentPreset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__SetCurrentPreset*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__SetCurrentPreset, sizeof(struct __timg__SetCurrentPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__SetCurrentPreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__SetCurrentPreset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__SetCurrentPreset(soap, "timg:SetCurrentPreset", &a->timg__SetCurrentPreset, ""))
				{	soap_flag_timg__SetCurrentPreset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__SetCurrentPreset * SOAP_FMAC2 imageing_instantiate___timg__SetCurrentPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate___timg__SetCurrentPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__SetCurrentPreset *p;
	size_t k = sizeof(struct __timg__SetCurrentPreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__SetCurrentPreset, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__SetCurrentPreset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__SetCurrentPreset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__SetCurrentPreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__SetCurrentPreset(struct soap *soap, const struct __timg__SetCurrentPreset *a, const char *tag, const char *type)
{
	if (soap_out___timg__SetCurrentPreset(soap, tag ? tag : "-timg:SetCurrentPreset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__SetCurrentPreset * SOAP_FMAC4 soap_get___timg__SetCurrentPreset(struct soap *soap, struct __timg__SetCurrentPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__SetCurrentPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetCurrentPreset(struct soap *soap, struct __timg__GetCurrentPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetCurrentPreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetCurrentPreset(struct soap *soap, const struct __timg__GetCurrentPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetCurrentPreset(soap, &a->timg__GetCurrentPreset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetCurrentPreset(struct soap *soap, const char *tag, int id, const struct __timg__GetCurrentPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetCurrentPreset(soap, "timg:GetCurrentPreset", -1, &a->timg__GetCurrentPreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetCurrentPreset * SOAP_FMAC4 soap_in___timg__GetCurrentPreset(struct soap *soap, const char *tag, struct __timg__GetCurrentPreset *a, const char *type)
{
	size_t soap_flag_timg__GetCurrentPreset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetCurrentPreset*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetCurrentPreset, sizeof(struct __timg__GetCurrentPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetCurrentPreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetCurrentPreset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetCurrentPreset(soap, "timg:GetCurrentPreset", &a->timg__GetCurrentPreset, ""))
				{	soap_flag_timg__GetCurrentPreset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetCurrentPreset * SOAP_FMAC2 imageing_instantiate___timg__GetCurrentPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate___timg__GetCurrentPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetCurrentPreset *p;
	size_t k = sizeof(struct __timg__GetCurrentPreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetCurrentPreset, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetCurrentPreset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetCurrentPreset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetCurrentPreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetCurrentPreset(struct soap *soap, const struct __timg__GetCurrentPreset *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetCurrentPreset(soap, tag ? tag : "-timg:GetCurrentPreset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetCurrentPreset * SOAP_FMAC4 soap_get___timg__GetCurrentPreset(struct soap *soap, struct __timg__GetCurrentPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetCurrentPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetPresets(struct soap *soap, struct __timg__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetPresets = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetPresets(struct soap *soap, const struct __timg__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetPresets(soap, &a->timg__GetPresets);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetPresets(struct soap *soap, const char *tag, int id, const struct __timg__GetPresets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetPresets(soap, "timg:GetPresets", -1, &a->timg__GetPresets, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetPresets * SOAP_FMAC4 soap_in___timg__GetPresets(struct soap *soap, const char *tag, struct __timg__GetPresets *a, const char *type)
{
	size_t soap_flag_timg__GetPresets = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetPresets*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetPresets, sizeof(struct __timg__GetPresets), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetPresets(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetPresets && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetPresets(soap, "timg:GetPresets", &a->timg__GetPresets, ""))
				{	soap_flag_timg__GetPresets--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetPresets * SOAP_FMAC2 imageing_instantiate___timg__GetPresets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate___timg__GetPresets(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetPresets *p;
	size_t k = sizeof(struct __timg__GetPresets);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetPresets, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetPresets);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetPresets, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetPresets location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetPresets(struct soap *soap, const struct __timg__GetPresets *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetPresets(soap, tag ? tag : "-timg:GetPresets", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetPresets * SOAP_FMAC4 soap_get___timg__GetPresets(struct soap *soap, struct __timg__GetPresets *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetMoveOptions(struct soap *soap, struct __timg__GetMoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetMoveOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetMoveOptions(struct soap *soap, const struct __timg__GetMoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetMoveOptions(soap, &a->timg__GetMoveOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetMoveOptions(struct soap *soap, const char *tag, int id, const struct __timg__GetMoveOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetMoveOptions(soap, "timg:GetMoveOptions", -1, &a->timg__GetMoveOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetMoveOptions * SOAP_FMAC4 soap_in___timg__GetMoveOptions(struct soap *soap, const char *tag, struct __timg__GetMoveOptions *a, const char *type)
{
	size_t soap_flag_timg__GetMoveOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetMoveOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetMoveOptions, sizeof(struct __timg__GetMoveOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetMoveOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetMoveOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetMoveOptions(soap, "timg:GetMoveOptions", &a->timg__GetMoveOptions, ""))
				{	soap_flag_timg__GetMoveOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetMoveOptions * SOAP_FMAC2 imageing_instantiate___timg__GetMoveOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate___timg__GetMoveOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetMoveOptions *p;
	size_t k = sizeof(struct __timg__GetMoveOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetMoveOptions, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetMoveOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetMoveOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetMoveOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetMoveOptions(struct soap *soap, const struct __timg__GetMoveOptions *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetMoveOptions(soap, tag ? tag : "-timg:GetMoveOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetMoveOptions * SOAP_FMAC4 soap_get___timg__GetMoveOptions(struct soap *soap, struct __timg__GetMoveOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetMoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetStatus(struct soap *soap, struct __timg__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetStatus(struct soap *soap, const struct __timg__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetStatus(soap, &a->timg__GetStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetStatus(struct soap *soap, const char *tag, int id, const struct __timg__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetStatus(soap, "timg:GetStatus", -1, &a->timg__GetStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetStatus * SOAP_FMAC4 soap_in___timg__GetStatus(struct soap *soap, const char *tag, struct __timg__GetStatus *a, const char *type)
{
	size_t soap_flag_timg__GetStatus = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetStatus*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetStatus, sizeof(struct __timg__GetStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetStatus(soap, "timg:GetStatus", &a->timg__GetStatus, ""))
				{	soap_flag_timg__GetStatus--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetStatus * SOAP_FMAC2 imageing_instantiate___timg__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate___timg__GetStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetStatus *p;
	size_t k = sizeof(struct __timg__GetStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetStatus, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetStatus(struct soap *soap, const struct __timg__GetStatus *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetStatus(soap, tag ? tag : "-timg:GetStatus", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetStatus * SOAP_FMAC4 soap_get___timg__GetStatus(struct soap *soap, struct __timg__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__Stop(struct soap *soap, struct __timg__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__Stop = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__Stop(struct soap *soap, const struct __timg__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__Stop(soap, &a->timg__Stop);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__Stop(struct soap *soap, const char *tag, int id, const struct __timg__Stop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__Stop(soap, "timg:Stop", -1, &a->timg__Stop, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__Stop * SOAP_FMAC4 soap_in___timg__Stop(struct soap *soap, const char *tag, struct __timg__Stop *a, const char *type)
{
	size_t soap_flag_timg__Stop = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__Stop*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__Stop, sizeof(struct __timg__Stop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__Stop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__Stop && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__Stop(soap, "timg:Stop", &a->timg__Stop, ""))
				{	soap_flag_timg__Stop--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__Stop * SOAP_FMAC2 imageing_instantiate___timg__Stop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate___timg__Stop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__Stop *p;
	size_t k = sizeof(struct __timg__Stop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__Stop, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__Stop);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__Stop, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__Stop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__Stop(struct soap *soap, const struct __timg__Stop *a, const char *tag, const char *type)
{
	if (soap_out___timg__Stop(soap, tag ? tag : "-timg:Stop", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__Stop * SOAP_FMAC4 soap_get___timg__Stop(struct soap *soap, struct __timg__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__Move(struct soap *soap, struct __timg__Move *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__Move = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__Move(struct soap *soap, const struct __timg__Move *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__Move(soap, &a->timg__Move);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__Move(struct soap *soap, const char *tag, int id, const struct __timg__Move *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__Move(soap, "timg:Move", -1, &a->timg__Move, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__Move * SOAP_FMAC4 soap_in___timg__Move(struct soap *soap, const char *tag, struct __timg__Move *a, const char *type)
{
	size_t soap_flag_timg__Move = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__Move*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__Move, sizeof(struct __timg__Move), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__Move(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__Move && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__Move(soap, "timg:Move", &a->timg__Move, ""))
				{	soap_flag_timg__Move--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__Move * SOAP_FMAC2 imageing_instantiate___timg__Move(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate___timg__Move(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__Move *p;
	size_t k = sizeof(struct __timg__Move);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__Move, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__Move);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__Move, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__Move location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__Move(struct soap *soap, const struct __timg__Move *a, const char *tag, const char *type)
{
	if (soap_out___timg__Move(soap, tag ? tag : "-timg:Move", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__Move * SOAP_FMAC4 soap_get___timg__Move(struct soap *soap, struct __timg__Move *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__Move(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetOptions(struct soap *soap, struct __timg__GetOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetOptions(struct soap *soap, const struct __timg__GetOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetOptions(soap, &a->timg__GetOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetOptions(struct soap *soap, const char *tag, int id, const struct __timg__GetOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetOptions(soap, "timg:GetOptions", -1, &a->timg__GetOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetOptions * SOAP_FMAC4 soap_in___timg__GetOptions(struct soap *soap, const char *tag, struct __timg__GetOptions *a, const char *type)
{
	size_t soap_flag_timg__GetOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetOptions, sizeof(struct __timg__GetOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetOptions(soap, "timg:GetOptions", &a->timg__GetOptions, ""))
				{	soap_flag_timg__GetOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetOptions * SOAP_FMAC2 imageing_instantiate___timg__GetOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate___timg__GetOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetOptions *p;
	size_t k = sizeof(struct __timg__GetOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetOptions, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetOptions(struct soap *soap, const struct __timg__GetOptions *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetOptions(soap, tag ? tag : "-timg:GetOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetOptions * SOAP_FMAC4 soap_get___timg__GetOptions(struct soap *soap, struct __timg__GetOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__SetImagingSettings(struct soap *soap, struct __timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__SetImagingSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__SetImagingSettings(struct soap *soap, const struct __timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__SetImagingSettings(soap, &a->timg__SetImagingSettings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__SetImagingSettings(struct soap *soap, const char *tag, int id, const struct __timg__SetImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__SetImagingSettings(soap, "timg:SetImagingSettings", -1, &a->timg__SetImagingSettings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__SetImagingSettings * SOAP_FMAC4 soap_in___timg__SetImagingSettings(struct soap *soap, const char *tag, struct __timg__SetImagingSettings *a, const char *type)
{
	size_t soap_flag_timg__SetImagingSettings = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__SetImagingSettings*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__SetImagingSettings, sizeof(struct __timg__SetImagingSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__SetImagingSettings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__SetImagingSettings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__SetImagingSettings(soap, "timg:SetImagingSettings", &a->timg__SetImagingSettings, ""))
				{	soap_flag_timg__SetImagingSettings--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__SetImagingSettings * SOAP_FMAC2 imageing_instantiate___timg__SetImagingSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate___timg__SetImagingSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__SetImagingSettings *p;
	size_t k = sizeof(struct __timg__SetImagingSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__SetImagingSettings, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__SetImagingSettings);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__SetImagingSettings, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__SetImagingSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__SetImagingSettings(struct soap *soap, const struct __timg__SetImagingSettings *a, const char *tag, const char *type)
{
	if (soap_out___timg__SetImagingSettings(soap, tag ? tag : "-timg:SetImagingSettings", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__SetImagingSettings * SOAP_FMAC4 soap_get___timg__SetImagingSettings(struct soap *soap, struct __timg__SetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__SetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetImagingSettings(struct soap *soap, struct __timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetImagingSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetImagingSettings(struct soap *soap, const struct __timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetImagingSettings(soap, &a->timg__GetImagingSettings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetImagingSettings(struct soap *soap, const char *tag, int id, const struct __timg__GetImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetImagingSettings(soap, "timg:GetImagingSettings", -1, &a->timg__GetImagingSettings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetImagingSettings * SOAP_FMAC4 soap_in___timg__GetImagingSettings(struct soap *soap, const char *tag, struct __timg__GetImagingSettings *a, const char *type)
{
	size_t soap_flag_timg__GetImagingSettings = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetImagingSettings*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetImagingSettings, sizeof(struct __timg__GetImagingSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetImagingSettings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetImagingSettings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetImagingSettings(soap, "timg:GetImagingSettings", &a->timg__GetImagingSettings, ""))
				{	soap_flag_timg__GetImagingSettings--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetImagingSettings * SOAP_FMAC2 imageing_instantiate___timg__GetImagingSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate___timg__GetImagingSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetImagingSettings *p;
	size_t k = sizeof(struct __timg__GetImagingSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetImagingSettings, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetImagingSettings);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetImagingSettings, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetImagingSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetImagingSettings(struct soap *soap, const struct __timg__GetImagingSettings *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetImagingSettings(soap, tag ? tag : "-timg:GetImagingSettings", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetImagingSettings * SOAP_FMAC4 soap_get___timg__GetImagingSettings(struct soap *soap, struct __timg__GetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetServiceCapabilities(struct soap *soap, struct __timg__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetServiceCapabilities(struct soap *soap, const struct __timg__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetServiceCapabilities(soap, &a->timg__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __timg__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetServiceCapabilities(soap, "timg:GetServiceCapabilities", -1, &a->timg__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetServiceCapabilities * SOAP_FMAC4 soap_in___timg__GetServiceCapabilities(struct soap *soap, const char *tag, struct __timg__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_timg__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetServiceCapabilities, sizeof(struct __timg__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetServiceCapabilities(soap, "timg:GetServiceCapabilities", &a->timg__GetServiceCapabilities, ""))
				{	soap_flag_timg__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetServiceCapabilities * SOAP_FMAC2 imageing_instantiate___timg__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate___timg__GetServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetServiceCapabilities *p;
	size_t k = sizeof(struct __timg__GetServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetServiceCapabilities, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetServiceCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetServiceCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetServiceCapabilities(struct soap *soap, const struct __timg__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetServiceCapabilities(soap, tag ? tag : "-timg:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetServiceCapabilities * SOAP_FMAC4 soap_get___timg__GetServiceCapabilities(struct soap *soap, struct __timg__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SOAP_ENV__Header = NULL;
	a->SOAP_ENV__Body = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSOAP_ENV__Header(soap, &a->SOAP_ENV__Header);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Envelope(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Envelope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Envelope), type))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", -1, &a->SOAP_ENV__Header, ""))
		return soap->error;
	if (soap_outliteral(soap, "SOAP-ENV:Body", (char*const*)&a->SOAP_ENV__Body, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_in_SOAP_ENV__Envelope(struct soap *soap, const char *tag, struct SOAP_ENV__Envelope *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Header = 1;
	size_t soap_flag_SOAP_ENV__Body = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Envelope*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Envelope(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Header && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", &a->SOAP_ENV__Header, ""))
				{	soap_flag_SOAP_ENV__Header--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Body && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "SOAP-ENV:Body", (char**)&a->SOAP_ENV__Body))
				{	soap_flag_SOAP_ENV__Body--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Envelope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Envelope, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), 0, imageing_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Envelope * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Envelope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_SOAP_ENV__Envelope(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Envelope *p;
	size_t k = sizeof(struct SOAP_ENV__Envelope);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Envelope, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Envelope);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Envelope, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Envelope location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Envelope(soap, tag ? tag : "SOAP-ENV:Envelope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_get_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Envelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, imageing_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, imageing_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, imageing_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, imageing_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa5__MessageID(soap, (char*const*)&a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, (char*const*)&a->wsa5__To);
	soap_serialize__wsa5__Action(soap, (char*const*)&a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, (char*const*)&a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, (char*const*)&a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, (char*const*)&a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", (char**)&a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__To(soap, "wsa5:To", (char**)&a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__Action(soap, "wsa5:Action", (char**)&a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, imageing_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->__item);
	a->wsa5__IsReferenceParameter = (enum _wsa5__IsReferenceParameter)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__item, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_chan__ChannelInstanceType(struct soap *soap, const char *tag, int id, const struct chan__ChannelInstanceType *a, const char *type)
{
	if (a->wsa5__IsReferenceParameter != (enum _wsa5__IsReferenceParameter)0)
	{	soap_set_attr(soap, "wsa5:IsReferenceParameter", soap__wsa5__IsReferenceParameter2s(soap, a->wsa5__IsReferenceParameter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_int(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_in_chan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct chan__ChannelInstanceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_chan__ChannelInstanceType(soap, a);
	if (soap_s2_wsa5__IsReferenceParameter(soap, soap_attr_value(soap, "wsa5:IsReferenceParameter", 5, 0), &a->wsa5__IsReferenceParameter))
		return NULL;
	if (!soap_in_int(soap, tag, &a->__item, "chan:ChannelInstanceType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct chan__ChannelInstanceType * SOAP_FMAC2 imageing_instantiate_chan__ChannelInstanceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_chan__ChannelInstanceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct chan__ChannelInstanceType *p;
	size_t k = sizeof(struct chan__ChannelInstanceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_chan__ChannelInstanceType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct chan__ChannelInstanceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct chan__ChannelInstanceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct chan__ChannelInstanceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a, const char *tag, const char *type)
{
	if (soap_out_chan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_get_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_chan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemAction(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemAction(soap, tag ? tag : "wsa5:ProblemAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__FaultTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__From(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReplyTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RelatesTo(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Metadata(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Metadata(soap, tag ? tag : "wsa5:Metadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReferenceParameters(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReferenceParameters(soap, tag ? tag : "wsa5:ReferenceParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__EndpointReference(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__EndpointReference(soap, tag ? tag : "wsa5:EndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Action);
	soap_serialize_string(soap, (char*const*)&a->SoapAction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, (char*const*)&a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, (char*const*)&a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ProblemActionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Action", (char**)&a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:SoapAction", (char**)&a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, imageing_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ProblemActionType * SOAP_FMAC2 imageing_instantiate_wsa5__ProblemActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsa5__ProblemActionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ProblemActionType *p;
	size_t k = sizeof(struct wsa5__ProblemActionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ProblemActionType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ProblemActionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ProblemActionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ProblemActionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ProblemActionType(soap, tag ? tag : "wsa5:ProblemActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_wsa5__RelationshipTypeOpenEnum2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), soap->type, soap->arrayType, imageing_instantiate, imageing_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2wsa5__RelationshipTypeOpenEnum(soap, soap_attr_value(soap, "RelationshipType", 1, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wsa5__RelatesToType * SOAP_FMAC2 imageing_instantiate_wsa5__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsa5__RelatesToType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__RelatesToType *p;
	size_t k = sizeof(struct wsa5__RelatesToType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__RelatesToType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__RelatesToType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__RelatesToType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__RelatesToType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelatesToType(soap, tag ? tag : "wsa5:RelatesToType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__MetadataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, imageing_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__MetadataType * SOAP_FMAC2 imageing_instantiate_wsa5__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsa5__MetadataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__MetadataType *p;
	size_t k = sizeof(struct wsa5__MetadataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__MetadataType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__MetadataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__MetadataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__MetadataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->chan__ChannelInstance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	size_t soap_flag_chan__ChannelInstance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ReferenceParametersType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "xsd:int"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, imageing_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ReferenceParametersType * SOAP_FMAC2 imageing_instantiate_wsa5__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsa5__ReferenceParametersType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ReferenceParametersType *p;
	size_t k = sizeof(struct wsa5__ReferenceParametersType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ReferenceParametersType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ReferenceParametersType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ReferenceParametersType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ReferenceParametersType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa5:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsa5:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__EndpointReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, imageing_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * SOAP_FMAC2 imageing_instantiate_wsa5__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_wsa5__EndpointReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__EndpointReferenceType *p;
	size_t k = sizeof(struct wsa5__EndpointReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__EndpointReferenceType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__EndpointReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__EndpointReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__EndpointReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xop__Include(struct soap *soap, struct _xop__Include *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xop__Include(struct soap *soap, const struct _xop__Include *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_attachment_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE__xop__Include, a->id, a->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__xop__Include2s(struct soap *soap, struct _xop__Include a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xop__Include(struct soap *soap, const char *tag, int id, const struct _xop__Include *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE__xop__Include);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE__xop__Include, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_xop__Include(struct soap *soap, const char *s, struct _xop__Include *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_in__xop__Include(struct soap *soap, const char *tag, struct _xop__Include *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct _xop__Include*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xop__Include(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct _xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xop__Include, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), 0, imageing_finsert, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _xop__Include * SOAP_FMAC2 imageing_instantiate__xop__Include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate__xop__Include(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _xop__Include *p;
	size_t k = sizeof(struct _xop__Include);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__xop__Include, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _xop__Include);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _xop__Include, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _xop__Include location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xop__Include(struct soap *soap, const struct _xop__Include *a, const char *tag, const char *type)
{
	if (soap_out__xop__Include(soap, tag ? tag : "xop:Include", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_get__xop__Include(struct soap *soap, struct _xop__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in__xop__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__SetCurrentPreset(struct soap *soap, _timg__SetCurrentPreset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__SetCurrentPreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__SetCurrentPreset(struct soap *soap, const char *tag, int id, _timg__SetCurrentPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__SetCurrentPreset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__SetCurrentPreset ? type : NULL);
}

SOAP_FMAC3 _timg__SetCurrentPreset ** SOAP_FMAC4 soap_in_PointerTo_timg__SetCurrentPreset(struct soap *soap, const char *tag, _timg__SetCurrentPreset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__SetCurrentPreset **)soap_malloc(soap, sizeof(_timg__SetCurrentPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__SetCurrentPreset *)imageing_instantiate__timg__SetCurrentPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__SetCurrentPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetCurrentPreset, sizeof(_timg__SetCurrentPreset), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__SetCurrentPreset(struct soap *soap, _timg__SetCurrentPreset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__SetCurrentPreset(soap, tag ? tag : "timg:SetCurrentPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__SetCurrentPreset ** SOAP_FMAC4 soap_get_PointerTo_timg__SetCurrentPreset(struct soap *soap, _timg__SetCurrentPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__SetCurrentPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetCurrentPreset(struct soap *soap, _timg__GetCurrentPreset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetCurrentPreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetCurrentPreset(struct soap *soap, const char *tag, int id, _timg__GetCurrentPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetCurrentPreset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetCurrentPreset ? type : NULL);
}

SOAP_FMAC3 _timg__GetCurrentPreset ** SOAP_FMAC4 soap_in_PointerTo_timg__GetCurrentPreset(struct soap *soap, const char *tag, _timg__GetCurrentPreset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetCurrentPreset **)soap_malloc(soap, sizeof(_timg__GetCurrentPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetCurrentPreset *)imageing_instantiate__timg__GetCurrentPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetCurrentPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetCurrentPreset, sizeof(_timg__GetCurrentPreset), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetCurrentPreset(struct soap *soap, _timg__GetCurrentPreset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetCurrentPreset(soap, tag ? tag : "timg:GetCurrentPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetCurrentPreset ** SOAP_FMAC4 soap_get_PointerTo_timg__GetCurrentPreset(struct soap *soap, _timg__GetCurrentPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetCurrentPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetPresets(struct soap *soap, _timg__GetPresets *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetPresets))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetPresets(struct soap *soap, const char *tag, int id, _timg__GetPresets *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetPresets, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetPresets ? type : NULL);
}

SOAP_FMAC3 _timg__GetPresets ** SOAP_FMAC4 soap_in_PointerTo_timg__GetPresets(struct soap *soap, const char *tag, _timg__GetPresets **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetPresets **)soap_malloc(soap, sizeof(_timg__GetPresets *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetPresets *)imageing_instantiate__timg__GetPresets(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetPresets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetPresets, sizeof(_timg__GetPresets), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetPresets(struct soap *soap, _timg__GetPresets *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetPresets(soap, tag ? tag : "timg:GetPresets", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetPresets ** SOAP_FMAC4 soap_get_PointerTo_timg__GetPresets(struct soap *soap, _timg__GetPresets **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetMoveOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetMoveOptions(struct soap *soap, const char *tag, int id, _timg__GetMoveOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetMoveOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetMoveOptions ? type : NULL);
}

SOAP_FMAC3 _timg__GetMoveOptions ** SOAP_FMAC4 soap_in_PointerTo_timg__GetMoveOptions(struct soap *soap, const char *tag, _timg__GetMoveOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetMoveOptions **)soap_malloc(soap, sizeof(_timg__GetMoveOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetMoveOptions *)imageing_instantiate__timg__GetMoveOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetMoveOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetMoveOptions, sizeof(_timg__GetMoveOptions), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetMoveOptions(soap, tag ? tag : "timg:GetMoveOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetMoveOptions ** SOAP_FMAC4 soap_get_PointerTo_timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetMoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetStatus(struct soap *soap, _timg__GetStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetStatus(struct soap *soap, const char *tag, int id, _timg__GetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetStatus ? type : NULL);
}

SOAP_FMAC3 _timg__GetStatus ** SOAP_FMAC4 soap_in_PointerTo_timg__GetStatus(struct soap *soap, const char *tag, _timg__GetStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetStatus **)soap_malloc(soap, sizeof(_timg__GetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetStatus *)imageing_instantiate__timg__GetStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetStatus, sizeof(_timg__GetStatus), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetStatus(struct soap *soap, _timg__GetStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetStatus(soap, tag ? tag : "timg:GetStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetStatus ** SOAP_FMAC4 soap_get_PointerTo_timg__GetStatus(struct soap *soap, _timg__GetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__Stop(struct soap *soap, _timg__Stop *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__Stop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__Stop(struct soap *soap, const char *tag, int id, _timg__Stop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__Stop, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__Stop ? type : NULL);
}

SOAP_FMAC3 _timg__Stop ** SOAP_FMAC4 soap_in_PointerTo_timg__Stop(struct soap *soap, const char *tag, _timg__Stop **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__Stop **)soap_malloc(soap, sizeof(_timg__Stop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__Stop *)imageing_instantiate__timg__Stop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__Stop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__Stop, sizeof(_timg__Stop), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__Stop(struct soap *soap, _timg__Stop *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__Stop(soap, tag ? tag : "timg:Stop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__Stop ** SOAP_FMAC4 soap_get_PointerTo_timg__Stop(struct soap *soap, _timg__Stop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__Move(struct soap *soap, _timg__Move *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__Move))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__Move(struct soap *soap, const char *tag, int id, _timg__Move *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__Move, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__Move ? type : NULL);
}

SOAP_FMAC3 _timg__Move ** SOAP_FMAC4 soap_in_PointerTo_timg__Move(struct soap *soap, const char *tag, _timg__Move **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__Move **)soap_malloc(soap, sizeof(_timg__Move *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__Move *)imageing_instantiate__timg__Move(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__Move **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__Move, sizeof(_timg__Move), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__Move(struct soap *soap, _timg__Move *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__Move(soap, tag ? tag : "timg:Move", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__Move ** SOAP_FMAC4 soap_get_PointerTo_timg__Move(struct soap *soap, _timg__Move **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__Move(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetOptions(struct soap *soap, _timg__GetOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetOptions(struct soap *soap, const char *tag, int id, _timg__GetOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetOptions ? type : NULL);
}

SOAP_FMAC3 _timg__GetOptions ** SOAP_FMAC4 soap_in_PointerTo_timg__GetOptions(struct soap *soap, const char *tag, _timg__GetOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetOptions **)soap_malloc(soap, sizeof(_timg__GetOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetOptions *)imageing_instantiate__timg__GetOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetOptions, sizeof(_timg__GetOptions), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetOptions(struct soap *soap, _timg__GetOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetOptions(soap, tag ? tag : "timg:GetOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetOptions ** SOAP_FMAC4 soap_get_PointerTo_timg__GetOptions(struct soap *soap, _timg__GetOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__SetImagingSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__SetImagingSettings(struct soap *soap, const char *tag, int id, _timg__SetImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__SetImagingSettings, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__SetImagingSettings ? type : NULL);
}

SOAP_FMAC3 _timg__SetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__SetImagingSettings(struct soap *soap, const char *tag, _timg__SetImagingSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__SetImagingSettings **)soap_malloc(soap, sizeof(_timg__SetImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__SetImagingSettings *)imageing_instantiate__timg__SetImagingSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__SetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetImagingSettings, sizeof(_timg__SetImagingSettings), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__SetImagingSettings(soap, tag ? tag : "timg:SetImagingSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__SetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__SetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetImagingSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetImagingSettings(struct soap *soap, const char *tag, int id, _timg__GetImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetImagingSettings, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetImagingSettings ? type : NULL);
}

SOAP_FMAC3 _timg__GetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__GetImagingSettings(struct soap *soap, const char *tag, _timg__GetImagingSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetImagingSettings **)soap_malloc(soap, sizeof(_timg__GetImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetImagingSettings *)imageing_instantiate__timg__GetImagingSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetImagingSettings, sizeof(_timg__GetImagingSettings), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetImagingSettings(soap, tag ? tag : "timg:GetImagingSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetServiceCapabilities(struct soap *soap, const char *tag, int id, _timg__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetServiceCapabilities ? type : NULL);
}

SOAP_FMAC3 _timg__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_timg__GetServiceCapabilities(struct soap *soap, const char *tag, _timg__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetServiceCapabilities **)soap_malloc(soap, sizeof(_timg__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetServiceCapabilities *)imageing_instantiate__timg__GetServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(_timg__GetServiceCapabilities), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetServiceCapabilities(soap, tag ? tag : "timg:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NCName(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__NCName))
		soap_serialize_xsd__NCName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NCName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__NCName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NCName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__NCName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NCName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NCName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__NCName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__ConcreteTopicExpression))
		soap_serialize_wstop__ConcreteTopicExpression(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__ConcreteTopicExpression, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__ConcreteTopicExpression(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowstop__ConcreteTopicExpression(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__ConcreteTopicExpression(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__ConcreteTopicExpression(soap, tag ? tag : "wstop:ConcreteTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__QName(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__QName))
		soap_serialize_xsd__QName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__QName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__QName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__QName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__QName, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__QName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__QName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicType(struct soap *soap, const char *tag, int id, wstop__TopicType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__TopicType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicType(struct soap *soap, const char *tag, wstop__TopicType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__TopicType **)soap_malloc(soap, sizeof(wstop__TopicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__TopicType *)imageing_instantiate_wstop__TopicType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__TopicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicType, sizeof(wstop__TopicType), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicType(soap, tag ? tag : "wstop:TopicType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__QueryExpressionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, int id, wstop__QueryExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__QueryExpressionType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__QueryExpressionType ? type : NULL);
}

SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, wstop__QueryExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__QueryExpressionType **)soap_malloc(soap, sizeof(wstop__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__QueryExpressionType *)imageing_instantiate_wstop__QueryExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(wstop__QueryExpressionType), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__QueryExpressionType(soap, tag ? tag : "wstop:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, tt__PTZConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, tt__PTZConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfigurationExtension **)soap_malloc(soap, sizeof(tt__PTZConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfigurationExtension *)imageing_instantiate_tt__PTZConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, tag ? tag : "tt:PTZConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ZoomLimits))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ZoomLimits(struct soap *soap, const char *tag, int id, tt__ZoomLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ZoomLimits, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ZoomLimits ? type : NULL);
}

SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_in_PointerTott__ZoomLimits(struct soap *soap, const char *tag, tt__ZoomLimits **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ZoomLimits **)soap_malloc(soap, sizeof(tt__ZoomLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ZoomLimits *)imageing_instantiate_tt__ZoomLimits(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ZoomLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ZoomLimits(soap, tag ? tag : "tt:ZoomLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_get_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PanTiltLimits))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, int id, tt__PanTiltLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PanTiltLimits, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PanTiltLimits ? type : NULL);
}

SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_in_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, tt__PanTiltLimits **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PanTiltLimits **)soap_malloc(soap, sizeof(tt__PanTiltLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PanTiltLimits *)imageing_instantiate_tt__PanTiltLimits(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PanTiltLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PanTiltLimits(soap, tag ? tag : "tt:PanTiltLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_get_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpeed(struct soap *soap, tt__PTZSpeed *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpeed))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpeed(struct soap *soap, const char *tag, int id, tt__PTZSpeed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpeed, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZSpeed ? type : NULL);
}

SOAP_FMAC3 tt__PTZSpeed ** SOAP_FMAC4 soap_in_PointerTott__PTZSpeed(struct soap *soap, const char *tag, tt__PTZSpeed **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZSpeed **)soap_malloc(soap, sizeof(tt__PTZSpeed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZSpeed *)imageing_instantiate_tt__PTZSpeed(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZSpeed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpeed, sizeof(tt__PTZSpeed), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpeed(struct soap *soap, tt__PTZSpeed *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZSpeed(soap, tag ? tag : "tt:PTZSpeed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZSpeed ** SOAP_FMAC4 soap_get_PointerTott__PTZSpeed(struct soap *soap, tt__PTZSpeed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, int id, tt__MetadataConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MetadataConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, tt__MetadataConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataConfigurationExtension **)soap_malloc(soap, sizeof(tt__MetadataConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataConfigurationExtension *)imageing_instantiate_tt__MetadataConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MetadataConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(tt__MetadataConfigurationExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfigurationExtension(soap, tag ? tag : "tt:MetadataConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventSubscription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventSubscription(struct soap *soap, const char *tag, int id, tt__EventSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventSubscription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EventSubscription ? type : NULL);
}

SOAP_FMAC3 tt__EventSubscription ** SOAP_FMAC4 soap_in_PointerTott__EventSubscription(struct soap *soap, const char *tag, tt__EventSubscription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EventSubscription **)soap_malloc(soap, sizeof(tt__EventSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EventSubscription *)imageing_instantiate_tt__EventSubscription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EventSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventSubscription, sizeof(tt__EventSubscription), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EventSubscription(soap, tag ? tag : "tt:EventSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EventSubscription ** SOAP_FMAC4 soap_get_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZFilter(struct soap *soap, const char *tag, int id, tt__PTZFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZFilter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZFilter ? type : NULL);
}

SOAP_FMAC3 tt__PTZFilter ** SOAP_FMAC4 soap_in_PointerTott__PTZFilter(struct soap *soap, const char *tag, tt__PTZFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZFilter **)soap_malloc(soap, sizeof(tt__PTZFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZFilter *)imageing_instantiate_tt__PTZFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZFilter, sizeof(tt__PTZFilter), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZFilter(soap, tag ? tag : "tt:PTZFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZFilter ** SOAP_FMAC4 soap_get_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, tt__RuleEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RuleEngineConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, tt__RuleEngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RuleEngineConfiguration **)soap_malloc(soap, sizeof(tt__RuleEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RuleEngineConfiguration *)imageing_instantiate_tt__RuleEngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RuleEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(tt__RuleEngineConfiguration), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RuleEngineConfiguration(soap, tag ? tag : "tt:RuleEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, tt__AnalyticsEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, tt__AnalyticsEngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsEngineConfiguration **)soap_malloc(soap, sizeof(tt__AnalyticsEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsEngineConfiguration *)imageing_instantiate_tt__AnalyticsEngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(tt__AnalyticsEngineConfiguration), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, tag ? tag : "tt:AnalyticsEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MulticastConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, int id, tt__MulticastConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MulticastConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MulticastConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__MulticastConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, tt__MulticastConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MulticastConfiguration **)soap_malloc(soap, sizeof(tt__MulticastConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MulticastConfiguration *)imageing_instantiate_tt__MulticastConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MulticastConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(tt__MulticastConfiguration), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MulticastConfiguration(soap, tag ? tag : "tt:MulticastConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MulticastConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Configuration(struct soap *soap, const char *tag, int id, tt__H264Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__H264Configuration ? type : NULL);
}

SOAP_FMAC3 tt__H264Configuration ** SOAP_FMAC4 soap_in_PointerTott__H264Configuration(struct soap *soap, const char *tag, tt__H264Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__H264Configuration **)soap_malloc(soap, sizeof(tt__H264Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__H264Configuration *)imageing_instantiate_tt__H264Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__H264Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Configuration, sizeof(tt__H264Configuration), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Configuration(soap, tag ? tag : "tt:H264Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__H264Configuration ** SOAP_FMAC4 soap_get_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, int id, tt__Mpeg4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Mpeg4Configuration ? type : NULL);
}

SOAP_FMAC3 tt__Mpeg4Configuration ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, tt__Mpeg4Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Mpeg4Configuration **)soap_malloc(soap, sizeof(tt__Mpeg4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Mpeg4Configuration *)imageing_instantiate_tt__Mpeg4Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Mpeg4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(tt__Mpeg4Configuration), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Configuration(soap, tag ? tag : "tt:Mpeg4Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Mpeg4Configuration ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoRateControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl(struct soap *soap, const char *tag, int id, tt__VideoRateControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoRateControl, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoRateControl ? type : NULL);
}

SOAP_FMAC3 tt__VideoRateControl ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl(struct soap *soap, const char *tag, tt__VideoRateControl **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoRateControl **)soap_malloc(soap, sizeof(tt__VideoRateControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoRateControl *)imageing_instantiate_tt__VideoRateControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoRateControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl, sizeof(tt__VideoRateControl), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoRateControl(soap, tag ? tag : "tt:VideoRateControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoRateControl ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoResolution(struct soap *soap, tt__VideoResolution *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoResolution))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoResolution(struct soap *soap, const char *tag, int id, tt__VideoResolution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoResolution, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoResolution ? type : NULL);
}

SOAP_FMAC3 tt__VideoResolution ** SOAP_FMAC4 soap_in_PointerTott__VideoResolution(struct soap *soap, const char *tag, tt__VideoResolution **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoResolution **)soap_malloc(soap, sizeof(tt__VideoResolution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoResolution *)imageing_instantiate_tt__VideoResolution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoResolution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoResolution, sizeof(tt__VideoResolution), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoResolution(struct soap *soap, tt__VideoResolution *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoResolution(soap, tag ? tag : "tt:VideoResolution", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoResolution ** SOAP_FMAC4 soap_get_PointerTott__VideoResolution(struct soap *soap, tt__VideoResolution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, int id, tt__VideoSourceConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfigurationExtension **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceConfigurationExtension *)imageing_instantiate_tt__VideoSourceConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoSourceConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(tt__VideoSourceConfigurationExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationExtension(soap, tag ? tag : "tt:VideoSourceConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangle))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangle(struct soap *soap, const char *tag, int id, tt__IntRectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangle, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IntRectangle ? type : NULL);
}

SOAP_FMAC3 tt__IntRectangle ** SOAP_FMAC4 soap_in_PointerTott__IntRectangle(struct soap *soap, const char *tag, tt__IntRectangle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntRectangle **)soap_malloc(soap, sizeof(tt__IntRectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntRectangle *)imageing_instantiate_tt__IntRectangle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IntRectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangle, sizeof(tt__IntRectangle), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRectangle(soap, tag ? tag : "tt:IntRectangle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntRectangle ** SOAP_FMAC4 soap_get_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__Documentation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__Documentation(struct soap *soap, const char *tag, int id, wstop__Documentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__Documentation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__Documentation ? type : NULL);
}

SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_in_PointerTowstop__Documentation(struct soap *soap, const char *tag, wstop__Documentation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__Documentation **)soap_malloc(soap, sizeof(wstop__Documentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__Documentation *)imageing_instantiate_wstop__Documentation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__Documentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__Documentation, sizeof(wstop__Documentation), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_get_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause ? type : NULL);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_FaultCause **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_FaultCause *)imageing_instantiate__wsrfbf__BaseFaultType_FaultCause(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsrfbf__BaseFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(_wsrfbf__BaseFaultType_FaultCause), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag ? tag : "wsrfbf:BaseFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xml__lang(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__xml__lang))
		soap_serialize__xml__lang(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xml__lang(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xml__lang, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__xml__lang(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTo_xml__lang(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xml__lang(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xml__lang, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xml__lang(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_xml__lang(soap, tag ? tag : "xml:lang", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTo_xml__lang(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xml__lang(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode ? type : NULL);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_ErrorCode *)imageing_instantiate__wsrfbf__BaseFaultType_ErrorCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsrfbf__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(_wsrfbf__BaseFaultType_ErrorCode), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag ? tag : "wsrfbf:BaseFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger))
		soap_serialize_xsd__nonNegativeInteger(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__nonNegativeInteger, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__nonNegativeInteger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy ? type : NULL);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, _wsnt__Subscribe_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(_wsnt__Subscribe_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__Subscribe_SubscriptionPolicy *)imageing_instantiate__wsnt__Subscribe_SubscriptionPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(_wsnt__Subscribe_SubscriptionPolicy), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag ? tag : "wsnt:Subscribe-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType))
		soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, tag ? tag : "wsnt:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NotificationMessageHolderType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, wsnt__NotificationMessageHolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NotificationMessageHolderType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__NotificationMessageHolderType ? type : NULL);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, wsnt__NotificationMessageHolderType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__NotificationMessageHolderType **)soap_malloc(soap, sizeof(wsnt__NotificationMessageHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__NotificationMessageHolderType *)imageing_instantiate_wsnt__NotificationMessageHolderType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscriptionPolicyType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, wsnt__SubscriptionPolicyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscriptionPolicyType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__SubscriptionPolicyType ? type : NULL);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, wsnt__SubscriptionPolicyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__SubscriptionPolicyType **)soap_malloc(soap, sizeof(wsnt__SubscriptionPolicyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__SubscriptionPolicyType *)imageing_instantiate_wsnt__SubscriptionPolicyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(wsnt__SubscriptionPolicyType), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicSetType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, int id, wstop__TopicSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicSetType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__TopicSetType ? type : NULL);
}

SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, wstop__TopicSetType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__TopicSetType **)soap_malloc(soap, sizeof(wstop__TopicSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__TopicSetType *)imageing_instantiate_wstop__TopicSetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__TopicSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicSetType, sizeof(wstop__TopicSetType), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, wsnt__TopicExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__TopicExpressionType ? type : NULL);
}

SOAP_FMAC3 wsnt__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, wsnt__TopicExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__TopicExpressionType **)soap_malloc(soap, sizeof(wsnt__TopicExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__TopicExpressionType *)imageing_instantiate_wsnt__TopicExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(wsnt__TopicExpressionType), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, tag ? tag : "wsnt:TopicExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
		soap_serialize_wsa5__EndpointReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__PropertyOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PropertyOperation(struct soap *soap, const char *tag, int id, enum tt__PropertyOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PropertyOperation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PropertyOperation(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_in_PointerTott__PropertyOperation(struct soap *soap, const char *tag, enum tt__PropertyOperation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__PropertyOperation **)soap_malloc(soap, sizeof(enum tt__PropertyOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PropertyOperation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__PropertyOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PropertyOperation(soap, tag ? tag : "tt:PropertyOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_get_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageExtension(struct soap *soap, const char *tag, int id, tt__MessageExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MessageExtension ? type : NULL);
}

SOAP_FMAC3 tt__MessageExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageExtension(struct soap *soap, const char *tag, tt__MessageExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MessageExtension **)soap_malloc(soap, sizeof(tt__MessageExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MessageExtension *)imageing_instantiate_tt__MessageExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MessageExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageExtension, sizeof(tt__MessageExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MessageExtension(soap, tag ? tag : "tt:MessageExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MessageExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemList(struct soap *soap, tt__ItemList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemList(struct soap *soap, const char *tag, int id, tt__ItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ItemList ? type : NULL);
}

SOAP_FMAC3 tt__ItemList ** SOAP_FMAC4 soap_in_PointerTott__ItemList(struct soap *soap, const char *tag, tt__ItemList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ItemList **)soap_malloc(soap, sizeof(tt__ItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ItemList *)imageing_instantiate_tt__ItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemList, sizeof(tt__ItemList), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemList(struct soap *soap, tt__ItemList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemList(soap, tag ? tag : "tt:ItemList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ItemList ** SOAP_FMAC4 soap_get_PointerTott__ItemList(struct soap *soap, tt__ItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, tt__RuleEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RuleEngineConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, tt__RuleEngineConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RuleEngineConfigurationExtension **)soap_malloc(soap, sizeof(tt__RuleEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RuleEngineConfigurationExtension *)imageing_instantiate_tt__RuleEngineConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RuleEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(tt__RuleEngineConfigurationExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, tag ? tag : "tt:RuleEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, tt__AnalyticsEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, tt__AnalyticsEngineConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsEngineConfigurationExtension **)soap_malloc(soap, sizeof(tt__AnalyticsEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsEngineConfigurationExtension *)imageing_instantiate_tt__AnalyticsEngineConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(tt__AnalyticsEngineConfigurationExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Config(struct soap *soap, tt__Config *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Config))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Config(struct soap *soap, const char *tag, int id, tt__Config *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Config, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Config ? type : NULL);
}

SOAP_FMAC3 tt__Config ** SOAP_FMAC4 soap_in_PointerTott__Config(struct soap *soap, const char *tag, tt__Config **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Config **)soap_malloc(soap, sizeof(tt__Config *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Config *)imageing_instantiate_tt__Config(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Config **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Config, sizeof(tt__Config), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Config(struct soap *soap, tt__Config *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Config(soap, tag ? tag : "tt:Config", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Config ** SOAP_FMAC4 soap_get_PointerTott__Config(struct soap *soap, tt__Config **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector(struct soap *soap, tt__Vector *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector(struct soap *soap, const char *tag, int id, tt__Vector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Vector ? type : NULL);
}

SOAP_FMAC3 tt__Vector ** SOAP_FMAC4 soap_in_PointerTott__Vector(struct soap *soap, const char *tag, tt__Vector **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Vector **)soap_malloc(soap, sizeof(tt__Vector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Vector *)imageing_instantiate_tt__Vector(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Vector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector, sizeof(tt__Vector), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector(struct soap *soap, tt__Vector *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector(soap, tag ? tag : "tt:Vector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Vector ** SOAP_FMAC4 soap_get_PointerTott__Vector(struct soap *soap, tt__Vector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListExtension(struct soap *soap, tt__ItemListExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListExtension(struct soap *soap, const char *tag, int id, tt__ItemListExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ItemListExtension ? type : NULL);
}

SOAP_FMAC3 tt__ItemListExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListExtension(struct soap *soap, const char *tag, tt__ItemListExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ItemListExtension **)soap_malloc(soap, sizeof(tt__ItemListExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ItemListExtension *)imageing_instantiate_tt__ItemListExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ItemListExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListExtension, sizeof(tt__ItemListExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListExtension(struct soap *soap, tt__ItemListExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemListExtension(soap, tag ? tag : "tt:ItemListExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ItemListExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListExtension(struct soap *soap, tt__ItemListExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, int id, tt__FocusOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusOptions20Extension ? type : NULL);
}

SOAP_FMAC3 tt__FocusOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, tt__FocusOptions20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusOptions20Extension **)soap_malloc(soap, sizeof(tt__FocusOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusOptions20Extension *)imageing_instantiate_tt__FocusOptions20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(tt__FocusOptions20Extension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusOptions20Extension(soap, tag ? tag : "tt:FocusOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, tt__WhiteBalanceOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WhiteBalanceOptions20Extension ? type : NULL);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalanceOptions20Extension **)soap_malloc(soap, sizeof(tt__WhiteBalanceOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalanceOptions20Extension *)imageing_instantiate_tt__WhiteBalanceOptions20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WhiteBalanceOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(tt__WhiteBalanceOptions20Extension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, tag ? tag : "tt:WhiteBalanceOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StringAttrList(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StringAttrList))
		soap_serialize_tt__StringAttrList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StringAttrList(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StringAttrList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__StringAttrList(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__StringAttrList(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__StringAttrList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StringAttrList, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StringAttrList(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StringAttrList(soap, tag ? tag : "tt:StringAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__StringAttrList(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StringAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, tt__FocusConfiguration20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusConfiguration20Extension ? type : NULL);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, tt__FocusConfiguration20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusConfiguration20Extension **)soap_malloc(soap, sizeof(tt__FocusConfiguration20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusConfiguration20Extension *)imageing_instantiate_tt__FocusConfiguration20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusConfiguration20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(tt__FocusConfiguration20Extension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, tag ? tag : "tt:FocusConfiguration20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, tt__WhiteBalance20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WhiteBalance20Extension ? type : NULL);
}

SOAP_FMAC3 tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, tt__WhiteBalance20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalance20Extension **)soap_malloc(soap, sizeof(tt__WhiteBalance20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalance20Extension *)imageing_instantiate_tt__WhiteBalance20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WhiteBalance20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(tt__WhiteBalance20Extension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, tag ? tag : "tt:WhiteBalance20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ContinuousFocusOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ContinuousFocusOptions(struct soap *soap, const char *tag, int id, tt__ContinuousFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ContinuousFocusOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ContinuousFocusOptions ? type : NULL);
}

SOAP_FMAC3 tt__ContinuousFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__ContinuousFocusOptions(struct soap *soap, const char *tag, tt__ContinuousFocusOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ContinuousFocusOptions **)soap_malloc(soap, sizeof(tt__ContinuousFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ContinuousFocusOptions *)imageing_instantiate_tt__ContinuousFocusOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ContinuousFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(tt__ContinuousFocusOptions), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, tag ? tag : "tt:ContinuousFocusOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ContinuousFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ContinuousFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocusOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, tt__RelativeFocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocusOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RelativeFocusOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, tt__RelativeFocusOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RelativeFocusOptions20 **)soap_malloc(soap, sizeof(tt__RelativeFocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RelativeFocusOptions20 *)imageing_instantiate_tt__RelativeFocusOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RelativeFocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(tt__RelativeFocusOptions20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, tag ? tag : "tt:RelativeFocusOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AbsoluteFocusOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AbsoluteFocusOptions(struct soap *soap, const char *tag, int id, tt__AbsoluteFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AbsoluteFocusOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AbsoluteFocusOptions ? type : NULL);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__AbsoluteFocusOptions(struct soap *soap, const char *tag, tt__AbsoluteFocusOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AbsoluteFocusOptions **)soap_malloc(soap, sizeof(tt__AbsoluteFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AbsoluteFocusOptions *)imageing_instantiate_tt__AbsoluteFocusOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AbsoluteFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(tt__AbsoluteFocusOptions), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, tag ? tag : "tt:AbsoluteFocusOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AbsoluteFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, int id, tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IrCutFilterAutoAdjustmentOptionsExtension **)soap_malloc(soap, sizeof(tt__IrCutFilterAutoAdjustmentOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IrCutFilterAutoAdjustmentOptionsExtension *)imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustmentOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(tt__IrCutFilterAutoAdjustmentOptionsExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DurationRange(struct soap *soap, tt__DurationRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DurationRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DurationRange(struct soap *soap, const char *tag, int id, tt__DurationRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DurationRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DurationRange ? type : NULL);
}

SOAP_FMAC3 tt__DurationRange ** SOAP_FMAC4 soap_in_PointerTott__DurationRange(struct soap *soap, const char *tag, tt__DurationRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DurationRange **)soap_malloc(soap, sizeof(tt__DurationRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DurationRange *)imageing_instantiate_tt__DurationRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DurationRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DurationRange(struct soap *soap, tt__DurationRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DurationRange(soap, tag ? tag : "tt:DurationRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DurationRange ** SOAP_FMAC4 soap_get_PointerTott__DurationRange(struct soap *soap, tt__DurationRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, int id, tt__ImageStabilizationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImageStabilizationOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__ImageStabilizationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, tt__ImageStabilizationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImageStabilizationOptionsExtension **)soap_malloc(soap, sizeof(tt__ImageStabilizationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImageStabilizationOptionsExtension *)imageing_instantiate_tt__ImageStabilizationOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImageStabilizationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(tt__ImageStabilizationOptionsExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilizationOptionsExtension(soap, tag ? tag : "tt:ImageStabilizationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImageStabilizationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension4))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension4(struct soap *soap, const char *tag, int id, tt__ImagingOptions20Extension4 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension4, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension4 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingOptions20Extension4 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension4(struct soap *soap, const char *tag, tt__ImagingOptions20Extension4 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingOptions20Extension4 **)soap_malloc(soap, sizeof(tt__ImagingOptions20Extension4 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingOptions20Extension4 *)imageing_instantiate_tt__ImagingOptions20Extension4(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingOptions20Extension4 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(tt__ImagingOptions20Extension4), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20Extension4(soap, tag ? tag : "tt:ImagingOptions20Extension4", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingOptions20Extension4 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NoiseReductionOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NoiseReductionOptions(struct soap *soap, const char *tag, int id, tt__NoiseReductionOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NoiseReductionOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NoiseReductionOptions ? type : NULL);
}

SOAP_FMAC3 tt__NoiseReductionOptions ** SOAP_FMAC4 soap_in_PointerTott__NoiseReductionOptions(struct soap *soap, const char *tag, tt__NoiseReductionOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NoiseReductionOptions **)soap_malloc(soap, sizeof(tt__NoiseReductionOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NoiseReductionOptions *)imageing_instantiate_tt__NoiseReductionOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NoiseReductionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(tt__NoiseReductionOptions), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NoiseReductionOptions(soap, tag ? tag : "tt:NoiseReductionOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NoiseReductionOptions ** SOAP_FMAC4 soap_get_PointerTott__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NoiseReductionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DefoggingOptions(struct soap *soap, tt__DefoggingOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DefoggingOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DefoggingOptions(struct soap *soap, const char *tag, int id, tt__DefoggingOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DefoggingOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DefoggingOptions ? type : NULL);
}

SOAP_FMAC3 tt__DefoggingOptions ** SOAP_FMAC4 soap_in_PointerTott__DefoggingOptions(struct soap *soap, const char *tag, tt__DefoggingOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DefoggingOptions **)soap_malloc(soap, sizeof(tt__DefoggingOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DefoggingOptions *)imageing_instantiate_tt__DefoggingOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DefoggingOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DefoggingOptions, sizeof(tt__DefoggingOptions), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DefoggingOptions(struct soap *soap, tt__DefoggingOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DefoggingOptions(soap, tag ? tag : "tt:DefoggingOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DefoggingOptions ** SOAP_FMAC4 soap_get_PointerTott__DefoggingOptions(struct soap *soap, tt__DefoggingOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DefoggingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ToneCompensationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ToneCompensationOptions(struct soap *soap, const char *tag, int id, tt__ToneCompensationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ToneCompensationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ToneCompensationOptions ? type : NULL);
}

SOAP_FMAC3 tt__ToneCompensationOptions ** SOAP_FMAC4 soap_in_PointerTott__ToneCompensationOptions(struct soap *soap, const char *tag, tt__ToneCompensationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ToneCompensationOptions **)soap_malloc(soap, sizeof(tt__ToneCompensationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ToneCompensationOptions *)imageing_instantiate_tt__ToneCompensationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ToneCompensationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(tt__ToneCompensationOptions), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ToneCompensationOptions(soap, tag ? tag : "tt:ToneCompensationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ToneCompensationOptions ** SOAP_FMAC4 soap_get_PointerTott__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ToneCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension3(struct soap *soap, const char *tag, int id, tt__ImagingOptions20Extension3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension3 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingOptions20Extension3 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension3(struct soap *soap, const char *tag, tt__ImagingOptions20Extension3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingOptions20Extension3 **)soap_malloc(soap, sizeof(tt__ImagingOptions20Extension3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingOptions20Extension3 *)imageing_instantiate_tt__ImagingOptions20Extension3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingOptions20Extension3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(tt__ImagingOptions20Extension3), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20Extension3(soap, tag ? tag : "tt:ImagingOptions20Extension3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingOptions20Extension3 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, int id, tt__IrCutFilterAutoAdjustmentOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions ? type : NULL);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IrCutFilterAutoAdjustmentOptions **)soap_malloc(soap, sizeof(tt__IrCutFilterAutoAdjustmentOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IrCutFilterAutoAdjustmentOptions *)imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustmentOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(tt__IrCutFilterAutoAdjustmentOptions), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension2(struct soap *soap, const char *tag, int id, tt__ImagingOptions20Extension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension2 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingOptions20Extension2 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension2(struct soap *soap, const char *tag, tt__ImagingOptions20Extension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingOptions20Extension2 **)soap_malloc(soap, sizeof(tt__ImagingOptions20Extension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingOptions20Extension2 *)imageing_instantiate_tt__ImagingOptions20Extension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingOptions20Extension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(tt__ImagingOptions20Extension2), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20Extension2(soap, tag ? tag : "tt:ImagingOptions20Extension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingOptions20Extension2 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationOptions(struct soap *soap, const char *tag, int id, tt__ImageStabilizationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImageStabilizationOptions ? type : NULL);
}

SOAP_FMAC3 tt__ImageStabilizationOptions ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationOptions(struct soap *soap, const char *tag, tt__ImageStabilizationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImageStabilizationOptions **)soap_malloc(soap, sizeof(tt__ImageStabilizationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImageStabilizationOptions *)imageing_instantiate_tt__ImageStabilizationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImageStabilizationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(tt__ImageStabilizationOptions), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilizationOptions(soap, tag ? tag : "tt:ImageStabilizationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImageStabilizationOptions ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, tt__ImagingOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension ? type : NULL);
}

SOAP_FMAC3 tt__ImagingOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension(struct soap *soap, const char *tag, tt__ImagingOptions20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingOptions20Extension **)soap_malloc(soap, sizeof(tt__ImagingOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingOptions20Extension *)imageing_instantiate_tt__ImagingOptions20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(tt__ImagingOptions20Extension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20Extension(soap, tag ? tag : "tt:ImagingOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, tt__WhiteBalanceOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WhiteBalanceOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalanceOptions20 **)soap_malloc(soap, sizeof(tt__WhiteBalanceOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalanceOptions20 *)imageing_instantiate_tt__WhiteBalanceOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WhiteBalanceOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(tt__WhiteBalanceOptions20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalanceOptions20(soap, tag ? tag : "tt:WhiteBalanceOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRangeOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, tt__WideDynamicRangeOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRangeOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WideDynamicRangeOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRangeOptions20(struct soap *soap, const char *tag, tt__WideDynamicRangeOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WideDynamicRangeOptions20 **)soap_malloc(soap, sizeof(tt__WideDynamicRangeOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WideDynamicRangeOptions20 *)imageing_instantiate_tt__WideDynamicRangeOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WideDynamicRangeOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(tt__WideDynamicRangeOptions20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WideDynamicRangeOptions20(soap, tag ? tag : "tt:WideDynamicRangeOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20(struct soap *soap, tt__FocusOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20(struct soap *soap, const char *tag, int id, tt__FocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__FocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20(struct soap *soap, const char *tag, tt__FocusOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusOptions20 **)soap_malloc(soap, sizeof(tt__FocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusOptions20 *)imageing_instantiate_tt__FocusOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20, sizeof(tt__FocusOptions20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20(struct soap *soap, tt__FocusOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusOptions20(soap, tag ? tag : "tt:FocusOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20(struct soap *soap, tt__FocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ExposureOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposureOptions20(struct soap *soap, const char *tag, int id, tt__ExposureOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposureOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ExposureOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__ExposureOptions20 ** SOAP_FMAC4 soap_in_PointerTott__ExposureOptions20(struct soap *soap, const char *tag, tt__ExposureOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ExposureOptions20 **)soap_malloc(soap, sizeof(tt__ExposureOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ExposureOptions20 *)imageing_instantiate_tt__ExposureOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ExposureOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposureOptions20, sizeof(tt__ExposureOptions20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ExposureOptions20(soap, tag ? tag : "tt:ExposureOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ExposureOptions20 ** SOAP_FMAC4 soap_get_PointerTott__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensationOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, tt__BacklightCompensationOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensationOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__BacklightCompensationOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensationOptions20(struct soap *soap, const char *tag, tt__BacklightCompensationOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BacklightCompensationOptions20 **)soap_malloc(soap, sizeof(tt__BacklightCompensationOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BacklightCompensationOptions20 *)imageing_instantiate_tt__BacklightCompensationOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__BacklightCompensationOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(tt__BacklightCompensationOptions20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BacklightCompensationOptions20(soap, tag ? tag : "tt:BacklightCompensationOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DefoggingExtension(struct soap *soap, tt__DefoggingExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DefoggingExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DefoggingExtension(struct soap *soap, const char *tag, int id, tt__DefoggingExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DefoggingExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DefoggingExtension ? type : NULL);
}

SOAP_FMAC3 tt__DefoggingExtension ** SOAP_FMAC4 soap_in_PointerTott__DefoggingExtension(struct soap *soap, const char *tag, tt__DefoggingExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DefoggingExtension **)soap_malloc(soap, sizeof(tt__DefoggingExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DefoggingExtension *)imageing_instantiate_tt__DefoggingExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DefoggingExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DefoggingExtension, sizeof(tt__DefoggingExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DefoggingExtension(struct soap *soap, tt__DefoggingExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DefoggingExtension(soap, tag ? tag : "tt:DefoggingExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DefoggingExtension ** SOAP_FMAC4 soap_get_PointerTott__DefoggingExtension(struct soap *soap, tt__DefoggingExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DefoggingExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ToneCompensationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ToneCompensationExtension(struct soap *soap, const char *tag, int id, tt__ToneCompensationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ToneCompensationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ToneCompensationExtension ? type : NULL);
}

SOAP_FMAC3 tt__ToneCompensationExtension ** SOAP_FMAC4 soap_in_PointerTott__ToneCompensationExtension(struct soap *soap, const char *tag, tt__ToneCompensationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ToneCompensationExtension **)soap_malloc(soap, sizeof(tt__ToneCompensationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ToneCompensationExtension *)imageing_instantiate_tt__ToneCompensationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ToneCompensationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(tt__ToneCompensationExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ToneCompensationExtension(soap, tag ? tag : "tt:ToneCompensationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ToneCompensationExtension ** SOAP_FMAC4 soap_get_PointerTott__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ToneCompensationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rectangle(struct soap *soap, tt__Rectangle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rectangle))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rectangle(struct soap *soap, const char *tag, int id, tt__Rectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rectangle, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Rectangle ? type : NULL);
}

SOAP_FMAC3 tt__Rectangle ** SOAP_FMAC4 soap_in_PointerTott__Rectangle(struct soap *soap, const char *tag, tt__Rectangle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Rectangle **)soap_malloc(soap, sizeof(tt__Rectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Rectangle *)imageing_instantiate_tt__Rectangle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Rectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rectangle, sizeof(tt__Rectangle), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rectangle(struct soap *soap, tt__Rectangle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Rectangle(soap, tag ? tag : "tt:Rectangle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Rectangle ** SOAP_FMAC4 soap_get_PointerTott__Rectangle(struct soap *soap, tt__Rectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ExposurePriority);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposurePriority(struct soap *soap, const char *tag, int id, enum tt__ExposurePriority *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposurePriority, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ExposurePriority(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__ExposurePriority ** SOAP_FMAC4 soap_in_PointerTott__ExposurePriority(struct soap *soap, const char *tag, enum tt__ExposurePriority **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__ExposurePriority **)soap_malloc(soap, sizeof(enum tt__ExposurePriority *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ExposurePriority(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__ExposurePriority **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ExposurePriority(soap, tag ? tag : "tt:ExposurePriority", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposurePriority ** SOAP_FMAC4 soap_get_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposurePriority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, int id, tt__IrCutFilterAutoAdjustmentExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension ? type : NULL);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IrCutFilterAutoAdjustmentExtension **)soap_malloc(soap, sizeof(tt__IrCutFilterAutoAdjustmentExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IrCutFilterAutoAdjustmentExtension *)imageing_instantiate_tt__IrCutFilterAutoAdjustmentExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustmentExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(tt__IrCutFilterAutoAdjustmentExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__duration))
		soap_serialize_xsd__duration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationExtension(struct soap *soap, const char *tag, int id, tt__ImageStabilizationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImageStabilizationExtension ? type : NULL);
}

SOAP_FMAC3 tt__ImageStabilizationExtension ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationExtension(struct soap *soap, const char *tag, tt__ImageStabilizationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImageStabilizationExtension **)soap_malloc(soap, sizeof(tt__ImageStabilizationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImageStabilizationExtension *)imageing_instantiate_tt__ImageStabilizationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImageStabilizationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(tt__ImageStabilizationExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilizationExtension(soap, tag ? tag : "tt:ImageStabilizationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImageStabilizationExtension ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension204))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension204(struct soap *soap, const char *tag, int id, tt__ImagingSettingsExtension204 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension204, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension204 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingSettingsExtension204 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension204(struct soap *soap, const char *tag, tt__ImagingSettingsExtension204 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettingsExtension204 **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension204 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettingsExtension204 *)imageing_instantiate_tt__ImagingSettingsExtension204(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingSettingsExtension204 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension204, sizeof(tt__ImagingSettingsExtension204), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension204(soap, tag ? tag : "tt:ImagingSettingsExtension204", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettingsExtension204 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension204(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NoiseReduction(struct soap *soap, tt__NoiseReduction *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NoiseReduction))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NoiseReduction(struct soap *soap, const char *tag, int id, tt__NoiseReduction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NoiseReduction, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NoiseReduction ? type : NULL);
}

SOAP_FMAC3 tt__NoiseReduction ** SOAP_FMAC4 soap_in_PointerTott__NoiseReduction(struct soap *soap, const char *tag, tt__NoiseReduction **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NoiseReduction **)soap_malloc(soap, sizeof(tt__NoiseReduction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NoiseReduction *)imageing_instantiate_tt__NoiseReduction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NoiseReduction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NoiseReduction, sizeof(tt__NoiseReduction), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NoiseReduction(struct soap *soap, tt__NoiseReduction *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NoiseReduction(soap, tag ? tag : "tt:NoiseReduction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NoiseReduction ** SOAP_FMAC4 soap_get_PointerTott__NoiseReduction(struct soap *soap, tt__NoiseReduction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NoiseReduction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Defogging(struct soap *soap, tt__Defogging *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Defogging))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Defogging(struct soap *soap, const char *tag, int id, tt__Defogging *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Defogging, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Defogging ? type : NULL);
}

SOAP_FMAC3 tt__Defogging ** SOAP_FMAC4 soap_in_PointerTott__Defogging(struct soap *soap, const char *tag, tt__Defogging **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Defogging **)soap_malloc(soap, sizeof(tt__Defogging *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Defogging *)imageing_instantiate_tt__Defogging(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Defogging **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Defogging, sizeof(tt__Defogging), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Defogging(struct soap *soap, tt__Defogging *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Defogging(soap, tag ? tag : "tt:Defogging", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Defogging ** SOAP_FMAC4 soap_get_PointerTott__Defogging(struct soap *soap, tt__Defogging **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Defogging(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ToneCompensation(struct soap *soap, tt__ToneCompensation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ToneCompensation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ToneCompensation(struct soap *soap, const char *tag, int id, tt__ToneCompensation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ToneCompensation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ToneCompensation ? type : NULL);
}

SOAP_FMAC3 tt__ToneCompensation ** SOAP_FMAC4 soap_in_PointerTott__ToneCompensation(struct soap *soap, const char *tag, tt__ToneCompensation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ToneCompensation **)soap_malloc(soap, sizeof(tt__ToneCompensation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ToneCompensation *)imageing_instantiate_tt__ToneCompensation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ToneCompensation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ToneCompensation, sizeof(tt__ToneCompensation), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ToneCompensation(struct soap *soap, tt__ToneCompensation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ToneCompensation(soap, tag ? tag : "tt:ToneCompensation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ToneCompensation ** SOAP_FMAC4 soap_get_PointerTott__ToneCompensation(struct soap *soap, tt__ToneCompensation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ToneCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension203))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension203(struct soap *soap, const char *tag, int id, tt__ImagingSettingsExtension203 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension203, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension203 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingSettingsExtension203 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension203(struct soap *soap, const char *tag, tt__ImagingSettingsExtension203 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettingsExtension203 **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension203 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettingsExtension203 *)imageing_instantiate_tt__ImagingSettingsExtension203(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingSettingsExtension203 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(tt__ImagingSettingsExtension203), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension203(soap, tag ? tag : "tt:ImagingSettingsExtension203", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettingsExtension203 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension203(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, int id, tt__IrCutFilterAutoAdjustment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustment ? type : NULL);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustment ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustment **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IrCutFilterAutoAdjustment **)soap_malloc(soap, sizeof(tt__IrCutFilterAutoAdjustment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IrCutFilterAutoAdjustment *)imageing_instantiate_tt__IrCutFilterAutoAdjustment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(tt__IrCutFilterAutoAdjustment), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterAutoAdjustment(soap, tag ? tag : "tt:IrCutFilterAutoAdjustment", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustment ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterAutoAdjustment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension202))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension202(struct soap *soap, const char *tag, int id, tt__ImagingSettingsExtension202 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension202, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension202 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingSettingsExtension202 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension202(struct soap *soap, const char *tag, tt__ImagingSettingsExtension202 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettingsExtension202 **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension202 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettingsExtension202 *)imageing_instantiate_tt__ImagingSettingsExtension202(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingSettingsExtension202 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(tt__ImagingSettingsExtension202), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension202(soap, tag ? tag : "tt:ImagingSettingsExtension202", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettingsExtension202 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension202(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilization(struct soap *soap, tt__ImageStabilization *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilization))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilization(struct soap *soap, const char *tag, int id, tt__ImageStabilization *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilization, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImageStabilization ? type : NULL);
}

SOAP_FMAC3 tt__ImageStabilization ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilization(struct soap *soap, const char *tag, tt__ImageStabilization **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImageStabilization **)soap_malloc(soap, sizeof(tt__ImageStabilization *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImageStabilization *)imageing_instantiate_tt__ImageStabilization(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImageStabilization **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilization, sizeof(tt__ImageStabilization), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilization(struct soap *soap, tt__ImageStabilization *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilization(soap, tag ? tag : "tt:ImageStabilization", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImageStabilization ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilization(struct soap *soap, tt__ImageStabilization **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, tt__ImagingSettingsExtension20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension20 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension20(struct soap *soap, const char *tag, tt__ImagingSettingsExtension20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettingsExtension20 **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettingsExtension20 *)imageing_instantiate_tt__ImagingSettingsExtension20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingSettingsExtension20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(tt__ImagingSettingsExtension20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension20(soap, tag ? tag : "tt:ImagingSettingsExtension20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20(struct soap *soap, const char *tag, int id, tt__WhiteBalance20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WhiteBalance20 ? type : NULL);
}

SOAP_FMAC3 tt__WhiteBalance20 ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20(struct soap *soap, const char *tag, tt__WhiteBalance20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalance20 **)soap_malloc(soap, sizeof(tt__WhiteBalance20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalance20 *)imageing_instantiate_tt__WhiteBalance20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WhiteBalance20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20, sizeof(tt__WhiteBalance20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalance20(soap, tag ? tag : "tt:WhiteBalance20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalance20 ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRange20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRange20(struct soap *soap, const char *tag, int id, tt__WideDynamicRange20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRange20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WideDynamicRange20 ? type : NULL);
}

SOAP_FMAC3 tt__WideDynamicRange20 ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRange20(struct soap *soap, const char *tag, tt__WideDynamicRange20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WideDynamicRange20 **)soap_malloc(soap, sizeof(tt__WideDynamicRange20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WideDynamicRange20 *)imageing_instantiate_tt__WideDynamicRange20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WideDynamicRange20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(tt__WideDynamicRange20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WideDynamicRange20(soap, tag ? tag : "tt:WideDynamicRange20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WideDynamicRange20 ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRange20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterMode(struct soap *soap, const char *tag, int id, enum tt__IrCutFilterMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IrCutFilterMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__IrCutFilterMode ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterMode(struct soap *soap, const char *tag, enum tt__IrCutFilterMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__IrCutFilterMode **)soap_malloc(soap, sizeof(enum tt__IrCutFilterMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IrCutFilterMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__IrCutFilterMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterMode(soap, tag ? tag : "tt:IrCutFilterMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IrCutFilterMode ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20(struct soap *soap, const char *tag, int id, tt__FocusConfiguration20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusConfiguration20 ? type : NULL);
}

SOAP_FMAC3 tt__FocusConfiguration20 ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20(struct soap *soap, const char *tag, tt__FocusConfiguration20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusConfiguration20 **)soap_malloc(soap, sizeof(tt__FocusConfiguration20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusConfiguration20 *)imageing_instantiate_tt__FocusConfiguration20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusConfiguration20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(tt__FocusConfiguration20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusConfiguration20(soap, tag ? tag : "tt:FocusConfiguration20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusConfiguration20 ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Exposure20(struct soap *soap, tt__Exposure20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Exposure20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Exposure20(struct soap *soap, const char *tag, int id, tt__Exposure20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Exposure20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Exposure20 ? type : NULL);
}

SOAP_FMAC3 tt__Exposure20 ** SOAP_FMAC4 soap_in_PointerTott__Exposure20(struct soap *soap, const char *tag, tt__Exposure20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Exposure20 **)soap_malloc(soap, sizeof(tt__Exposure20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Exposure20 *)imageing_instantiate_tt__Exposure20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Exposure20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Exposure20, sizeof(tt__Exposure20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Exposure20(struct soap *soap, tt__Exposure20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Exposure20(soap, tag ? tag : "tt:Exposure20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Exposure20 ** SOAP_FMAC4 soap_get_PointerTott__Exposure20(struct soap *soap, tt__Exposure20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Exposure20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensation20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensation20(struct soap *soap, const char *tag, int id, tt__BacklightCompensation20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensation20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__BacklightCompensation20 ? type : NULL);
}

SOAP_FMAC3 tt__BacklightCompensation20 ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensation20(struct soap *soap, const char *tag, tt__BacklightCompensation20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BacklightCompensation20 **)soap_malloc(soap, sizeof(tt__BacklightCompensation20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BacklightCompensation20 *)imageing_instantiate_tt__BacklightCompensation20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__BacklightCompensation20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(tt__BacklightCompensation20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BacklightCompensation20(soap, tag ? tag : "tt:BacklightCompensation20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BacklightCompensation20 ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensation20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusStatus20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus20Extension(struct soap *soap, const char *tag, int id, tt__FocusStatus20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusStatus20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusStatus20Extension ? type : NULL);
}

SOAP_FMAC3 tt__FocusStatus20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus20Extension(struct soap *soap, const char *tag, tt__FocusStatus20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusStatus20Extension **)soap_malloc(soap, sizeof(tt__FocusStatus20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusStatus20Extension *)imageing_instantiate_tt__FocusStatus20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(tt__FocusStatus20Extension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusStatus20Extension(soap, tag ? tag : "tt:FocusStatus20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusStatus20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingStatus20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingStatus20Extension(struct soap *soap, const char *tag, int id, tt__ImagingStatus20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingStatus20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingStatus20Extension ? type : NULL);
}

SOAP_FMAC3 tt__ImagingStatus20Extension ** SOAP_FMAC4 soap_in_PointerTott__ImagingStatus20Extension(struct soap *soap, const char *tag, tt__ImagingStatus20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingStatus20Extension **)soap_malloc(soap, sizeof(tt__ImagingStatus20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingStatus20Extension *)imageing_instantiate_tt__ImagingStatus20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(tt__ImagingStatus20Extension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingStatus20Extension(soap, tag ? tag : "tt:ImagingStatus20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingStatus20Extension ** SOAP_FMAC4 soap_get_PointerTott__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus20(struct soap *soap, tt__FocusStatus20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusStatus20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus20(struct soap *soap, const char *tag, int id, tt__FocusStatus20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusStatus20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusStatus20 ? type : NULL);
}

SOAP_FMAC3 tt__FocusStatus20 ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus20(struct soap *soap, const char *tag, tt__FocusStatus20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusStatus20 **)soap_malloc(soap, sizeof(tt__FocusStatus20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusStatus20 *)imageing_instantiate_tt__FocusStatus20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusStatus20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus20, sizeof(tt__FocusStatus20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus20(struct soap *soap, tt__FocusStatus20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusStatus20(soap, tag ? tag : "tt:FocusStatus20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusStatus20 ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus20(struct soap *soap, tt__FocusStatus20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ContinuousFocus(struct soap *soap, tt__ContinuousFocus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ContinuousFocus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ContinuousFocus(struct soap *soap, const char *tag, int id, tt__ContinuousFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ContinuousFocus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ContinuousFocus ? type : NULL);
}

SOAP_FMAC3 tt__ContinuousFocus ** SOAP_FMAC4 soap_in_PointerTott__ContinuousFocus(struct soap *soap, const char *tag, tt__ContinuousFocus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ContinuousFocus **)soap_malloc(soap, sizeof(tt__ContinuousFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ContinuousFocus *)imageing_instantiate_tt__ContinuousFocus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ContinuousFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ContinuousFocus, sizeof(tt__ContinuousFocus), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ContinuousFocus(struct soap *soap, tt__ContinuousFocus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ContinuousFocus(soap, tag ? tag : "tt:ContinuousFocus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ContinuousFocus ** SOAP_FMAC4 soap_get_PointerTott__ContinuousFocus(struct soap *soap, tt__ContinuousFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ContinuousFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocus(struct soap *soap, tt__RelativeFocus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocus(struct soap *soap, const char *tag, int id, tt__RelativeFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RelativeFocus ? type : NULL);
}

SOAP_FMAC3 tt__RelativeFocus ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocus(struct soap *soap, const char *tag, tt__RelativeFocus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RelativeFocus **)soap_malloc(soap, sizeof(tt__RelativeFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RelativeFocus *)imageing_instantiate_tt__RelativeFocus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RelativeFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocus, sizeof(tt__RelativeFocus), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocus(struct soap *soap, tt__RelativeFocus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelativeFocus(soap, tag ? tag : "tt:RelativeFocus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RelativeFocus ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocus(struct soap *soap, tt__RelativeFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AbsoluteFocus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AbsoluteFocus(struct soap *soap, const char *tag, int id, tt__AbsoluteFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AbsoluteFocus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AbsoluteFocus ? type : NULL);
}

SOAP_FMAC3 tt__AbsoluteFocus ** SOAP_FMAC4 soap_in_PointerTott__AbsoluteFocus(struct soap *soap, const char *tag, tt__AbsoluteFocus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AbsoluteFocus **)soap_malloc(soap, sizeof(tt__AbsoluteFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AbsoluteFocus *)imageing_instantiate_tt__AbsoluteFocus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AbsoluteFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AbsoluteFocus, sizeof(tt__AbsoluteFocus), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AbsoluteFocus(soap, tag ? tag : "tt:AbsoluteFocus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AbsoluteFocus ** SOAP_FMAC4 soap_get_PointerTott__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AbsoluteFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector1D(struct soap *soap, tt__Vector1D *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector1D))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector1D(struct soap *soap, const char *tag, int id, tt__Vector1D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector1D, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Vector1D ? type : NULL);
}

SOAP_FMAC3 tt__Vector1D ** SOAP_FMAC4 soap_in_PointerTott__Vector1D(struct soap *soap, const char *tag, tt__Vector1D **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Vector1D **)soap_malloc(soap, sizeof(tt__Vector1D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Vector1D *)imageing_instantiate_tt__Vector1D(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Vector1D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector1D, sizeof(tt__Vector1D), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector1D(struct soap *soap, tt__Vector1D *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector1D(soap, tag ? tag : "tt:Vector1D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Vector1D ** SOAP_FMAC4 soap_get_PointerTott__Vector1D(struct soap *soap, tt__Vector1D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector2D(struct soap *soap, tt__Vector2D *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector2D))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector2D(struct soap *soap, const char *tag, int id, tt__Vector2D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector2D, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Vector2D ? type : NULL);
}

SOAP_FMAC3 tt__Vector2D ** SOAP_FMAC4 soap_in_PointerTott__Vector2D(struct soap *soap, const char *tag, tt__Vector2D **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Vector2D **)soap_malloc(soap, sizeof(tt__Vector2D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Vector2D *)imageing_instantiate_tt__Vector2D(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Vector2D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector2D, sizeof(tt__Vector2D), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector2D(struct soap *soap, tt__Vector2D *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector2D(soap, tag ? tag : "tt:Vector2D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Vector2D ** SOAP_FMAC4 soap_get_PointerTott__Vector2D(struct soap *soap, tt__Vector2D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FloatRange(struct soap *soap, tt__FloatRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FloatRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FloatRange(struct soap *soap, const char *tag, int id, tt__FloatRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FloatRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FloatRange ? type : NULL);
}

SOAP_FMAC3 tt__FloatRange ** SOAP_FMAC4 soap_in_PointerTott__FloatRange(struct soap *soap, const char *tag, tt__FloatRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FloatRange **)soap_malloc(soap, sizeof(tt__FloatRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FloatRange *)imageing_instantiate_tt__FloatRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FloatRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FloatRange(struct soap *soap, tt__FloatRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FloatRange(soap, tag ? tag : "tt:FloatRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FloatRange ** SOAP_FMAC4 soap_get_PointerTott__FloatRange(struct soap *soap, tt__FloatRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space1DDescription(struct soap *soap, tt__Space1DDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space1DDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space1DDescription(struct soap *soap, const char *tag, int id, tt__Space1DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space1DDescription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Space1DDescription ? type : NULL);
}

SOAP_FMAC3 tt__Space1DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space1DDescription(struct soap *soap, const char *tag, tt__Space1DDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Space1DDescription **)soap_malloc(soap, sizeof(tt__Space1DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Space1DDescription *)imageing_instantiate_tt__Space1DDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Space1DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space1DDescription, sizeof(tt__Space1DDescription), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space1DDescription(struct soap *soap, tt__Space1DDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Space1DDescription(soap, tag ? tag : "tt:Space1DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Space1DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space1DDescription(struct soap *soap, tt__Space1DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space2DDescription(struct soap *soap, tt__Space2DDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space2DDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space2DDescription(struct soap *soap, const char *tag, int id, tt__Space2DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space2DDescription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Space2DDescription ? type : NULL);
}

SOAP_FMAC3 tt__Space2DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space2DDescription(struct soap *soap, const char *tag, tt__Space2DDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Space2DDescription **)soap_malloc(soap, sizeof(tt__Space2DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Space2DDescription *)imageing_instantiate_tt__Space2DDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Space2DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space2DDescription, sizeof(tt__Space2DDescription), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space2DDescription(struct soap *soap, tt__Space2DDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Space2DDescription(soap, tag ? tag : "tt:Space2DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Space2DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space2DDescription(struct soap *soap, tt__Space2DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirectionExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirectionExtension(struct soap *soap, const char *tag, int id, tt__PTControlDirectionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirectionExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTControlDirectionExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTControlDirectionExtension ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirectionExtension(struct soap *soap, const char *tag, tt__PTControlDirectionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTControlDirectionExtension **)soap_malloc(soap, sizeof(tt__PTControlDirectionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTControlDirectionExtension *)imageing_instantiate_tt__PTControlDirectionExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTControlDirectionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(tt__PTControlDirectionExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTControlDirectionExtension(soap, tag ? tag : "tt:PTControlDirectionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTControlDirectionExtension ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirectionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Reverse(struct soap *soap, tt__Reverse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Reverse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Reverse(struct soap *soap, const char *tag, int id, tt__Reverse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Reverse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Reverse ? type : NULL);
}

SOAP_FMAC3 tt__Reverse ** SOAP_FMAC4 soap_in_PointerTott__Reverse(struct soap *soap, const char *tag, tt__Reverse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Reverse **)soap_malloc(soap, sizeof(tt__Reverse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Reverse *)imageing_instantiate_tt__Reverse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Reverse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Reverse, sizeof(tt__Reverse), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Reverse(struct soap *soap, tt__Reverse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Reverse(soap, tag ? tag : "tt:Reverse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Reverse ** SOAP_FMAC4 soap_get_PointerTott__Reverse(struct soap *soap, tt__Reverse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Reverse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlip(struct soap *soap, tt__EFlip *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EFlip))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlip(struct soap *soap, const char *tag, int id, tt__EFlip *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EFlip, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EFlip ? type : NULL);
}

SOAP_FMAC3 tt__EFlip ** SOAP_FMAC4 soap_in_PointerTott__EFlip(struct soap *soap, const char *tag, tt__EFlip **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EFlip **)soap_malloc(soap, sizeof(tt__EFlip *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EFlip *)imageing_instantiate_tt__EFlip(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EFlip **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlip, sizeof(tt__EFlip), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlip(struct soap *soap, tt__EFlip *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EFlip(soap, tag ? tag : "tt:EFlip", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EFlip ** SOAP_FMAC4 soap_get_PointerTott__EFlip(struct soap *soap, tt__EFlip **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EFlip(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension2(struct soap *soap, const char *tag, int id, tt__PTZConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension2(struct soap *soap, const char *tag, tt__PTZConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfigurationExtension2 **)soap_malloc(soap, sizeof(tt__PTZConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfigurationExtension2 *)imageing_instantiate_tt__PTZConfigurationExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(tt__PTZConfigurationExtension2), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationExtension2(soap, tag ? tag : "tt:PTZConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirection(struct soap *soap, tt__PTControlDirection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirection))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirection(struct soap *soap, const char *tag, int id, tt__PTControlDirection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirection, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTControlDirection ? type : NULL);
}

SOAP_FMAC3 tt__PTControlDirection ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirection(struct soap *soap, const char *tag, tt__PTControlDirection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTControlDirection **)soap_malloc(soap, sizeof(tt__PTControlDirection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTControlDirection *)imageing_instantiate_tt__PTControlDirection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTControlDirection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirection, sizeof(tt__PTControlDirection), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirection(struct soap *soap, tt__PTControlDirection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTControlDirection(soap, tag ? tag : "tt:PTControlDirection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTControlDirection ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirection(struct soap *soap, tt__PTControlDirection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Address(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Address))
		soap_serialize_tt__IPv6Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Address(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Address, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__IPv6Address(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Address, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Address(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6Address(soap, tag ? tag : "tt:IPv6Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__IPv6Address(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Address(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Address))
		soap_serialize_tt__IPv4Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Address(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Address, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__IPv4Address(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Address, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Address(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4Address(soap, tag ? tag : "tt:IPv4Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__IPv4Address(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddress(struct soap *soap, tt__IPAddress *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddress))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddress(struct soap *soap, const char *tag, int id, tt__IPAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddress, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPAddress ? type : NULL);
}

SOAP_FMAC3 tt__IPAddress ** SOAP_FMAC4 soap_in_PointerTott__IPAddress(struct soap *soap, const char *tag, tt__IPAddress **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPAddress **)soap_malloc(soap, sizeof(tt__IPAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPAddress *)imageing_instantiate_tt__IPAddress(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddress, sizeof(tt__IPAddress), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddress(struct soap *soap, tt__IPAddress *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPAddress(soap, tag ? tag : "tt:IPAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPAddress ** SOAP_FMAC4 soap_get_PointerTott__IPAddress(struct soap *soap, tt__IPAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, _tt__EventSubscription_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy ? type : NULL);
}

SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, _tt__EventSubscription_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tt__EventSubscription_SubscriptionPolicy **)soap_malloc(soap, sizeof(_tt__EventSubscription_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tt__EventSubscription_SubscriptionPolicy *)imageing_instantiate__tt__EventSubscription_SubscriptionPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tt__EventSubscription_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(_tt__EventSubscription_SubscriptionPolicy), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, tag ? tag : "tt:EventSubscription-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__FilterType(struct soap *soap, wsnt__FilterType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__FilterType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__FilterType(struct soap *soap, const char *tag, int id, wsnt__FilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__FilterType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__FilterType ? type : NULL);
}

SOAP_FMAC3 wsnt__FilterType ** SOAP_FMAC4 soap_in_PointerTowsnt__FilterType(struct soap *soap, const char *tag, wsnt__FilterType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__FilterType **)soap_malloc(soap, sizeof(wsnt__FilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__FilterType *)imageing_instantiate_wsnt__FilterType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__FilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__FilterType, sizeof(wsnt__FilterType), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__FilterType(struct soap *soap, wsnt__FilterType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__FilterType(soap, tag ? tag : "wsnt:FilterType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__FilterType ** SOAP_FMAC4 soap_get_PointerTowsnt__FilterType(struct soap *soap, wsnt__FilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensProjection(struct soap *soap, tt__LensProjection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LensProjection))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensProjection(struct soap *soap, const char *tag, int id, tt__LensProjection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LensProjection, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LensProjection ? type : NULL);
}

SOAP_FMAC3 tt__LensProjection ** SOAP_FMAC4 soap_in_PointerTott__LensProjection(struct soap *soap, const char *tag, tt__LensProjection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LensProjection **)soap_malloc(soap, sizeof(tt__LensProjection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LensProjection *)imageing_instantiate_tt__LensProjection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LensProjection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensProjection, sizeof(tt__LensProjection), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensProjection(struct soap *soap, tt__LensProjection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LensProjection(soap, tag ? tag : "tt:LensProjection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LensProjection ** SOAP_FMAC4 soap_get_PointerTott__LensProjection(struct soap *soap, tt__LensProjection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LensProjection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensOffset(struct soap *soap, tt__LensOffset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LensOffset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensOffset(struct soap *soap, const char *tag, int id, tt__LensOffset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LensOffset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LensOffset ? type : NULL);
}

SOAP_FMAC3 tt__LensOffset ** SOAP_FMAC4 soap_in_PointerTott__LensOffset(struct soap *soap, const char *tag, tt__LensOffset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LensOffset **)soap_malloc(soap, sizeof(tt__LensOffset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LensOffset *)imageing_instantiate_tt__LensOffset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LensOffset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensOffset, sizeof(tt__LensOffset), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensOffset(struct soap *soap, tt__LensOffset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LensOffset(soap, tag ? tag : "tt:LensOffset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LensOffset ** SOAP_FMAC4 soap_get_PointerTott__LensOffset(struct soap *soap, tt__LensOffset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LensOffset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTofloat(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateExtension(struct soap *soap, tt__RotateExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RotateExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateExtension(struct soap *soap, const char *tag, int id, tt__RotateExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RotateExtension ? type : NULL);
}

SOAP_FMAC3 tt__RotateExtension ** SOAP_FMAC4 soap_in_PointerTott__RotateExtension(struct soap *soap, const char *tag, tt__RotateExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RotateExtension **)soap_malloc(soap, sizeof(tt__RotateExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RotateExtension *)imageing_instantiate_tt__RotateExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RotateExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateExtension, sizeof(tt__RotateExtension), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateExtension(struct soap *soap, tt__RotateExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RotateExtension(soap, tag ? tag : "tt:RotateExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RotateExtension ** SOAP_FMAC4 soap_get_PointerTott__RotateExtension(struct soap *soap, tt__RotateExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SceneOrientation(struct soap *soap, tt__SceneOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SceneOrientation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SceneOrientation(struct soap *soap, const char *tag, int id, tt__SceneOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SceneOrientation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SceneOrientation ? type : NULL);
}

SOAP_FMAC3 tt__SceneOrientation ** SOAP_FMAC4 soap_in_PointerTott__SceneOrientation(struct soap *soap, const char *tag, tt__SceneOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SceneOrientation **)soap_malloc(soap, sizeof(tt__SceneOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SceneOrientation *)imageing_instantiate_tt__SceneOrientation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SceneOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SceneOrientation, sizeof(tt__SceneOrientation), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SceneOrientation(struct soap *soap, tt__SceneOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SceneOrientation(soap, tag ? tag : "tt:SceneOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SceneOrientation ** SOAP_FMAC4 soap_get_PointerTott__SceneOrientation(struct soap *soap, tt__SceneOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SceneOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensDescription(struct soap *soap, tt__LensDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LensDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensDescription(struct soap *soap, const char *tag, int id, tt__LensDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LensDescription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LensDescription ? type : NULL);
}

SOAP_FMAC3 tt__LensDescription ** SOAP_FMAC4 soap_in_PointerTott__LensDescription(struct soap *soap, const char *tag, tt__LensDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LensDescription **)soap_malloc(soap, sizeof(tt__LensDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LensDescription *)imageing_instantiate_tt__LensDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LensDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensDescription, sizeof(tt__LensDescription), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensDescription(struct soap *soap, tt__LensDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LensDescription(soap, tag ? tag : "tt:LensDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LensDescription ** SOAP_FMAC4 soap_get_PointerTott__LensDescription(struct soap *soap, tt__LensDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LensDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, int id, tt__VideoSourceConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfigurationExtension2 **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceConfigurationExtension2 *)imageing_instantiate_tt__VideoSourceConfigurationExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoSourceConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(tt__VideoSourceConfigurationExtension2), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rotate(struct soap *soap, tt__Rotate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rotate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rotate(struct soap *soap, const char *tag, int id, tt__Rotate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rotate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Rotate ? type : NULL);
}

SOAP_FMAC3 tt__Rotate ** SOAP_FMAC4 soap_in_PointerTott__Rotate(struct soap *soap, const char *tag, tt__Rotate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Rotate **)soap_malloc(soap, sizeof(tt__Rotate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Rotate *)imageing_instantiate_tt__Rotate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Rotate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rotate, sizeof(tt__Rotate), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rotate(struct soap *soap, tt__Rotate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Rotate(soap, tag ? tag : "tt:Rotate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Rotate ** SOAP_FMAC4 soap_get_PointerTott__Rotate(struct soap *soap, tt__Rotate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rotate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRange(struct soap *soap, tt__IntRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRange(struct soap *soap, const char *tag, int id, tt__IntRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IntRange ? type : NULL);
}

SOAP_FMAC3 tt__IntRange ** SOAP_FMAC4 soap_in_PointerTott__IntRange(struct soap *soap, const char *tag, tt__IntRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntRange **)soap_malloc(soap, sizeof(tt__IntRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntRange *)imageing_instantiate_tt__IntRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IntRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRange(struct soap *soap, tt__IntRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRange(soap, tag ? tag : "tt:IntRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntRange ** SOAP_FMAC4 soap_get_PointerTott__IntRange(struct soap *soap, tt__IntRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotimg__ImagingPreset(struct soap *soap, timg__ImagingPreset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_timg__ImagingPreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotimg__ImagingPreset(struct soap *soap, const char *tag, int id, timg__ImagingPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_timg__ImagingPreset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_timg__ImagingPreset ? type : NULL);
}

SOAP_FMAC3 timg__ImagingPreset ** SOAP_FMAC4 soap_in_PointerTotimg__ImagingPreset(struct soap *soap, const char *tag, timg__ImagingPreset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (timg__ImagingPreset **)soap_malloc(soap, sizeof(timg__ImagingPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (timg__ImagingPreset *)imageing_instantiate_timg__ImagingPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (timg__ImagingPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_timg__ImagingPreset, sizeof(timg__ImagingPreset), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotimg__ImagingPreset(struct soap *soap, timg__ImagingPreset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotimg__ImagingPreset(soap, tag ? tag : "timg:ImagingPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 timg__ImagingPreset ** SOAP_FMAC4 soap_get_PointerTotimg__ImagingPreset(struct soap *soap, timg__ImagingPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotimg__ImagingPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingStatus20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingStatus20(struct soap *soap, const char *tag, int id, tt__ImagingStatus20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingStatus20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingStatus20 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingStatus20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingStatus20(struct soap *soap, const char *tag, tt__ImagingStatus20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingStatus20 **)soap_malloc(soap, sizeof(tt__ImagingStatus20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingStatus20 *)imageing_instantiate_tt__ImagingStatus20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingStatus20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingStatus20, sizeof(tt__ImagingStatus20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingStatus20(soap, tag ? tag : "tt:ImagingStatus20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingStatus20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MoveOptions20(struct soap *soap, tt__MoveOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MoveOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MoveOptions20(struct soap *soap, const char *tag, int id, tt__MoveOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MoveOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MoveOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__MoveOptions20 ** SOAP_FMAC4 soap_in_PointerTott__MoveOptions20(struct soap *soap, const char *tag, tt__MoveOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MoveOptions20 **)soap_malloc(soap, sizeof(tt__MoveOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MoveOptions20 *)imageing_instantiate_tt__MoveOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MoveOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveOptions20, sizeof(tt__MoveOptions20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MoveOptions20(struct soap *soap, tt__MoveOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MoveOptions20(soap, tag ? tag : "tt:MoveOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MoveOptions20 ** SOAP_FMAC4 soap_get_PointerTott__MoveOptions20(struct soap *soap, tt__MoveOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MoveOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusMove(struct soap *soap, tt__FocusMove *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusMove))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusMove(struct soap *soap, const char *tag, int id, tt__FocusMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusMove, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusMove ? type : NULL);
}

SOAP_FMAC3 tt__FocusMove ** SOAP_FMAC4 soap_in_PointerTott__FocusMove(struct soap *soap, const char *tag, tt__FocusMove **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusMove **)soap_malloc(soap, sizeof(tt__FocusMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusMove *)imageing_instantiate_tt__FocusMove(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusMove, sizeof(tt__FocusMove), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusMove(struct soap *soap, tt__FocusMove *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusMove(soap, tag ? tag : "tt:FocusMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusMove ** SOAP_FMAC4 soap_get_PointerTott__FocusMove(struct soap *soap, tt__FocusMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20(struct soap *soap, const char *tag, int id, tt__ImagingOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingOptions20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20(struct soap *soap, const char *tag, tt__ImagingOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingOptions20 **)soap_malloc(soap, sizeof(tt__ImagingOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingOptions20 *)imageing_instantiate_tt__ImagingOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20, sizeof(tt__ImagingOptions20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20(soap, tag ? tag : "tt:ImagingOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingOptions20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettings20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings20(struct soap *soap, const char *tag, int id, tt__ImagingSettings20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettings20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingSettings20 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingSettings20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings20(struct soap *soap, const char *tag, tt__ImagingSettings20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettings20 **)soap_malloc(soap, sizeof(tt__ImagingSettings20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettings20 *)imageing_instantiate_tt__ImagingSettings20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingSettings20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings20, sizeof(tt__ImagingSettings20), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettings20(soap, tag ? tag : "tt:ImagingSettings20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettings20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettings20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotimg__Capabilities(struct soap *soap, timg__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_timg__Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotimg__Capabilities(struct soap *soap, const char *tag, int id, timg__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_timg__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_timg__Capabilities ? type : NULL);
}

SOAP_FMAC3 timg__Capabilities ** SOAP_FMAC4 soap_in_PointerTotimg__Capabilities(struct soap *soap, const char *tag, timg__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (timg__Capabilities **)soap_malloc(soap, sizeof(timg__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (timg__Capabilities *)imageing_instantiate_timg__Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (timg__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_timg__Capabilities, sizeof(timg__Capabilities), 0, imageing_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotimg__Capabilities(struct soap *soap, timg__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotimg__Capabilities(soap, tag ? tag : "timg:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 timg__Capabilities ** SOAP_FMAC4 soap_get_PointerTotimg__Capabilities(struct soap *soap, timg__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotimg__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Header))
		soap_serialize_SOAP_ENV__Header(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Header *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Header, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Header(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Header **)soap_malloc(soap, sizeof(struct SOAP_ENV__Header *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Header(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_chan__ChannelInstanceType))
		soap_serialize_chan__ChannelInstanceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, int id, struct chan__ChannelInstanceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_chan__ChannelInstanceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_chan__ChannelInstanceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_chan__ChannelInstanceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTochan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTochan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemIRI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemIRI(soap, tag ? tag : "wsa5:ProblemIRI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Action(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Action(soap, tag ? tag : "wsa5:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__To(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__To(soap, tag ? tag : "wsa5:To", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__MessageID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__MessageID(soap, tag ? tag : "wsa5:MessageID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag ? tag : "wsa5:FaultCodesOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag ? tag : "wsa5:RelationshipTypeOpenEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, std::vector<_wstop__TopicNamespaceType_Topic> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const std::vector<_wstop__TopicNamespaceType_Topic> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_wstop__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const std::vector<_wstop__TopicNamespaceType_Topic> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_wstop__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_wstop__TopicNamespaceType_Topic> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, std::vector<_wstop__TopicNamespaceType_Topic> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_wstop__TopicNamespaceType_Topic n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__wstop__TopicNamespaceType_Topic, SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic, sizeof(_wstop__TopicNamespaceType_Topic), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in__wstop__TopicNamespaceType_Topic(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__wstop__TopicNamespaceType_Topic(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_wstop__TopicNamespaceType_Topic));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_wstop__TopicNamespaceType_Topic));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_wstop__TopicNamespaceType_Topic));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_wstop__TopicNamespaceType_Topic>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_wstop__TopicNamespaceType_Topic> *p;
	size_t k = sizeof(std::vector<_wstop__TopicNamespaceType_Topic> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_wstop__TopicNamespaceType_Topic> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_wstop__TopicNamespaceType_Topic> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_wstop__TopicNamespaceType_Topic>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, std::vector<wstop__TopicType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const std::vector<wstop__TopicType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wstop__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowstop__TopicType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const char *tag, int id, const std::vector<wstop__TopicType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wstop__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowstop__TopicType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wstop__TopicType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const char *tag, std::vector<wstop__TopicType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowstop__TopicType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wstop__TopicType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wstop__TopicType, SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType, sizeof(wstop__TopicType), 1, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_PointerTowstop__TopicType(soap, tag, NULL, "wstop:TopicType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowstop__TopicType(soap, tag, &n, "wstop:TopicType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wstop__TopicType *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wstop__TopicType *> *p;
	size_t k = sizeof(std::vector<wstop__TopicType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wstop__TopicType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wstop__TopicType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wstop__TopicType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__QName(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		std::string soap_tmp(soap_QName2s(soap, (*i).c_str()));
		if (soap_out_xsd__QName(soap, tag, id, &soap_tmp, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__QName(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_xsd__QName(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xsd__QName, SOAP_TYPE_std__vectorTemplateOfxsd__QName, sizeof(std::string), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_xsd__QName(soap, tag, NULL, "xsd:QName"))
				break;
		}
		else
		{	if (!soap_in_xsd__QName(soap, tag, &n, "xsd:QName"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfxsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOfxsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__QName, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, std::vector<_wsrfbf__BaseFaultType_Description> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const std::vector<_wsrfbf__BaseFaultType_Description> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const std::vector<_wsrfbf__BaseFaultType_Description> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_wsrfbf__BaseFaultType_Description> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, std::vector<_wsrfbf__BaseFaultType_Description> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_wsrfbf__BaseFaultType_Description n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__wsrfbf__BaseFaultType_Description, SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description, sizeof(_wsrfbf__BaseFaultType_Description), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in__wsrfbf__BaseFaultType_Description(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__wsrfbf__BaseFaultType_Description(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_wsrfbf__BaseFaultType_Description));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_wsrfbf__BaseFaultType_Description));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_wsrfbf__BaseFaultType_Description));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_wsrfbf__BaseFaultType_Description>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_wsrfbf__BaseFaultType_Description> *p;
	size_t k = sizeof(std::vector<_wsrfbf__BaseFaultType_Description> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_wsrfbf__BaseFaultType_Description> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_wsrfbf__BaseFaultType_Description> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_wsrfbf__BaseFaultType_Description>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, std::vector<wsnt__NotificationMessageHolderType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const std::vector<wsnt__NotificationMessageHolderType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsnt__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const std::vector<wsnt__NotificationMessageHolderType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsnt__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsnt__NotificationMessageHolderType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, std::vector<wsnt__NotificationMessageHolderType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsnt__NotificationMessageHolderType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsnt__NotificationMessageHolderType, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), 1, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, NULL, "wsnt:NotificationMessageHolderType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, &n, "wsnt:NotificationMessageHolderType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsnt__NotificationMessageHolderType *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsnt__NotificationMessageHolderType *> *p;
	size_t k = sizeof(std::vector<wsnt__NotificationMessageHolderType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wsnt__NotificationMessageHolderType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wsnt__NotificationMessageHolderType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsnt__NotificationMessageHolderType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyURI(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyURI(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyURI(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyURI(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_xsd__anyURI(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xsd__anyURI, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, sizeof(std::string), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI"))
				break;
		}
		else
		{	if (!soap_in_xsd__anyURI(soap, tag, &n, "xsd:anyURI"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOfxsd__anyURI(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, std::vector<wsnt__TopicExpressionType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, const std::vector<wsnt__TopicExpressionType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsnt__TopicExpressionType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsnt__TopicExpressionType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, const std::vector<wsnt__TopicExpressionType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsnt__TopicExpressionType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsnt__TopicExpressionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsnt__TopicExpressionType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, std::vector<wsnt__TopicExpressionType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsnt__TopicExpressionType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsnt__TopicExpressionType, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType, sizeof(wsnt__TopicExpressionType), 1, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_PointerTowsnt__TopicExpressionType(soap, tag, NULL, "wsnt:TopicExpressionType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowsnt__TopicExpressionType(soap, tag, &n, "wsnt:TopicExpressionType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsnt__TopicExpressionType *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsnt__TopicExpressionType *> *p;
	size_t k = sizeof(std::vector<wsnt__TopicExpressionType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wsnt__TopicExpressionType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wsnt__TopicExpressionType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsnt__TopicExpressionType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Config(struct soap *soap, std::vector<tt__Config *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const std::vector<tt__Config *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Config *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Config(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const char *tag, int id, const std::vector<tt__Config *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Config *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Config(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Config *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const char *tag, std::vector<tt__Config *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Config(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Config *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Config, SOAP_TYPE_std__vectorTemplateOfPointerTott__Config, sizeof(tt__Config), 1, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_PointerTott__Config(soap, tag, NULL, "tt:Config"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Config(soap, tag, &n, "tt:Config"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Config *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTott__Config(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOfPointerTott__Config(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Config *> *p;
	size_t k = sizeof(std::vector<tt__Config *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Config, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Config *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Config *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Config *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, std::vector<tt__Vector *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const std::vector<tt__Vector *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Vector *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Vector(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const char *tag, int id, const std::vector<tt__Vector *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Vector *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Vector(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Vector *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const char *tag, std::vector<tt__Vector *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Vector(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Vector *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Vector, SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector, sizeof(tt__Vector), 1, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_PointerTott__Vector(soap, tag, NULL, "tt:Vector"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Vector(soap, tag, &n, "tt:Vector"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Vector *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOfPointerTott__Vector(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Vector *> *p;
	size_t k = sizeof(std::vector<tt__Vector *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Vector *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Vector *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Vector *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, std::vector<_tt__ItemList_ElementItem> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, const std::vector<_tt__ItemList_ElementItem> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ItemList_ElementItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, const std::vector<_tt__ItemList_ElementItem> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ItemList_ElementItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ItemList_ElementItem> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, const char *tag, std::vector<_tt__ItemList_ElementItem> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ItemList_ElementItem(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_tt__ItemList_ElementItem n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__tt__ItemList_ElementItem, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem, sizeof(_tt__ItemList_ElementItem), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in__tt__ItemList_ElementItem(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ItemList_ElementItem(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ItemList_ElementItem));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_tt__ItemList_ElementItem));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ItemList_ElementItem));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ItemList_ElementItem>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOf_tt__ItemList_ElementItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ItemList_ElementItem> *p;
	size_t k = sizeof(std::vector<_tt__ItemList_ElementItem> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ItemList_ElementItem> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ItemList_ElementItem> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ItemList_ElementItem>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, std::vector<_tt__ItemList_SimpleItem> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, const std::vector<_tt__ItemList_SimpleItem> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ItemList_SimpleItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, const std::vector<_tt__ItemList_SimpleItem> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ItemList_SimpleItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ItemList_SimpleItem> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, std::vector<_tt__ItemList_SimpleItem> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_tt__ItemList_SimpleItem n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__tt__ItemList_SimpleItem, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem, sizeof(_tt__ItemList_SimpleItem), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in__tt__ItemList_SimpleItem(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ItemList_SimpleItem(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ItemList_SimpleItem));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_tt__ItemList_SimpleItem));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ItemList_SimpleItem));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ItemList_SimpleItem>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOf_tt__ItemList_SimpleItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ItemList_SimpleItem> *p;
	size_t k = sizeof(std::vector<_tt__ItemList_SimpleItem> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ItemList_SimpleItem> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ItemList_SimpleItem> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ItemList_SimpleItem>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, std::vector<enum tt__AutoFocusMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const std::vector<enum tt__AutoFocusMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__AutoFocusMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__AutoFocusMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__AutoFocusMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__AutoFocusMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const char *tag, std::vector<enum tt__AutoFocusMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__AutoFocusMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__AutoFocusMode n;
		soap_default_tt__AutoFocusMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__AutoFocusMode, SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_tt__AutoFocusMode(soap, tag, NULL, "tt:AutoFocusMode"))
				break;
		}
		else
		{	if (!soap_in_tt__AutoFocusMode(soap, tag, &n, "tt:AutoFocusMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__AutoFocusMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOftt__AutoFocusMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__AutoFocusMode> *p;
	size_t k = sizeof(std::vector<enum tt__AutoFocusMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__AutoFocusMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__AutoFocusMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__AutoFocusMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, std::vector<enum tt__WhiteBalanceMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const std::vector<enum tt__WhiteBalanceMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__WhiteBalanceMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__WhiteBalanceMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__WhiteBalanceMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__WhiteBalanceMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const char *tag, std::vector<enum tt__WhiteBalanceMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__WhiteBalanceMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__WhiteBalanceMode n;
		soap_default_tt__WhiteBalanceMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__WhiteBalanceMode, SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_tt__WhiteBalanceMode(soap, tag, NULL, "tt:WhiteBalanceMode"))
				break;
		}
		else
		{	if (!soap_in_tt__WhiteBalanceMode(soap, tag, &n, "tt:WhiteBalanceMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__WhiteBalanceMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__WhiteBalanceMode> *p;
	size_t k = sizeof(std::vector<enum tt__WhiteBalanceMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__WhiteBalanceMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__WhiteBalanceMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__WhiteBalanceMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, std::vector<enum tt__ExposurePriority> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const std::vector<enum tt__ExposurePriority> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const char *tag, int id, const std::vector<enum tt__ExposurePriority> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__ExposurePriority> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ExposurePriority(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__ExposurePriority> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const char *tag, std::vector<enum tt__ExposurePriority> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ExposurePriority(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__ExposurePriority n;
		soap_default_tt__ExposurePriority(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ExposurePriority, SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_tt__ExposurePriority(soap, tag, NULL, "tt:ExposurePriority"))
				break;
		}
		else
		{	if (!soap_in_tt__ExposurePriority(soap, tag, &n, "tt:ExposurePriority"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__ExposurePriority>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOftt__ExposurePriority(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__ExposurePriority> *p;
	size_t k = sizeof(std::vector<enum tt__ExposurePriority> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__ExposurePriority> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__ExposurePriority> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__ExposurePriority>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ExposureMode(struct soap *soap, std::vector<enum tt__ExposureMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const std::vector<enum tt__ExposureMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__ExposureMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__ExposureMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ExposureMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__ExposureMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const char *tag, std::vector<enum tt__ExposureMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ExposureMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__ExposureMode n;
		soap_default_tt__ExposureMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ExposureMode, SOAP_TYPE_std__vectorTemplateOftt__ExposureMode, sizeof(enum tt__ExposureMode), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_tt__ExposureMode(soap, tag, NULL, "tt:ExposureMode"))
				break;
		}
		else
		{	if (!soap_in_tt__ExposureMode(soap, tag, &n, "tt:ExposureMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__ExposureMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__ExposureMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOftt__ExposureMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__ExposureMode> *p;
	size_t k = sizeof(std::vector<enum tt__ExposureMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ExposureMode, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__ExposureMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__ExposureMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__ExposureMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, std::vector<enum tt__BacklightCompensationMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const std::vector<enum tt__BacklightCompensationMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__BacklightCompensationMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__BacklightCompensationMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__BacklightCompensationMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__BacklightCompensationMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const char *tag, std::vector<enum tt__BacklightCompensationMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__BacklightCompensationMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__BacklightCompensationMode n;
		soap_default_tt__BacklightCompensationMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__BacklightCompensationMode, SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_tt__BacklightCompensationMode(soap, tag, NULL, "tt:BacklightCompensationMode"))
				break;
		}
		else
		{	if (!soap_in_tt__BacklightCompensationMode(soap, tag, &n, "tt:BacklightCompensationMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__BacklightCompensationMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__BacklightCompensationMode> *p;
	size_t k = sizeof(std::vector<enum tt__BacklightCompensationMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__BacklightCompensationMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__BacklightCompensationMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__BacklightCompensationMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, std::vector<enum tt__WideDynamicMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const std::vector<enum tt__WideDynamicMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__WideDynamicMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__WideDynamicMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__WideDynamicMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__WideDynamicMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const char *tag, std::vector<enum tt__WideDynamicMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__WideDynamicMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__WideDynamicMode n;
		soap_default_tt__WideDynamicMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__WideDynamicMode, SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_tt__WideDynamicMode(soap, tag, NULL, "tt:WideDynamicMode"))
				break;
		}
		else
		{	if (!soap_in_tt__WideDynamicMode(soap, tag, &n, "tt:WideDynamicMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__WideDynamicMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOftt__WideDynamicMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__WideDynamicMode> *p;
	size_t k = sizeof(std::vector<enum tt__WideDynamicMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__WideDynamicMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__WideDynamicMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__WideDynamicMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_std__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfstd__string, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, std::vector<enum tt__ImageStabilizationMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, const std::vector<enum tt__ImageStabilizationMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__ImageStabilizationMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__ImageStabilizationMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ImageStabilizationMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__ImageStabilizationMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, const char *tag, std::vector<enum tt__ImageStabilizationMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ImageStabilizationMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__ImageStabilizationMode n;
		soap_default_tt__ImageStabilizationMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ImageStabilizationMode, SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode, sizeof(enum tt__ImageStabilizationMode), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_tt__ImageStabilizationMode(soap, tag, NULL, "tt:ImageStabilizationMode"))
				break;
		}
		else
		{	if (!soap_in_tt__ImageStabilizationMode(soap, tag, &n, "tt:ImageStabilizationMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__ImageStabilizationMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOftt__ImageStabilizationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__ImageStabilizationMode> *p;
	size_t k = sizeof(std::vector<enum tt__ImageStabilizationMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__ImageStabilizationMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__ImageStabilizationMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__ImageStabilizationMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, std::vector<enum tt__IrCutFilterMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const std::vector<enum tt__IrCutFilterMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__IrCutFilterMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__IrCutFilterMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IrCutFilterMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__IrCutFilterMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const char *tag, std::vector<enum tt__IrCutFilterMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__IrCutFilterMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__IrCutFilterMode n;
		soap_default_tt__IrCutFilterMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__IrCutFilterMode, SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_tt__IrCutFilterMode(soap, tag, NULL, "tt:IrCutFilterMode"))
				break;
		}
		else
		{	if (!soap_in_tt__IrCutFilterMode(soap, tag, &n, "tt:IrCutFilterMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__IrCutFilterMode>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOftt__IrCutFilterMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__IrCutFilterMode> *p;
	size_t k = sizeof(std::vector<enum tt__IrCutFilterMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__IrCutFilterMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__IrCutFilterMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__IrCutFilterMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, std::vector<tt__IrCutFilterAutoAdjustment *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const std::vector<tt__IrCutFilterAutoAdjustment *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__IrCutFilterAutoAdjustment *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__IrCutFilterAutoAdjustment(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, int id, const std::vector<tt__IrCutFilterAutoAdjustment *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__IrCutFilterAutoAdjustment *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__IrCutFilterAutoAdjustment(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__IrCutFilterAutoAdjustment *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, std::vector<tt__IrCutFilterAutoAdjustment *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__IrCutFilterAutoAdjustment *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__IrCutFilterAutoAdjustment, SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment, sizeof(tt__IrCutFilterAutoAdjustment), 1, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_PointerTott__IrCutFilterAutoAdjustment(soap, tag, NULL, "tt:IrCutFilterAutoAdjustment"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__IrCutFilterAutoAdjustment(soap, tag, &n, "tt:IrCutFilterAutoAdjustment"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__IrCutFilterAutoAdjustment *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__IrCutFilterAutoAdjustment *> *p;
	size_t k = sizeof(std::vector<tt__IrCutFilterAutoAdjustment *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__IrCutFilterAutoAdjustment *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__IrCutFilterAutoAdjustment *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__IrCutFilterAutoAdjustment *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, std::vector<tt__LensProjection *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, const std::vector<tt__LensProjection *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__LensProjection *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__LensProjection(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, const char *tag, int id, const std::vector<tt__LensProjection *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__LensProjection *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__LensProjection(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__LensProjection *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, const char *tag, std::vector<tt__LensProjection *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__LensProjection(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__LensProjection *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__LensProjection, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection, sizeof(tt__LensProjection), 1, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_PointerTott__LensProjection(soap, tag, NULL, "tt:LensProjection"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__LensProjection(soap, tag, &n, "tt:LensProjection"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__LensProjection *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOfPointerTott__LensProjection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__LensProjection *> *p;
	size_t k = sizeof(std::vector<tt__LensProjection *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__LensProjection *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__LensProjection *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__LensProjection *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, std::vector<tt__LensDescription *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, const std::vector<tt__LensDescription *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__LensDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__LensDescription(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__LensDescription *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__LensDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__LensDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__LensDescription *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, const char *tag, std::vector<tt__LensDescription *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__LensDescription(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__LensDescription *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__LensDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription, sizeof(tt__LensDescription), 1, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_PointerTott__LensDescription(soap, tag, NULL, "tt:LensDescription"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__LensDescription(soap, tag, &n, "tt:LensDescription"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__LensDescription *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOfPointerTott__LensDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__LensDescription *> *p;
	size_t k = sizeof(std::vector<tt__LensDescription *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__LensDescription *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__LensDescription *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__LensDescription *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, std::vector<timg__ImagingPreset *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, const std::vector<timg__ImagingPreset *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<timg__ImagingPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotimg__ImagingPreset(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, const char *tag, int id, const std::vector<timg__ImagingPreset *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<timg__ImagingPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotimg__ImagingPreset(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<timg__ImagingPreset *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, const char *tag, std::vector<timg__ImagingPreset *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotimg__ImagingPreset(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		timg__ImagingPreset *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_timg__ImagingPreset, SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset, sizeof(timg__ImagingPreset), 1, imageing_finsert, imageing_fbase))
				break;
			if (!soap_in_PointerTotimg__ImagingPreset(soap, tag, NULL, "timg:ImagingPreset"))
				break;
		}
		else
		{	if (!soap_in_PointerTotimg__ImagingPreset(soap, tag, &n, "timg:ImagingPreset"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<timg__ImagingPreset *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOfPointerTotimg__ImagingPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<timg__ImagingPreset *> *p;
	size_t k = sizeof(std::vector<timg__ImagingPreset *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<timg__ImagingPreset *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<timg__ImagingPreset *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<timg__ImagingPreset *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<char *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, (char*const*)&(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		char *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1, imageing_finsert, imageing_fbase))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{	if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 imageing_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "imageing_instantiate_std__vectorTemplateOf_XML(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<char *> *p;
	size_t k = sizeof(std::vector<char *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_XML, n, imageing_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<char *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<char *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<char *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of imageingC.cpp */
