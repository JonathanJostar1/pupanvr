/* imageingStub.h
   Generated by gSOAP 2.8.117 for out/onvif_imaging.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_WSA_2005
#define SOAP_NAMESPACE_OF_wsa5	"http://www.w3.org/2005/08/addressing"
#define SOAP_NAMESPACE_OF_timg	"http://www.onvif.org/ver20/imaging/wsdl"
#define SOAP_NAMESPACE_OF_tt	"http://www.onvif.org/ver10/schema"
#define SOAP_NAMESPACE_OF_wsnt	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_wsrfbf	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_wstop	"http://docs.oasis-open.org/wsn/t-1"

#ifndef imageingStub_H
#define imageingStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208117
# error "GSOAP VERSION 208117 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* wsa5.h:96 */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (19)
/* wsa5:RelationshipType */
enum wsa5__RelationshipType {
	http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0
};
#endif

/* wsa5.h:104 */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (20)
/* wsa5:FaultCodesType */
enum wsa5__FaultCodesType {
	wsa5__InvalidAddressingHeader = 0,
	wsa5__InvalidAddress = 1,
	wsa5__InvalidEPR = 2,
	wsa5__InvalidCardinality = 3,
	wsa5__MissingAddressInEPR = 4,
	wsa5__DuplicateMessageID = 5,
	wsa5__ActionMismatch = 6,
	wsa5__MessageAddressingHeaderRequired = 7,
	wsa5__DestinationUnreachable = 8,
	wsa5__ActionNotSupported = 9,
	wsa5__EndpointUnavailable = 10
};
#endif

/* wsa5.h:254 */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (40)
/* wsa5:IsReferenceParameter */
enum _wsa5__IsReferenceParameter {
	_wsa5__IsReferenceParameter__false = 0,
	_wsa5__IsReferenceParameter__true = 1
};
#endif

/* out/onvif_imaging.h:849 */
#ifndef SOAP_TYPE_tt__RotateMode
#define SOAP_TYPE_tt__RotateMode (293)
/* tt:RotateMode */
enum tt__RotateMode {
	tt__RotateMode__OFF = 0,
	tt__RotateMode__ON = 1,
	tt__RotateMode__AUTO = 2
};
#endif

/* out/onvif_imaging.h:879 */
#ifndef SOAP_TYPE_tt__SceneOrientationMode
#define SOAP_TYPE_tt__SceneOrientationMode (295)
/* tt:SceneOrientationMode */
enum tt__SceneOrientationMode {
	tt__SceneOrientationMode__MANUAL = 0,
	tt__SceneOrientationMode__AUTO = 1
};
#endif

/* out/onvif_imaging.h:900 */
#ifndef SOAP_TYPE_tt__VideoEncoding
#define SOAP_TYPE_tt__VideoEncoding (297)
/* tt:VideoEncoding */
enum tt__VideoEncoding {
	tt__VideoEncoding__JPEG = 0,
	tt__VideoEncoding__MPEG4 = 1,
	tt__VideoEncoding__H264 = 2
};
#endif

/* out/onvif_imaging.h:918 */
#ifndef SOAP_TYPE_tt__Mpeg4Profile
#define SOAP_TYPE_tt__Mpeg4Profile (299)
/* tt:Mpeg4Profile */
enum tt__Mpeg4Profile {
	tt__Mpeg4Profile__SP = 0,
	tt__Mpeg4Profile__ASP = 1
};
#endif

/* out/onvif_imaging.h:935 */
#ifndef SOAP_TYPE_tt__H264Profile
#define SOAP_TYPE_tt__H264Profile (301)
/* tt:H264Profile */
enum tt__H264Profile {
	tt__H264Profile__Baseline = 0,
	tt__H264Profile__Main = 1,
	tt__H264Profile__Extended = 2,
	tt__H264Profile__High = 3
};
#endif

/* out/onvif_imaging.h:958 */
#ifndef SOAP_TYPE_tt__AudioEncoding
#define SOAP_TYPE_tt__AudioEncoding (303)
/* tt:AudioEncoding */
enum tt__AudioEncoding {
	tt__AudioEncoding__G711 = 0,
	tt__AudioEncoding__G726 = 1,
	tt__AudioEncoding__AAC = 2
};
#endif

/* out/onvif_imaging.h:1026 */
#ifndef SOAP_TYPE_tt__IPType
#define SOAP_TYPE_tt__IPType (309)
/* tt:IPType */
enum tt__IPType {
	tt__IPType__IPv4 = 0,
	tt__IPType__IPv6 = 1
};
#endif

/* out/onvif_imaging.h:1085 */
#ifndef SOAP_TYPE_tt__EFlipMode
#define SOAP_TYPE_tt__EFlipMode (311)
/* tt:EFlipMode */
enum tt__EFlipMode {
	tt__EFlipMode__OFF = 0,
	tt__EFlipMode__ON = 1,
	tt__EFlipMode__Extended = 2
};
#endif

/* out/onvif_imaging.h:1103 */
#ifndef SOAP_TYPE_tt__ReverseMode
#define SOAP_TYPE_tt__ReverseMode (313)
/* tt:ReverseMode */
enum tt__ReverseMode {
	tt__ReverseMode__OFF = 0,
	tt__ReverseMode__ON = 1,
	tt__ReverseMode__AUTO = 2,
	tt__ReverseMode__Extended = 3
};
#endif

/* out/onvif_imaging.h:1132 */
#ifndef SOAP_TYPE_tt__AutoFocusMode
#define SOAP_TYPE_tt__AutoFocusMode (315)
/* tt:AutoFocusMode */
enum tt__AutoFocusMode {
	tt__AutoFocusMode__AUTO = 0,
	tt__AutoFocusMode__MANUAL = 1
};
#endif

/* out/onvif_imaging.h:1151 */
#ifndef SOAP_TYPE_tt__WideDynamicMode
#define SOAP_TYPE_tt__WideDynamicMode (317)
/* tt:WideDynamicMode */
enum tt__WideDynamicMode {
	tt__WideDynamicMode__OFF = 0,
	tt__WideDynamicMode__ON = 1
};
#endif

/* out/onvif_imaging.h:1172 */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode
#define SOAP_TYPE_tt__BacklightCompensationMode (319)
/* tt:BacklightCompensationMode */
enum tt__BacklightCompensationMode {
	tt__BacklightCompensationMode__OFF = 0,
	tt__BacklightCompensationMode__ON = 1
};
#endif

/* out/onvif_imaging.h:1197 */
#ifndef SOAP_TYPE_tt__ExposurePriority
#define SOAP_TYPE_tt__ExposurePriority (321)
/* tt:ExposurePriority */
enum tt__ExposurePriority {
	tt__ExposurePriority__LowNoise = 0,
	tt__ExposurePriority__FrameRate = 1
};
#endif

/* out/onvif_imaging.h:1214 */
#ifndef SOAP_TYPE_tt__ExposureMode
#define SOAP_TYPE_tt__ExposureMode (323)
/* tt:ExposureMode */
enum tt__ExposureMode {
	tt__ExposureMode__AUTO = 0,
	tt__ExposureMode__MANUAL = 1
};
#endif

/* out/onvif_imaging.h:1233 */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode
#define SOAP_TYPE_tt__WhiteBalanceMode (325)
/* tt:WhiteBalanceMode */
enum tt__WhiteBalanceMode {
	tt__WhiteBalanceMode__AUTO = 0,
	tt__WhiteBalanceMode__MANUAL = 1
};
#endif

/* out/onvif_imaging.h:1250 */
#ifndef SOAP_TYPE_tt__IrCutFilterMode
#define SOAP_TYPE_tt__IrCutFilterMode (327)
/* tt:IrCutFilterMode */
enum tt__IrCutFilterMode {
	tt__IrCutFilterMode__ON = 0,
	tt__IrCutFilterMode__OFF = 1,
	tt__IrCutFilterMode__AUTO = 2
};
#endif

/* out/onvif_imaging.h:1268 */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode
#define SOAP_TYPE_tt__ImageStabilizationMode (329)
/* tt:ImageStabilizationMode */
enum tt__ImageStabilizationMode {
	tt__ImageStabilizationMode__OFF = 0,
	tt__ImageStabilizationMode__ON = 1,
	tt__ImageStabilizationMode__AUTO = 2,
	tt__ImageStabilizationMode__Extended = 3
};
#endif

/* out/onvif_imaging.h:1295 */
#ifndef SOAP_TYPE_tt__PropertyOperation
#define SOAP_TYPE_tt__PropertyOperation (331)
/* tt:PropertyOperation */
enum tt__PropertyOperation {
	tt__PropertyOperation__Initialized = 0,
	tt__PropertyOperation__Deleted = 1,
	tt__PropertyOperation__Changed = 2
};
#endif

/* out/onvif_imaging.h:1359 */
#ifndef SOAP_TYPE_tt__MoveStatus
#define SOAP_TYPE_tt__MoveStatus (335)
/* tt:MoveStatus */
enum tt__MoveStatus {
	tt__MoveStatus__IDLE = 0,
	tt__MoveStatus__MOVING = 1,
	tt__MoveStatus__UNKNOWN = 2
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* out/onvif_imaging.h:191 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (62)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

struct _xop__Include;	/* xop.h:59 */
struct wsa5__EndpointReferenceType;	/* wsa5.h:65 */
struct wsa5__ReferenceParametersType;	/* wsa5.h:68 */
struct wsa5__MetadataType;	/* wsa5.h:71 */
struct wsa5__ProblemActionType;	/* wsa5.h:86 */
struct wsa5__RelatesToType;	/* wsa5.h:74 */
struct chan__ChannelInstanceType;	/* wsa5.h:260 */
class xsd__anyType;	/* out/onvif_imaging.h:181 */
struct SOAP_ENV__Envelope;	/* out/onvif_imaging.h:188 */
class xsd__base64Binary;	/* out/onvif_imaging.h:194 */
class xsd__hexBinary;	/* out/onvif_imaging.h:202 */
class wsa5__EndpointReferenceType__;	/* out/onvif_imaging.h:212 */
class SOAP_ENV__Envelope_;	/* out/onvif_imaging.h:219 */
class SOAP_ENV__Fault_;	/* out/onvif_imaging.h:226 */
class xsd__NCName__;	/* out/onvif_imaging.h:236 */
class xsd__QName__;	/* out/onvif_imaging.h:243 */
class xsd__anySimpleType__;	/* out/onvif_imaging.h:253 */
class xsd__anyURI__;	/* out/onvif_imaging.h:263 */
class xsd__base64Binary__;	/* out/onvif_imaging.h:270 */
class xsd__boolean_;	/* out/onvif_imaging.h:277 */
class xsd__dateTime_;	/* out/onvif_imaging.h:284 */
class xsd__double_;	/* out/onvif_imaging.h:291 */
class xsd__duration__;	/* out/onvif_imaging.h:301 */
class xsd__float_;	/* out/onvif_imaging.h:308 */
class xsd__hexBinary__;	/* out/onvif_imaging.h:315 */
class xsd__int_;	/* out/onvif_imaging.h:322 */
class xsd__integer__;	/* out/onvif_imaging.h:332 */
class xsd__nonNegativeInteger__;	/* out/onvif_imaging.h:342 */
class xsd__string_;	/* out/onvif_imaging.h:349 */
class xsd__token__;	/* out/onvif_imaging.h:359 */
class tt__Name__;	/* out/onvif_imaging.h:840 */
class tt__RotateMode_;	/* out/onvif_imaging.h:870 */
class tt__SceneOrientationMode_;	/* out/onvif_imaging.h:887 */
class tt__VideoEncoding_;	/* out/onvif_imaging.h:909 */
class tt__Mpeg4Profile_;	/* out/onvif_imaging.h:926 */
class tt__H264Profile_;	/* out/onvif_imaging.h:945 */
class tt__AudioEncoding_;	/* out/onvif_imaging.h:967 */
class tt__IPv4Address__;	/* out/onvif_imaging.h:1003 */
class tt__IPv6Address__;	/* out/onvif_imaging.h:1015 */
class tt__IPType_;	/* out/onvif_imaging.h:1034 */
class tt__EFlipMode_;	/* out/onvif_imaging.h:1094 */
class tt__ReverseMode_;	/* out/onvif_imaging.h:1113 */
class tt__AutoFocusMode_;	/* out/onvif_imaging.h:1140 */
class tt__WideDynamicMode_;	/* out/onvif_imaging.h:1159 */
class tt__BacklightCompensationMode_;	/* out/onvif_imaging.h:1188 */
class tt__ExposurePriority_;	/* out/onvif_imaging.h:1205 */
class tt__ExposureMode_;	/* out/onvif_imaging.h:1222 */
class tt__WhiteBalanceMode_;	/* out/onvif_imaging.h:1241 */
class tt__IrCutFilterMode_;	/* out/onvif_imaging.h:1259 */
class tt__ImageStabilizationMode_;	/* out/onvif_imaging.h:1278 */
class tt__PropertyOperation_;	/* out/onvif_imaging.h:1304 */
class tt__ReferenceToken__;	/* out/onvif_imaging.h:1350 */
class tt__MoveStatus_;	/* out/onvif_imaging.h:1368 */
class wstop__ConcreteTopicExpression__;	/* out/onvif_imaging.h:1414 */
class timg__Capabilities;	/* out/onvif_imaging.h:377 */
class timg__ImagingPreset;	/* out/onvif_imaging.h:379 */
class _timg__GetServiceCapabilities;	/* out/onvif_imaging.h:381 */
class _timg__GetServiceCapabilitiesResponse;	/* out/onvif_imaging.h:383 */
class _timg__GetImagingSettings;	/* out/onvif_imaging.h:385 */
class _timg__GetImagingSettingsResponse;	/* out/onvif_imaging.h:387 */
class _timg__SetImagingSettings;	/* out/onvif_imaging.h:389 */
class _timg__SetImagingSettingsResponse;	/* out/onvif_imaging.h:391 */
class _timg__GetOptions;	/* out/onvif_imaging.h:393 */
class _timg__GetOptionsResponse;	/* out/onvif_imaging.h:395 */
class _timg__Move;	/* out/onvif_imaging.h:397 */
class _timg__MoveResponse;	/* out/onvif_imaging.h:399 */
class _timg__GetMoveOptions;	/* out/onvif_imaging.h:401 */
class _timg__GetMoveOptionsResponse;	/* out/onvif_imaging.h:403 */
class _timg__Stop;	/* out/onvif_imaging.h:405 */
class _timg__StopResponse;	/* out/onvif_imaging.h:407 */
class _timg__GetStatus;	/* out/onvif_imaging.h:409 */
class _timg__GetStatusResponse;	/* out/onvif_imaging.h:411 */
class _timg__GetPresets;	/* out/onvif_imaging.h:413 */
class _timg__GetPresetsResponse;	/* out/onvif_imaging.h:415 */
class _timg__GetCurrentPreset;	/* out/onvif_imaging.h:417 */
class _timg__GetCurrentPresetResponse;	/* out/onvif_imaging.h:419 */
class _timg__SetCurrentPreset;	/* out/onvif_imaging.h:421 */
class _timg__SetCurrentPresetResponse;	/* out/onvif_imaging.h:423 */
class tt__IntRectangle;	/* out/onvif_imaging.h:425 */
class tt__IntRectangleRange;	/* out/onvif_imaging.h:427 */
class tt__FloatRange;	/* out/onvif_imaging.h:429 */
class tt__DurationRange;	/* out/onvif_imaging.h:431 */
class tt__ConfigurationEntity;	/* out/onvif_imaging.h:433 */
class tt__VideoSourceConfigurationExtension;	/* out/onvif_imaging.h:437 */
class tt__VideoSourceConfigurationExtension2;	/* out/onvif_imaging.h:439 */
class tt__Rotate;	/* out/onvif_imaging.h:441 */
class tt__RotateExtension;	/* out/onvif_imaging.h:443 */
class tt__LensProjection;	/* out/onvif_imaging.h:445 */
class tt__LensOffset;	/* out/onvif_imaging.h:447 */
class tt__LensDescription;	/* out/onvif_imaging.h:449 */
class tt__SceneOrientation;	/* out/onvif_imaging.h:451 */
class tt__VideoResolution;	/* out/onvif_imaging.h:455 */
class tt__VideoRateControl;	/* out/onvif_imaging.h:457 */
class tt__Mpeg4Configuration;	/* out/onvif_imaging.h:459 */
class tt__H264Configuration;	/* out/onvif_imaging.h:461 */
class tt__MetadataConfigurationExtension;	/* out/onvif_imaging.h:471 */
class tt__PTZFilter;	/* out/onvif_imaging.h:473 */
class _tt__EventSubscription_SubscriptionPolicy;	/* out/onvif_imaging.h:2865 */
class tt__EventSubscription;	/* out/onvif_imaging.h:475 */
class tt__MulticastConfiguration;	/* out/onvif_imaging.h:481 */
class tt__IPAddress;	/* out/onvif_imaging.h:483 */
class tt__PTZConfigurationExtension;	/* out/onvif_imaging.h:487 */
class tt__PTZConfigurationExtension2;	/* out/onvif_imaging.h:489 */
class tt__PTControlDirection;	/* out/onvif_imaging.h:491 */
class tt__PTControlDirectionExtension;	/* out/onvif_imaging.h:493 */
class tt__EFlip;	/* out/onvif_imaging.h:495 */
class tt__Reverse;	/* out/onvif_imaging.h:497 */
class tt__PanTiltLimits;	/* out/onvif_imaging.h:499 */
class tt__ZoomLimits;	/* out/onvif_imaging.h:501 */
class tt__Space2DDescription;	/* out/onvif_imaging.h:503 */
class tt__Space1DDescription;	/* out/onvif_imaging.h:505 */
class tt__PTZSpeed;	/* out/onvif_imaging.h:507 */
class tt__FocusMove;	/* out/onvif_imaging.h:509 */
class tt__AbsoluteFocus;	/* out/onvif_imaging.h:511 */
class tt__RelativeFocus;	/* out/onvif_imaging.h:513 */
class tt__ContinuousFocus;	/* out/onvif_imaging.h:515 */
class tt__AbsoluteFocusOptions;	/* out/onvif_imaging.h:517 */
class tt__ContinuousFocusOptions;	/* out/onvif_imaging.h:519 */
class tt__ImagingStatus20;	/* out/onvif_imaging.h:521 */
class tt__ImagingStatus20Extension;	/* out/onvif_imaging.h:523 */
class tt__FocusStatus20;	/* out/onvif_imaging.h:525 */
class tt__FocusStatus20Extension;	/* out/onvif_imaging.h:527 */
class tt__ImagingSettings20;	/* out/onvif_imaging.h:529 */
class tt__ImagingSettingsExtension20;	/* out/onvif_imaging.h:531 */
class tt__ImagingSettingsExtension202;	/* out/onvif_imaging.h:533 */
class tt__ImagingSettingsExtension203;	/* out/onvif_imaging.h:535 */
class tt__ImagingSettingsExtension204;	/* out/onvif_imaging.h:537 */
class tt__ImageStabilization;	/* out/onvif_imaging.h:539 */
class tt__ImageStabilizationExtension;	/* out/onvif_imaging.h:541 */
class tt__IrCutFilterAutoAdjustment;	/* out/onvif_imaging.h:543 */
class tt__IrCutFilterAutoAdjustmentExtension;	/* out/onvif_imaging.h:545 */
class tt__WideDynamicRange20;	/* out/onvif_imaging.h:547 */
class tt__BacklightCompensation20;	/* out/onvif_imaging.h:549 */
class tt__Exposure20;	/* out/onvif_imaging.h:551 */
class tt__ToneCompensation;	/* out/onvif_imaging.h:553 */
class tt__ToneCompensationExtension;	/* out/onvif_imaging.h:555 */
class tt__Defogging;	/* out/onvif_imaging.h:557 */
class tt__DefoggingExtension;	/* out/onvif_imaging.h:559 */
class tt__NoiseReduction;	/* out/onvif_imaging.h:561 */
class tt__ImagingOptions20;	/* out/onvif_imaging.h:563 */
class tt__ImagingOptions20Extension;	/* out/onvif_imaging.h:565 */
class tt__ImagingOptions20Extension2;	/* out/onvif_imaging.h:567 */
class tt__ImagingOptions20Extension3;	/* out/onvif_imaging.h:569 */
class tt__ImagingOptions20Extension4;	/* out/onvif_imaging.h:571 */
class tt__ImageStabilizationOptions;	/* out/onvif_imaging.h:573 */
class tt__ImageStabilizationOptionsExtension;	/* out/onvif_imaging.h:575 */
class tt__IrCutFilterAutoAdjustmentOptions;	/* out/onvif_imaging.h:577 */
class tt__IrCutFilterAutoAdjustmentOptionsExtension;	/* out/onvif_imaging.h:579 */
class tt__WideDynamicRangeOptions20;	/* out/onvif_imaging.h:581 */
class tt__BacklightCompensationOptions20;	/* out/onvif_imaging.h:583 */
class tt__ExposureOptions20;	/* out/onvif_imaging.h:585 */
class tt__MoveOptions20;	/* out/onvif_imaging.h:587 */
class tt__RelativeFocusOptions20;	/* out/onvif_imaging.h:589 */
class tt__WhiteBalance20;	/* out/onvif_imaging.h:591 */
class tt__WhiteBalance20Extension;	/* out/onvif_imaging.h:593 */
class tt__FocusConfiguration20;	/* out/onvif_imaging.h:595 */
class tt__FocusConfiguration20Extension;	/* out/onvif_imaging.h:597 */
class tt__WhiteBalanceOptions20;	/* out/onvif_imaging.h:599 */
class tt__WhiteBalanceOptions20Extension;	/* out/onvif_imaging.h:601 */
class tt__FocusOptions20;	/* out/onvif_imaging.h:603 */
class tt__FocusOptions20Extension;	/* out/onvif_imaging.h:605 */
class tt__ToneCompensationOptions;	/* out/onvif_imaging.h:607 */
class tt__DefoggingOptions;	/* out/onvif_imaging.h:609 */
class tt__NoiseReductionOptions;	/* out/onvif_imaging.h:611 */
class tt__MessageExtension;	/* out/onvif_imaging.h:613 */
class _tt__ItemList_SimpleItem;	/* out/onvif_imaging.h:5637 */
class _tt__ItemList_ElementItem;	/* out/onvif_imaging.h:5669 */
class tt__ItemList;	/* out/onvif_imaging.h:615 */
class tt__ItemListExtension;	/* out/onvif_imaging.h:617 */
class tt__Polyline;	/* out/onvif_imaging.h:619 */
class tt__AnalyticsEngineConfiguration;	/* out/onvif_imaging.h:621 */
class tt__AnalyticsEngineConfigurationExtension;	/* out/onvif_imaging.h:623 */
class tt__RuleEngineConfiguration;	/* out/onvif_imaging.h:625 */
class tt__RuleEngineConfigurationExtension;	/* out/onvif_imaging.h:627 */
class tt__Config;	/* out/onvif_imaging.h:629 */
class tt__PolygonOptions;	/* out/onvif_imaging.h:631 */
class tt__IntRange;	/* out/onvif_imaging.h:633 */
class tt__Vector2D;	/* out/onvif_imaging.h:635 */
class tt__Vector1D;	/* out/onvif_imaging.h:637 */
class tt__Vector;	/* out/onvif_imaging.h:639 */
class tt__Rectangle;	/* out/onvif_imaging.h:641 */
class tt__Polygon;	/* out/onvif_imaging.h:643 */
class _tt__StringItems;	/* out/onvif_imaging.h:645 */
class _tt__Message;	/* out/onvif_imaging.h:647 */
class wsnt__QueryExpressionType;	/* out/onvif_imaging.h:649 */
class wsnt__TopicExpressionType;	/* out/onvif_imaging.h:651 */
class wsnt__FilterType;	/* out/onvif_imaging.h:653 */
class wsnt__SubscriptionPolicyType;	/* out/onvif_imaging.h:655 */
class _wsnt__NotificationMessageHolderType_Message;	/* out/onvif_imaging.h:6548 */
class wsnt__NotificationMessageHolderType;	/* out/onvif_imaging.h:657 */
class _wsnt__NotificationProducerRP;	/* out/onvif_imaging.h:699 */
class _wsnt__SubscriptionManagerRP;	/* out/onvif_imaging.h:701 */
class _wsnt__Notify;	/* out/onvif_imaging.h:703 */
class _wsnt__UseRaw;	/* out/onvif_imaging.h:705 */
class _wsnt__Subscribe_SubscriptionPolicy;	/* out/onvif_imaging.h:6699 */
class _wsnt__Subscribe;	/* out/onvif_imaging.h:707 */
class _wsnt__SubscribeResponse;	/* out/onvif_imaging.h:709 */
class _wsnt__GetCurrentMessage;	/* out/onvif_imaging.h:711 */
class _wsnt__GetCurrentMessageResponse;	/* out/onvif_imaging.h:713 */
class _wsnt__GetMessages;	/* out/onvif_imaging.h:715 */
class _wsnt__GetMessagesResponse;	/* out/onvif_imaging.h:717 */
class _wsnt__DestroyPullPoint;	/* out/onvif_imaging.h:719 */
class _wsnt__DestroyPullPointResponse;	/* out/onvif_imaging.h:721 */
class _wsnt__CreatePullPoint;	/* out/onvif_imaging.h:723 */
class _wsnt__CreatePullPointResponse;	/* out/onvif_imaging.h:725 */
class _wsnt__Renew;	/* out/onvif_imaging.h:727 */
class _wsnt__RenewResponse;	/* out/onvif_imaging.h:729 */
class _wsnt__Unsubscribe;	/* out/onvif_imaging.h:731 */
class _wsnt__UnsubscribeResponse;	/* out/onvif_imaging.h:733 */
class _wsnt__PauseSubscription;	/* out/onvif_imaging.h:735 */
class _wsnt__PauseSubscriptionResponse;	/* out/onvif_imaging.h:737 */
class _wsnt__ResumeSubscription;	/* out/onvif_imaging.h:739 */
class _wsnt__ResumeSubscriptionResponse;	/* out/onvif_imaging.h:741 */
class _wsrfbf__BaseFaultType_ErrorCode;	/* out/onvif_imaging.h:7322 */
class _wsrfbf__BaseFaultType_Description;	/* out/onvif_imaging.h:7345 */
class _wsrfbf__BaseFaultType_FaultCause;	/* out/onvif_imaging.h:7363 */
class wsrfbf__BaseFaultType;	/* out/onvif_imaging.h:743 */
class wstop__Documentation;	/* out/onvif_imaging.h:745 */
class wstop__ExtensibleDocumented;	/* out/onvif_imaging.h:747 */
class wstop__QueryExpressionType;	/* out/onvif_imaging.h:749 */
class tt__VideoSourceConfiguration;	/* out/onvif_imaging.h:435 */
class tt__VideoEncoderConfiguration;	/* out/onvif_imaging.h:453 */
class tt__AudioSourceConfiguration;	/* out/onvif_imaging.h:463 */
class tt__AudioEncoderConfiguration;	/* out/onvif_imaging.h:465 */
class tt__VideoAnalyticsConfiguration;	/* out/onvif_imaging.h:467 */
class tt__MetadataConfiguration;	/* out/onvif_imaging.h:469 */
class tt__AudioOutputConfiguration;	/* out/onvif_imaging.h:477 */
class tt__AudioDecoderConfiguration;	/* out/onvif_imaging.h:479 */
class tt__PTZConfiguration;	/* out/onvif_imaging.h:485 */
class wsnt__SubscribeCreationFailedFaultType;	/* out/onvif_imaging.h:659 */
class wsnt__InvalidFilterFaultType;	/* out/onvif_imaging.h:661 */
class wsnt__TopicExpressionDialectUnknownFaultType;	/* out/onvif_imaging.h:663 */
class wsnt__InvalidTopicExpressionFaultType;	/* out/onvif_imaging.h:665 */
class wsnt__TopicNotSupportedFaultType;	/* out/onvif_imaging.h:667 */
class wsnt__MultipleTopicsSpecifiedFaultType;	/* out/onvif_imaging.h:669 */
class wsnt__InvalidProducerPropertiesExpressionFaultType;	/* out/onvif_imaging.h:671 */
class wsnt__InvalidMessageContentExpressionFaultType;	/* out/onvif_imaging.h:673 */
class wsnt__UnrecognizedPolicyRequestFaultType;	/* out/onvif_imaging.h:675 */
class wsnt__UnsupportedPolicyRequestFaultType;	/* out/onvif_imaging.h:677 */
class wsnt__NotifyMessageNotSupportedFaultType;	/* out/onvif_imaging.h:679 */
class wsnt__UnacceptableInitialTerminationTimeFaultType;	/* out/onvif_imaging.h:681 */
class wsnt__NoCurrentMessageOnTopicFaultType;	/* out/onvif_imaging.h:683 */
class wsnt__UnableToGetMessagesFaultType;	/* out/onvif_imaging.h:685 */
class wsnt__UnableToDestroyPullPointFaultType;	/* out/onvif_imaging.h:687 */
class wsnt__UnableToCreatePullPointFaultType;	/* out/onvif_imaging.h:689 */
class wsnt__UnacceptableTerminationTimeFaultType;	/* out/onvif_imaging.h:691 */
class wsnt__UnableToDestroySubscriptionFaultType;	/* out/onvif_imaging.h:693 */
class wsnt__PauseFailedFaultType;	/* out/onvif_imaging.h:695 */
class wsnt__ResumeFailedFaultType;	/* out/onvif_imaging.h:697 */
class _wstop__TopicNamespaceType_Topic;	/* out/onvif_imaging.h:10308 */
class wstop__TopicNamespaceType;	/* out/onvif_imaging.h:751 */
class wstop__TopicType;	/* out/onvif_imaging.h:753 */
class wstop__TopicSetType;	/* out/onvif_imaging.h:755 */
struct __timg__GetServiceCapabilities;	/* out/onvif_imaging.h:10841 */
struct __timg__GetImagingSettings;	/* out/onvif_imaging.h:10909 */
struct __timg__SetImagingSettings;	/* out/onvif_imaging.h:10977 */
struct __timg__GetOptions;	/* out/onvif_imaging.h:11055 */
struct __timg__Move;	/* out/onvif_imaging.h:11145 */
struct __timg__Stop;	/* out/onvif_imaging.h:11216 */
struct __timg__GetStatus;	/* out/onvif_imaging.h:11286 */
struct __timg__GetMoveOptions;	/* out/onvif_imaging.h:11354 */
struct __timg__GetPresets;	/* out/onvif_imaging.h:11422 */
struct __timg__GetCurrentPreset;	/* out/onvif_imaging.h:11494 */
struct __timg__SetCurrentPreset;	/* out/onvif_imaging.h:11570 */

/* xop.h:59 */
#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (8)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
struct SOAP_CMAC _xop__Include {
      public:
        unsigned char *__ptr;
        int __size;
        /** Optional element 'id' of XML schema type 'xsd:string' */
        char *id;
        /** Optional element 'type' of XML schema type 'xsd:string' */
        char *type;
        /** Optional element 'options' of XML schema type 'xsd:string' */
        char *options;
      public:
        /** Return unique type id SOAP_TYPE__xop__Include */
        long soap_type() const { return SOAP_TYPE__xop__Include; }
        /** Constructor with member initializations */
        _xop__Include() : __ptr(), __size(), id(), type(), options() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _xop__Include * SOAP_FMAC2 imageing_instantiate__xop__Include(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:65 */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (12)
/* complex XML schema type 'wsa5:EndpointReferenceType': */
struct SOAP_CMAC wsa5__EndpointReferenceType {
      public:
        /** Required element 'wsa5:Address' of XML schema type 'xsd:string' */
        char *Address;
        /** Optional element 'wsa5:ReferenceParameters' of XML schema type 'wsa5:ReferenceParametersType' */
        struct wsa5__ReferenceParametersType *ReferenceParameters;
        /** Optional element 'wsa5:Metadata' of XML schema type 'wsa5:MetadataType' */
        struct wsa5__MetadataType *Metadata;
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__EndpointReferenceType */
        long soap_type() const { return SOAP_TYPE_wsa5__EndpointReferenceType; }
        /** Constructor with member initializations */
        wsa5__EndpointReferenceType() : Address(), ReferenceParameters(), Metadata(), __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__EndpointReferenceType * SOAP_FMAC2 imageing_instantiate_wsa5__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:68 */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (13)
/* complex XML schema type 'wsa5:ReferenceParametersType': */
struct SOAP_CMAC wsa5__ReferenceParametersType {
      public:
        /** Optional element 'chan:ChannelInstance' of XML schema type 'xsd:int' */
        int *chan__ChannelInstance;
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__ReferenceParametersType */
        long soap_type() const { return SOAP_TYPE_wsa5__ReferenceParametersType; }
        /** Constructor with member initializations */
        wsa5__ReferenceParametersType() : chan__ChannelInstance(), __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__ReferenceParametersType * SOAP_FMAC2 imageing_instantiate_wsa5__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:71 */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (14)
/* complex XML schema type 'wsa5:MetadataType': */
struct SOAP_CMAC wsa5__MetadataType {
      public:
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__MetadataType */
        long soap_type() const { return SOAP_TYPE_wsa5__MetadataType; }
        /** Constructor with member initializations */
        wsa5__MetadataType() : __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__MetadataType * SOAP_FMAC2 imageing_instantiate_wsa5__MetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:86 */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (16)
/* complex XML schema type 'wsa5:ProblemActionType': */
struct SOAP_CMAC wsa5__ProblemActionType {
      public:
        /** Optional element 'wsa5:Action' of XML schema type 'xsd:string' */
        char *Action;
        /** Optional element 'wsa5:SoapAction' of XML schema type 'xsd:string' */
        char *SoapAction;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__ProblemActionType */
        long soap_type() const { return SOAP_TYPE_wsa5__ProblemActionType; }
        /** Constructor with member initializations */
        wsa5__ProblemActionType() : Action(), SoapAction(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__ProblemActionType * SOAP_FMAC2 imageing_instantiate_wsa5__ProblemActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:74 */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (15)
/* simple XML schema type 'wsa5:RelatesToType': */
struct SOAP_CMAC wsa5__RelatesToType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'RelationshipType' of XML schema type 'wsa5:RelationshipTypeOpenEnum' */
        char *RelationshipType;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__RelatesToType */
        long soap_type() const { return SOAP_TYPE_wsa5__RelatesToType; }
        /** Constructor with member initializations */
        wsa5__RelatesToType() : __item(), RelationshipType(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__RelatesToType * SOAP_FMAC2 imageing_instantiate_wsa5__RelatesToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:260 */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (41)
/* simple XML schema type 'chan:ChannelInstanceType': */
struct SOAP_CMAC chan__ChannelInstanceType {
      public:
        /** Simple content of XML schema type 'xsd:int' wrapped by this struct */
        int __item;
        /** Optional attribute 'wsa5:IsReferenceParameter' of XML schema type 'wsa5:IsReferenceParameter' */
        enum _wsa5__IsReferenceParameter wsa5__IsReferenceParameter;	/**< initialized with default value = (enum _wsa5__IsReferenceParameter)0 */
      public:
        /** Return unique type id SOAP_TYPE_chan__ChannelInstanceType */
        long soap_type() const { return SOAP_TYPE_chan__ChannelInstanceType; }
        /** Constructor with member initializations */
        chan__ChannelInstanceType() : __item(), wsa5__IsReferenceParameter((enum _wsa5__IsReferenceParameter)0) { }
        /** Friend allocator */
        friend SOAP_FMAC1 chan__ChannelInstanceType * SOAP_FMAC2 imageing_instantiate_chan__ChannelInstanceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:266 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (42)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Optional element 'wsa5:MessageID' of XML schema type 'wsa5:MessageID' */
        char *wsa5__MessageID;
        /** Optional element 'wsa5:RelatesTo' of XML schema type 'wsa5:RelatesTo' */
        struct wsa5__RelatesToType *wsa5__RelatesTo;
        /** Optional element 'wsa5:From' of XML schema type 'wsa5:From' */
        struct wsa5__EndpointReferenceType *wsa5__From;
        /** MustUnderstand */
        struct wsa5__EndpointReferenceType *wsa5__ReplyTo;
        /** MustUnderstand */
        struct wsa5__EndpointReferenceType *wsa5__FaultTo;
        /** MustUnderstand */
        char *wsa5__To;
        /** MustUnderstand */
        char *wsa5__Action;
        /** Optional element 'chan:ChannelInstance' of XML schema type 'chan:ChannelInstanceType' */
        struct chan__ChannelInstanceType *chan__ChannelInstance;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() : wsa5__MessageID(), wsa5__RelatesTo(), wsa5__From(), wsa5__ReplyTo(), wsa5__FaultTo(), wsa5__To(), wsa5__Action(), chan__ChannelInstance() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:283 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (48)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:284 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (50)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:285 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (52)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:290 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (56)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* out/onvif_imaging.h:181 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (57)
/* simple XML schema type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyType); }
      public:
        /// Constructor with default initializations
        xsd__anyType() : __item(), soap() { }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 imageing_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:188 */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (59)
/* complex XML schema type 'SOAP-ENV:Envelope': */
struct SOAP_CMAC SOAP_ENV__Envelope {
      public:
        /** Optional element 'SOAP-ENV:Header' of XML schema type 'SOAP-ENV:Header' */
        struct SOAP_ENV__Header *SOAP_ENV__Header;
        /** Optional element 'SOAP-ENV:Body' of XML schema type 'xsd:anyType' */
        char *SOAP_ENV__Body;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Envelope */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Envelope; }
        /** Constructor with member initializations */
        SOAP_ENV__Envelope() : SOAP_ENV__Header(), SOAP_ENV__Body() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Envelope * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Envelope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:194 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (63)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XML schema type 'xsd:string'
        char *id;
        /// Optional element 'type' of XML schema type 'xsd:string'
        char *type;
        /// Optional element 'options' of XML schema type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 imageing_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:202 */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (64)
/* hexBinary XML schema type: */
class SOAP_CMAC xsd__hexBinary {
      public:
        unsigned char *__ptr;
        int __size;
      public:
        /// Return unique type id SOAP_TYPE_xsd__hexBinary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__hexBinary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__hexBinary, default initialized and not managed by a soap context
        virtual xsd__hexBinary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__hexBinary); }
      public:
        /// Constructor with default initializations
        xsd__hexBinary() : __ptr(), __size() { }
        virtual ~xsd__hexBinary() { }
        /// Friend allocator used by soap_new_xsd__hexBinary(struct soap*, int)
        friend SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 imageing_instantiate_xsd__hexBinary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:212 */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType__
#define SOAP_TYPE_wsa5__EndpointReferenceType__ (65)
/* simple XML schema type 'wsa5:EndpointReferenceType': */
class SOAP_CMAC wsa5__EndpointReferenceType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'wsa5:EndpointReferenceType' wrapped by this struct
        struct wsa5__EndpointReferenceType __item;
      public:
        /// Return unique type id SOAP_TYPE_wsa5__EndpointReferenceType__
        virtual long soap_type(void) const { return SOAP_TYPE_wsa5__EndpointReferenceType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsa5__EndpointReferenceType__, default initialized and not managed by a soap context
        virtual wsa5__EndpointReferenceType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsa5__EndpointReferenceType__); }
      public:
        /// Constructor with default initializations
        wsa5__EndpointReferenceType__() : __item() { }
        virtual ~wsa5__EndpointReferenceType__() { }
        /// Friend allocator used by soap_new_wsa5__EndpointReferenceType__(struct soap*, int)
        friend SOAP_FMAC1 wsa5__EndpointReferenceType__ * SOAP_FMAC2 imageing_instantiate_wsa5__EndpointReferenceType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:219 */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope_
#define SOAP_TYPE_SOAP_ENV__Envelope_ (66)
/* simple XML schema type 'SOAP-ENV:Envelope': */
class SOAP_CMAC SOAP_ENV__Envelope_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'SOAP-ENV:Envelope' wrapped by this struct
        struct SOAP_ENV__Envelope __item;
      public:
        /// Return unique type id SOAP_TYPE_SOAP_ENV__Envelope_
        virtual long soap_type(void) const { return SOAP_TYPE_SOAP_ENV__Envelope_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type SOAP_ENV__Envelope_, default initialized and not managed by a soap context
        virtual SOAP_ENV__Envelope_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(SOAP_ENV__Envelope_); }
      public:
        /// Constructor with default initializations
        SOAP_ENV__Envelope_() : __item() { }
        virtual ~SOAP_ENV__Envelope_() { }
        /// Friend allocator used by soap_new_SOAP_ENV__Envelope_(struct soap*, int)
        friend SOAP_FMAC1 SOAP_ENV__Envelope_ * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Envelope_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:226 */
#ifndef SOAP_TYPE_SOAP_ENV__Fault_
#define SOAP_TYPE_SOAP_ENV__Fault_ (67)
/* simple XML schema type 'SOAP-ENV:Fault': */
class SOAP_CMAC SOAP_ENV__Fault_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'SOAP-ENV:Fault' wrapped by this struct
        struct SOAP_ENV__Fault __item;
      public:
        /// Return unique type id SOAP_TYPE_SOAP_ENV__Fault_
        virtual long soap_type(void) const { return SOAP_TYPE_SOAP_ENV__Fault_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type SOAP_ENV__Fault_, default initialized and not managed by a soap context
        virtual SOAP_ENV__Fault_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(SOAP_ENV__Fault_); }
      public:
        /// Constructor with default initializations
        SOAP_ENV__Fault_() : __item() { }
        virtual ~SOAP_ENV__Fault_() { }
        /// Friend allocator used by soap_new_SOAP_ENV__Fault_(struct soap*, int)
        friend SOAP_FMAC1 SOAP_ENV__Fault_ * SOAP_FMAC2 imageing_instantiate_SOAP_ENV__Fault_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:236 */
#ifndef SOAP_TYPE_xsd__NCName__
#define SOAP_TYPE_xsd__NCName__ (69)
/* simple XML schema type 'xsd:NCName': */
class SOAP_CMAC xsd__NCName__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:NCName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__NCName__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__NCName__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__NCName__, default initialized and not managed by a soap context
        virtual xsd__NCName__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__NCName__); }
      public:
        /// Constructor with default initializations
        xsd__NCName__() : __item() { }
        virtual ~xsd__NCName__() { }
        /// Friend allocator used by soap_new_xsd__NCName__(struct soap*, int)
        friend SOAP_FMAC1 xsd__NCName__ * SOAP_FMAC2 imageing_instantiate_xsd__NCName__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:243 */
#ifndef SOAP_TYPE_xsd__QName__
#define SOAP_TYPE_xsd__QName__ (70)
/* simple XML schema type 'xsd:QName': */
class SOAP_CMAC xsd__QName__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:QName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__QName__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__QName__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__QName__, default initialized and not managed by a soap context
        virtual xsd__QName__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__QName__); }
      public:
        /// Constructor with default initializations
        xsd__QName__() : __item() { }
        virtual ~xsd__QName__() { }
        /// Friend allocator used by soap_new_xsd__QName__(struct soap*, int)
        friend SOAP_FMAC1 xsd__QName__ * SOAP_FMAC2 imageing_instantiate_xsd__QName__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:253 */
#ifndef SOAP_TYPE_xsd__anySimpleType__
#define SOAP_TYPE_xsd__anySimpleType__ (72)
/* simple XML schema type 'xsd:anySimpleType': */
class SOAP_CMAC xsd__anySimpleType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anySimpleType' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anySimpleType__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anySimpleType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anySimpleType__, default initialized and not managed by a soap context
        virtual xsd__anySimpleType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anySimpleType__); }
      public:
        /// Constructor with default initializations
        xsd__anySimpleType__() : __item() { }
        virtual ~xsd__anySimpleType__() { }
        /// Friend allocator used by soap_new_xsd__anySimpleType__(struct soap*, int)
        friend SOAP_FMAC1 xsd__anySimpleType__ * SOAP_FMAC2 imageing_instantiate_xsd__anySimpleType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:263 */
#ifndef SOAP_TYPE_xsd__anyURI__
#define SOAP_TYPE_xsd__anyURI__ (74)
/* simple XML schema type 'xsd:anyURI': */
class SOAP_CMAC xsd__anyURI__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anyURI' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyURI__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyURI__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyURI__, default initialized and not managed by a soap context
        virtual xsd__anyURI__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyURI__); }
      public:
        /// Constructor with default initializations
        xsd__anyURI__() : __item() { }
        virtual ~xsd__anyURI__() { }
        /// Friend allocator used by soap_new_xsd__anyURI__(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyURI__ * SOAP_FMAC2 imageing_instantiate_xsd__anyURI__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:270 */
#ifndef SOAP_TYPE_xsd__base64Binary__
#define SOAP_TYPE_xsd__base64Binary__ (75)
/* simple XML schema type 'xsd:base64Binary': */
class SOAP_CMAC xsd__base64Binary__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary__, default initialized and not managed by a soap context
        virtual xsd__base64Binary__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary__); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary__() : __item() { }
        virtual ~xsd__base64Binary__() { }
        /// Friend allocator used by soap_new_xsd__base64Binary__(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary__ * SOAP_FMAC2 imageing_instantiate_xsd__base64Binary__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:277 */
#ifndef SOAP_TYPE_xsd__boolean_
#define SOAP_TYPE_xsd__boolean_ (76)
/* simple XML schema type 'xsd:boolean': */
class SOAP_CMAC xsd__boolean_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__boolean_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__boolean_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean_, default initialized and not managed by a soap context
        virtual xsd__boolean_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__boolean_); }
      public:
        /// Constructor with default initializations
        xsd__boolean_() : __item() { }
        virtual ~xsd__boolean_() { }
        /// Friend allocator used by soap_new_xsd__boolean_(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean_ * SOAP_FMAC2 imageing_instantiate_xsd__boolean_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:284 */
#ifndef SOAP_TYPE_xsd__dateTime_
#define SOAP_TYPE_xsd__dateTime_ (78)
/* simple XML schema type 'xsd:dateTime': */
class SOAP_CMAC xsd__dateTime_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:dateTime' wrapped by this struct
        time_t __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__dateTime_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__dateTime_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__dateTime_, default initialized and not managed by a soap context
        virtual xsd__dateTime_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__dateTime_); }
      public:
        /// Constructor with default initializations
        xsd__dateTime_() : __item() { }
        virtual ~xsd__dateTime_() { }
        /// Friend allocator used by soap_new_xsd__dateTime_(struct soap*, int)
        friend SOAP_FMAC1 xsd__dateTime_ * SOAP_FMAC2 imageing_instantiate_xsd__dateTime_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:291 */
#ifndef SOAP_TYPE_xsd__double_
#define SOAP_TYPE_xsd__double_ (80)
/* simple XML schema type 'xsd:double': */
class SOAP_CMAC xsd__double_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:double' wrapped by this struct
        double __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__double_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__double_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__double_, default initialized and not managed by a soap context
        virtual xsd__double_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__double_); }
      public:
        /// Constructor with default initializations
        xsd__double_() : __item() { }
        virtual ~xsd__double_() { }
        /// Friend allocator used by soap_new_xsd__double_(struct soap*, int)
        friend SOAP_FMAC1 xsd__double_ * SOAP_FMAC2 imageing_instantiate_xsd__double_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:301 */
#ifndef SOAP_TYPE_xsd__duration__
#define SOAP_TYPE_xsd__duration__ (83)
/* simple XML schema type 'xsd:duration': */
class SOAP_CMAC xsd__duration__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:duration' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__duration__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__duration__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__duration__, default initialized and not managed by a soap context
        virtual xsd__duration__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__duration__); }
      public:
        /// Constructor with default initializations
        xsd__duration__() : __item() { }
        virtual ~xsd__duration__() { }
        /// Friend allocator used by soap_new_xsd__duration__(struct soap*, int)
        friend SOAP_FMAC1 xsd__duration__ * SOAP_FMAC2 imageing_instantiate_xsd__duration__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:308 */
#ifndef SOAP_TYPE_xsd__float_
#define SOAP_TYPE_xsd__float_ (84)
/* simple XML schema type 'xsd:float': */
class SOAP_CMAC xsd__float_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:float' wrapped by this struct
        float __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__float_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__float_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__float_, default initialized and not managed by a soap context
        virtual xsd__float_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__float_); }
      public:
        /// Constructor with default initializations
        xsd__float_() : __item() { }
        virtual ~xsd__float_() { }
        /// Friend allocator used by soap_new_xsd__float_(struct soap*, int)
        friend SOAP_FMAC1 xsd__float_ * SOAP_FMAC2 imageing_instantiate_xsd__float_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:315 */
#ifndef SOAP_TYPE_xsd__hexBinary__
#define SOAP_TYPE_xsd__hexBinary__ (86)
/* simple XML schema type 'xsd:hexBinary': */
class SOAP_CMAC xsd__hexBinary__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:hexBinary' wrapped by this struct
        xsd__hexBinary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__hexBinary__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__hexBinary__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__hexBinary__, default initialized and not managed by a soap context
        virtual xsd__hexBinary__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__hexBinary__); }
      public:
        /// Constructor with default initializations
        xsd__hexBinary__() : __item() { }
        virtual ~xsd__hexBinary__() { }
        /// Friend allocator used by soap_new_xsd__hexBinary__(struct soap*, int)
        friend SOAP_FMAC1 xsd__hexBinary__ * SOAP_FMAC2 imageing_instantiate_xsd__hexBinary__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:322 */
#ifndef SOAP_TYPE_xsd__int_
#define SOAP_TYPE_xsd__int_ (87)
/* simple XML schema type 'xsd:int': */
class SOAP_CMAC xsd__int_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:int' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__int_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__int_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__int_, default initialized and not managed by a soap context
        virtual xsd__int_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__int_); }
      public:
        /// Constructor with default initializations
        xsd__int_() : __item() { }
        virtual ~xsd__int_() { }
        /// Friend allocator used by soap_new_xsd__int_(struct soap*, int)
        friend SOAP_FMAC1 xsd__int_ * SOAP_FMAC2 imageing_instantiate_xsd__int_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:332 */
#ifndef SOAP_TYPE_xsd__integer__
#define SOAP_TYPE_xsd__integer__ (89)
/* simple XML schema type 'xsd:integer': */
class SOAP_CMAC xsd__integer__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:integer' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__integer__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__integer__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__integer__, default initialized and not managed by a soap context
        virtual xsd__integer__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__integer__); }
      public:
        /// Constructor with default initializations
        xsd__integer__() : __item() { }
        virtual ~xsd__integer__() { }
        /// Friend allocator used by soap_new_xsd__integer__(struct soap*, int)
        friend SOAP_FMAC1 xsd__integer__ * SOAP_FMAC2 imageing_instantiate_xsd__integer__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:342 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger__
#define SOAP_TYPE_xsd__nonNegativeInteger__ (91)
/* simple XML schema type 'xsd:nonNegativeInteger': */
class SOAP_CMAC xsd__nonNegativeInteger__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:nonNegativeInteger' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__nonNegativeInteger__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__nonNegativeInteger__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__nonNegativeInteger__, default initialized and not managed by a soap context
        virtual xsd__nonNegativeInteger__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__nonNegativeInteger__); }
      public:
        /// Constructor with default initializations
        xsd__nonNegativeInteger__() : __item() { }
        virtual ~xsd__nonNegativeInteger__() { }
        /// Friend allocator used by soap_new_xsd__nonNegativeInteger__(struct soap*, int)
        friend SOAP_FMAC1 xsd__nonNegativeInteger__ * SOAP_FMAC2 imageing_instantiate_xsd__nonNegativeInteger__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:349 */
#ifndef SOAP_TYPE_xsd__string_
#define SOAP_TYPE_xsd__string_ (92)
/* simple XML schema type 'xsd:string': */
class SOAP_CMAC xsd__string_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__string_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__string_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string_, default initialized and not managed by a soap context
        virtual xsd__string_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__string_); }
      public:
        /// Constructor with default initializations
        xsd__string_() : __item() { }
        virtual ~xsd__string_() { }
        /// Friend allocator used by soap_new_xsd__string_(struct soap*, int)
        friend SOAP_FMAC1 xsd__string_ * SOAP_FMAC2 imageing_instantiate_xsd__string_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:359 */
#ifndef SOAP_TYPE_xsd__token__
#define SOAP_TYPE_xsd__token__ (94)
/* simple XML schema type 'xsd:token': */
class SOAP_CMAC xsd__token__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:token' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__token__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__token__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__token__, default initialized and not managed by a soap context
        virtual xsd__token__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__token__); }
      public:
        /// Constructor with default initializations
        xsd__token__() : __item() { }
        virtual ~xsd__token__() { }
        /// Friend allocator used by soap_new_xsd__token__(struct soap*, int)
        friend SOAP_FMAC1 xsd__token__ * SOAP_FMAC2 imageing_instantiate_xsd__token__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:840 */
#ifndef SOAP_TYPE_tt__Name__
#define SOAP_TYPE_tt__Name__ (292)
/* simple XML schema type 'tt:Name': */
class SOAP_CMAC tt__Name__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Name' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Name__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Name__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Name__, default initialized and not managed by a soap context
        virtual tt__Name__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Name__); }
      public:
        /// Constructor with default initializations
        tt__Name__() : __item() { }
        virtual ~tt__Name__() { }
        /// Friend allocator used by soap_new_tt__Name__(struct soap*, int)
        friend SOAP_FMAC1 tt__Name__ * SOAP_FMAC2 imageing_instantiate_tt__Name__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:870 */
#ifndef SOAP_TYPE_tt__RotateMode_
#define SOAP_TYPE_tt__RotateMode_ (294)
/* simple XML schema type 'tt:RotateMode': */
class SOAP_CMAC tt__RotateMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:RotateMode' wrapped by this struct
        enum tt__RotateMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__RotateMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RotateMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RotateMode_, default initialized and not managed by a soap context
        virtual tt__RotateMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RotateMode_); }
      public:
        /// Constructor with default initializations
        tt__RotateMode_() : __item() { }
        virtual ~tt__RotateMode_() { }
        /// Friend allocator used by soap_new_tt__RotateMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__RotateMode_ * SOAP_FMAC2 imageing_instantiate_tt__RotateMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:887 */
#ifndef SOAP_TYPE_tt__SceneOrientationMode_
#define SOAP_TYPE_tt__SceneOrientationMode_ (296)
/* simple XML schema type 'tt:SceneOrientationMode': */
class SOAP_CMAC tt__SceneOrientationMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:SceneOrientationMode' wrapped by this struct
        enum tt__SceneOrientationMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__SceneOrientationMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SceneOrientationMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SceneOrientationMode_, default initialized and not managed by a soap context
        virtual tt__SceneOrientationMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SceneOrientationMode_); }
      public:
        /// Constructor with default initializations
        tt__SceneOrientationMode_() : __item() { }
        virtual ~tt__SceneOrientationMode_() { }
        /// Friend allocator used by soap_new_tt__SceneOrientationMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__SceneOrientationMode_ * SOAP_FMAC2 imageing_instantiate_tt__SceneOrientationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:909 */
#ifndef SOAP_TYPE_tt__VideoEncoding_
#define SOAP_TYPE_tt__VideoEncoding_ (298)
/* simple XML schema type 'tt:VideoEncoding': */
class SOAP_CMAC tt__VideoEncoding_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:VideoEncoding' wrapped by this struct
        enum tt__VideoEncoding __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncoding_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncoding_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncoding_, default initialized and not managed by a soap context
        virtual tt__VideoEncoding_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncoding_); }
      public:
        /// Constructor with default initializations
        tt__VideoEncoding_() : __item() { }
        virtual ~tt__VideoEncoding_() { }
        /// Friend allocator used by soap_new_tt__VideoEncoding_(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncoding_ * SOAP_FMAC2 imageing_instantiate_tt__VideoEncoding_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:926 */
#ifndef SOAP_TYPE_tt__Mpeg4Profile_
#define SOAP_TYPE_tt__Mpeg4Profile_ (300)
/* simple XML schema type 'tt:Mpeg4Profile': */
class SOAP_CMAC tt__Mpeg4Profile_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Mpeg4Profile' wrapped by this struct
        enum tt__Mpeg4Profile __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Mpeg4Profile_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Mpeg4Profile_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Mpeg4Profile_, default initialized and not managed by a soap context
        virtual tt__Mpeg4Profile_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Mpeg4Profile_); }
      public:
        /// Constructor with default initializations
        tt__Mpeg4Profile_() : __item() { }
        virtual ~tt__Mpeg4Profile_() { }
        /// Friend allocator used by soap_new_tt__Mpeg4Profile_(struct soap*, int)
        friend SOAP_FMAC1 tt__Mpeg4Profile_ * SOAP_FMAC2 imageing_instantiate_tt__Mpeg4Profile_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:945 */
#ifndef SOAP_TYPE_tt__H264Profile_
#define SOAP_TYPE_tt__H264Profile_ (302)
/* simple XML schema type 'tt:H264Profile': */
class SOAP_CMAC tt__H264Profile_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:H264Profile' wrapped by this struct
        enum tt__H264Profile __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__H264Profile_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__H264Profile_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__H264Profile_, default initialized and not managed by a soap context
        virtual tt__H264Profile_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__H264Profile_); }
      public:
        /// Constructor with default initializations
        tt__H264Profile_() : __item() { }
        virtual ~tt__H264Profile_() { }
        /// Friend allocator used by soap_new_tt__H264Profile_(struct soap*, int)
        friend SOAP_FMAC1 tt__H264Profile_ * SOAP_FMAC2 imageing_instantiate_tt__H264Profile_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:967 */
#ifndef SOAP_TYPE_tt__AudioEncoding_
#define SOAP_TYPE_tt__AudioEncoding_ (304)
/* simple XML schema type 'tt:AudioEncoding': */
class SOAP_CMAC tt__AudioEncoding_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:AudioEncoding' wrapped by this struct
        enum tt__AudioEncoding __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioEncoding_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioEncoding_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioEncoding_, default initialized and not managed by a soap context
        virtual tt__AudioEncoding_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioEncoding_); }
      public:
        /// Constructor with default initializations
        tt__AudioEncoding_() : __item() { }
        virtual ~tt__AudioEncoding_() { }
        /// Friend allocator used by soap_new_tt__AudioEncoding_(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioEncoding_ * SOAP_FMAC2 imageing_instantiate_tt__AudioEncoding_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1003 */
#ifndef SOAP_TYPE_tt__IPv4Address__
#define SOAP_TYPE_tt__IPv4Address__ (306)
/* simple XML schema type 'tt:IPv4Address': */
class SOAP_CMAC tt__IPv4Address__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:IPv4Address' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv4Address__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv4Address__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv4Address__, default initialized and not managed by a soap context
        virtual tt__IPv4Address__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv4Address__); }
      public:
        /// Constructor with default initializations
        tt__IPv4Address__() : __item() { }
        virtual ~tt__IPv4Address__() { }
        /// Friend allocator used by soap_new_tt__IPv4Address__(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv4Address__ * SOAP_FMAC2 imageing_instantiate_tt__IPv4Address__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1015 */
#ifndef SOAP_TYPE_tt__IPv6Address__
#define SOAP_TYPE_tt__IPv6Address__ (308)
/* simple XML schema type 'tt:IPv6Address': */
class SOAP_CMAC tt__IPv6Address__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:IPv6Address' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv6Address__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv6Address__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv6Address__, default initialized and not managed by a soap context
        virtual tt__IPv6Address__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv6Address__); }
      public:
        /// Constructor with default initializations
        tt__IPv6Address__() : __item() { }
        virtual ~tt__IPv6Address__() { }
        /// Friend allocator used by soap_new_tt__IPv6Address__(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv6Address__ * SOAP_FMAC2 imageing_instantiate_tt__IPv6Address__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1034 */
#ifndef SOAP_TYPE_tt__IPType_
#define SOAP_TYPE_tt__IPType_ (310)
/* simple XML schema type 'tt:IPType': */
class SOAP_CMAC tt__IPType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:IPType' wrapped by this struct
        enum tt__IPType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPType_, default initialized and not managed by a soap context
        virtual tt__IPType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPType_); }
      public:
        /// Constructor with default initializations
        tt__IPType_() : __item() { }
        virtual ~tt__IPType_() { }
        /// Friend allocator used by soap_new_tt__IPType_(struct soap*, int)
        friend SOAP_FMAC1 tt__IPType_ * SOAP_FMAC2 imageing_instantiate_tt__IPType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1094 */
#ifndef SOAP_TYPE_tt__EFlipMode_
#define SOAP_TYPE_tt__EFlipMode_ (312)
/* simple XML schema type 'tt:EFlipMode': */
class SOAP_CMAC tt__EFlipMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:EFlipMode' wrapped by this struct
        enum tt__EFlipMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__EFlipMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EFlipMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EFlipMode_, default initialized and not managed by a soap context
        virtual tt__EFlipMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EFlipMode_); }
      public:
        /// Constructor with default initializations
        tt__EFlipMode_() : __item() { }
        virtual ~tt__EFlipMode_() { }
        /// Friend allocator used by soap_new_tt__EFlipMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__EFlipMode_ * SOAP_FMAC2 imageing_instantiate_tt__EFlipMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1113 */
#ifndef SOAP_TYPE_tt__ReverseMode_
#define SOAP_TYPE_tt__ReverseMode_ (314)
/* simple XML schema type 'tt:ReverseMode': */
class SOAP_CMAC tt__ReverseMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ReverseMode' wrapped by this struct
        enum tt__ReverseMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReverseMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReverseMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReverseMode_, default initialized and not managed by a soap context
        virtual tt__ReverseMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReverseMode_); }
      public:
        /// Constructor with default initializations
        tt__ReverseMode_() : __item() { }
        virtual ~tt__ReverseMode_() { }
        /// Friend allocator used by soap_new_tt__ReverseMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__ReverseMode_ * SOAP_FMAC2 imageing_instantiate_tt__ReverseMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1140 */
#ifndef SOAP_TYPE_tt__AutoFocusMode_
#define SOAP_TYPE_tt__AutoFocusMode_ (316)
/* simple XML schema type 'tt:AutoFocusMode': */
class SOAP_CMAC tt__AutoFocusMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:AutoFocusMode' wrapped by this struct
        enum tt__AutoFocusMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__AutoFocusMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AutoFocusMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AutoFocusMode_, default initialized and not managed by a soap context
        virtual tt__AutoFocusMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AutoFocusMode_); }
      public:
        /// Constructor with default initializations
        tt__AutoFocusMode_() : __item() { }
        virtual ~tt__AutoFocusMode_() { }
        /// Friend allocator used by soap_new_tt__AutoFocusMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__AutoFocusMode_ * SOAP_FMAC2 imageing_instantiate_tt__AutoFocusMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1159 */
#ifndef SOAP_TYPE_tt__WideDynamicMode_
#define SOAP_TYPE_tt__WideDynamicMode_ (318)
/* simple XML schema type 'tt:WideDynamicMode': */
class SOAP_CMAC tt__WideDynamicMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:WideDynamicMode' wrapped by this struct
        enum tt__WideDynamicMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__WideDynamicMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WideDynamicMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WideDynamicMode_, default initialized and not managed by a soap context
        virtual tt__WideDynamicMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WideDynamicMode_); }
      public:
        /// Constructor with default initializations
        tt__WideDynamicMode_() : __item() { }
        virtual ~tt__WideDynamicMode_() { }
        /// Friend allocator used by soap_new_tt__WideDynamicMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__WideDynamicMode_ * SOAP_FMAC2 imageing_instantiate_tt__WideDynamicMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1188 */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode_
#define SOAP_TYPE_tt__BacklightCompensationMode_ (320)
/* simple XML schema type 'tt:BacklightCompensationMode': */
class SOAP_CMAC tt__BacklightCompensationMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:BacklightCompensationMode' wrapped by this struct
        enum tt__BacklightCompensationMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__BacklightCompensationMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BacklightCompensationMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BacklightCompensationMode_, default initialized and not managed by a soap context
        virtual tt__BacklightCompensationMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BacklightCompensationMode_); }
      public:
        /// Constructor with default initializations
        tt__BacklightCompensationMode_() : __item() { }
        virtual ~tt__BacklightCompensationMode_() { }
        /// Friend allocator used by soap_new_tt__BacklightCompensationMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__BacklightCompensationMode_ * SOAP_FMAC2 imageing_instantiate_tt__BacklightCompensationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1205 */
#ifndef SOAP_TYPE_tt__ExposurePriority_
#define SOAP_TYPE_tt__ExposurePriority_ (322)
/* simple XML schema type 'tt:ExposurePriority': */
class SOAP_CMAC tt__ExposurePriority_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ExposurePriority' wrapped by this struct
        enum tt__ExposurePriority __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ExposurePriority_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ExposurePriority_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ExposurePriority_, default initialized and not managed by a soap context
        virtual tt__ExposurePriority_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ExposurePriority_); }
      public:
        /// Constructor with default initializations
        tt__ExposurePriority_() : __item() { }
        virtual ~tt__ExposurePriority_() { }
        /// Friend allocator used by soap_new_tt__ExposurePriority_(struct soap*, int)
        friend SOAP_FMAC1 tt__ExposurePriority_ * SOAP_FMAC2 imageing_instantiate_tt__ExposurePriority_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1222 */
#ifndef SOAP_TYPE_tt__ExposureMode_
#define SOAP_TYPE_tt__ExposureMode_ (324)
/* simple XML schema type 'tt:ExposureMode': */
class SOAP_CMAC tt__ExposureMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ExposureMode' wrapped by this struct
        enum tt__ExposureMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ExposureMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ExposureMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ExposureMode_, default initialized and not managed by a soap context
        virtual tt__ExposureMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ExposureMode_); }
      public:
        /// Constructor with default initializations
        tt__ExposureMode_() : __item() { }
        virtual ~tt__ExposureMode_() { }
        /// Friend allocator used by soap_new_tt__ExposureMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__ExposureMode_ * SOAP_FMAC2 imageing_instantiate_tt__ExposureMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1241 */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode_
#define SOAP_TYPE_tt__WhiteBalanceMode_ (326)
/* simple XML schema type 'tt:WhiteBalanceMode': */
class SOAP_CMAC tt__WhiteBalanceMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:WhiteBalanceMode' wrapped by this struct
        enum tt__WhiteBalanceMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalanceMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalanceMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalanceMode_, default initialized and not managed by a soap context
        virtual tt__WhiteBalanceMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalanceMode_); }
      public:
        /// Constructor with default initializations
        tt__WhiteBalanceMode_() : __item() { }
        virtual ~tt__WhiteBalanceMode_() { }
        /// Friend allocator used by soap_new_tt__WhiteBalanceMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalanceMode_ * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalanceMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1259 */
#ifndef SOAP_TYPE_tt__IrCutFilterMode_
#define SOAP_TYPE_tt__IrCutFilterMode_ (328)
/* simple XML schema type 'tt:IrCutFilterMode': */
class SOAP_CMAC tt__IrCutFilterMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:IrCutFilterMode' wrapped by this struct
        enum tt__IrCutFilterMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterMode_, default initialized and not managed by a soap context
        virtual tt__IrCutFilterMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterMode_); }
      public:
        /// Constructor with default initializations
        tt__IrCutFilterMode_() : __item() { }
        virtual ~tt__IrCutFilterMode_() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterMode_ * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1278 */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode_
#define SOAP_TYPE_tt__ImageStabilizationMode_ (330)
/* simple XML schema type 'tt:ImageStabilizationMode': */
class SOAP_CMAC tt__ImageStabilizationMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ImageStabilizationMode' wrapped by this struct
        enum tt__ImageStabilizationMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilizationMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilizationMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilizationMode_, default initialized and not managed by a soap context
        virtual tt__ImageStabilizationMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilizationMode_); }
      public:
        /// Constructor with default initializations
        tt__ImageStabilizationMode_() : __item() { }
        virtual ~tt__ImageStabilizationMode_() { }
        /// Friend allocator used by soap_new_tt__ImageStabilizationMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilizationMode_ * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilizationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1304 */
#ifndef SOAP_TYPE_tt__PropertyOperation_
#define SOAP_TYPE_tt__PropertyOperation_ (332)
/* simple XML schema type 'tt:PropertyOperation': */
class SOAP_CMAC tt__PropertyOperation_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:PropertyOperation' wrapped by this struct
        enum tt__PropertyOperation __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__PropertyOperation_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PropertyOperation_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PropertyOperation_, default initialized and not managed by a soap context
        virtual tt__PropertyOperation_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PropertyOperation_); }
      public:
        /// Constructor with default initializations
        tt__PropertyOperation_() : __item() { }
        virtual ~tt__PropertyOperation_() { }
        /// Friend allocator used by soap_new_tt__PropertyOperation_(struct soap*, int)
        friend SOAP_FMAC1 tt__PropertyOperation_ * SOAP_FMAC2 imageing_instantiate_tt__PropertyOperation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1350 */
#ifndef SOAP_TYPE_tt__ReferenceToken__
#define SOAP_TYPE_tt__ReferenceToken__ (334)
/* simple XML schema type 'tt:ReferenceToken': */
class SOAP_CMAC tt__ReferenceToken__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ReferenceToken' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReferenceToken__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReferenceToken__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReferenceToken__, default initialized and not managed by a soap context
        virtual tt__ReferenceToken__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReferenceToken__); }
      public:
        /// Constructor with default initializations
        tt__ReferenceToken__() : __item() { }
        virtual ~tt__ReferenceToken__() { }
        /// Friend allocator used by soap_new_tt__ReferenceToken__(struct soap*, int)
        friend SOAP_FMAC1 tt__ReferenceToken__ * SOAP_FMAC2 imageing_instantiate_tt__ReferenceToken__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1368 */
#ifndef SOAP_TYPE_tt__MoveStatus_
#define SOAP_TYPE_tt__MoveStatus_ (336)
/* simple XML schema type 'tt:MoveStatus': */
class SOAP_CMAC tt__MoveStatus_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:MoveStatus' wrapped by this struct
        enum tt__MoveStatus __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__MoveStatus_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MoveStatus_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MoveStatus_, default initialized and not managed by a soap context
        virtual tt__MoveStatus_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MoveStatus_); }
      public:
        /// Constructor with default initializations
        tt__MoveStatus_() : __item() { }
        virtual ~tt__MoveStatus_() { }
        /// Friend allocator used by soap_new_tt__MoveStatus_(struct soap*, int)
        friend SOAP_FMAC1 tt__MoveStatus_ * SOAP_FMAC2 imageing_instantiate_tt__MoveStatus_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:1414 */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression__
#define SOAP_TYPE_wstop__ConcreteTopicExpression__ (338)
/* simple XML schema type 'wstop:ConcreteTopicExpression': */
class SOAP_CMAC wstop__ConcreteTopicExpression__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'wstop:ConcreteTopicExpression' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_wstop__ConcreteTopicExpression__
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__ConcreteTopicExpression__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__ConcreteTopicExpression__, default initialized and not managed by a soap context
        virtual wstop__ConcreteTopicExpression__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__ConcreteTopicExpression__); }
      public:
        /// Constructor with default initializations
        wstop__ConcreteTopicExpression__() : __item() { }
        virtual ~wstop__ConcreteTopicExpression__() { }
        /// Friend allocator used by soap_new_wstop__ConcreteTopicExpression__(struct soap*, int)
        friend SOAP_FMAC1 wstop__ConcreteTopicExpression__ * SOAP_FMAC2 imageing_instantiate_wstop__ConcreteTopicExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:377 */
#ifndef SOAP_TYPE_timg__Capabilities
#define SOAP_TYPE_timg__Capabilities (96)
/* complex XML schema type 'timg:Capabilities': */
class SOAP_CMAC timg__Capabilities : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute 'ImageStabilization' of XML schema type 'xsd:boolean'
        bool *ImageStabilization;
        /// Optional attribute 'Presets' of XML schema type 'xsd:boolean'
        bool *Presets;
        /// Optional attribute 'AdaptablePreset' of XML schema type 'xsd:boolean'
        bool *AdaptablePreset;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_timg__Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE_timg__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type timg__Capabilities, default initialized and not managed by a soap context
        virtual timg__Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(timg__Capabilities); }
      public:
        /// Constructor with default initializations
        timg__Capabilities() : __any(), ImageStabilization(), Presets(), AdaptablePreset(), __anyAttribute() { }
        virtual ~timg__Capabilities() { }
        /// Friend allocator used by soap_new_timg__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 timg__Capabilities * SOAP_FMAC2 imageing_instantiate_timg__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:379 */
#ifndef SOAP_TYPE_timg__ImagingPreset
#define SOAP_TYPE_timg__ImagingPreset (97)
/* complex XML schema type 'timg:ImagingPreset': */
class SOAP_CMAC timg__ImagingPreset : public xsd__anyType {
      public:
        /// Required element 'timg:Name' of XML schema type 'tt:Name'
        std::string Name;
        /// Required attribute 'token' of XML schema type 'tt:ReferenceToken'
        std::string token;
        /// Required attribute 'type' of XML schema type 'xsd:string'
        std::string type;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_timg__ImagingPreset
        virtual long soap_type(void) const { return SOAP_TYPE_timg__ImagingPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type timg__ImagingPreset, default initialized and not managed by a soap context
        virtual timg__ImagingPreset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(timg__ImagingPreset); }
      public:
        /// Constructor with default initializations
        timg__ImagingPreset() : Name(), token(), type(), __anyAttribute() { }
        virtual ~timg__ImagingPreset() { }
        /// Friend allocator used by soap_new_timg__ImagingPreset(struct soap*, int)
        friend SOAP_FMAC1 timg__ImagingPreset * SOAP_FMAC2 imageing_instantiate_timg__ImagingPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:381 */
#ifndef SOAP_TYPE__timg__GetServiceCapabilities
#define SOAP_TYPE__timg__GetServiceCapabilities (98)
/* complex XML schema type 'timg:GetServiceCapabilities': */
class SOAP_CMAC _timg__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetServiceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _timg__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetServiceCapabilities); }
      public:
        /// Constructor with default initializations
        _timg__GetServiceCapabilities() : soap() { }
        virtual ~_timg__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__timg__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetServiceCapabilities * SOAP_FMAC2 imageing_instantiate__timg__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:383 */
#ifndef SOAP_TYPE__timg__GetServiceCapabilitiesResponse
#define SOAP_TYPE__timg__GetServiceCapabilitiesResponse (99)
/* complex XML schema type 'timg:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _timg__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'timg:Capabilities' of XML schema type 'timg:Capabilities'
        timg__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetServiceCapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _timg__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with default initializations
        _timg__GetServiceCapabilitiesResponse() : Capabilities(), soap() { }
        virtual ~_timg__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__timg__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetServiceCapabilitiesResponse * SOAP_FMAC2 imageing_instantiate__timg__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:385 */
#ifndef SOAP_TYPE__timg__GetImagingSettings
#define SOAP_TYPE__timg__GetImagingSettings (100)
/* complex XML schema type 'timg:GetImagingSettings': */
class SOAP_CMAC _timg__GetImagingSettings {
      public:
        /// Required element 'timg:VideoSourceToken' of XML schema type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetImagingSettings
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetImagingSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetImagingSettings, default initialized and not managed by a soap context
        virtual _timg__GetImagingSettings *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetImagingSettings); }
      public:
        /// Constructor with default initializations
        _timg__GetImagingSettings() : VideoSourceToken(), soap() { }
        virtual ~_timg__GetImagingSettings() { }
        /// Friend allocator used by soap_new__timg__GetImagingSettings(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetImagingSettings * SOAP_FMAC2 imageing_instantiate__timg__GetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:387 */
#ifndef SOAP_TYPE__timg__GetImagingSettingsResponse
#define SOAP_TYPE__timg__GetImagingSettingsResponse (101)
/* complex XML schema type 'timg:GetImagingSettingsResponse': */
class SOAP_CMAC _timg__GetImagingSettingsResponse {
      public:
        /// Required element 'timg:ImagingSettings' of XML schema type 'tt:ImagingSettings20'
        tt__ImagingSettings20 *ImagingSettings;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetImagingSettingsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetImagingSettingsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetImagingSettingsResponse, default initialized and not managed by a soap context
        virtual _timg__GetImagingSettingsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetImagingSettingsResponse); }
      public:
        /// Constructor with default initializations
        _timg__GetImagingSettingsResponse() : ImagingSettings(), soap() { }
        virtual ~_timg__GetImagingSettingsResponse() { }
        /// Friend allocator used by soap_new__timg__GetImagingSettingsResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetImagingSettingsResponse * SOAP_FMAC2 imageing_instantiate__timg__GetImagingSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:389 */
#ifndef SOAP_TYPE__timg__SetImagingSettings
#define SOAP_TYPE__timg__SetImagingSettings (102)
/* complex XML schema type 'timg:SetImagingSettings': */
class SOAP_CMAC _timg__SetImagingSettings {
      public:
        /// Required element 'timg:VideoSourceToken' of XML schema type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Required element 'timg:ImagingSettings' of XML schema type 'tt:ImagingSettings20'
        tt__ImagingSettings20 *ImagingSettings;
        /// Optional element 'timg:ForcePersistence' of XML schema type 'xsd:boolean'
        bool *ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__SetImagingSettings
        virtual long soap_type(void) const { return SOAP_TYPE__timg__SetImagingSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__SetImagingSettings, default initialized and not managed by a soap context
        virtual _timg__SetImagingSettings *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__SetImagingSettings); }
      public:
        /// Constructor with default initializations
        _timg__SetImagingSettings() : VideoSourceToken(), ImagingSettings(), ForcePersistence(), soap() { }
        virtual ~_timg__SetImagingSettings() { }
        /// Friend allocator used by soap_new__timg__SetImagingSettings(struct soap*, int)
        friend SOAP_FMAC1 _timg__SetImagingSettings * SOAP_FMAC2 imageing_instantiate__timg__SetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:391 */
#ifndef SOAP_TYPE__timg__SetImagingSettingsResponse
#define SOAP_TYPE__timg__SetImagingSettingsResponse (103)
/* complex XML schema type 'timg:SetImagingSettingsResponse': */
class SOAP_CMAC _timg__SetImagingSettingsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__SetImagingSettingsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__SetImagingSettingsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__SetImagingSettingsResponse, default initialized and not managed by a soap context
        virtual _timg__SetImagingSettingsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__SetImagingSettingsResponse); }
      public:
        /// Constructor with default initializations
        _timg__SetImagingSettingsResponse() : soap() { }
        virtual ~_timg__SetImagingSettingsResponse() { }
        /// Friend allocator used by soap_new__timg__SetImagingSettingsResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__SetImagingSettingsResponse * SOAP_FMAC2 imageing_instantiate__timg__SetImagingSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:393 */
#ifndef SOAP_TYPE__timg__GetOptions
#define SOAP_TYPE__timg__GetOptions (104)
/* complex XML schema type 'timg:GetOptions': */
class SOAP_CMAC _timg__GetOptions {
      public:
        /// Required element 'timg:VideoSourceToken' of XML schema type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetOptions
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetOptions, default initialized and not managed by a soap context
        virtual _timg__GetOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetOptions); }
      public:
        /// Constructor with default initializations
        _timg__GetOptions() : VideoSourceToken(), soap() { }
        virtual ~_timg__GetOptions() { }
        /// Friend allocator used by soap_new__timg__GetOptions(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetOptions * SOAP_FMAC2 imageing_instantiate__timg__GetOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:395 */
#ifndef SOAP_TYPE__timg__GetOptionsResponse
#define SOAP_TYPE__timg__GetOptionsResponse (105)
/* complex XML schema type 'timg:GetOptionsResponse': */
class SOAP_CMAC _timg__GetOptionsResponse {
      public:
        /// Required element 'timg:ImagingOptions' of XML schema type 'tt:ImagingOptions20'
        tt__ImagingOptions20 *ImagingOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetOptionsResponse, default initialized and not managed by a soap context
        virtual _timg__GetOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetOptionsResponse); }
      public:
        /// Constructor with default initializations
        _timg__GetOptionsResponse() : ImagingOptions(), soap() { }
        virtual ~_timg__GetOptionsResponse() { }
        /// Friend allocator used by soap_new__timg__GetOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetOptionsResponse * SOAP_FMAC2 imageing_instantiate__timg__GetOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:397 */
#ifndef SOAP_TYPE__timg__Move
#define SOAP_TYPE__timg__Move (106)
/* complex XML schema type 'timg:Move': */
class SOAP_CMAC _timg__Move {
      public:
        /// Required element 'timg:VideoSourceToken' of XML schema type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Required element 'timg:Focus' of XML schema type 'tt:FocusMove'
        tt__FocusMove *Focus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__Move
        virtual long soap_type(void) const { return SOAP_TYPE__timg__Move; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__Move, default initialized and not managed by a soap context
        virtual _timg__Move *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__Move); }
      public:
        /// Constructor with default initializations
        _timg__Move() : VideoSourceToken(), Focus(), soap() { }
        virtual ~_timg__Move() { }
        /// Friend allocator used by soap_new__timg__Move(struct soap*, int)
        friend SOAP_FMAC1 _timg__Move * SOAP_FMAC2 imageing_instantiate__timg__Move(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:399 */
#ifndef SOAP_TYPE__timg__MoveResponse
#define SOAP_TYPE__timg__MoveResponse (107)
/* complex XML schema type 'timg:MoveResponse': */
class SOAP_CMAC _timg__MoveResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__MoveResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__MoveResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__MoveResponse, default initialized and not managed by a soap context
        virtual _timg__MoveResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__MoveResponse); }
      public:
        /// Constructor with default initializations
        _timg__MoveResponse() : soap() { }
        virtual ~_timg__MoveResponse() { }
        /// Friend allocator used by soap_new__timg__MoveResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__MoveResponse * SOAP_FMAC2 imageing_instantiate__timg__MoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:401 */
#ifndef SOAP_TYPE__timg__GetMoveOptions
#define SOAP_TYPE__timg__GetMoveOptions (108)
/* complex XML schema type 'timg:GetMoveOptions': */
class SOAP_CMAC _timg__GetMoveOptions {
      public:
        /// Required element 'timg:VideoSourceToken' of XML schema type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetMoveOptions
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetMoveOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetMoveOptions, default initialized and not managed by a soap context
        virtual _timg__GetMoveOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetMoveOptions); }
      public:
        /// Constructor with default initializations
        _timg__GetMoveOptions() : VideoSourceToken(), soap() { }
        virtual ~_timg__GetMoveOptions() { }
        /// Friend allocator used by soap_new__timg__GetMoveOptions(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetMoveOptions * SOAP_FMAC2 imageing_instantiate__timg__GetMoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:403 */
#ifndef SOAP_TYPE__timg__GetMoveOptionsResponse
#define SOAP_TYPE__timg__GetMoveOptionsResponse (109)
/* complex XML schema type 'timg:GetMoveOptionsResponse': */
class SOAP_CMAC _timg__GetMoveOptionsResponse {
      public:
        /// Required element 'timg:MoveOptions' of XML schema type 'tt:MoveOptions20'
        tt__MoveOptions20 *MoveOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetMoveOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetMoveOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetMoveOptionsResponse, default initialized and not managed by a soap context
        virtual _timg__GetMoveOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetMoveOptionsResponse); }
      public:
        /// Constructor with default initializations
        _timg__GetMoveOptionsResponse() : MoveOptions(), soap() { }
        virtual ~_timg__GetMoveOptionsResponse() { }
        /// Friend allocator used by soap_new__timg__GetMoveOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetMoveOptionsResponse * SOAP_FMAC2 imageing_instantiate__timg__GetMoveOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:405 */
#ifndef SOAP_TYPE__timg__Stop
#define SOAP_TYPE__timg__Stop (110)
/* complex XML schema type 'timg:Stop': */
class SOAP_CMAC _timg__Stop {
      public:
        /// Required element 'timg:VideoSourceToken' of XML schema type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__Stop
        virtual long soap_type(void) const { return SOAP_TYPE__timg__Stop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__Stop, default initialized and not managed by a soap context
        virtual _timg__Stop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__Stop); }
      public:
        /// Constructor with default initializations
        _timg__Stop() : VideoSourceToken(), soap() { }
        virtual ~_timg__Stop() { }
        /// Friend allocator used by soap_new__timg__Stop(struct soap*, int)
        friend SOAP_FMAC1 _timg__Stop * SOAP_FMAC2 imageing_instantiate__timg__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:407 */
#ifndef SOAP_TYPE__timg__StopResponse
#define SOAP_TYPE__timg__StopResponse (111)
/* complex XML schema type 'timg:StopResponse': */
class SOAP_CMAC _timg__StopResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__StopResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__StopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__StopResponse, default initialized and not managed by a soap context
        virtual _timg__StopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__StopResponse); }
      public:
        /// Constructor with default initializations
        _timg__StopResponse() : soap() { }
        virtual ~_timg__StopResponse() { }
        /// Friend allocator used by soap_new__timg__StopResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__StopResponse * SOAP_FMAC2 imageing_instantiate__timg__StopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:409 */
#ifndef SOAP_TYPE__timg__GetStatus
#define SOAP_TYPE__timg__GetStatus (112)
/* complex XML schema type 'timg:GetStatus': */
class SOAP_CMAC _timg__GetStatus {
      public:
        /// Required element 'timg:VideoSourceToken' of XML schema type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetStatus
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetStatus, default initialized and not managed by a soap context
        virtual _timg__GetStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetStatus); }
      public:
        /// Constructor with default initializations
        _timg__GetStatus() : VideoSourceToken(), soap() { }
        virtual ~_timg__GetStatus() { }
        /// Friend allocator used by soap_new__timg__GetStatus(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetStatus * SOAP_FMAC2 imageing_instantiate__timg__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:411 */
#ifndef SOAP_TYPE__timg__GetStatusResponse
#define SOAP_TYPE__timg__GetStatusResponse (113)
/* complex XML schema type 'timg:GetStatusResponse': */
class SOAP_CMAC _timg__GetStatusResponse {
      public:
        /// Required element 'timg:Status' of XML schema type 'tt:ImagingStatus20'
        tt__ImagingStatus20 *Status;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetStatusResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetStatusResponse, default initialized and not managed by a soap context
        virtual _timg__GetStatusResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetStatusResponse); }
      public:
        /// Constructor with default initializations
        _timg__GetStatusResponse() : Status(), soap() { }
        virtual ~_timg__GetStatusResponse() { }
        /// Friend allocator used by soap_new__timg__GetStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetStatusResponse * SOAP_FMAC2 imageing_instantiate__timg__GetStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:413 */
#ifndef SOAP_TYPE__timg__GetPresets
#define SOAP_TYPE__timg__GetPresets (114)
/* complex XML schema type 'timg:GetPresets': */
class SOAP_CMAC _timg__GetPresets {
      public:
        /// Required element 'timg:VideoSourceToken' of XML schema type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetPresets
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetPresets; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetPresets, default initialized and not managed by a soap context
        virtual _timg__GetPresets *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetPresets); }
      public:
        /// Constructor with default initializations
        _timg__GetPresets() : VideoSourceToken(), soap() { }
        virtual ~_timg__GetPresets() { }
        /// Friend allocator used by soap_new__timg__GetPresets(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetPresets * SOAP_FMAC2 imageing_instantiate__timg__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:415 */
#ifndef SOAP_TYPE__timg__GetPresetsResponse
#define SOAP_TYPE__timg__GetPresetsResponse (115)
/* complex XML schema type 'timg:GetPresetsResponse': */
class SOAP_CMAC _timg__GetPresetsResponse {
      public:
        /// Required element 'timg:Preset' of XML schema type 'timg:ImagingPreset'
        std::vector<timg__ImagingPreset *> Preset;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetPresetsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetPresetsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetPresetsResponse, default initialized and not managed by a soap context
        virtual _timg__GetPresetsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetPresetsResponse); }
      public:
        /// Constructor with default initializations
        _timg__GetPresetsResponse() : Preset(), soap() { }
        virtual ~_timg__GetPresetsResponse() { }
        /// Friend allocator used by soap_new__timg__GetPresetsResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetPresetsResponse * SOAP_FMAC2 imageing_instantiate__timg__GetPresetsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:417 */
#ifndef SOAP_TYPE__timg__GetCurrentPreset
#define SOAP_TYPE__timg__GetCurrentPreset (116)
/* complex XML schema type 'timg:GetCurrentPreset': */
class SOAP_CMAC _timg__GetCurrentPreset {
      public:
        /// Required element 'timg:VideoSourceToken' of XML schema type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetCurrentPreset
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetCurrentPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetCurrentPreset, default initialized and not managed by a soap context
        virtual _timg__GetCurrentPreset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetCurrentPreset); }
      public:
        /// Constructor with default initializations
        _timg__GetCurrentPreset() : VideoSourceToken(), soap() { }
        virtual ~_timg__GetCurrentPreset() { }
        /// Friend allocator used by soap_new__timg__GetCurrentPreset(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetCurrentPreset * SOAP_FMAC2 imageing_instantiate__timg__GetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:419 */
#ifndef SOAP_TYPE__timg__GetCurrentPresetResponse
#define SOAP_TYPE__timg__GetCurrentPresetResponse (117)
/* complex XML schema type 'timg:GetCurrentPresetResponse': */
class SOAP_CMAC _timg__GetCurrentPresetResponse {
      public:
        /// Optional element 'timg:Preset' of XML schema type 'timg:ImagingPreset'
        timg__ImagingPreset *Preset;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetCurrentPresetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetCurrentPresetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetCurrentPresetResponse, default initialized and not managed by a soap context
        virtual _timg__GetCurrentPresetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetCurrentPresetResponse); }
      public:
        /// Constructor with default initializations
        _timg__GetCurrentPresetResponse() : Preset(), soap() { }
        virtual ~_timg__GetCurrentPresetResponse() { }
        /// Friend allocator used by soap_new__timg__GetCurrentPresetResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetCurrentPresetResponse * SOAP_FMAC2 imageing_instantiate__timg__GetCurrentPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:421 */
#ifndef SOAP_TYPE__timg__SetCurrentPreset
#define SOAP_TYPE__timg__SetCurrentPreset (118)
/* complex XML schema type 'timg:SetCurrentPreset': */
class SOAP_CMAC _timg__SetCurrentPreset {
      public:
        /// Required element 'timg:VideoSourceToken' of XML schema type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Required element 'timg:PresetToken' of XML schema type 'tt:ReferenceToken'
        std::string PresetToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__SetCurrentPreset
        virtual long soap_type(void) const { return SOAP_TYPE__timg__SetCurrentPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__SetCurrentPreset, default initialized and not managed by a soap context
        virtual _timg__SetCurrentPreset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__SetCurrentPreset); }
      public:
        /// Constructor with default initializations
        _timg__SetCurrentPreset() : VideoSourceToken(), PresetToken(), soap() { }
        virtual ~_timg__SetCurrentPreset() { }
        /// Friend allocator used by soap_new__timg__SetCurrentPreset(struct soap*, int)
        friend SOAP_FMAC1 _timg__SetCurrentPreset * SOAP_FMAC2 imageing_instantiate__timg__SetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:423 */
#ifndef SOAP_TYPE__timg__SetCurrentPresetResponse
#define SOAP_TYPE__timg__SetCurrentPresetResponse (119)
/* complex XML schema type 'timg:SetCurrentPresetResponse': */
class SOAP_CMAC _timg__SetCurrentPresetResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__SetCurrentPresetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__SetCurrentPresetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__SetCurrentPresetResponse, default initialized and not managed by a soap context
        virtual _timg__SetCurrentPresetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__SetCurrentPresetResponse); }
      public:
        /// Constructor with default initializations
        _timg__SetCurrentPresetResponse() : soap() { }
        virtual ~_timg__SetCurrentPresetResponse() { }
        /// Friend allocator used by soap_new__timg__SetCurrentPresetResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__SetCurrentPresetResponse * SOAP_FMAC2 imageing_instantiate__timg__SetCurrentPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:425 */
#ifndef SOAP_TYPE_tt__IntRectangle
#define SOAP_TYPE_tt__IntRectangle (120)
/* simple XML schema type 'tt:IntRectangle': */
class SOAP_CMAC tt__IntRectangle : public xsd__anyType {
      public:
        /// Required attribute 'x' of XML schema type 'xsd:int'
        int x;
        /// Required attribute 'y' of XML schema type 'xsd:int'
        int y;
        /// Required attribute 'width' of XML schema type 'xsd:int'
        int width;
        /// Required attribute 'height' of XML schema type 'xsd:int'
        int height;
      public:
        /// Return unique type id SOAP_TYPE_tt__IntRectangle
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IntRectangle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IntRectangle, default initialized and not managed by a soap context
        virtual tt__IntRectangle *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IntRectangle); }
      public:
        /// Constructor with default initializations
        tt__IntRectangle() : x(), y(), width(), height() { }
        virtual ~tt__IntRectangle() { }
        /// Friend allocator used by soap_new_tt__IntRectangle(struct soap*, int)
        friend SOAP_FMAC1 tt__IntRectangle * SOAP_FMAC2 imageing_instantiate_tt__IntRectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:427 */
#ifndef SOAP_TYPE_tt__IntRectangleRange
#define SOAP_TYPE_tt__IntRectangleRange (121)
/* complex XML schema type 'tt:IntRectangleRange': */
class SOAP_CMAC tt__IntRectangleRange : public xsd__anyType {
      public:
        /// Required element 'tt:XRange' of XML schema type 'tt:IntRange'
        tt__IntRange *XRange;
        /// Required element 'tt:YRange' of XML schema type 'tt:IntRange'
        tt__IntRange *YRange;
        /// Required element 'tt:WidthRange' of XML schema type 'tt:IntRange'
        tt__IntRange *WidthRange;
        /// Required element 'tt:HeightRange' of XML schema type 'tt:IntRange'
        tt__IntRange *HeightRange;
      public:
        /// Return unique type id SOAP_TYPE_tt__IntRectangleRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IntRectangleRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IntRectangleRange, default initialized and not managed by a soap context
        virtual tt__IntRectangleRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IntRectangleRange); }
      public:
        /// Constructor with default initializations
        tt__IntRectangleRange() : XRange(), YRange(), WidthRange(), HeightRange() { }
        virtual ~tt__IntRectangleRange() { }
        /// Friend allocator used by soap_new_tt__IntRectangleRange(struct soap*, int)
        friend SOAP_FMAC1 tt__IntRectangleRange * SOAP_FMAC2 imageing_instantiate_tt__IntRectangleRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:429 */
#ifndef SOAP_TYPE_tt__FloatRange
#define SOAP_TYPE_tt__FloatRange (122)
/* complex XML schema type 'tt:FloatRange': */
class SOAP_CMAC tt__FloatRange : public xsd__anyType {
      public:
        /// Required element 'tt:Min' of XML schema type 'xsd:float'
        float Min;
        /// Required element 'tt:Max' of XML schema type 'xsd:float'
        float Max;
      public:
        /// Return unique type id SOAP_TYPE_tt__FloatRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FloatRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FloatRange, default initialized and not managed by a soap context
        virtual tt__FloatRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FloatRange); }
      public:
        /// Constructor with default initializations
        tt__FloatRange() : Min(), Max() { }
        virtual ~tt__FloatRange() { }
        /// Friend allocator used by soap_new_tt__FloatRange(struct soap*, int)
        friend SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 imageing_instantiate_tt__FloatRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:431 */
#ifndef SOAP_TYPE_tt__DurationRange
#define SOAP_TYPE_tt__DurationRange (123)
/* complex XML schema type 'tt:DurationRange': */
class SOAP_CMAC tt__DurationRange : public xsd__anyType {
      public:
        /// Required element 'tt:Min' of XML schema type 'xsd:duration'
        std::string Min;
        /// Required element 'tt:Max' of XML schema type 'xsd:duration'
        std::string Max;
      public:
        /// Return unique type id SOAP_TYPE_tt__DurationRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DurationRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DurationRange, default initialized and not managed by a soap context
        virtual tt__DurationRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DurationRange); }
      public:
        /// Constructor with default initializations
        tt__DurationRange() : Min(), Max() { }
        virtual ~tt__DurationRange() { }
        /// Friend allocator used by soap_new_tt__DurationRange(struct soap*, int)
        friend SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 imageing_instantiate_tt__DurationRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:433 */
#ifndef SOAP_TYPE_tt__ConfigurationEntity
#define SOAP_TYPE_tt__ConfigurationEntity (124)
/* complex XML schema type 'tt:ConfigurationEntity': */
class SOAP_CMAC tt__ConfigurationEntity : public xsd__anyType {
      public:
        /// Required element 'tt:Name' of XML schema type 'tt:Name'
        std::string Name;
        /// Required element 'tt:UseCount' of XML schema type 'xsd:int'
        int UseCount;
        /// Required attribute 'token' of XML schema type 'tt:ReferenceToken'
        std::string token;
      public:
        /// Return unique type id SOAP_TYPE_tt__ConfigurationEntity
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ConfigurationEntity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ConfigurationEntity, default initialized and not managed by a soap context
        virtual tt__ConfigurationEntity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ConfigurationEntity); }
      public:
        /// Constructor with default initializations
        tt__ConfigurationEntity() : Name(), UseCount(), token() { }
        virtual ~tt__ConfigurationEntity() { }
        /// Friend allocator used by soap_new_tt__ConfigurationEntity(struct soap*, int)
        friend SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 imageing_instantiate_tt__ConfigurationEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:437 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension (126)
/* complex XML schema type 'tt:VideoSourceConfigurationExtension': */
class SOAP_CMAC tt__VideoSourceConfigurationExtension : public xsd__anyType {
      public:
        /// Optional element 'tt:Rotate' of XML schema type 'tt:Rotate'
        tt__Rotate *Rotate;
        /// Optional element 'tt:Extension' of XML schema type 'tt:VideoSourceConfigurationExtension2'
        tt__VideoSourceConfigurationExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__VideoSourceConfigurationExtension() : Rotate(), Extension() { }
        virtual ~tt__VideoSourceConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__VideoSourceConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:439 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (127)
/* complex XML schema type 'tt:VideoSourceConfigurationExtension2': */
class SOAP_CMAC tt__VideoSourceConfigurationExtension2 : public xsd__anyType {
      public:
        /// Optional element 'tt:LensDescription' of XML schema type 'tt:LensDescription'
        std::vector<tt__LensDescription *> LensDescription;
        /// Optional element 'tt:SceneOrientation' of XML schema type 'tt:SceneOrientation'
        tt__SceneOrientation *SceneOrientation;
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfigurationExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfigurationExtension2, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfigurationExtension2); }
      public:
        /// Constructor with default initializations
        tt__VideoSourceConfigurationExtension2() : LensDescription(), SceneOrientation(), __any() { }
        virtual ~tt__VideoSourceConfigurationExtension2() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC2 imageing_instantiate_tt__VideoSourceConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:441 */
#ifndef SOAP_TYPE_tt__Rotate
#define SOAP_TYPE_tt__Rotate (128)
/* complex XML schema type 'tt:Rotate': */
class SOAP_CMAC tt__Rotate : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:RotateMode'
        enum tt__RotateMode Mode;
        /// Optional element 'tt:Degree' of XML schema type 'xsd:int'
        int *Degree;
        /// Optional element 'tt:Extension' of XML schema type 'tt:RotateExtension'
        tt__RotateExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Rotate
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Rotate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Rotate, default initialized and not managed by a soap context
        virtual tt__Rotate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Rotate); }
      public:
        /// Constructor with default initializations
        tt__Rotate() : Mode(), Degree(), Extension(), __anyAttribute() { }
        virtual ~tt__Rotate() { }
        /// Friend allocator used by soap_new_tt__Rotate(struct soap*, int)
        friend SOAP_FMAC1 tt__Rotate * SOAP_FMAC2 imageing_instantiate_tt__Rotate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:443 */
#ifndef SOAP_TYPE_tt__RotateExtension
#define SOAP_TYPE_tt__RotateExtension (129)
/* complex XML schema type 'tt:RotateExtension': */
class SOAP_CMAC tt__RotateExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__RotateExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RotateExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RotateExtension, default initialized and not managed by a soap context
        virtual tt__RotateExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RotateExtension); }
      public:
        /// Constructor with default initializations
        tt__RotateExtension() : __any() { }
        virtual ~tt__RotateExtension() { }
        /// Friend allocator used by soap_new_tt__RotateExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__RotateExtension * SOAP_FMAC2 imageing_instantiate_tt__RotateExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:445 */
#ifndef SOAP_TYPE_tt__LensProjection
#define SOAP_TYPE_tt__LensProjection (130)
/* complex XML schema type 'tt:LensProjection': */
class SOAP_CMAC tt__LensProjection : public xsd__anyType {
      public:
        /// Required element 'tt:Angle' of XML schema type 'xsd:float'
        float Angle;
        /// Required element 'tt:Radius' of XML schema type 'xsd:float'
        float Radius;
        /// Optional element 'tt:Transmittance' of XML schema type 'xsd:float'
        float *Transmittance;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__LensProjection
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LensProjection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LensProjection, default initialized and not managed by a soap context
        virtual tt__LensProjection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LensProjection); }
      public:
        /// Constructor with default initializations
        tt__LensProjection() : Angle(), Radius(), Transmittance(), __any(), __anyAttribute() { }
        virtual ~tt__LensProjection() { }
        /// Friend allocator used by soap_new_tt__LensProjection(struct soap*, int)
        friend SOAP_FMAC1 tt__LensProjection * SOAP_FMAC2 imageing_instantiate_tt__LensProjection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:447 */
#ifndef SOAP_TYPE_tt__LensOffset
#define SOAP_TYPE_tt__LensOffset (131)
/* simple XML schema type 'tt:LensOffset': */
class SOAP_CMAC tt__LensOffset : public xsd__anyType {
      public:
        /// Optional attribute 'x' of XML schema type 'xsd:float'
        float *x;
        /// Optional attribute 'y' of XML schema type 'xsd:float'
        float *y;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__LensOffset
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LensOffset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LensOffset, default initialized and not managed by a soap context
        virtual tt__LensOffset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LensOffset); }
      public:
        /// Constructor with default initializations
        tt__LensOffset() : x(), y(), __anyAttribute() { }
        virtual ~tt__LensOffset() { }
        /// Friend allocator used by soap_new_tt__LensOffset(struct soap*, int)
        friend SOAP_FMAC1 tt__LensOffset * SOAP_FMAC2 imageing_instantiate_tt__LensOffset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:449 */
#ifndef SOAP_TYPE_tt__LensDescription
#define SOAP_TYPE_tt__LensDescription (132)
/* complex XML schema type 'tt:LensDescription': */
class SOAP_CMAC tt__LensDescription : public xsd__anyType {
      public:
        /// Required element 'tt:Offset' of XML schema type 'tt:LensOffset'
        tt__LensOffset *Offset;
        /// Required element 'tt:Projection' of XML schema type 'tt:LensProjection'
        std::vector<tt__LensProjection *> Projection;
        /// Required element 'tt:XFactor' of XML schema type 'xsd:float'
        float XFactor;
        std::vector<char *> __any;
        /// Optional attribute 'FocalLength' of XML schema type 'xsd:float'
        float *FocalLength;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__LensDescription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LensDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LensDescription, default initialized and not managed by a soap context
        virtual tt__LensDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LensDescription); }
      public:
        /// Constructor with default initializations
        tt__LensDescription() : Offset(), Projection(), XFactor(), __any(), FocalLength(), __anyAttribute() { }
        virtual ~tt__LensDescription() { }
        /// Friend allocator used by soap_new_tt__LensDescription(struct soap*, int)
        friend SOAP_FMAC1 tt__LensDescription * SOAP_FMAC2 imageing_instantiate_tt__LensDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:451 */
#ifndef SOAP_TYPE_tt__SceneOrientation
#define SOAP_TYPE_tt__SceneOrientation (133)
/* complex XML schema type 'tt:SceneOrientation': */
class SOAP_CMAC tt__SceneOrientation : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:SceneOrientationMode'
        enum tt__SceneOrientationMode Mode;
        /// Optional element 'tt:Orientation' of XML schema type 'xsd:string'
        std::string *Orientation;
      public:
        /// Return unique type id SOAP_TYPE_tt__SceneOrientation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SceneOrientation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SceneOrientation, default initialized and not managed by a soap context
        virtual tt__SceneOrientation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SceneOrientation); }
      public:
        /// Constructor with default initializations
        tt__SceneOrientation() : Mode(), Orientation() { }
        virtual ~tt__SceneOrientation() { }
        /// Friend allocator used by soap_new_tt__SceneOrientation(struct soap*, int)
        friend SOAP_FMAC1 tt__SceneOrientation * SOAP_FMAC2 imageing_instantiate_tt__SceneOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:455 */
#ifndef SOAP_TYPE_tt__VideoResolution
#define SOAP_TYPE_tt__VideoResolution (135)
/* complex XML schema type 'tt:VideoResolution': */
class SOAP_CMAC tt__VideoResolution : public xsd__anyType {
      public:
        /// Required element 'tt:Width' of XML schema type 'xsd:int'
        int Width;
        /// Required element 'tt:Height' of XML schema type 'xsd:int'
        int Height;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoResolution
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoResolution; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoResolution, default initialized and not managed by a soap context
        virtual tt__VideoResolution *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoResolution); }
      public:
        /// Constructor with default initializations
        tt__VideoResolution() : Width(), Height() { }
        virtual ~tt__VideoResolution() { }
        /// Friend allocator used by soap_new_tt__VideoResolution(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoResolution * SOAP_FMAC2 imageing_instantiate_tt__VideoResolution(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:457 */
#ifndef SOAP_TYPE_tt__VideoRateControl
#define SOAP_TYPE_tt__VideoRateControl (136)
/* complex XML schema type 'tt:VideoRateControl': */
class SOAP_CMAC tt__VideoRateControl : public xsd__anyType {
      public:
        /// Required element 'tt:FrameRateLimit' of XML schema type 'xsd:int'
        int FrameRateLimit;
        /// Required element 'tt:EncodingInterval' of XML schema type 'xsd:int'
        int EncodingInterval;
        /// Required element 'tt:BitrateLimit' of XML schema type 'xsd:int'
        int BitrateLimit;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoRateControl
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoRateControl; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoRateControl, default initialized and not managed by a soap context
        virtual tt__VideoRateControl *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoRateControl); }
      public:
        /// Constructor with default initializations
        tt__VideoRateControl() : FrameRateLimit(), EncodingInterval(), BitrateLimit() { }
        virtual ~tt__VideoRateControl() { }
        /// Friend allocator used by soap_new_tt__VideoRateControl(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoRateControl * SOAP_FMAC2 imageing_instantiate_tt__VideoRateControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:459 */
#ifndef SOAP_TYPE_tt__Mpeg4Configuration
#define SOAP_TYPE_tt__Mpeg4Configuration (137)
/* complex XML schema type 'tt:Mpeg4Configuration': */
class SOAP_CMAC tt__Mpeg4Configuration : public xsd__anyType {
      public:
        /// Required element 'tt:GovLength' of XML schema type 'xsd:int'
        int GovLength;
        /// Required element 'tt:Mpeg4Profile' of XML schema type 'tt:Mpeg4Profile'
        enum tt__Mpeg4Profile Mpeg4Profile;
      public:
        /// Return unique type id SOAP_TYPE_tt__Mpeg4Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Mpeg4Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Mpeg4Configuration, default initialized and not managed by a soap context
        virtual tt__Mpeg4Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Mpeg4Configuration); }
      public:
        /// Constructor with default initializations
        tt__Mpeg4Configuration() : GovLength(), Mpeg4Profile() { }
        virtual ~tt__Mpeg4Configuration() { }
        /// Friend allocator used by soap_new_tt__Mpeg4Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__Mpeg4Configuration * SOAP_FMAC2 imageing_instantiate_tt__Mpeg4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:461 */
#ifndef SOAP_TYPE_tt__H264Configuration
#define SOAP_TYPE_tt__H264Configuration (138)
/* complex XML schema type 'tt:H264Configuration': */
class SOAP_CMAC tt__H264Configuration : public xsd__anyType {
      public:
        /// Required element 'tt:GovLength' of XML schema type 'xsd:int'
        int GovLength;
        /// Required element 'tt:H264Profile' of XML schema type 'tt:H264Profile'
        enum tt__H264Profile H264Profile;
      public:
        /// Return unique type id SOAP_TYPE_tt__H264Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__H264Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__H264Configuration, default initialized and not managed by a soap context
        virtual tt__H264Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__H264Configuration); }
      public:
        /// Constructor with default initializations
        tt__H264Configuration() : GovLength(), H264Profile() { }
        virtual ~tt__H264Configuration() { }
        /// Friend allocator used by soap_new_tt__H264Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__H264Configuration * SOAP_FMAC2 imageing_instantiate_tt__H264Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:471 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationExtension
#define SOAP_TYPE_tt__MetadataConfigurationExtension (143)
/* complex XML schema type 'tt:MetadataConfigurationExtension': */
class SOAP_CMAC tt__MetadataConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__MetadataConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__MetadataConfigurationExtension() : __any() { }
        virtual ~tt__MetadataConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__MetadataConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__MetadataConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:473 */
#ifndef SOAP_TYPE_tt__PTZFilter
#define SOAP_TYPE_tt__PTZFilter (144)
/* complex XML schema type 'tt:PTZFilter': */
class SOAP_CMAC tt__PTZFilter : public xsd__anyType {
      public:
        /// Required element 'tt:Status' of XML schema type 'xsd:boolean'
        bool Status;
        /// Required element 'tt:Position' of XML schema type 'xsd:boolean'
        bool Position;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZFilter
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZFilter, default initialized and not managed by a soap context
        virtual tt__PTZFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZFilter); }
      public:
        /// Constructor with default initializations
        tt__PTZFilter() : Status(), Position(), __anyAttribute() { }
        virtual ~tt__PTZFilter() { }
        /// Friend allocator used by soap_new_tt__PTZFilter(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZFilter * SOAP_FMAC2 imageing_instantiate_tt__PTZFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:2865 */
#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (362)
/* complex XML schema type 'tt:EventSubscription-SubscriptionPolicy': */
class SOAP_CMAC _tt__EventSubscription_SubscriptionPolicy {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__EventSubscription_SubscriptionPolicy, default initialized and not managed by a soap context
        virtual _tt__EventSubscription_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__EventSubscription_SubscriptionPolicy); }
      public:
        /// Constructor with default initializations
        _tt__EventSubscription_SubscriptionPolicy() : __any() { }
        virtual ~_tt__EventSubscription_SubscriptionPolicy() { }
        /// Friend allocator used by soap_new__tt__EventSubscription_SubscriptionPolicy(struct soap*, int)
        friend SOAP_FMAC1 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC2 imageing_instantiate__tt__EventSubscription_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:475 */
#ifndef SOAP_TYPE_tt__EventSubscription
#define SOAP_TYPE_tt__EventSubscription (145)
/* complex XML schema type 'tt:EventSubscription': */
class SOAP_CMAC tt__EventSubscription : public xsd__anyType {
      public:
        /// Optional element 'tt:Filter' of XML schema type 'wsnt:FilterType'
        wsnt__FilterType *Filter;
        /// Optional element 'tt:SubscriptionPolicy' of XML schema type 'tt:EventSubscription-SubscriptionPolicy'
        _tt__EventSubscription_SubscriptionPolicy *SubscriptionPolicy;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__EventSubscription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EventSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EventSubscription, default initialized and not managed by a soap context
        virtual tt__EventSubscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EventSubscription); }
      public:
        /// Constructor with default initializations
        tt__EventSubscription() : Filter(), SubscriptionPolicy(), __any(), __anyAttribute() { }
        virtual ~tt__EventSubscription() { }
        /// Friend allocator used by soap_new_tt__EventSubscription(struct soap*, int)
        friend SOAP_FMAC1 tt__EventSubscription * SOAP_FMAC2 imageing_instantiate_tt__EventSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:481 */
#ifndef SOAP_TYPE_tt__MulticastConfiguration
#define SOAP_TYPE_tt__MulticastConfiguration (148)
/* complex XML schema type 'tt:MulticastConfiguration': */
class SOAP_CMAC tt__MulticastConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:Address' of XML schema type 'tt:IPAddress'
        tt__IPAddress *Address;
        /// Required element 'tt:Port' of XML schema type 'xsd:int'
        int Port;
        /// Required element 'tt:TTL' of XML schema type 'xsd:int'
        int TTL;
        /// Required element 'tt:AutoStart' of XML schema type 'xsd:boolean'
        bool AutoStart;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MulticastConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MulticastConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MulticastConfiguration, default initialized and not managed by a soap context
        virtual tt__MulticastConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MulticastConfiguration); }
      public:
        /// Constructor with default initializations
        tt__MulticastConfiguration() : Address(), Port(), TTL(), AutoStart(), __any(), __anyAttribute() { }
        virtual ~tt__MulticastConfiguration() { }
        /// Friend allocator used by soap_new_tt__MulticastConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__MulticastConfiguration * SOAP_FMAC2 imageing_instantiate_tt__MulticastConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:483 */
#ifndef SOAP_TYPE_tt__IPAddress
#define SOAP_TYPE_tt__IPAddress (149)
/* complex XML schema type 'tt:IPAddress': */
class SOAP_CMAC tt__IPAddress : public xsd__anyType {
      public:
        /// Required element 'tt:Type' of XML schema type 'tt:IPType'
        enum tt__IPType Type;
        /// Optional element 'tt:IPv4Address' of XML schema type 'tt:IPv4Address'
        std::string *IPv4Address;
        /// Optional element 'tt:IPv6Address' of XML schema type 'tt:IPv6Address'
        std::string *IPv6Address;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPAddress
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPAddress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPAddress, default initialized and not managed by a soap context
        virtual tt__IPAddress *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPAddress); }
      public:
        /// Constructor with default initializations
        tt__IPAddress() : Type(), IPv4Address(), IPv6Address() { }
        virtual ~tt__IPAddress() { }
        /// Friend allocator used by soap_new_tt__IPAddress(struct soap*, int)
        friend SOAP_FMAC1 tt__IPAddress * SOAP_FMAC2 imageing_instantiate_tt__IPAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:487 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension
#define SOAP_TYPE_tt__PTZConfigurationExtension (151)
/* complex XML schema type 'tt:PTZConfigurationExtension': */
class SOAP_CMAC tt__PTZConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:PTControlDirection' of XML schema type 'tt:PTControlDirection'
        tt__PTControlDirection *PTControlDirection;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZConfigurationExtension2'
        tt__PTZConfigurationExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__PTZConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__PTZConfigurationExtension() : __any(), PTControlDirection(), Extension() { }
        virtual ~tt__PTZConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__PTZConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__PTZConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:489 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension2
#define SOAP_TYPE_tt__PTZConfigurationExtension2 (152)
/* complex XML schema type 'tt:PTZConfigurationExtension2': */
class SOAP_CMAC tt__PTZConfigurationExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZConfigurationExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZConfigurationExtension2, default initialized and not managed by a soap context
        virtual tt__PTZConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZConfigurationExtension2); }
      public:
        /// Constructor with default initializations
        tt__PTZConfigurationExtension2() : __any() { }
        virtual ~tt__PTZConfigurationExtension2() { }
        /// Friend allocator used by soap_new_tt__PTZConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZConfigurationExtension2 * SOAP_FMAC2 imageing_instantiate_tt__PTZConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:491 */
#ifndef SOAP_TYPE_tt__PTControlDirection
#define SOAP_TYPE_tt__PTControlDirection (153)
/* complex XML schema type 'tt:PTControlDirection': */
class SOAP_CMAC tt__PTControlDirection : public xsd__anyType {
      public:
        /// Optional element 'tt:EFlip' of XML schema type 'tt:EFlip'
        tt__EFlip *EFlip;
        /// Optional element 'tt:Reverse' of XML schema type 'tt:Reverse'
        tt__Reverse *Reverse;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTControlDirectionExtension'
        tt__PTControlDirectionExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTControlDirection
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTControlDirection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTControlDirection, default initialized and not managed by a soap context
        virtual tt__PTControlDirection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTControlDirection); }
      public:
        /// Constructor with default initializations
        tt__PTControlDirection() : EFlip(), Reverse(), Extension(), __anyAttribute() { }
        virtual ~tt__PTControlDirection() { }
        /// Friend allocator used by soap_new_tt__PTControlDirection(struct soap*, int)
        friend SOAP_FMAC1 tt__PTControlDirection * SOAP_FMAC2 imageing_instantiate_tt__PTControlDirection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:493 */
#ifndef SOAP_TYPE_tt__PTControlDirectionExtension
#define SOAP_TYPE_tt__PTControlDirectionExtension (154)
/* complex XML schema type 'tt:PTControlDirectionExtension': */
class SOAP_CMAC tt__PTControlDirectionExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTControlDirectionExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTControlDirectionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTControlDirectionExtension, default initialized and not managed by a soap context
        virtual tt__PTControlDirectionExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTControlDirectionExtension); }
      public:
        /// Constructor with default initializations
        tt__PTControlDirectionExtension() : __any(), __anyAttribute() { }
        virtual ~tt__PTControlDirectionExtension() { }
        /// Friend allocator used by soap_new_tt__PTControlDirectionExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTControlDirectionExtension * SOAP_FMAC2 imageing_instantiate_tt__PTControlDirectionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:495 */
#ifndef SOAP_TYPE_tt__EFlip
#define SOAP_TYPE_tt__EFlip (155)
/* complex XML schema type 'tt:EFlip': */
class SOAP_CMAC tt__EFlip : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:EFlipMode'
        enum tt__EFlipMode Mode;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__EFlip
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EFlip; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EFlip, default initialized and not managed by a soap context
        virtual tt__EFlip *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EFlip); }
      public:
        /// Constructor with default initializations
        tt__EFlip() : Mode(), __any(), __anyAttribute() { }
        virtual ~tt__EFlip() { }
        /// Friend allocator used by soap_new_tt__EFlip(struct soap*, int)
        friend SOAP_FMAC1 tt__EFlip * SOAP_FMAC2 imageing_instantiate_tt__EFlip(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:497 */
#ifndef SOAP_TYPE_tt__Reverse
#define SOAP_TYPE_tt__Reverse (156)
/* complex XML schema type 'tt:Reverse': */
class SOAP_CMAC tt__Reverse : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:ReverseMode'
        enum tt__ReverseMode Mode;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Reverse
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Reverse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Reverse, default initialized and not managed by a soap context
        virtual tt__Reverse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Reverse); }
      public:
        /// Constructor with default initializations
        tt__Reverse() : Mode(), __any(), __anyAttribute() { }
        virtual ~tt__Reverse() { }
        /// Friend allocator used by soap_new_tt__Reverse(struct soap*, int)
        friend SOAP_FMAC1 tt__Reverse * SOAP_FMAC2 imageing_instantiate_tt__Reverse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:499 */
#ifndef SOAP_TYPE_tt__PanTiltLimits
#define SOAP_TYPE_tt__PanTiltLimits (157)
/* complex XML schema type 'tt:PanTiltLimits': */
class SOAP_CMAC tt__PanTiltLimits : public xsd__anyType {
      public:
        /// Required element 'tt:Range' of XML schema type 'tt:Space2DDescription'
        tt__Space2DDescription *Range;
      public:
        /// Return unique type id SOAP_TYPE_tt__PanTiltLimits
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PanTiltLimits; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PanTiltLimits, default initialized and not managed by a soap context
        virtual tt__PanTiltLimits *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PanTiltLimits); }
      public:
        /// Constructor with default initializations
        tt__PanTiltLimits() : Range() { }
        virtual ~tt__PanTiltLimits() { }
        /// Friend allocator used by soap_new_tt__PanTiltLimits(struct soap*, int)
        friend SOAP_FMAC1 tt__PanTiltLimits * SOAP_FMAC2 imageing_instantiate_tt__PanTiltLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:501 */
#ifndef SOAP_TYPE_tt__ZoomLimits
#define SOAP_TYPE_tt__ZoomLimits (158)
/* complex XML schema type 'tt:ZoomLimits': */
class SOAP_CMAC tt__ZoomLimits : public xsd__anyType {
      public:
        /// Required element 'tt:Range' of XML schema type 'tt:Space1DDescription'
        tt__Space1DDescription *Range;
      public:
        /// Return unique type id SOAP_TYPE_tt__ZoomLimits
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ZoomLimits; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ZoomLimits, default initialized and not managed by a soap context
        virtual tt__ZoomLimits *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ZoomLimits); }
      public:
        /// Constructor with default initializations
        tt__ZoomLimits() : Range() { }
        virtual ~tt__ZoomLimits() { }
        /// Friend allocator used by soap_new_tt__ZoomLimits(struct soap*, int)
        friend SOAP_FMAC1 tt__ZoomLimits * SOAP_FMAC2 imageing_instantiate_tt__ZoomLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:503 */
#ifndef SOAP_TYPE_tt__Space2DDescription
#define SOAP_TYPE_tt__Space2DDescription (159)
/* complex XML schema type 'tt:Space2DDescription': */
class SOAP_CMAC tt__Space2DDescription : public xsd__anyType {
      public:
        /// Required element 'tt:URI' of XML schema type 'xsd:anyURI'
        std::string URI;
        /// Required element 'tt:XRange' of XML schema type 'tt:FloatRange'
        tt__FloatRange *XRange;
        /// Required element 'tt:YRange' of XML schema type 'tt:FloatRange'
        tt__FloatRange *YRange;
      public:
        /// Return unique type id SOAP_TYPE_tt__Space2DDescription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Space2DDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Space2DDescription, default initialized and not managed by a soap context
        virtual tt__Space2DDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Space2DDescription); }
      public:
        /// Constructor with default initializations
        tt__Space2DDescription() : URI(), XRange(), YRange() { }
        virtual ~tt__Space2DDescription() { }
        /// Friend allocator used by soap_new_tt__Space2DDescription(struct soap*, int)
        friend SOAP_FMAC1 tt__Space2DDescription * SOAP_FMAC2 imageing_instantiate_tt__Space2DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:505 */
#ifndef SOAP_TYPE_tt__Space1DDescription
#define SOAP_TYPE_tt__Space1DDescription (160)
/* complex XML schema type 'tt:Space1DDescription': */
class SOAP_CMAC tt__Space1DDescription : public xsd__anyType {
      public:
        /// Required element 'tt:URI' of XML schema type 'xsd:anyURI'
        std::string URI;
        /// Required element 'tt:XRange' of XML schema type 'tt:FloatRange'
        tt__FloatRange *XRange;
      public:
        /// Return unique type id SOAP_TYPE_tt__Space1DDescription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Space1DDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Space1DDescription, default initialized and not managed by a soap context
        virtual tt__Space1DDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Space1DDescription); }
      public:
        /// Constructor with default initializations
        tt__Space1DDescription() : URI(), XRange() { }
        virtual ~tt__Space1DDescription() { }
        /// Friend allocator used by soap_new_tt__Space1DDescription(struct soap*, int)
        friend SOAP_FMAC1 tt__Space1DDescription * SOAP_FMAC2 imageing_instantiate_tt__Space1DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:507 */
#ifndef SOAP_TYPE_tt__PTZSpeed
#define SOAP_TYPE_tt__PTZSpeed (161)
/* complex XML schema type 'tt:PTZSpeed': */
class SOAP_CMAC tt__PTZSpeed : public xsd__anyType {
      public:
        /// Optional element 'tt:PanTilt' of XML schema type 'tt:Vector2D'
        tt__Vector2D *PanTilt;
        /// Optional element 'tt:Zoom' of XML schema type 'tt:Vector1D'
        tt__Vector1D *Zoom;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZSpeed
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZSpeed; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZSpeed, default initialized and not managed by a soap context
        virtual tt__PTZSpeed *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZSpeed); }
      public:
        /// Constructor with default initializations
        tt__PTZSpeed() : PanTilt(), Zoom() { }
        virtual ~tt__PTZSpeed() { }
        /// Friend allocator used by soap_new_tt__PTZSpeed(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZSpeed * SOAP_FMAC2 imageing_instantiate_tt__PTZSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:509 */
#ifndef SOAP_TYPE_tt__FocusMove
#define SOAP_TYPE_tt__FocusMove (162)
/* complex XML schema type 'tt:FocusMove': */
class SOAP_CMAC tt__FocusMove : public xsd__anyType {
      public:
        /// Optional element 'tt:Absolute' of XML schema type 'tt:AbsoluteFocus'
        tt__AbsoluteFocus *Absolute;
        /// Optional element 'tt:Relative' of XML schema type 'tt:RelativeFocus'
        tt__RelativeFocus *Relative;
        /// Optional element 'tt:Continuous' of XML schema type 'tt:ContinuousFocus'
        tt__ContinuousFocus *Continuous;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusMove
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusMove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusMove, default initialized and not managed by a soap context
        virtual tt__FocusMove *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusMove); }
      public:
        /// Constructor with default initializations
        tt__FocusMove() : Absolute(), Relative(), Continuous() { }
        virtual ~tt__FocusMove() { }
        /// Friend allocator used by soap_new_tt__FocusMove(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusMove * SOAP_FMAC2 imageing_instantiate_tt__FocusMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:511 */
#ifndef SOAP_TYPE_tt__AbsoluteFocus
#define SOAP_TYPE_tt__AbsoluteFocus (163)
/* complex XML schema type 'tt:AbsoluteFocus': */
class SOAP_CMAC tt__AbsoluteFocus : public xsd__anyType {
      public:
        /// Required element 'tt:Position' of XML schema type 'xsd:float'
        float Position;
        /// Optional element 'tt:Speed' of XML schema type 'xsd:float'
        float *Speed;
      public:
        /// Return unique type id SOAP_TYPE_tt__AbsoluteFocus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AbsoluteFocus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AbsoluteFocus, default initialized and not managed by a soap context
        virtual tt__AbsoluteFocus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AbsoluteFocus); }
      public:
        /// Constructor with default initializations
        tt__AbsoluteFocus() : Position(), Speed() { }
        virtual ~tt__AbsoluteFocus() { }
        /// Friend allocator used by soap_new_tt__AbsoluteFocus(struct soap*, int)
        friend SOAP_FMAC1 tt__AbsoluteFocus * SOAP_FMAC2 imageing_instantiate_tt__AbsoluteFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:513 */
#ifndef SOAP_TYPE_tt__RelativeFocus
#define SOAP_TYPE_tt__RelativeFocus (164)
/* complex XML schema type 'tt:RelativeFocus': */
class SOAP_CMAC tt__RelativeFocus : public xsd__anyType {
      public:
        /// Required element 'tt:Distance' of XML schema type 'xsd:float'
        float Distance;
        /// Optional element 'tt:Speed' of XML schema type 'xsd:float'
        float *Speed;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelativeFocus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelativeFocus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelativeFocus, default initialized and not managed by a soap context
        virtual tt__RelativeFocus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelativeFocus); }
      public:
        /// Constructor with default initializations
        tt__RelativeFocus() : Distance(), Speed() { }
        virtual ~tt__RelativeFocus() { }
        /// Friend allocator used by soap_new_tt__RelativeFocus(struct soap*, int)
        friend SOAP_FMAC1 tt__RelativeFocus * SOAP_FMAC2 imageing_instantiate_tt__RelativeFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:515 */
#ifndef SOAP_TYPE_tt__ContinuousFocus
#define SOAP_TYPE_tt__ContinuousFocus (165)
/* complex XML schema type 'tt:ContinuousFocus': */
class SOAP_CMAC tt__ContinuousFocus : public xsd__anyType {
      public:
        /// Required element 'tt:Speed' of XML schema type 'xsd:float'
        float Speed;
      public:
        /// Return unique type id SOAP_TYPE_tt__ContinuousFocus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ContinuousFocus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ContinuousFocus, default initialized and not managed by a soap context
        virtual tt__ContinuousFocus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ContinuousFocus); }
      public:
        /// Constructor with default initializations
        tt__ContinuousFocus() : Speed() { }
        virtual ~tt__ContinuousFocus() { }
        /// Friend allocator used by soap_new_tt__ContinuousFocus(struct soap*, int)
        friend SOAP_FMAC1 tt__ContinuousFocus * SOAP_FMAC2 imageing_instantiate_tt__ContinuousFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:517 */
#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions
#define SOAP_TYPE_tt__AbsoluteFocusOptions (166)
/* complex XML schema type 'tt:AbsoluteFocusOptions': */
class SOAP_CMAC tt__AbsoluteFocusOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Position' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Position;
        /// Optional element 'tt:Speed' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Speed;
      public:
        /// Return unique type id SOAP_TYPE_tt__AbsoluteFocusOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AbsoluteFocusOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AbsoluteFocusOptions, default initialized and not managed by a soap context
        virtual tt__AbsoluteFocusOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AbsoluteFocusOptions); }
      public:
        /// Constructor with default initializations
        tt__AbsoluteFocusOptions() : Position(), Speed() { }
        virtual ~tt__AbsoluteFocusOptions() { }
        /// Friend allocator used by soap_new_tt__AbsoluteFocusOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AbsoluteFocusOptions * SOAP_FMAC2 imageing_instantiate_tt__AbsoluteFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:519 */
#ifndef SOAP_TYPE_tt__ContinuousFocusOptions
#define SOAP_TYPE_tt__ContinuousFocusOptions (167)
/* complex XML schema type 'tt:ContinuousFocusOptions': */
class SOAP_CMAC tt__ContinuousFocusOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Speed' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Speed;
      public:
        /// Return unique type id SOAP_TYPE_tt__ContinuousFocusOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ContinuousFocusOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ContinuousFocusOptions, default initialized and not managed by a soap context
        virtual tt__ContinuousFocusOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ContinuousFocusOptions); }
      public:
        /// Constructor with default initializations
        tt__ContinuousFocusOptions() : Speed() { }
        virtual ~tt__ContinuousFocusOptions() { }
        /// Friend allocator used by soap_new_tt__ContinuousFocusOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ContinuousFocusOptions * SOAP_FMAC2 imageing_instantiate_tt__ContinuousFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:521 */
#ifndef SOAP_TYPE_tt__ImagingStatus20
#define SOAP_TYPE_tt__ImagingStatus20 (168)
/* complex XML schema type 'tt:ImagingStatus20': */
class SOAP_CMAC tt__ImagingStatus20 : public xsd__anyType {
      public:
        /// Optional element 'tt:FocusStatus20' of XML schema type 'tt:FocusStatus20'
        tt__FocusStatus20 *FocusStatus20;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingStatus20Extension'
        tt__ImagingStatus20Extension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingStatus20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingStatus20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingStatus20, default initialized and not managed by a soap context
        virtual tt__ImagingStatus20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingStatus20); }
      public:
        /// Constructor with default initializations
        tt__ImagingStatus20() : FocusStatus20(), Extension(), __anyAttribute() { }
        virtual ~tt__ImagingStatus20() { }
        /// Friend allocator used by soap_new_tt__ImagingStatus20(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingStatus20 * SOAP_FMAC2 imageing_instantiate_tt__ImagingStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:523 */
#ifndef SOAP_TYPE_tt__ImagingStatus20Extension
#define SOAP_TYPE_tt__ImagingStatus20Extension (169)
/* complex XML schema type 'tt:ImagingStatus20Extension': */
class SOAP_CMAC tt__ImagingStatus20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingStatus20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingStatus20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingStatus20Extension, default initialized and not managed by a soap context
        virtual tt__ImagingStatus20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingStatus20Extension); }
      public:
        /// Constructor with default initializations
        tt__ImagingStatus20Extension() : __any() { }
        virtual ~tt__ImagingStatus20Extension() { }
        /// Friend allocator used by soap_new_tt__ImagingStatus20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingStatus20Extension * SOAP_FMAC2 imageing_instantiate_tt__ImagingStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:525 */
#ifndef SOAP_TYPE_tt__FocusStatus20
#define SOAP_TYPE_tt__FocusStatus20 (170)
/* complex XML schema type 'tt:FocusStatus20': */
class SOAP_CMAC tt__FocusStatus20 : public xsd__anyType {
      public:
        /// Required element 'tt:Position' of XML schema type 'xsd:float'
        float Position;
        /// Required element 'tt:MoveStatus' of XML schema type 'tt:MoveStatus'
        enum tt__MoveStatus MoveStatus;
        /// Optional element 'tt:Error' of XML schema type 'xsd:string'
        std::string *Error;
        /// Optional element 'tt:Extension' of XML schema type 'tt:FocusStatus20Extension'
        tt__FocusStatus20Extension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusStatus20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusStatus20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusStatus20, default initialized and not managed by a soap context
        virtual tt__FocusStatus20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusStatus20); }
      public:
        /// Constructor with default initializations
        tt__FocusStatus20() : Position(), MoveStatus(), Error(), Extension(), __anyAttribute() { }
        virtual ~tt__FocusStatus20() { }
        /// Friend allocator used by soap_new_tt__FocusStatus20(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusStatus20 * SOAP_FMAC2 imageing_instantiate_tt__FocusStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:527 */
#ifndef SOAP_TYPE_tt__FocusStatus20Extension
#define SOAP_TYPE_tt__FocusStatus20Extension (171)
/* complex XML schema type 'tt:FocusStatus20Extension': */
class SOAP_CMAC tt__FocusStatus20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusStatus20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusStatus20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusStatus20Extension, default initialized and not managed by a soap context
        virtual tt__FocusStatus20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusStatus20Extension); }
      public:
        /// Constructor with default initializations
        tt__FocusStatus20Extension() : __any() { }
        virtual ~tt__FocusStatus20Extension() { }
        /// Friend allocator used by soap_new_tt__FocusStatus20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusStatus20Extension * SOAP_FMAC2 imageing_instantiate_tt__FocusStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:529 */
#ifndef SOAP_TYPE_tt__ImagingSettings20
#define SOAP_TYPE_tt__ImagingSettings20 (172)
/* complex XML schema type 'tt:ImagingSettings20': */
class SOAP_CMAC tt__ImagingSettings20 : public xsd__anyType {
      public:
        /// Optional element 'tt:BacklightCompensation' of XML schema type 'tt:BacklightCompensation20'
        tt__BacklightCompensation20 *BacklightCompensation;
        /// Optional element 'tt:Brightness' of XML schema type 'xsd:float'
        float *Brightness;
        /// Optional element 'tt:ColorSaturation' of XML schema type 'xsd:float'
        float *ColorSaturation;
        /// Optional element 'tt:Contrast' of XML schema type 'xsd:float'
        float *Contrast;
        /// Optional element 'tt:Exposure' of XML schema type 'tt:Exposure20'
        tt__Exposure20 *Exposure;
        /// Optional element 'tt:Focus' of XML schema type 'tt:FocusConfiguration20'
        tt__FocusConfiguration20 *Focus;
        /// Optional element 'tt:IrCutFilter' of XML schema type 'tt:IrCutFilterMode'
        enum tt__IrCutFilterMode *IrCutFilter;
        /// Optional element 'tt:Sharpness' of XML schema type 'xsd:float'
        float *Sharpness;
        /// Optional element 'tt:WideDynamicRange' of XML schema type 'tt:WideDynamicRange20'
        tt__WideDynamicRange20 *WideDynamicRange;
        /// Optional element 'tt:WhiteBalance' of XML schema type 'tt:WhiteBalance20'
        tt__WhiteBalance20 *WhiteBalance;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingSettingsExtension20'
        tt__ImagingSettingsExtension20 *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettings20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettings20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettings20, default initialized and not managed by a soap context
        virtual tt__ImagingSettings20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettings20); }
      public:
        /// Constructor with default initializations
        tt__ImagingSettings20() : BacklightCompensation(), Brightness(), ColorSaturation(), Contrast(), Exposure(), Focus(), IrCutFilter(), Sharpness(), WideDynamicRange(), WhiteBalance(), Extension(), __anyAttribute() { }
        virtual ~tt__ImagingSettings20() { }
        /// Friend allocator used by soap_new_tt__ImagingSettings20(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettings20 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettings20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:531 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20
#define SOAP_TYPE_tt__ImagingSettingsExtension20 (173)
/* complex XML schema type 'tt:ImagingSettingsExtension20': */
class SOAP_CMAC tt__ImagingSettingsExtension20 : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:ImageStabilization' of XML schema type 'tt:ImageStabilization'
        tt__ImageStabilization *ImageStabilization;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingSettingsExtension202'
        tt__ImagingSettingsExtension202 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension20, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension20); }
      public:
        /// Constructor with default initializations
        tt__ImagingSettingsExtension20() : __any(), ImageStabilization(), Extension() { }
        virtual ~tt__ImagingSettingsExtension20() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension20(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension20 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettingsExtension20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:533 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension202
#define SOAP_TYPE_tt__ImagingSettingsExtension202 (174)
/* complex XML schema type 'tt:ImagingSettingsExtension202': */
class SOAP_CMAC tt__ImagingSettingsExtension202 : public xsd__anyType {
      public:
        /// Optional element 'tt:IrCutFilterAutoAdjustment' of XML schema type 'tt:IrCutFilterAutoAdjustment'
        std::vector<tt__IrCutFilterAutoAdjustment *> IrCutFilterAutoAdjustment;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingSettingsExtension203'
        tt__ImagingSettingsExtension203 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension202
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension202; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension202, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension202 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension202); }
      public:
        /// Constructor with default initializations
        tt__ImagingSettingsExtension202() : IrCutFilterAutoAdjustment(), Extension() { }
        virtual ~tt__ImagingSettingsExtension202() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension202(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension202 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettingsExtension202(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:535 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension203
#define SOAP_TYPE_tt__ImagingSettingsExtension203 (175)
/* complex XML schema type 'tt:ImagingSettingsExtension203': */
class SOAP_CMAC tt__ImagingSettingsExtension203 : public xsd__anyType {
      public:
        /// Optional element 'tt:ToneCompensation' of XML schema type 'tt:ToneCompensation'
        tt__ToneCompensation *ToneCompensation;
        /// Optional element 'tt:Defogging' of XML schema type 'tt:Defogging'
        tt__Defogging *Defogging;
        /// Optional element 'tt:NoiseReduction' of XML schema type 'tt:NoiseReduction'
        tt__NoiseReduction *NoiseReduction;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingSettingsExtension204'
        tt__ImagingSettingsExtension204 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension203
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension203; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension203, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension203 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension203); }
      public:
        /// Constructor with default initializations
        tt__ImagingSettingsExtension203() : ToneCompensation(), Defogging(), NoiseReduction(), Extension() { }
        virtual ~tt__ImagingSettingsExtension203() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension203(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension203 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettingsExtension203(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:537 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension204
#define SOAP_TYPE_tt__ImagingSettingsExtension204 (176)
/* complex XML schema type 'tt:ImagingSettingsExtension204': */
class SOAP_CMAC tt__ImagingSettingsExtension204 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension204
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension204; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension204, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension204 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension204); }
      public:
        /// Constructor with default initializations
        tt__ImagingSettingsExtension204() : __any() { }
        virtual ~tt__ImagingSettingsExtension204() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension204(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension204 * SOAP_FMAC2 imageing_instantiate_tt__ImagingSettingsExtension204(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:539 */
#ifndef SOAP_TYPE_tt__ImageStabilization
#define SOAP_TYPE_tt__ImageStabilization (177)
/* complex XML schema type 'tt:ImageStabilization': */
class SOAP_CMAC tt__ImageStabilization : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:ImageStabilizationMode'
        enum tt__ImageStabilizationMode Mode;
        /// Optional element 'tt:Level' of XML schema type 'xsd:float'
        float *Level;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImageStabilizationExtension'
        tt__ImageStabilizationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilization
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilization; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilization, default initialized and not managed by a soap context
        virtual tt__ImageStabilization *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilization); }
      public:
        /// Constructor with default initializations
        tt__ImageStabilization() : Mode(), Level(), Extension(), __anyAttribute() { }
        virtual ~tt__ImageStabilization() { }
        /// Friend allocator used by soap_new_tt__ImageStabilization(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilization * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:541 */
#ifndef SOAP_TYPE_tt__ImageStabilizationExtension
#define SOAP_TYPE_tt__ImageStabilizationExtension (178)
/* complex XML schema type 'tt:ImageStabilizationExtension': */
class SOAP_CMAC tt__ImageStabilizationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilizationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilizationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilizationExtension, default initialized and not managed by a soap context
        virtual tt__ImageStabilizationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilizationExtension); }
      public:
        /// Constructor with default initializations
        tt__ImageStabilizationExtension() : __any() { }
        virtual ~tt__ImageStabilizationExtension() { }
        /// Friend allocator used by soap_new_tt__ImageStabilizationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilizationExtension * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilizationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:543 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustment
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustment (179)
/* complex XML schema type 'tt:IrCutFilterAutoAdjustment': */
class SOAP_CMAC tt__IrCutFilterAutoAdjustment : public xsd__anyType {
      public:
        /// Required element 'tt:BoundaryType' of XML schema type 'xsd:string'
        std::string BoundaryType;
        /// Optional element 'tt:BoundaryOffset' of XML schema type 'xsd:float'
        float *BoundaryOffset;
        /// Optional element 'tt:ResponseTime' of XML schema type 'xsd:duration'
        std::string *ResponseTime;
        /// Optional element 'tt:Extension' of XML schema type 'tt:IrCutFilterAutoAdjustmentExtension'
        tt__IrCutFilterAutoAdjustmentExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustment
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterAutoAdjustment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterAutoAdjustment, default initialized and not managed by a soap context
        virtual tt__IrCutFilterAutoAdjustment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterAutoAdjustment); }
      public:
        /// Constructor with default initializations
        tt__IrCutFilterAutoAdjustment() : BoundaryType(), BoundaryOffset(), ResponseTime(), Extension(), __anyAttribute() { }
        virtual ~tt__IrCutFilterAutoAdjustment() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterAutoAdjustment(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustment * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterAutoAdjustment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:545 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension (180)
/* complex XML schema type 'tt:IrCutFilterAutoAdjustmentExtension': */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterAutoAdjustmentExtension, default initialized and not managed by a soap context
        virtual tt__IrCutFilterAutoAdjustmentExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterAutoAdjustmentExtension); }
      public:
        /// Constructor with default initializations
        tt__IrCutFilterAutoAdjustmentExtension() : __any() { }
        virtual ~tt__IrCutFilterAutoAdjustmentExtension() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterAutoAdjustmentExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterAutoAdjustmentExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:547 */
#ifndef SOAP_TYPE_tt__WideDynamicRange20
#define SOAP_TYPE_tt__WideDynamicRange20 (181)
/* complex XML schema type 'tt:WideDynamicRange20': */
class SOAP_CMAC tt__WideDynamicRange20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:WideDynamicMode'
        enum tt__WideDynamicMode Mode;
        /// Optional element 'tt:Level' of XML schema type 'xsd:float'
        float *Level;
      public:
        /// Return unique type id SOAP_TYPE_tt__WideDynamicRange20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WideDynamicRange20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WideDynamicRange20, default initialized and not managed by a soap context
        virtual tt__WideDynamicRange20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WideDynamicRange20); }
      public:
        /// Constructor with default initializations
        tt__WideDynamicRange20() : Mode(), Level() { }
        virtual ~tt__WideDynamicRange20() { }
        /// Friend allocator used by soap_new_tt__WideDynamicRange20(struct soap*, int)
        friend SOAP_FMAC1 tt__WideDynamicRange20 * SOAP_FMAC2 imageing_instantiate_tt__WideDynamicRange20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:549 */
#ifndef SOAP_TYPE_tt__BacklightCompensation20
#define SOAP_TYPE_tt__BacklightCompensation20 (182)
/* complex XML schema type 'tt:BacklightCompensation20': */
class SOAP_CMAC tt__BacklightCompensation20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:BacklightCompensationMode'
        enum tt__BacklightCompensationMode Mode;
        /// Optional element 'tt:Level' of XML schema type 'xsd:float'
        float *Level;
      public:
        /// Return unique type id SOAP_TYPE_tt__BacklightCompensation20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BacklightCompensation20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BacklightCompensation20, default initialized and not managed by a soap context
        virtual tt__BacklightCompensation20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BacklightCompensation20); }
      public:
        /// Constructor with default initializations
        tt__BacklightCompensation20() : Mode(), Level() { }
        virtual ~tt__BacklightCompensation20() { }
        /// Friend allocator used by soap_new_tt__BacklightCompensation20(struct soap*, int)
        friend SOAP_FMAC1 tt__BacklightCompensation20 * SOAP_FMAC2 imageing_instantiate_tt__BacklightCompensation20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:551 */
#ifndef SOAP_TYPE_tt__Exposure20
#define SOAP_TYPE_tt__Exposure20 (183)
/* complex XML schema type 'tt:Exposure20': */
class SOAP_CMAC tt__Exposure20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:ExposureMode'
        enum tt__ExposureMode Mode;
        /// Optional element 'tt:Priority' of XML schema type 'tt:ExposurePriority'
        enum tt__ExposurePriority *Priority;
        /// Optional element 'tt:Window' of XML schema type 'tt:Rectangle'
        tt__Rectangle *Window;
        /// Optional element 'tt:MinExposureTime' of XML schema type 'xsd:float'
        float *MinExposureTime;
        /// Optional element 'tt:MaxExposureTime' of XML schema type 'xsd:float'
        float *MaxExposureTime;
        /// Optional element 'tt:MinGain' of XML schema type 'xsd:float'
        float *MinGain;
        /// Optional element 'tt:MaxGain' of XML schema type 'xsd:float'
        float *MaxGain;
        /// Optional element 'tt:MinIris' of XML schema type 'xsd:float'
        float *MinIris;
        /// Optional element 'tt:MaxIris' of XML schema type 'xsd:float'
        float *MaxIris;
        /// Optional element 'tt:ExposureTime' of XML schema type 'xsd:float'
        float *ExposureTime;
        /// Optional element 'tt:Gain' of XML schema type 'xsd:float'
        float *Gain;
        /// Optional element 'tt:Iris' of XML schema type 'xsd:float'
        float *Iris;
      public:
        /// Return unique type id SOAP_TYPE_tt__Exposure20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Exposure20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Exposure20, default initialized and not managed by a soap context
        virtual tt__Exposure20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Exposure20); }
      public:
        /// Constructor with default initializations
        tt__Exposure20() : Mode(), Priority(), Window(), MinExposureTime(), MaxExposureTime(), MinGain(), MaxGain(), MinIris(), MaxIris(), ExposureTime(), Gain(), Iris() { }
        virtual ~tt__Exposure20() { }
        /// Friend allocator used by soap_new_tt__Exposure20(struct soap*, int)
        friend SOAP_FMAC1 tt__Exposure20 * SOAP_FMAC2 imageing_instantiate_tt__Exposure20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:553 */
#ifndef SOAP_TYPE_tt__ToneCompensation
#define SOAP_TYPE_tt__ToneCompensation (184)
/* complex XML schema type 'tt:ToneCompensation': */
class SOAP_CMAC tt__ToneCompensation : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'xsd:string'
        std::string Mode;
        /// Optional element 'tt:Level' of XML schema type 'xsd:float'
        float *Level;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ToneCompensationExtension'
        tt__ToneCompensationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ToneCompensation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ToneCompensation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ToneCompensation, default initialized and not managed by a soap context
        virtual tt__ToneCompensation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ToneCompensation); }
      public:
        /// Constructor with default initializations
        tt__ToneCompensation() : Mode(), Level(), Extension(), __anyAttribute() { }
        virtual ~tt__ToneCompensation() { }
        /// Friend allocator used by soap_new_tt__ToneCompensation(struct soap*, int)
        friend SOAP_FMAC1 tt__ToneCompensation * SOAP_FMAC2 imageing_instantiate_tt__ToneCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:555 */
#ifndef SOAP_TYPE_tt__ToneCompensationExtension
#define SOAP_TYPE_tt__ToneCompensationExtension (185)
/* complex XML schema type 'tt:ToneCompensationExtension': */
class SOAP_CMAC tt__ToneCompensationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ToneCompensationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ToneCompensationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ToneCompensationExtension, default initialized and not managed by a soap context
        virtual tt__ToneCompensationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ToneCompensationExtension); }
      public:
        /// Constructor with default initializations
        tt__ToneCompensationExtension() : __any() { }
        virtual ~tt__ToneCompensationExtension() { }
        /// Friend allocator used by soap_new_tt__ToneCompensationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ToneCompensationExtension * SOAP_FMAC2 imageing_instantiate_tt__ToneCompensationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:557 */
#ifndef SOAP_TYPE_tt__Defogging
#define SOAP_TYPE_tt__Defogging (186)
/* complex XML schema type 'tt:Defogging': */
class SOAP_CMAC tt__Defogging : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'xsd:string'
        std::string Mode;
        /// Optional element 'tt:Level' of XML schema type 'xsd:float'
        float *Level;
        /// Optional element 'tt:Extension' of XML schema type 'tt:DefoggingExtension'
        tt__DefoggingExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Defogging
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Defogging; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Defogging, default initialized and not managed by a soap context
        virtual tt__Defogging *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Defogging); }
      public:
        /// Constructor with default initializations
        tt__Defogging() : Mode(), Level(), Extension(), __anyAttribute() { }
        virtual ~tt__Defogging() { }
        /// Friend allocator used by soap_new_tt__Defogging(struct soap*, int)
        friend SOAP_FMAC1 tt__Defogging * SOAP_FMAC2 imageing_instantiate_tt__Defogging(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:559 */
#ifndef SOAP_TYPE_tt__DefoggingExtension
#define SOAP_TYPE_tt__DefoggingExtension (187)
/* complex XML schema type 'tt:DefoggingExtension': */
class SOAP_CMAC tt__DefoggingExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__DefoggingExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DefoggingExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DefoggingExtension, default initialized and not managed by a soap context
        virtual tt__DefoggingExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DefoggingExtension); }
      public:
        /// Constructor with default initializations
        tt__DefoggingExtension() : __any() { }
        virtual ~tt__DefoggingExtension() { }
        /// Friend allocator used by soap_new_tt__DefoggingExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__DefoggingExtension * SOAP_FMAC2 imageing_instantiate_tt__DefoggingExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:561 */
#ifndef SOAP_TYPE_tt__NoiseReduction
#define SOAP_TYPE_tt__NoiseReduction (188)
/* complex XML schema type 'tt:NoiseReduction': */
class SOAP_CMAC tt__NoiseReduction : public xsd__anyType {
      public:
        /// Required element 'tt:Level' of XML schema type 'xsd:float'
        float Level;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__NoiseReduction
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NoiseReduction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NoiseReduction, default initialized and not managed by a soap context
        virtual tt__NoiseReduction *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NoiseReduction); }
      public:
        /// Constructor with default initializations
        tt__NoiseReduction() : Level(), __any(), __anyAttribute() { }
        virtual ~tt__NoiseReduction() { }
        /// Friend allocator used by soap_new_tt__NoiseReduction(struct soap*, int)
        friend SOAP_FMAC1 tt__NoiseReduction * SOAP_FMAC2 imageing_instantiate_tt__NoiseReduction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:563 */
#ifndef SOAP_TYPE_tt__ImagingOptions20
#define SOAP_TYPE_tt__ImagingOptions20 (189)
/* complex XML schema type 'tt:ImagingOptions20': */
class SOAP_CMAC tt__ImagingOptions20 : public xsd__anyType {
      public:
        /// Optional element 'tt:BacklightCompensation' of XML schema type 'tt:BacklightCompensationOptions20'
        tt__BacklightCompensationOptions20 *BacklightCompensation;
        /// Optional element 'tt:Brightness' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Brightness;
        /// Optional element 'tt:ColorSaturation' of XML schema type 'tt:FloatRange'
        tt__FloatRange *ColorSaturation;
        /// Optional element 'tt:Contrast' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Contrast;
        /// Optional element 'tt:Exposure' of XML schema type 'tt:ExposureOptions20'
        tt__ExposureOptions20 *Exposure;
        /// Optional element 'tt:Focus' of XML schema type 'tt:FocusOptions20'
        tt__FocusOptions20 *Focus;
        /// Optional element 'tt:IrCutFilterModes' of XML schema type 'tt:IrCutFilterMode'
        std::vector<enum tt__IrCutFilterMode> IrCutFilterModes;
        /// Optional element 'tt:Sharpness' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Sharpness;
        /// Optional element 'tt:WideDynamicRange' of XML schema type 'tt:WideDynamicRangeOptions20'
        tt__WideDynamicRangeOptions20 *WideDynamicRange;
        /// Optional element 'tt:WhiteBalance' of XML schema type 'tt:WhiteBalanceOptions20'
        tt__WhiteBalanceOptions20 *WhiteBalance;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingOptions20Extension'
        tt__ImagingOptions20Extension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20); }
      public:
        /// Constructor with default initializations
        tt__ImagingOptions20() : BacklightCompensation(), Brightness(), ColorSaturation(), Contrast(), Exposure(), Focus(), IrCutFilterModes(), Sharpness(), WideDynamicRange(), WhiteBalance(), Extension(), __anyAttribute() { }
        virtual ~tt__ImagingOptions20() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20 * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:565 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension
#define SOAP_TYPE_tt__ImagingOptions20Extension (190)
/* complex XML schema type 'tt:ImagingOptions20Extension': */
class SOAP_CMAC tt__ImagingOptions20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:ImageStabilization' of XML schema type 'tt:ImageStabilizationOptions'
        tt__ImageStabilizationOptions *ImageStabilization;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingOptions20Extension2'
        tt__ImagingOptions20Extension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20Extension, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20Extension); }
      public:
        /// Constructor with default initializations
        tt__ImagingOptions20Extension() : __any(), ImageStabilization(), Extension() { }
        virtual ~tt__ImagingOptions20Extension() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20Extension * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:567 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension2
#define SOAP_TYPE_tt__ImagingOptions20Extension2 (191)
/* complex XML schema type 'tt:ImagingOptions20Extension2': */
class SOAP_CMAC tt__ImagingOptions20Extension2 : public xsd__anyType {
      public:
        /// Optional element 'tt:IrCutFilterAutoAdjustment' of XML schema type 'tt:IrCutFilterAutoAdjustmentOptions'
        tt__IrCutFilterAutoAdjustmentOptions *IrCutFilterAutoAdjustment;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingOptions20Extension3'
        tt__ImagingOptions20Extension3 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20Extension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20Extension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20Extension2, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20Extension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20Extension2); }
      public:
        /// Constructor with default initializations
        tt__ImagingOptions20Extension2() : IrCutFilterAutoAdjustment(), Extension() { }
        virtual ~tt__ImagingOptions20Extension2() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20Extension2(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20Extension2 * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20Extension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:569 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension3
#define SOAP_TYPE_tt__ImagingOptions20Extension3 (192)
/* complex XML schema type 'tt:ImagingOptions20Extension3': */
class SOAP_CMAC tt__ImagingOptions20Extension3 : public xsd__anyType {
      public:
        /// Optional element 'tt:ToneCompensationOptions' of XML schema type 'tt:ToneCompensationOptions'
        tt__ToneCompensationOptions *ToneCompensationOptions;
        /// Optional element 'tt:DefoggingOptions' of XML schema type 'tt:DefoggingOptions'
        tt__DefoggingOptions *DefoggingOptions;
        /// Optional element 'tt:NoiseReductionOptions' of XML schema type 'tt:NoiseReductionOptions'
        tt__NoiseReductionOptions *NoiseReductionOptions;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingOptions20Extension4'
        tt__ImagingOptions20Extension4 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20Extension3
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20Extension3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20Extension3, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20Extension3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20Extension3); }
      public:
        /// Constructor with default initializations
        tt__ImagingOptions20Extension3() : ToneCompensationOptions(), DefoggingOptions(), NoiseReductionOptions(), Extension() { }
        virtual ~tt__ImagingOptions20Extension3() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20Extension3(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20Extension3 * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20Extension3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:571 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension4
#define SOAP_TYPE_tt__ImagingOptions20Extension4 (193)
/* complex XML schema type 'tt:ImagingOptions20Extension4': */
class SOAP_CMAC tt__ImagingOptions20Extension4 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20Extension4
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20Extension4; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20Extension4, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20Extension4 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20Extension4); }
      public:
        /// Constructor with default initializations
        tt__ImagingOptions20Extension4() : __any() { }
        virtual ~tt__ImagingOptions20Extension4() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20Extension4(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20Extension4 * SOAP_FMAC2 imageing_instantiate_tt__ImagingOptions20Extension4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:573 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptions
#define SOAP_TYPE_tt__ImageStabilizationOptions (194)
/* complex XML schema type 'tt:ImageStabilizationOptions': */
class SOAP_CMAC tt__ImageStabilizationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:ImageStabilizationMode'
        std::vector<enum tt__ImageStabilizationMode> Mode;
        /// Optional element 'tt:Level' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Level;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImageStabilizationOptionsExtension'
        tt__ImageStabilizationOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilizationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilizationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilizationOptions, default initialized and not managed by a soap context
        virtual tt__ImageStabilizationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilizationOptions); }
      public:
        /// Constructor with default initializations
        tt__ImageStabilizationOptions() : Mode(), Level(), Extension(), __anyAttribute() { }
        virtual ~tt__ImageStabilizationOptions() { }
        /// Friend allocator used by soap_new_tt__ImageStabilizationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilizationOptions * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilizationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:575 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptionsExtension
#define SOAP_TYPE_tt__ImageStabilizationOptionsExtension (195)
/* complex XML schema type 'tt:ImageStabilizationOptionsExtension': */
class SOAP_CMAC tt__ImageStabilizationOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilizationOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilizationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilizationOptionsExtension, default initialized and not managed by a soap context
        virtual tt__ImageStabilizationOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilizationOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__ImageStabilizationOptionsExtension() : __any() { }
        virtual ~tt__ImageStabilizationOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__ImageStabilizationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilizationOptionsExtension * SOAP_FMAC2 imageing_instantiate_tt__ImageStabilizationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:577 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions (196)
/* complex XML schema type 'tt:IrCutFilterAutoAdjustmentOptions': */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptions : public xsd__anyType {
      public:
        /// Required element 'tt:BoundaryType' of XML schema type 'xsd:string'
        std::vector<std::string> BoundaryType;
        /// Optional element 'tt:BoundaryOffset' of XML schema type 'xsd:boolean'
        bool *BoundaryOffset;
        /// Optional element 'tt:ResponseTimeRange' of XML schema type 'tt:DurationRange'
        tt__DurationRange *ResponseTimeRange;
        /// Optional element 'tt:Extension' of XML schema type 'tt:IrCutFilterAutoAdjustmentOptionsExtension'
        tt__IrCutFilterAutoAdjustmentOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterAutoAdjustmentOptions, default initialized and not managed by a soap context
        virtual tt__IrCutFilterAutoAdjustmentOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterAutoAdjustmentOptions); }
      public:
        /// Constructor with default initializations
        tt__IrCutFilterAutoAdjustmentOptions() : BoundaryType(), BoundaryOffset(), ResponseTimeRange(), Extension(), __anyAttribute() { }
        virtual ~tt__IrCutFilterAutoAdjustmentOptions() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterAutoAdjustmentOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:579 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension (197)
/* complex XML schema type 'tt:IrCutFilterAutoAdjustmentOptionsExtension': */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterAutoAdjustmentOptionsExtension, default initialized and not managed by a soap context
        virtual tt__IrCutFilterAutoAdjustmentOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterAutoAdjustmentOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__IrCutFilterAutoAdjustmentOptionsExtension() : __any() { }
        virtual ~tt__IrCutFilterAutoAdjustmentOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC2 imageing_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:581 */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20
#define SOAP_TYPE_tt__WideDynamicRangeOptions20 (198)
/* complex XML schema type 'tt:WideDynamicRangeOptions20': */
class SOAP_CMAC tt__WideDynamicRangeOptions20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:WideDynamicMode'
        std::vector<enum tt__WideDynamicMode> Mode;
        /// Optional element 'tt:Level' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Level;
      public:
        /// Return unique type id SOAP_TYPE_tt__WideDynamicRangeOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WideDynamicRangeOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WideDynamicRangeOptions20, default initialized and not managed by a soap context
        virtual tt__WideDynamicRangeOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WideDynamicRangeOptions20); }
      public:
        /// Constructor with default initializations
        tt__WideDynamicRangeOptions20() : Mode(), Level() { }
        virtual ~tt__WideDynamicRangeOptions20() { }
        /// Friend allocator used by soap_new_tt__WideDynamicRangeOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__WideDynamicRangeOptions20 * SOAP_FMAC2 imageing_instantiate_tt__WideDynamicRangeOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:583 */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20
#define SOAP_TYPE_tt__BacklightCompensationOptions20 (199)
/* complex XML schema type 'tt:BacklightCompensationOptions20': */
class SOAP_CMAC tt__BacklightCompensationOptions20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:BacklightCompensationMode'
        std::vector<enum tt__BacklightCompensationMode> Mode;
        /// Optional element 'tt:Level' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Level;
      public:
        /// Return unique type id SOAP_TYPE_tt__BacklightCompensationOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BacklightCompensationOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BacklightCompensationOptions20, default initialized and not managed by a soap context
        virtual tt__BacklightCompensationOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BacklightCompensationOptions20); }
      public:
        /// Constructor with default initializations
        tt__BacklightCompensationOptions20() : Mode(), Level() { }
        virtual ~tt__BacklightCompensationOptions20() { }
        /// Friend allocator used by soap_new_tt__BacklightCompensationOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__BacklightCompensationOptions20 * SOAP_FMAC2 imageing_instantiate_tt__BacklightCompensationOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:585 */
#ifndef SOAP_TYPE_tt__ExposureOptions20
#define SOAP_TYPE_tt__ExposureOptions20 (200)
/* complex XML schema type 'tt:ExposureOptions20': */
class SOAP_CMAC tt__ExposureOptions20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:ExposureMode'
        std::vector<enum tt__ExposureMode> Mode;
        /// Optional element 'tt:Priority' of XML schema type 'tt:ExposurePriority'
        std::vector<enum tt__ExposurePriority> Priority;
        /// Optional element 'tt:MinExposureTime' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MinExposureTime;
        /// Optional element 'tt:MaxExposureTime' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MaxExposureTime;
        /// Optional element 'tt:MinGain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MinGain;
        /// Optional element 'tt:MaxGain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MaxGain;
        /// Optional element 'tt:MinIris' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MinIris;
        /// Optional element 'tt:MaxIris' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MaxIris;
        /// Optional element 'tt:ExposureTime' of XML schema type 'tt:FloatRange'
        tt__FloatRange *ExposureTime;
        /// Optional element 'tt:Gain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Gain;
        /// Optional element 'tt:Iris' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Iris;
      public:
        /// Return unique type id SOAP_TYPE_tt__ExposureOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ExposureOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ExposureOptions20, default initialized and not managed by a soap context
        virtual tt__ExposureOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ExposureOptions20); }
      public:
        /// Constructor with default initializations
        tt__ExposureOptions20() : Mode(), Priority(), MinExposureTime(), MaxExposureTime(), MinGain(), MaxGain(), MinIris(), MaxIris(), ExposureTime(), Gain(), Iris() { }
        virtual ~tt__ExposureOptions20() { }
        /// Friend allocator used by soap_new_tt__ExposureOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__ExposureOptions20 * SOAP_FMAC2 imageing_instantiate_tt__ExposureOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:587 */
#ifndef SOAP_TYPE_tt__MoveOptions20
#define SOAP_TYPE_tt__MoveOptions20 (201)
/* complex XML schema type 'tt:MoveOptions20': */
class SOAP_CMAC tt__MoveOptions20 : public xsd__anyType {
      public:
        /// Optional element 'tt:Absolute' of XML schema type 'tt:AbsoluteFocusOptions'
        tt__AbsoluteFocusOptions *Absolute;
        /// Optional element 'tt:Relative' of XML schema type 'tt:RelativeFocusOptions20'
        tt__RelativeFocusOptions20 *Relative;
        /// Optional element 'tt:Continuous' of XML schema type 'tt:ContinuousFocusOptions'
        tt__ContinuousFocusOptions *Continuous;
      public:
        /// Return unique type id SOAP_TYPE_tt__MoveOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MoveOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MoveOptions20, default initialized and not managed by a soap context
        virtual tt__MoveOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MoveOptions20); }
      public:
        /// Constructor with default initializations
        tt__MoveOptions20() : Absolute(), Relative(), Continuous() { }
        virtual ~tt__MoveOptions20() { }
        /// Friend allocator used by soap_new_tt__MoveOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__MoveOptions20 * SOAP_FMAC2 imageing_instantiate_tt__MoveOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:589 */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions20
#define SOAP_TYPE_tt__RelativeFocusOptions20 (202)
/* complex XML schema type 'tt:RelativeFocusOptions20': */
class SOAP_CMAC tt__RelativeFocusOptions20 : public xsd__anyType {
      public:
        /// Required element 'tt:Distance' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Distance;
        /// Optional element 'tt:Speed' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Speed;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelativeFocusOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelativeFocusOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelativeFocusOptions20, default initialized and not managed by a soap context
        virtual tt__RelativeFocusOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelativeFocusOptions20); }
      public:
        /// Constructor with default initializations
        tt__RelativeFocusOptions20() : Distance(), Speed() { }
        virtual ~tt__RelativeFocusOptions20() { }
        /// Friend allocator used by soap_new_tt__RelativeFocusOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__RelativeFocusOptions20 * SOAP_FMAC2 imageing_instantiate_tt__RelativeFocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:591 */
#ifndef SOAP_TYPE_tt__WhiteBalance20
#define SOAP_TYPE_tt__WhiteBalance20 (203)
/* complex XML schema type 'tt:WhiteBalance20': */
class SOAP_CMAC tt__WhiteBalance20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:WhiteBalanceMode'
        enum tt__WhiteBalanceMode Mode;
        /// Optional element 'tt:CrGain' of XML schema type 'xsd:float'
        float *CrGain;
        /// Optional element 'tt:CbGain' of XML schema type 'xsd:float'
        float *CbGain;
        /// Optional element 'tt:Extension' of XML schema type 'tt:WhiteBalance20Extension'
        tt__WhiteBalance20Extension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalance20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalance20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalance20, default initialized and not managed by a soap context
        virtual tt__WhiteBalance20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalance20); }
      public:
        /// Constructor with default initializations
        tt__WhiteBalance20() : Mode(), CrGain(), CbGain(), Extension(), __anyAttribute() { }
        virtual ~tt__WhiteBalance20() { }
        /// Friend allocator used by soap_new_tt__WhiteBalance20(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalance20 * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalance20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:593 */
#ifndef SOAP_TYPE_tt__WhiteBalance20Extension
#define SOAP_TYPE_tt__WhiteBalance20Extension (204)
/* complex XML schema type 'tt:WhiteBalance20Extension': */
class SOAP_CMAC tt__WhiteBalance20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalance20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalance20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalance20Extension, default initialized and not managed by a soap context
        virtual tt__WhiteBalance20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalance20Extension); }
      public:
        /// Constructor with default initializations
        tt__WhiteBalance20Extension() : __any() { }
        virtual ~tt__WhiteBalance20Extension() { }
        /// Friend allocator used by soap_new_tt__WhiteBalance20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalance20Extension * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalance20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:595 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20
#define SOAP_TYPE_tt__FocusConfiguration20 (205)
/* complex XML schema type 'tt:FocusConfiguration20': */
class SOAP_CMAC tt__FocusConfiguration20 : public xsd__anyType {
      public:
        /// Required element 'tt:AutoFocusMode' of XML schema type 'tt:AutoFocusMode'
        enum tt__AutoFocusMode AutoFocusMode;
        /// Optional element 'tt:DefaultSpeed' of XML schema type 'xsd:float'
        float *DefaultSpeed;
        /// Optional element 'tt:NearLimit' of XML schema type 'xsd:float'
        float *NearLimit;
        /// Optional element 'tt:FarLimit' of XML schema type 'xsd:float'
        float *FarLimit;
        /// Optional element 'tt:Extension' of XML schema type 'tt:FocusConfiguration20Extension'
        tt__FocusConfiguration20Extension *Extension;
        /// Optional attribute 'AFMode' of XML schema type 'tt:StringAttrList'
        std::string *AFMode;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusConfiguration20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusConfiguration20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusConfiguration20, default initialized and not managed by a soap context
        virtual tt__FocusConfiguration20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusConfiguration20); }
      public:
        /// Constructor with default initializations
        tt__FocusConfiguration20() : AutoFocusMode(), DefaultSpeed(), NearLimit(), FarLimit(), Extension(), AFMode(), __anyAttribute() { }
        virtual ~tt__FocusConfiguration20() { }
        /// Friend allocator used by soap_new_tt__FocusConfiguration20(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusConfiguration20 * SOAP_FMAC2 imageing_instantiate_tt__FocusConfiguration20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:597 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension
#define SOAP_TYPE_tt__FocusConfiguration20Extension (206)
/* complex XML schema type 'tt:FocusConfiguration20Extension': */
class SOAP_CMAC tt__FocusConfiguration20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusConfiguration20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusConfiguration20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusConfiguration20Extension, default initialized and not managed by a soap context
        virtual tt__FocusConfiguration20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusConfiguration20Extension); }
      public:
        /// Constructor with default initializations
        tt__FocusConfiguration20Extension() : __any() { }
        virtual ~tt__FocusConfiguration20Extension() { }
        /// Friend allocator used by soap_new_tt__FocusConfiguration20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusConfiguration20Extension * SOAP_FMAC2 imageing_instantiate_tt__FocusConfiguration20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:599 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20
#define SOAP_TYPE_tt__WhiteBalanceOptions20 (207)
/* complex XML schema type 'tt:WhiteBalanceOptions20': */
class SOAP_CMAC tt__WhiteBalanceOptions20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:WhiteBalanceMode'
        std::vector<enum tt__WhiteBalanceMode> Mode;
        /// Optional element 'tt:YrGain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *YrGain;
        /// Optional element 'tt:YbGain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *YbGain;
        /// Optional element 'tt:Extension' of XML schema type 'tt:WhiteBalanceOptions20Extension'
        tt__WhiteBalanceOptions20Extension *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalanceOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalanceOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalanceOptions20, default initialized and not managed by a soap context
        virtual tt__WhiteBalanceOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalanceOptions20); }
      public:
        /// Constructor with default initializations
        tt__WhiteBalanceOptions20() : Mode(), YrGain(), YbGain(), Extension() { }
        virtual ~tt__WhiteBalanceOptions20() { }
        /// Friend allocator used by soap_new_tt__WhiteBalanceOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalanceOptions20 * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalanceOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:601 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension (208)
/* complex XML schema type 'tt:WhiteBalanceOptions20Extension': */
class SOAP_CMAC tt__WhiteBalanceOptions20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalanceOptions20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalanceOptions20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalanceOptions20Extension, default initialized and not managed by a soap context
        virtual tt__WhiteBalanceOptions20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalanceOptions20Extension); }
      public:
        /// Constructor with default initializations
        tt__WhiteBalanceOptions20Extension() : __any() { }
        virtual ~tt__WhiteBalanceOptions20Extension() { }
        /// Friend allocator used by soap_new_tt__WhiteBalanceOptions20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalanceOptions20Extension * SOAP_FMAC2 imageing_instantiate_tt__WhiteBalanceOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:603 */
#ifndef SOAP_TYPE_tt__FocusOptions20
#define SOAP_TYPE_tt__FocusOptions20 (209)
/* complex XML schema type 'tt:FocusOptions20': */
class SOAP_CMAC tt__FocusOptions20 : public xsd__anyType {
      public:
        /// Optional element 'tt:AutoFocusModes' of XML schema type 'tt:AutoFocusMode'
        std::vector<enum tt__AutoFocusMode> AutoFocusModes;
        /// Optional element 'tt:DefaultSpeed' of XML schema type 'tt:FloatRange'
        tt__FloatRange *DefaultSpeed;
        /// Optional element 'tt:NearLimit' of XML schema type 'tt:FloatRange'
        tt__FloatRange *NearLimit;
        /// Optional element 'tt:FarLimit' of XML schema type 'tt:FloatRange'
        tt__FloatRange *FarLimit;
        /// Optional element 'tt:Extension' of XML schema type 'tt:FocusOptions20Extension'
        tt__FocusOptions20Extension *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusOptions20, default initialized and not managed by a soap context
        virtual tt__FocusOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusOptions20); }
      public:
        /// Constructor with default initializations
        tt__FocusOptions20() : AutoFocusModes(), DefaultSpeed(), NearLimit(), FarLimit(), Extension() { }
        virtual ~tt__FocusOptions20() { }
        /// Friend allocator used by soap_new_tt__FocusOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusOptions20 * SOAP_FMAC2 imageing_instantiate_tt__FocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:605 */
#ifndef SOAP_TYPE_tt__FocusOptions20Extension
#define SOAP_TYPE_tt__FocusOptions20Extension (210)
/* complex XML schema type 'tt:FocusOptions20Extension': */
class SOAP_CMAC tt__FocusOptions20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:AFModes' of XML schema type 'tt:StringAttrList'
        std::string *AFModes;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusOptions20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusOptions20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusOptions20Extension, default initialized and not managed by a soap context
        virtual tt__FocusOptions20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusOptions20Extension); }
      public:
        /// Constructor with default initializations
        tt__FocusOptions20Extension() : __any(), AFModes() { }
        virtual ~tt__FocusOptions20Extension() { }
        /// Friend allocator used by soap_new_tt__FocusOptions20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusOptions20Extension * SOAP_FMAC2 imageing_instantiate_tt__FocusOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:607 */
#ifndef SOAP_TYPE_tt__ToneCompensationOptions
#define SOAP_TYPE_tt__ToneCompensationOptions (211)
/* complex XML schema type 'tt:ToneCompensationOptions': */
class SOAP_CMAC tt__ToneCompensationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'xsd:string'
        std::vector<std::string> Mode;
        /// Required element 'tt:Level' of XML schema type 'xsd:boolean'
        bool Level;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ToneCompensationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ToneCompensationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ToneCompensationOptions, default initialized and not managed by a soap context
        virtual tt__ToneCompensationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ToneCompensationOptions); }
      public:
        /// Constructor with default initializations
        tt__ToneCompensationOptions() : Mode(), Level(), __any(), __anyAttribute() { }
        virtual ~tt__ToneCompensationOptions() { }
        /// Friend allocator used by soap_new_tt__ToneCompensationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ToneCompensationOptions * SOAP_FMAC2 imageing_instantiate_tt__ToneCompensationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:609 */
#ifndef SOAP_TYPE_tt__DefoggingOptions
#define SOAP_TYPE_tt__DefoggingOptions (212)
/* complex XML schema type 'tt:DefoggingOptions': */
class SOAP_CMAC tt__DefoggingOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'xsd:string'
        std::vector<std::string> Mode;
        /// Required element 'tt:Level' of XML schema type 'xsd:boolean'
        bool Level;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__DefoggingOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DefoggingOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DefoggingOptions, default initialized and not managed by a soap context
        virtual tt__DefoggingOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DefoggingOptions); }
      public:
        /// Constructor with default initializations
        tt__DefoggingOptions() : Mode(), Level(), __any(), __anyAttribute() { }
        virtual ~tt__DefoggingOptions() { }
        /// Friend allocator used by soap_new_tt__DefoggingOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__DefoggingOptions * SOAP_FMAC2 imageing_instantiate_tt__DefoggingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:611 */
#ifndef SOAP_TYPE_tt__NoiseReductionOptions
#define SOAP_TYPE_tt__NoiseReductionOptions (213)
/* complex XML schema type 'tt:NoiseReductionOptions': */
class SOAP_CMAC tt__NoiseReductionOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Level' of XML schema type 'xsd:boolean'
        bool Level;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__NoiseReductionOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NoiseReductionOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NoiseReductionOptions, default initialized and not managed by a soap context
        virtual tt__NoiseReductionOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NoiseReductionOptions); }
      public:
        /// Constructor with default initializations
        tt__NoiseReductionOptions() : Level(), __any(), __anyAttribute() { }
        virtual ~tt__NoiseReductionOptions() { }
        /// Friend allocator used by soap_new_tt__NoiseReductionOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__NoiseReductionOptions * SOAP_FMAC2 imageing_instantiate_tt__NoiseReductionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:613 */
#ifndef SOAP_TYPE_tt__MessageExtension
#define SOAP_TYPE_tt__MessageExtension (214)
/* complex XML schema type 'tt:MessageExtension': */
class SOAP_CMAC tt__MessageExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__MessageExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MessageExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MessageExtension, default initialized and not managed by a soap context
        virtual tt__MessageExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MessageExtension); }
      public:
        /// Constructor with default initializations
        tt__MessageExtension() : __any() { }
        virtual ~tt__MessageExtension() { }
        /// Friend allocator used by soap_new_tt__MessageExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__MessageExtension * SOAP_FMAC2 imageing_instantiate_tt__MessageExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:5637 */
#ifndef SOAP_TYPE__tt__ItemList_SimpleItem
#define SOAP_TYPE__tt__ItemList_SimpleItem (440)
/* complex XML schema type 'tt:ItemList-SimpleItem': */
class SOAP_CMAC _tt__ItemList_SimpleItem {
      public:
        /// Required attribute 'Name' of XML schema type 'xsd:string'
        std::string Name;
        /// Required attribute 'Value' of XML schema type 'xsd:anySimpleType'
        std::string Value;
      public:
        /// Return unique type id SOAP_TYPE__tt__ItemList_SimpleItem
        virtual long soap_type(void) const { return SOAP_TYPE__tt__ItemList_SimpleItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__ItemList_SimpleItem, default initialized and not managed by a soap context
        virtual _tt__ItemList_SimpleItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__ItemList_SimpleItem); }
      public:
        /// Constructor with default initializations
        _tt__ItemList_SimpleItem() : Name(), Value() { }
        virtual ~_tt__ItemList_SimpleItem() { }
        /// Friend allocator used by soap_new__tt__ItemList_SimpleItem(struct soap*, int)
        friend SOAP_FMAC1 _tt__ItemList_SimpleItem * SOAP_FMAC2 imageing_instantiate__tt__ItemList_SimpleItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:5669 */
#ifndef SOAP_TYPE__tt__ItemList_ElementItem
#define SOAP_TYPE__tt__ItemList_ElementItem (442)
/* complex XML schema type 'tt:ItemList-ElementItem': */
class SOAP_CMAC _tt__ItemList_ElementItem {
      public:
        char *__any;
        /// Required attribute 'Name' of XML schema type 'xsd:string'
        std::string Name;
      public:
        /// Return unique type id SOAP_TYPE__tt__ItemList_ElementItem
        virtual long soap_type(void) const { return SOAP_TYPE__tt__ItemList_ElementItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__ItemList_ElementItem, default initialized and not managed by a soap context
        virtual _tt__ItemList_ElementItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__ItemList_ElementItem); }
      public:
        /// Constructor with default initializations
        _tt__ItemList_ElementItem() : __any(), Name() { }
        virtual ~_tt__ItemList_ElementItem() { }
        /// Friend allocator used by soap_new__tt__ItemList_ElementItem(struct soap*, int)
        friend SOAP_FMAC1 _tt__ItemList_ElementItem * SOAP_FMAC2 imageing_instantiate__tt__ItemList_ElementItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:615 */
#ifndef SOAP_TYPE_tt__ItemList
#define SOAP_TYPE_tt__ItemList (215)
/* complex XML schema type 'tt:ItemList': */
class SOAP_CMAC tt__ItemList : public xsd__anyType {
      public:
        /// Optional element 'tt:SimpleItem' of XML schema type 'tt:ItemList-SimpleItem'
        std::vector<_tt__ItemList_SimpleItem> SimpleItem;
        /// Optional element 'tt:ElementItem' of XML schema type 'tt:ItemList-ElementItem'
        std::vector<_tt__ItemList_ElementItem> ElementItem;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ItemListExtension'
        tt__ItemListExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ItemList
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ItemList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ItemList, default initialized and not managed by a soap context
        virtual tt__ItemList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ItemList); }
      public:
        /// Constructor with default initializations
        tt__ItemList() : SimpleItem(), ElementItem(), Extension(), __anyAttribute() { }
        virtual ~tt__ItemList() { }
        /// Friend allocator used by soap_new_tt__ItemList(struct soap*, int)
        friend SOAP_FMAC1 tt__ItemList * SOAP_FMAC2 imageing_instantiate_tt__ItemList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:617 */
#ifndef SOAP_TYPE_tt__ItemListExtension
#define SOAP_TYPE_tt__ItemListExtension (216)
/* complex XML schema type 'tt:ItemListExtension': */
class SOAP_CMAC tt__ItemListExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ItemListExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ItemListExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ItemListExtension, default initialized and not managed by a soap context
        virtual tt__ItemListExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ItemListExtension); }
      public:
        /// Constructor with default initializations
        tt__ItemListExtension() : __any() { }
        virtual ~tt__ItemListExtension() { }
        /// Friend allocator used by soap_new_tt__ItemListExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ItemListExtension * SOAP_FMAC2 imageing_instantiate_tt__ItemListExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:619 */
#ifndef SOAP_TYPE_tt__Polyline
#define SOAP_TYPE_tt__Polyline (217)
/* complex XML schema type 'tt:Polyline': */
class SOAP_CMAC tt__Polyline : public xsd__anyType {
      public:
        /// Required element 'tt:Point' of XML schema type 'tt:Vector'
        std::vector<tt__Vector *> Point;
      public:
        /// Return unique type id SOAP_TYPE_tt__Polyline
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Polyline; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Polyline, default initialized and not managed by a soap context
        virtual tt__Polyline *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Polyline); }
      public:
        /// Constructor with default initializations
        tt__Polyline() : Point() { }
        virtual ~tt__Polyline() { }
        /// Friend allocator used by soap_new_tt__Polyline(struct soap*, int)
        friend SOAP_FMAC1 tt__Polyline * SOAP_FMAC2 imageing_instantiate_tt__Polyline(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:621 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration (218)
/* complex XML schema type 'tt:AnalyticsEngineConfiguration': */
class SOAP_CMAC tt__AnalyticsEngineConfiguration : public xsd__anyType {
      public:
        /// Optional element 'tt:AnalyticsModule' of XML schema type 'tt:Config'
        std::vector<tt__Config *> AnalyticsModule;
        /// Optional element 'tt:Extension' of XML schema type 'tt:AnalyticsEngineConfigurationExtension'
        tt__AnalyticsEngineConfigurationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsEngineConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsEngineConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsEngineConfiguration, default initialized and not managed by a soap context
        virtual tt__AnalyticsEngineConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsEngineConfiguration); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsEngineConfiguration() : AnalyticsModule(), Extension(), __anyAttribute() { }
        virtual ~tt__AnalyticsEngineConfiguration() { }
        /// Friend allocator used by soap_new_tt__AnalyticsEngineConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsEngineConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AnalyticsEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:623 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (219)
/* complex XML schema type 'tt:AnalyticsEngineConfigurationExtension': */
class SOAP_CMAC tt__AnalyticsEngineConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsEngineConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__AnalyticsEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsEngineConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsEngineConfigurationExtension() : __any() { }
        virtual ~tt__AnalyticsEngineConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__AnalyticsEngineConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__AnalyticsEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:625 */
#ifndef SOAP_TYPE_tt__RuleEngineConfiguration
#define SOAP_TYPE_tt__RuleEngineConfiguration (220)
/* complex XML schema type 'tt:RuleEngineConfiguration': */
class SOAP_CMAC tt__RuleEngineConfiguration : public xsd__anyType {
      public:
        /// Optional element 'tt:Rule' of XML schema type 'tt:Config'
        std::vector<tt__Config *> Rule;
        /// Optional element 'tt:Extension' of XML schema type 'tt:RuleEngineConfigurationExtension'
        tt__RuleEngineConfigurationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RuleEngineConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RuleEngineConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RuleEngineConfiguration, default initialized and not managed by a soap context
        virtual tt__RuleEngineConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RuleEngineConfiguration); }
      public:
        /// Constructor with default initializations
        tt__RuleEngineConfiguration() : Rule(), Extension(), __anyAttribute() { }
        virtual ~tt__RuleEngineConfiguration() { }
        /// Friend allocator used by soap_new_tt__RuleEngineConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__RuleEngineConfiguration * SOAP_FMAC2 imageing_instantiate_tt__RuleEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:627 */
#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension (221)
/* complex XML schema type 'tt:RuleEngineConfigurationExtension': */
class SOAP_CMAC tt__RuleEngineConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__RuleEngineConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RuleEngineConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RuleEngineConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__RuleEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RuleEngineConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__RuleEngineConfigurationExtension() : __any() { }
        virtual ~tt__RuleEngineConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__RuleEngineConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__RuleEngineConfigurationExtension * SOAP_FMAC2 imageing_instantiate_tt__RuleEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:629 */
#ifndef SOAP_TYPE_tt__Config
#define SOAP_TYPE_tt__Config (222)
/* complex XML schema type 'tt:Config': */
class SOAP_CMAC tt__Config : public xsd__anyType {
      public:
        /// Required element 'tt:Parameters' of XML schema type 'tt:ItemList'
        tt__ItemList *Parameters;
        /// Required attribute 'Name' of XML schema type 'xsd:string'
        std::string Name;
        /// Required attribute 'Type' of XML schema type 'xsd:QName'
        std::string Type;
      public:
        /// Return unique type id SOAP_TYPE_tt__Config
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Config; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Config, default initialized and not managed by a soap context
        virtual tt__Config *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Config); }
      public:
        /// Constructor with default initializations
        tt__Config() : Parameters(), Name(), Type() { }
        virtual ~tt__Config() { }
        /// Friend allocator used by soap_new_tt__Config(struct soap*, int)
        friend SOAP_FMAC1 tt__Config * SOAP_FMAC2 imageing_instantiate_tt__Config(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:631 */
#ifndef SOAP_TYPE_tt__PolygonOptions
#define SOAP_TYPE_tt__PolygonOptions (223)
/* complex XML schema type 'tt:PolygonOptions': */
class SOAP_CMAC tt__PolygonOptions : public xsd__anyType {
      public:
        /// Optional element 'tt:RectangleOnly' of XML schema type 'xsd:boolean'
        bool *RectangleOnly;
        /// Optional element 'tt:VertexLimits' of XML schema type 'tt:IntRange'
        tt__IntRange *VertexLimits;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PolygonOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PolygonOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PolygonOptions, default initialized and not managed by a soap context
        virtual tt__PolygonOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PolygonOptions); }
      public:
        /// Constructor with default initializations
        tt__PolygonOptions() : RectangleOnly(), VertexLimits(), __any(), __anyAttribute() { }
        virtual ~tt__PolygonOptions() { }
        /// Friend allocator used by soap_new_tt__PolygonOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PolygonOptions * SOAP_FMAC2 imageing_instantiate_tt__PolygonOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:633 */
#ifndef SOAP_TYPE_tt__IntRange
#define SOAP_TYPE_tt__IntRange (224)
/* complex XML schema type 'tt:IntRange': */
class SOAP_CMAC tt__IntRange : public xsd__anyType {
      public:
        /// Required element 'tt:Min' of XML schema type 'xsd:int'
        int Min;
        /// Required element 'tt:Max' of XML schema type 'xsd:int'
        int Max;
      public:
        /// Return unique type id SOAP_TYPE_tt__IntRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IntRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IntRange, default initialized and not managed by a soap context
        virtual tt__IntRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IntRange); }
      public:
        /// Constructor with default initializations
        tt__IntRange() : Min(), Max() { }
        virtual ~tt__IntRange() { }
        /// Friend allocator used by soap_new_tt__IntRange(struct soap*, int)
        friend SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 imageing_instantiate_tt__IntRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:635 */
#ifndef SOAP_TYPE_tt__Vector2D
#define SOAP_TYPE_tt__Vector2D (225)
/* simple XML schema type 'tt:Vector2D': */
class SOAP_CMAC tt__Vector2D : public xsd__anyType {
      public:
        /// Required attribute 'x' of XML schema type 'xsd:float'
        float x;
        /// Required attribute 'y' of XML schema type 'xsd:float'
        float y;
        /// Optional attribute 'space' of XML schema type 'xsd:anyURI'
        std::string *space;
      public:
        /// Return unique type id SOAP_TYPE_tt__Vector2D
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Vector2D; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Vector2D, default initialized and not managed by a soap context
        virtual tt__Vector2D *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Vector2D); }
      public:
        /// Constructor with default initializations
        tt__Vector2D() : x(), y(), space() { }
        virtual ~tt__Vector2D() { }
        /// Friend allocator used by soap_new_tt__Vector2D(struct soap*, int)
        friend SOAP_FMAC1 tt__Vector2D * SOAP_FMAC2 imageing_instantiate_tt__Vector2D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:637 */
#ifndef SOAP_TYPE_tt__Vector1D
#define SOAP_TYPE_tt__Vector1D (226)
/* simple XML schema type 'tt:Vector1D': */
class SOAP_CMAC tt__Vector1D : public xsd__anyType {
      public:
        /// Required attribute 'x' of XML schema type 'xsd:float'
        float x;
        /// Optional attribute 'space' of XML schema type 'xsd:anyURI'
        std::string *space;
      public:
        /// Return unique type id SOAP_TYPE_tt__Vector1D
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Vector1D; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Vector1D, default initialized and not managed by a soap context
        virtual tt__Vector1D *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Vector1D); }
      public:
        /// Constructor with default initializations
        tt__Vector1D() : x(), space() { }
        virtual ~tt__Vector1D() { }
        /// Friend allocator used by soap_new_tt__Vector1D(struct soap*, int)
        friend SOAP_FMAC1 tt__Vector1D * SOAP_FMAC2 imageing_instantiate_tt__Vector1D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:639 */
#ifndef SOAP_TYPE_tt__Vector
#define SOAP_TYPE_tt__Vector (227)
/* simple XML schema type 'tt:Vector': */
class SOAP_CMAC tt__Vector : public xsd__anyType {
      public:
        /// Optional attribute 'x' of XML schema type 'xsd:float'
        float *x;
        /// Optional attribute 'y' of XML schema type 'xsd:float'
        float *y;
      public:
        /// Return unique type id SOAP_TYPE_tt__Vector
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Vector; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Vector, default initialized and not managed by a soap context
        virtual tt__Vector *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Vector); }
      public:
        /// Constructor with default initializations
        tt__Vector() : x(), y() { }
        virtual ~tt__Vector() { }
        /// Friend allocator used by soap_new_tt__Vector(struct soap*, int)
        friend SOAP_FMAC1 tt__Vector * SOAP_FMAC2 imageing_instantiate_tt__Vector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:641 */
#ifndef SOAP_TYPE_tt__Rectangle
#define SOAP_TYPE_tt__Rectangle (228)
/* simple XML schema type 'tt:Rectangle': */
class SOAP_CMAC tt__Rectangle : public xsd__anyType {
      public:
        /// Optional attribute 'bottom' of XML schema type 'xsd:float'
        float *bottom;
        /// Optional attribute 'top' of XML schema type 'xsd:float'
        float *top;
        /// Optional attribute 'right' of XML schema type 'xsd:float'
        float *right;
        /// Optional attribute 'left' of XML schema type 'xsd:float'
        float *left;
      public:
        /// Return unique type id SOAP_TYPE_tt__Rectangle
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Rectangle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Rectangle, default initialized and not managed by a soap context
        virtual tt__Rectangle *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Rectangle); }
      public:
        /// Constructor with default initializations
        tt__Rectangle() : bottom(), top(), right(), left() { }
        virtual ~tt__Rectangle() { }
        /// Friend allocator used by soap_new_tt__Rectangle(struct soap*, int)
        friend SOAP_FMAC1 tt__Rectangle * SOAP_FMAC2 imageing_instantiate_tt__Rectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:643 */
#ifndef SOAP_TYPE_tt__Polygon
#define SOAP_TYPE_tt__Polygon (229)
/* complex XML schema type 'tt:Polygon': */
class SOAP_CMAC tt__Polygon : public xsd__anyType {
      public:
        /// Required element 'tt:Point' of XML schema type 'tt:Vector'
        std::vector<tt__Vector *> Point;
      public:
        /// Return unique type id SOAP_TYPE_tt__Polygon
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Polygon; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Polygon, default initialized and not managed by a soap context
        virtual tt__Polygon *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Polygon); }
      public:
        /// Constructor with default initializations
        tt__Polygon() : Point() { }
        virtual ~tt__Polygon() { }
        /// Friend allocator used by soap_new_tt__Polygon(struct soap*, int)
        friend SOAP_FMAC1 tt__Polygon * SOAP_FMAC2 imageing_instantiate_tt__Polygon(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:645 */
#ifndef SOAP_TYPE__tt__StringItems
#define SOAP_TYPE__tt__StringItems (230)
/* complex XML schema type 'tt:StringItems': */
class SOAP_CMAC _tt__StringItems {
      public:
        /// Required element 'tt:Item' of XML schema type 'xsd:string'
        std::vector<std::string> Item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tt__StringItems
        virtual long soap_type(void) const { return SOAP_TYPE__tt__StringItems; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__StringItems, default initialized and not managed by a soap context
        virtual _tt__StringItems *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__StringItems); }
      public:
        /// Constructor with default initializations
        _tt__StringItems() : Item(), soap() { }
        virtual ~_tt__StringItems() { }
        /// Friend allocator used by soap_new__tt__StringItems(struct soap*, int)
        friend SOAP_FMAC1 _tt__StringItems * SOAP_FMAC2 imageing_instantiate__tt__StringItems(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:647 */
#ifndef SOAP_TYPE__tt__Message
#define SOAP_TYPE__tt__Message (231)
/* complex XML schema type 'tt:Message': */
class SOAP_CMAC _tt__Message {
      public:
        /// Optional element 'tt:Source' of XML schema type 'tt:ItemList'
        tt__ItemList *Source;
        /// Optional element 'tt:Key' of XML schema type 'tt:ItemList'
        tt__ItemList *Key;
        /// Optional element 'tt:Data' of XML schema type 'tt:ItemList'
        tt__ItemList *Data;
        /// Optional element 'tt:Extension' of XML schema type 'tt:MessageExtension'
        tt__MessageExtension *Extension;
        /// Required attribute 'UtcTime' of XML schema type 'xsd:dateTime'
        time_t UtcTime;
        /// Optional attribute 'PropertyOperation' of XML schema type 'tt:PropertyOperation'
        enum tt__PropertyOperation *PropertyOperation;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tt__Message
        virtual long soap_type(void) const { return SOAP_TYPE__tt__Message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__Message, default initialized and not managed by a soap context
        virtual _tt__Message *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__Message); }
      public:
        /// Constructor with default initializations
        _tt__Message() : Source(), Key(), Data(), Extension(), UtcTime(), PropertyOperation(), __anyAttribute(), soap() { }
        virtual ~_tt__Message() { }
        /// Friend allocator used by soap_new__tt__Message(struct soap*, int)
        friend SOAP_FMAC1 _tt__Message * SOAP_FMAC2 imageing_instantiate__tt__Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:649 */
#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (232)
/* complex XML schema type 'wsnt:QueryExpressionType': */
class SOAP_CMAC wsnt__QueryExpressionType : public xsd__anyType {
      public:
        char *__any;
        /// Required attribute 'Dialect' of XML schema type 'xsd:anyURI'
        std::string Dialect;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__QueryExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__QueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__QueryExpressionType, default initialized and not managed by a soap context
        virtual wsnt__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__QueryExpressionType); }
      public:
        /// Constructor with default initializations
        wsnt__QueryExpressionType() : __any(), Dialect(), __mixed() { }
        virtual ~wsnt__QueryExpressionType() { }
        /// Friend allocator used by soap_new_wsnt__QueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__QueryExpressionType * SOAP_FMAC2 imageing_instantiate_wsnt__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:651 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (233)
/* complex XML schema type 'wsnt:TopicExpressionType': */
class SOAP_CMAC wsnt__TopicExpressionType : public xsd__anyType {
      public:
        char *__any;
        /// Required attribute 'Dialect' of XML schema type 'xsd:anyURI'
        std::string Dialect;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__TopicExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__TopicExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__TopicExpressionType, default initialized and not managed by a soap context
        virtual wsnt__TopicExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__TopicExpressionType); }
      public:
        /// Constructor with default initializations
        wsnt__TopicExpressionType() : __any(), Dialect(), __anyAttribute(), __mixed() { }
        virtual ~wsnt__TopicExpressionType() { }
        /// Friend allocator used by soap_new_wsnt__TopicExpressionType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__TopicExpressionType * SOAP_FMAC2 imageing_instantiate_wsnt__TopicExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:653 */
#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (234)
/* complex XML schema type 'wsnt:FilterType': */
class SOAP_CMAC wsnt__FilterType : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__FilterType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__FilterType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__FilterType, default initialized and not managed by a soap context
        virtual wsnt__FilterType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__FilterType); }
      public:
        /// Constructor with default initializations
        wsnt__FilterType() : __any() { }
        virtual ~wsnt__FilterType() { }
        /// Friend allocator used by soap_new_wsnt__FilterType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__FilterType * SOAP_FMAC2 imageing_instantiate_wsnt__FilterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:655 */
#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (235)
/* complex XML schema type 'wsnt:SubscriptionPolicyType': */
class SOAP_CMAC wsnt__SubscriptionPolicyType : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__SubscriptionPolicyType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__SubscriptionPolicyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__SubscriptionPolicyType, default initialized and not managed by a soap context
        virtual wsnt__SubscriptionPolicyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__SubscriptionPolicyType); }
      public:
        /// Constructor with default initializations
        wsnt__SubscriptionPolicyType() : __any() { }
        virtual ~wsnt__SubscriptionPolicyType() { }
        /// Friend allocator used by soap_new_wsnt__SubscriptionPolicyType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__SubscriptionPolicyType * SOAP_FMAC2 imageing_instantiate_wsnt__SubscriptionPolicyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:6548 */
#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (457)
/* complex XML schema type 'wsnt:NotificationMessageHolderType-Message': */
class SOAP_CMAC _wsnt__NotificationMessageHolderType_Message {
      public:
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__NotificationMessageHolderType_Message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__NotificationMessageHolderType_Message, default initialized and not managed by a soap context
        virtual _wsnt__NotificationMessageHolderType_Message *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__NotificationMessageHolderType_Message); }
      public:
        /// Constructor with default initializations
        _wsnt__NotificationMessageHolderType_Message() : __any() { }
        virtual ~_wsnt__NotificationMessageHolderType_Message() { }
        /// Friend allocator used by soap_new__wsnt__NotificationMessageHolderType_Message(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC2 imageing_instantiate__wsnt__NotificationMessageHolderType_Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:657 */
#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (236)
/* complex XML schema type 'wsnt:NotificationMessageHolderType': */
class SOAP_CMAC wsnt__NotificationMessageHolderType : public xsd__anyType {
      public:
        /// Optional element 'wsnt:SubscriptionReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType *SubscriptionReference;
        /// Optional element 'wsnt:Topic' of XML schema type 'wsnt:TopicExpressionType'
        wsnt__TopicExpressionType *Topic;
        /// Optional element 'wsnt:ProducerReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType *ProducerReference;
        /// Required element 'wsnt:Message' of XML schema type 'wsnt:NotificationMessageHolderType-Message'
        _wsnt__NotificationMessageHolderType_Message Message;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__NotificationMessageHolderType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__NotificationMessageHolderType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__NotificationMessageHolderType, default initialized and not managed by a soap context
        virtual wsnt__NotificationMessageHolderType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__NotificationMessageHolderType); }
      public:
        /// Constructor with default initializations
        wsnt__NotificationMessageHolderType() : SubscriptionReference(), Topic(), ProducerReference(), Message() { }
        virtual ~wsnt__NotificationMessageHolderType() { }
        /// Friend allocator used by soap_new_wsnt__NotificationMessageHolderType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__NotificationMessageHolderType * SOAP_FMAC2 imageing_instantiate_wsnt__NotificationMessageHolderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:699 */
#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (257)
/* complex XML schema type 'wsnt:NotificationProducerRP': */
class SOAP_CMAC _wsnt__NotificationProducerRP {
      public:
        /// Optional element 'wsnt:TopicExpression' of XML schema type 'wsnt:TopicExpressionType'
        std::vector<wsnt__TopicExpressionType *> TopicExpression;
        /// Optional element 'wsnt:FixedTopicSet' of XML schema type 'xsd:boolean'
        bool *FixedTopicSet;	///< optional with default value = (bool)1
        /// Optional element 'wsnt:TopicExpressionDialect' of XML schema type 'xsd:anyURI'
        std::vector<std::string> TopicExpressionDialect;
        /// Optional element 'wstop:TopicSet' of XML schema type 'wstop:TopicSetType'
        wstop__TopicSetType *wstop__TopicSet;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__NotificationProducerRP
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__NotificationProducerRP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__NotificationProducerRP, default initialized and not managed by a soap context
        virtual _wsnt__NotificationProducerRP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__NotificationProducerRP); }
      public:
        /// Constructor with default initializations
        _wsnt__NotificationProducerRP() : TopicExpression(), FixedTopicSet(), TopicExpressionDialect(), wstop__TopicSet(), soap() { }
        virtual ~_wsnt__NotificationProducerRP() { }
        /// Friend allocator used by soap_new__wsnt__NotificationProducerRP(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__NotificationProducerRP * SOAP_FMAC2 imageing_instantiate__wsnt__NotificationProducerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:701 */
#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (258)
/* complex XML schema type 'wsnt:SubscriptionManagerRP': */
class SOAP_CMAC _wsnt__SubscriptionManagerRP {
      public:
        /// Required element 'wsnt:ConsumerReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType ConsumerReference;
        /// Optional element 'wsnt:Filter' of XML schema type 'wsnt:FilterType'
        wsnt__FilterType *Filter;
        /// Optional element 'wsnt:SubscriptionPolicy' of XML schema type 'wsnt:SubscriptionPolicyType'
        wsnt__SubscriptionPolicyType *SubscriptionPolicy;
        /// Optional element 'wsnt:CreationTime' of XML schema type 'xsd:dateTime'
        time_t *CreationTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__SubscriptionManagerRP
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__SubscriptionManagerRP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__SubscriptionManagerRP, default initialized and not managed by a soap context
        virtual _wsnt__SubscriptionManagerRP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__SubscriptionManagerRP); }
      public:
        /// Constructor with default initializations
        _wsnt__SubscriptionManagerRP() : ConsumerReference(), Filter(), SubscriptionPolicy(), CreationTime(), soap() { }
        virtual ~_wsnt__SubscriptionManagerRP() { }
        /// Friend allocator used by soap_new__wsnt__SubscriptionManagerRP(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__SubscriptionManagerRP * SOAP_FMAC2 imageing_instantiate__wsnt__SubscriptionManagerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:703 */
#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (259)
/* complex XML schema type 'wsnt:Notify': */
class SOAP_CMAC _wsnt__Notify {
      public:
        /// Required element 'wsnt:NotificationMessage' of XML schema type 'wsnt:NotificationMessageHolderType'
        std::vector<wsnt__NotificationMessageHolderType *> NotificationMessage;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Notify
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Notify; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Notify, default initialized and not managed by a soap context
        virtual _wsnt__Notify *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Notify); }
      public:
        /// Constructor with default initializations
        _wsnt__Notify() : NotificationMessage(), __any(), soap() { }
        virtual ~_wsnt__Notify() { }
        /// Friend allocator used by soap_new__wsnt__Notify(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Notify * SOAP_FMAC2 imageing_instantiate__wsnt__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:705 */
#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (260)
/* complex XML schema type 'wsnt:UseRaw': */
class SOAP_CMAC _wsnt__UseRaw {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__UseRaw
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__UseRaw; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__UseRaw, default initialized and not managed by a soap context
        virtual _wsnt__UseRaw *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__UseRaw); }
      public:
        /// Constructor with default initializations
        _wsnt__UseRaw() : soap() { }
        virtual ~_wsnt__UseRaw() { }
        /// Friend allocator used by soap_new__wsnt__UseRaw(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__UseRaw * SOAP_FMAC2 imageing_instantiate__wsnt__UseRaw(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:6699 */
#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (466)
/* complex XML schema type 'wsnt:Subscribe-SubscriptionPolicy': */
class SOAP_CMAC _wsnt__Subscribe_SubscriptionPolicy {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Subscribe_SubscriptionPolicy, default initialized and not managed by a soap context
        virtual _wsnt__Subscribe_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Subscribe_SubscriptionPolicy); }
      public:
        /// Constructor with default initializations
        _wsnt__Subscribe_SubscriptionPolicy() : __any() { }
        virtual ~_wsnt__Subscribe_SubscriptionPolicy() { }
        /// Friend allocator used by soap_new__wsnt__Subscribe_SubscriptionPolicy(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC2 imageing_instantiate__wsnt__Subscribe_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:707 */
#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (261)
/* complex XML schema type 'wsnt:Subscribe': */
class SOAP_CMAC _wsnt__Subscribe {
      public:
        /// Required element 'wsnt:ConsumerReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType ConsumerReference;
        /// Optional element 'wsnt:Filter' of XML schema type 'wsnt:FilterType'
        wsnt__FilterType *Filter;
        /// Optional element 'wsnt:InitialTerminationTime' of XML schema type 'wsnt:AbsoluteOrRelativeTimeType'
        std::string *InitialTerminationTime;
        /// Optional element 'wsnt:SubscriptionPolicy' of XML schema type 'wsnt:Subscribe-SubscriptionPolicy'
        _wsnt__Subscribe_SubscriptionPolicy *SubscriptionPolicy;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Subscribe
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Subscribe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Subscribe, default initialized and not managed by a soap context
        virtual _wsnt__Subscribe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Subscribe); }
      public:
        /// Constructor with default initializations
        _wsnt__Subscribe() : ConsumerReference(), Filter(), InitialTerminationTime(), SubscriptionPolicy(), __any(), soap() { }
        virtual ~_wsnt__Subscribe() { }
        /// Friend allocator used by soap_new__wsnt__Subscribe(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Subscribe * SOAP_FMAC2 imageing_instantiate__wsnt__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:709 */
#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (262)
/* complex XML schema type 'wsnt:SubscribeResponse': */
class SOAP_CMAC _wsnt__SubscribeResponse {
      public:
        /// Required element 'wsnt:SubscriptionReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType SubscriptionReference;
        /// Optional element 'wsnt:CurrentTime' of XML schema type 'xsd:dateTime'
        time_t *CurrentTime;
        /// Optional element 'wsnt:TerminationTime' of XML schema type 'xsd:dateTime'
        time_t *TerminationTime;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__SubscribeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__SubscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__SubscribeResponse, default initialized and not managed by a soap context
        virtual _wsnt__SubscribeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__SubscribeResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__SubscribeResponse() : SubscriptionReference(), CurrentTime(), TerminationTime(), __any(), soap() { }
        virtual ~_wsnt__SubscribeResponse() { }
        /// Friend allocator used by soap_new__wsnt__SubscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__SubscribeResponse * SOAP_FMAC2 imageing_instantiate__wsnt__SubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:711 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (263)
/* complex XML schema type 'wsnt:GetCurrentMessage': */
class SOAP_CMAC _wsnt__GetCurrentMessage {
      public:
        /// Required element 'wsnt:Topic' of XML schema type 'wsnt:TopicExpressionType'
        wsnt__TopicExpressionType *Topic;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetCurrentMessage
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetCurrentMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetCurrentMessage, default initialized and not managed by a soap context
        virtual _wsnt__GetCurrentMessage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetCurrentMessage); }
      public:
        /// Constructor with default initializations
        _wsnt__GetCurrentMessage() : Topic(), __any(), soap() { }
        virtual ~_wsnt__GetCurrentMessage() { }
        /// Friend allocator used by soap_new__wsnt__GetCurrentMessage(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetCurrentMessage * SOAP_FMAC2 imageing_instantiate__wsnt__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:713 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (264)
/* complex XML schema type 'wsnt:GetCurrentMessageResponse': */
class SOAP_CMAC _wsnt__GetCurrentMessageResponse {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetCurrentMessageResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetCurrentMessageResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetCurrentMessageResponse, default initialized and not managed by a soap context
        virtual _wsnt__GetCurrentMessageResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetCurrentMessageResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__GetCurrentMessageResponse() : __any(), soap() { }
        virtual ~_wsnt__GetCurrentMessageResponse() { }
        /// Friend allocator used by soap_new__wsnt__GetCurrentMessageResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetCurrentMessageResponse * SOAP_FMAC2 imageing_instantiate__wsnt__GetCurrentMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:715 */
#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (265)
/* complex XML schema type 'wsnt:GetMessages': */
class SOAP_CMAC _wsnt__GetMessages {
      public:
        /// Optional element 'wsnt:MaximumNumber' of XML schema type 'xsd:nonNegativeInteger'
        std::string *MaximumNumber;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetMessages
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetMessages; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetMessages, default initialized and not managed by a soap context
        virtual _wsnt__GetMessages *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetMessages); }
      public:
        /// Constructor with default initializations
        _wsnt__GetMessages() : MaximumNumber(), __any(), __anyAttribute(), soap() { }
        virtual ~_wsnt__GetMessages() { }
        /// Friend allocator used by soap_new__wsnt__GetMessages(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetMessages * SOAP_FMAC2 imageing_instantiate__wsnt__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:717 */
#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (266)
/* complex XML schema type 'wsnt:GetMessagesResponse': */
class SOAP_CMAC _wsnt__GetMessagesResponse {
      public:
        /// Optional element 'wsnt:NotificationMessage' of XML schema type 'wsnt:NotificationMessageHolderType'
        std::vector<wsnt__NotificationMessageHolderType *> NotificationMessage;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetMessagesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetMessagesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetMessagesResponse, default initialized and not managed by a soap context
        virtual _wsnt__GetMessagesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetMessagesResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__GetMessagesResponse() : NotificationMessage(), __any(), __anyAttribute(), soap() { }
        virtual ~_wsnt__GetMessagesResponse() { }
        /// Friend allocator used by soap_new__wsnt__GetMessagesResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetMessagesResponse * SOAP_FMAC2 imageing_instantiate__wsnt__GetMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:719 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (267)
/* complex XML schema type 'wsnt:DestroyPullPoint': */
class SOAP_CMAC _wsnt__DestroyPullPoint {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__DestroyPullPoint
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__DestroyPullPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__DestroyPullPoint, default initialized and not managed by a soap context
        virtual _wsnt__DestroyPullPoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__DestroyPullPoint); }
      public:
        /// Constructor with default initializations
        _wsnt__DestroyPullPoint() : __any(), __anyAttribute(), soap() { }
        virtual ~_wsnt__DestroyPullPoint() { }
        /// Friend allocator used by soap_new__wsnt__DestroyPullPoint(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__DestroyPullPoint * SOAP_FMAC2 imageing_instantiate__wsnt__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:721 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (268)
/* complex XML schema type 'wsnt:DestroyPullPointResponse': */
class SOAP_CMAC _wsnt__DestroyPullPointResponse {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__DestroyPullPointResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__DestroyPullPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__DestroyPullPointResponse, default initialized and not managed by a soap context
        virtual _wsnt__DestroyPullPointResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__DestroyPullPointResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__DestroyPullPointResponse() : __any(), __anyAttribute(), soap() { }
        virtual ~_wsnt__DestroyPullPointResponse() { }
        /// Friend allocator used by soap_new__wsnt__DestroyPullPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__DestroyPullPointResponse * SOAP_FMAC2 imageing_instantiate__wsnt__DestroyPullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:723 */
#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (269)
/* complex XML schema type 'wsnt:CreatePullPoint': */
class SOAP_CMAC _wsnt__CreatePullPoint {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__CreatePullPoint
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__CreatePullPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__CreatePullPoint, default initialized and not managed by a soap context
        virtual _wsnt__CreatePullPoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__CreatePullPoint); }
      public:
        /// Constructor with default initializations
        _wsnt__CreatePullPoint() : __any(), __anyAttribute(), soap() { }
        virtual ~_wsnt__CreatePullPoint() { }
        /// Friend allocator used by soap_new__wsnt__CreatePullPoint(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__CreatePullPoint * SOAP_FMAC2 imageing_instantiate__wsnt__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:725 */
#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (270)
/* complex XML schema type 'wsnt:CreatePullPointResponse': */
class SOAP_CMAC _wsnt__CreatePullPointResponse {
      public:
        /// Required element 'wsnt:PullPoint' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType PullPoint;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__CreatePullPointResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__CreatePullPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__CreatePullPointResponse, default initialized and not managed by a soap context
        virtual _wsnt__CreatePullPointResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__CreatePullPointResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__CreatePullPointResponse() : PullPoint(), __any(), __anyAttribute(), soap() { }
        virtual ~_wsnt__CreatePullPointResponse() { }
        /// Friend allocator used by soap_new__wsnt__CreatePullPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__CreatePullPointResponse * SOAP_FMAC2 imageing_instantiate__wsnt__CreatePullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:727 */
#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (271)
/* complex XML schema type 'wsnt:Renew': */
class SOAP_CMAC _wsnt__Renew {
      public:
        /// Required nillable (xsi:nil when NULL) element 'wsnt:TerminationTime' of XML schema type 'wsnt:AbsoluteOrRelativeTimeType'
        std::string *TerminationTime;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Renew
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Renew; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Renew, default initialized and not managed by a soap context
        virtual _wsnt__Renew *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Renew); }
      public:
        /// Constructor with default initializations
        _wsnt__Renew() : TerminationTime(), __any(), soap() { }
        virtual ~_wsnt__Renew() { }
        /// Friend allocator used by soap_new__wsnt__Renew(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Renew * SOAP_FMAC2 imageing_instantiate__wsnt__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:729 */
#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (272)
/* complex XML schema type 'wsnt:RenewResponse': */
class SOAP_CMAC _wsnt__RenewResponse {
      public:
        /// Required element 'wsnt:TerminationTime' of XML schema type 'xsd:dateTime'
        time_t TerminationTime;
        /// Optional element 'wsnt:CurrentTime' of XML schema type 'xsd:dateTime'
        time_t *CurrentTime;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__RenewResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__RenewResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__RenewResponse, default initialized and not managed by a soap context
        virtual _wsnt__RenewResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__RenewResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__RenewResponse() : TerminationTime(), CurrentTime(), __any(), soap() { }
        virtual ~_wsnt__RenewResponse() { }
        /// Friend allocator used by soap_new__wsnt__RenewResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__RenewResponse * SOAP_FMAC2 imageing_instantiate__wsnt__RenewResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:731 */
#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (273)
/* complex XML schema type 'wsnt:Unsubscribe': */
class SOAP_CMAC _wsnt__Unsubscribe {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Unsubscribe
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Unsubscribe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Unsubscribe, default initialized and not managed by a soap context
        virtual _wsnt__Unsubscribe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Unsubscribe); }
      public:
        /// Constructor with default initializations
        _wsnt__Unsubscribe() : __any(), soap() { }
        virtual ~_wsnt__Unsubscribe() { }
        /// Friend allocator used by soap_new__wsnt__Unsubscribe(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Unsubscribe * SOAP_FMAC2 imageing_instantiate__wsnt__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:733 */
#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (274)
/* complex XML schema type 'wsnt:UnsubscribeResponse': */
class SOAP_CMAC _wsnt__UnsubscribeResponse {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__UnsubscribeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__UnsubscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__UnsubscribeResponse, default initialized and not managed by a soap context
        virtual _wsnt__UnsubscribeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__UnsubscribeResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__UnsubscribeResponse() : __any(), soap() { }
        virtual ~_wsnt__UnsubscribeResponse() { }
        /// Friend allocator used by soap_new__wsnt__UnsubscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__UnsubscribeResponse * SOAP_FMAC2 imageing_instantiate__wsnt__UnsubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:735 */
#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (275)
/* complex XML schema type 'wsnt:PauseSubscription': */
class SOAP_CMAC _wsnt__PauseSubscription {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__PauseSubscription
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__PauseSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__PauseSubscription, default initialized and not managed by a soap context
        virtual _wsnt__PauseSubscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__PauseSubscription); }
      public:
        /// Constructor with default initializations
        _wsnt__PauseSubscription() : __any(), soap() { }
        virtual ~_wsnt__PauseSubscription() { }
        /// Friend allocator used by soap_new__wsnt__PauseSubscription(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__PauseSubscription * SOAP_FMAC2 imageing_instantiate__wsnt__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:737 */
#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (276)
/* complex XML schema type 'wsnt:PauseSubscriptionResponse': */
class SOAP_CMAC _wsnt__PauseSubscriptionResponse {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__PauseSubscriptionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__PauseSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__PauseSubscriptionResponse, default initialized and not managed by a soap context
        virtual _wsnt__PauseSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__PauseSubscriptionResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__PauseSubscriptionResponse() : __any(), soap() { }
        virtual ~_wsnt__PauseSubscriptionResponse() { }
        /// Friend allocator used by soap_new__wsnt__PauseSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__PauseSubscriptionResponse * SOAP_FMAC2 imageing_instantiate__wsnt__PauseSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:739 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (277)
/* complex XML schema type 'wsnt:ResumeSubscription': */
class SOAP_CMAC _wsnt__ResumeSubscription {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__ResumeSubscription
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__ResumeSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__ResumeSubscription, default initialized and not managed by a soap context
        virtual _wsnt__ResumeSubscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__ResumeSubscription); }
      public:
        /// Constructor with default initializations
        _wsnt__ResumeSubscription() : __any(), soap() { }
        virtual ~_wsnt__ResumeSubscription() { }
        /// Friend allocator used by soap_new__wsnt__ResumeSubscription(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__ResumeSubscription * SOAP_FMAC2 imageing_instantiate__wsnt__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:741 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (278)
/* complex XML schema type 'wsnt:ResumeSubscriptionResponse': */
class SOAP_CMAC _wsnt__ResumeSubscriptionResponse {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__ResumeSubscriptionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__ResumeSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__ResumeSubscriptionResponse, default initialized and not managed by a soap context
        virtual _wsnt__ResumeSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__ResumeSubscriptionResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__ResumeSubscriptionResponse() : __any(), soap() { }
        virtual ~_wsnt__ResumeSubscriptionResponse() { }
        /// Friend allocator used by soap_new__wsnt__ResumeSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC2 imageing_instantiate__wsnt__ResumeSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:7322 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (469)
/* complex XML schema type 'wsrfbf:BaseFaultType-ErrorCode': */
class SOAP_CMAC _wsrfbf__BaseFaultType_ErrorCode {
      public:
        /// Required attribute 'dialect' of XML schema type 'xsd:anyURI'
        std::string dialect;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
        virtual long soap_type(void) const { return SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsrfbf__BaseFaultType_ErrorCode, default initialized and not managed by a soap context
        virtual _wsrfbf__BaseFaultType_ErrorCode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsrfbf__BaseFaultType_ErrorCode); }
      public:
        /// Constructor with default initializations
        _wsrfbf__BaseFaultType_ErrorCode() : dialect(), __mixed() { }
        virtual ~_wsrfbf__BaseFaultType_ErrorCode() { }
        /// Friend allocator used by soap_new__wsrfbf__BaseFaultType_ErrorCode(struct soap*, int)
        friend SOAP_FMAC1 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC2 imageing_instantiate__wsrfbf__BaseFaultType_ErrorCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:7345 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description (471)
/* simple XML schema type 'wsrfbf:BaseFaultType-Description': */
class SOAP_CMAC _wsrfbf__BaseFaultType_Description {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'xml:lang' of XML schema type 'xml:lang'
        std::string *xml__lang;
      public:
        /// Return unique type id SOAP_TYPE__wsrfbf__BaseFaultType_Description
        virtual long soap_type(void) const { return SOAP_TYPE__wsrfbf__BaseFaultType_Description; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsrfbf__BaseFaultType_Description, default initialized and not managed by a soap context
        virtual _wsrfbf__BaseFaultType_Description *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsrfbf__BaseFaultType_Description); }
      public:
        /// Constructor with default initializations
        _wsrfbf__BaseFaultType_Description() : __item(), xml__lang() { }
        virtual ~_wsrfbf__BaseFaultType_Description() { }
        /// Friend allocator used by soap_new__wsrfbf__BaseFaultType_Description(struct soap*, int)
        friend SOAP_FMAC1 _wsrfbf__BaseFaultType_Description * SOAP_FMAC2 imageing_instantiate__wsrfbf__BaseFaultType_Description(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:7363 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (474)
/* complex XML schema type 'wsrfbf:BaseFaultType-FaultCause': */
class SOAP_CMAC _wsrfbf__BaseFaultType_FaultCause {
      public:
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
        virtual long soap_type(void) const { return SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsrfbf__BaseFaultType_FaultCause, default initialized and not managed by a soap context
        virtual _wsrfbf__BaseFaultType_FaultCause *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsrfbf__BaseFaultType_FaultCause); }
      public:
        /// Constructor with default initializations
        _wsrfbf__BaseFaultType_FaultCause() : __any() { }
        virtual ~_wsrfbf__BaseFaultType_FaultCause() { }
        /// Friend allocator used by soap_new__wsrfbf__BaseFaultType_FaultCause(struct soap*, int)
        friend SOAP_FMAC1 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC2 imageing_instantiate__wsrfbf__BaseFaultType_FaultCause(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:743 */
#ifndef SOAP_TYPE_wsrfbf__BaseFaultType
#define SOAP_TYPE_wsrfbf__BaseFaultType (279)
/* complex XML schema type 'wsrfbf:BaseFaultType': */
class SOAP_CMAC wsrfbf__BaseFaultType : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Required element 'wsrfbf:Timestamp' of XML schema type 'xsd:dateTime'
        time_t Timestamp;
        /// Optional element 'wsrfbf:Originator' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType *Originator;
        /// Optional element 'wsrfbf:ErrorCode' of XML schema type 'wsrfbf:BaseFaultType-ErrorCode'
        _wsrfbf__BaseFaultType_ErrorCode *ErrorCode;
        /// Optional element 'wsrfbf:Description' of XML schema type 'wsrfbf:BaseFaultType-Description'
        std::vector<_wsrfbf__BaseFaultType_Description> Description;
        /// Optional element 'wsrfbf:FaultCause' of XML schema type 'wsrfbf:BaseFaultType-FaultCause'
        _wsrfbf__BaseFaultType_FaultCause *FaultCause;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_wsrfbf__BaseFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsrfbf__BaseFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrfbf__BaseFaultType, default initialized and not managed by a soap context
        virtual wsrfbf__BaseFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsrfbf__BaseFaultType); }
      public:
        /// Constructor with default initializations
        wsrfbf__BaseFaultType() : __any(), Timestamp(), Originator(), ErrorCode(), Description(), FaultCause(), __anyAttribute() { }
        virtual ~wsrfbf__BaseFaultType() { }
        /// Friend allocator used by soap_new_wsrfbf__BaseFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsrfbf__BaseFaultType * SOAP_FMAC2 imageing_instantiate_wsrfbf__BaseFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:745 */
#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (280)
/* complex XML schema type 'wstop:Documentation': */
class SOAP_CMAC wstop__Documentation : public xsd__anyType {
      public:
        std::vector<char *> __any;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_wstop__Documentation
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__Documentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__Documentation, default initialized and not managed by a soap context
        virtual wstop__Documentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__Documentation); }
      public:
        /// Constructor with default initializations
        wstop__Documentation() : __any(), __mixed() { }
        virtual ~wstop__Documentation() { }
        /// Friend allocator used by soap_new_wstop__Documentation(struct soap*, int)
        friend SOAP_FMAC1 wstop__Documentation * SOAP_FMAC2 imageing_instantiate_wstop__Documentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:747 */
#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (281)
/* complex XML schema type 'wstop:ExtensibleDocumented': */
class SOAP_CMAC wstop__ExtensibleDocumented : public xsd__anyType {
      public:
        /// Optional element 'wstop:documentation' of XML schema type 'wstop:Documentation'
        wstop__Documentation *documentation;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_wstop__ExtensibleDocumented
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__ExtensibleDocumented; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__ExtensibleDocumented, default initialized and not managed by a soap context
        virtual wstop__ExtensibleDocumented *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__ExtensibleDocumented); }
      public:
        /// Constructor with default initializations
        wstop__ExtensibleDocumented() : documentation(), __anyAttribute() { }
        virtual ~wstop__ExtensibleDocumented() { }
        /// Friend allocator used by soap_new_wstop__ExtensibleDocumented(struct soap*, int)
        friend SOAP_FMAC1 wstop__ExtensibleDocumented * SOAP_FMAC2 imageing_instantiate_wstop__ExtensibleDocumented(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:749 */
#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (282)
/* complex XML schema type 'wstop:QueryExpressionType': */
class SOAP_CMAC wstop__QueryExpressionType : public xsd__anyType {
      public:
        char *__any;
        /// Required attribute 'Dialect' of XML schema type 'xsd:anyURI'
        std::string Dialect;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_wstop__QueryExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__QueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__QueryExpressionType, default initialized and not managed by a soap context
        virtual wstop__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__QueryExpressionType); }
      public:
        /// Constructor with default initializations
        wstop__QueryExpressionType() : __any(), Dialect(), __mixed() { }
        virtual ~wstop__QueryExpressionType() { }
        /// Friend allocator used by soap_new_wstop__QueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 wstop__QueryExpressionType * SOAP_FMAC2 imageing_instantiate_wstop__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:435 */
#ifndef SOAP_TYPE_tt__VideoSourceConfiguration
#define SOAP_TYPE_tt__VideoSourceConfiguration (125)
/* complex XML schema type 'tt:VideoSourceConfiguration': */
class SOAP_CMAC tt__VideoSourceConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:SourceToken' of XML schema type 'tt:ReferenceToken'
        std::string SourceToken;
        /// Required element 'tt:Bounds' of XML schema type 'tt:IntRectangle'
        tt__IntRectangle *Bounds;
        std::vector<char *> __any;
        /// Optional element 'tt:Extension' of XML schema type 'tt:VideoSourceConfigurationExtension'
        tt__VideoSourceConfigurationExtension *Extension;
        /// Optional attribute 'ViewMode' of XML schema type 'xsd:string'
        std::string *ViewMode;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfiguration, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfiguration); }
      public:
        /// Constructor with default initializations
        tt__VideoSourceConfiguration() : SourceToken(), Bounds(), __any(), Extension(), ViewMode(), __anyAttribute() { }
        virtual ~tt__VideoSourceConfiguration() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfiguration * SOAP_FMAC2 imageing_instantiate_tt__VideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:453 */
#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration
#define SOAP_TYPE_tt__VideoEncoderConfiguration (134)
/* complex XML schema type 'tt:VideoEncoderConfiguration': */
class SOAP_CMAC tt__VideoEncoderConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:Encoding' of XML schema type 'tt:VideoEncoding'
        enum tt__VideoEncoding Encoding;
        /// Required element 'tt:Resolution' of XML schema type 'tt:VideoResolution'
        tt__VideoResolution *Resolution;
        /// Required element 'tt:Quality' of XML schema type 'xsd:float'
        float Quality;
        /// Optional element 'tt:RateControl' of XML schema type 'tt:VideoRateControl'
        tt__VideoRateControl *RateControl;
        /// Optional element 'tt:MPEG4' of XML schema type 'tt:Mpeg4Configuration'
        tt__Mpeg4Configuration *MPEG4;
        /// Optional element 'tt:H264' of XML schema type 'tt:H264Configuration'
        tt__H264Configuration *H264;
        /// Required element 'tt:Multicast' of XML schema type 'tt:MulticastConfiguration'
        tt__MulticastConfiguration *Multicast;
        /// Required element 'tt:SessionTimeout' of XML schema type 'xsd:duration'
        std::string SessionTimeout;
        std::vector<char *> __any;
        /// Optional attribute 'GuaranteedFrameRate' of XML schema type 'xsd:boolean'
        bool *GuaranteedFrameRate;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncoderConfiguration, default initialized and not managed by a soap context
        virtual tt__VideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncoderConfiguration); }
      public:
        /// Constructor with default initializations
        tt__VideoEncoderConfiguration() : Encoding(), Resolution(), Quality(), RateControl(), MPEG4(), H264(), Multicast(), SessionTimeout(), __any(), GuaranteedFrameRate(), __anyAttribute() { }
        virtual ~tt__VideoEncoderConfiguration() { }
        /// Friend allocator used by soap_new_tt__VideoEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncoderConfiguration * SOAP_FMAC2 imageing_instantiate_tt__VideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:463 */
#ifndef SOAP_TYPE_tt__AudioSourceConfiguration
#define SOAP_TYPE_tt__AudioSourceConfiguration (139)
/* complex XML schema type 'tt:AudioSourceConfiguration': */
class SOAP_CMAC tt__AudioSourceConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:SourceToken' of XML schema type 'tt:ReferenceToken'
        std::string SourceToken;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioSourceConfiguration, default initialized and not managed by a soap context
        virtual tt__AudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioSourceConfiguration); }
      public:
        /// Constructor with default initializations
        tt__AudioSourceConfiguration() : SourceToken(), __any(), __anyAttribute() { }
        virtual ~tt__AudioSourceConfiguration() { }
        /// Friend allocator used by soap_new_tt__AudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioSourceConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:465 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration
#define SOAP_TYPE_tt__AudioEncoderConfiguration (140)
/* complex XML schema type 'tt:AudioEncoderConfiguration': */
class SOAP_CMAC tt__AudioEncoderConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:Encoding' of XML schema type 'tt:AudioEncoding'
        enum tt__AudioEncoding Encoding;
        /// Required element 'tt:Bitrate' of XML schema type 'xsd:int'
        int Bitrate;
        /// Required element 'tt:SampleRate' of XML schema type 'xsd:int'
        int SampleRate;
        /// Required element 'tt:Multicast' of XML schema type 'tt:MulticastConfiguration'
        tt__MulticastConfiguration *Multicast;
        /// Required element 'tt:SessionTimeout' of XML schema type 'xsd:duration'
        std::string SessionTimeout;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioEncoderConfiguration, default initialized and not managed by a soap context
        virtual tt__AudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioEncoderConfiguration); }
      public:
        /// Constructor with default initializations
        tt__AudioEncoderConfiguration() : Encoding(), Bitrate(), SampleRate(), Multicast(), SessionTimeout(), __any(), __anyAttribute() { }
        virtual ~tt__AudioEncoderConfiguration() { }
        /// Friend allocator used by soap_new_tt__AudioEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioEncoderConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:467 */
#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration (141)
/* complex XML schema type 'tt:VideoAnalyticsConfiguration': */
class SOAP_CMAC tt__VideoAnalyticsConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:AnalyticsEngineConfiguration' of XML schema type 'tt:AnalyticsEngineConfiguration'
        tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;
        /// Required element 'tt:RuleEngineConfiguration' of XML schema type 'tt:RuleEngineConfiguration'
        tt__RuleEngineConfiguration *RuleEngineConfiguration;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoAnalyticsConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoAnalyticsConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoAnalyticsConfiguration, default initialized and not managed by a soap context
        virtual tt__VideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoAnalyticsConfiguration); }
      public:
        /// Constructor with default initializations
        tt__VideoAnalyticsConfiguration() : AnalyticsEngineConfiguration(), RuleEngineConfiguration(), __any(), __anyAttribute() { }
        virtual ~tt__VideoAnalyticsConfiguration() { }
        /// Friend allocator used by soap_new_tt__VideoAnalyticsConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoAnalyticsConfiguration * SOAP_FMAC2 imageing_instantiate_tt__VideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:469 */
#ifndef SOAP_TYPE_tt__MetadataConfiguration
#define SOAP_TYPE_tt__MetadataConfiguration (142)
/* complex XML schema type 'tt:MetadataConfiguration': */
class SOAP_CMAC tt__MetadataConfiguration : public tt__ConfigurationEntity {
      public:
        /// Optional element 'tt:PTZStatus' of XML schema type 'tt:PTZFilter'
        tt__PTZFilter *PTZStatus;
        /// Optional element 'tt:Events' of XML schema type 'tt:EventSubscription'
        tt__EventSubscription *Events;
        /// Optional element 'tt:Analytics' of XML schema type 'xsd:boolean'
        bool *Analytics;
        /// Required element 'tt:Multicast' of XML schema type 'tt:MulticastConfiguration'
        tt__MulticastConfiguration *Multicast;
        /// Required element 'tt:SessionTimeout' of XML schema type 'xsd:duration'
        std::string SessionTimeout;
        std::vector<char *> __any;
        /// Optional element 'tt:AnalyticsEngineConfiguration' of XML schema type 'tt:AnalyticsEngineConfiguration'
        tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;
        /// Optional element 'tt:Extension' of XML schema type 'tt:MetadataConfigurationExtension'
        tt__MetadataConfigurationExtension *Extension;
        /// Optional attribute 'CompressionType' of XML schema type 'xsd:string'
        std::string *CompressionType;
        /// Optional attribute 'GeoLocation' of XML schema type 'xsd:boolean'
        bool *GeoLocation;
        /// Optional attribute 'ShapePolygon' of XML schema type 'xsd:boolean'
        bool *ShapePolygon;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataConfiguration, default initialized and not managed by a soap context
        virtual tt__MetadataConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataConfiguration); }
      public:
        /// Constructor with default initializations
        tt__MetadataConfiguration() : PTZStatus(), Events(), Analytics(), Multicast(), SessionTimeout(), __any(), AnalyticsEngineConfiguration(), Extension(), CompressionType(), GeoLocation(), ShapePolygon(), __anyAttribute() { }
        virtual ~tt__MetadataConfiguration() { }
        /// Friend allocator used by soap_new_tt__MetadataConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataConfiguration * SOAP_FMAC2 imageing_instantiate_tt__MetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:477 */
#ifndef SOAP_TYPE_tt__AudioOutputConfiguration
#define SOAP_TYPE_tt__AudioOutputConfiguration (146)
/* complex XML schema type 'tt:AudioOutputConfiguration': */
class SOAP_CMAC tt__AudioOutputConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:OutputToken' of XML schema type 'tt:ReferenceToken'
        std::string OutputToken;
        /// Optional element 'tt:SendPrimacy' of XML schema type 'xsd:anyURI'
        std::string *SendPrimacy;
        /// Required element 'tt:OutputLevel' of XML schema type 'xsd:int'
        int OutputLevel;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioOutputConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioOutputConfiguration, default initialized and not managed by a soap context
        virtual tt__AudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioOutputConfiguration); }
      public:
        /// Constructor with default initializations
        tt__AudioOutputConfiguration() : OutputToken(), SendPrimacy(), OutputLevel(), __any(), __anyAttribute() { }
        virtual ~tt__AudioOutputConfiguration() { }
        /// Friend allocator used by soap_new_tt__AudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioOutputConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:479 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfiguration
#define SOAP_TYPE_tt__AudioDecoderConfiguration (147)
/* complex XML schema type 'tt:AudioDecoderConfiguration': */
class SOAP_CMAC tt__AudioDecoderConfiguration : public tt__ConfigurationEntity {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioDecoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioDecoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioDecoderConfiguration, default initialized and not managed by a soap context
        virtual tt__AudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioDecoderConfiguration); }
      public:
        /// Constructor with default initializations
        tt__AudioDecoderConfiguration() : __any(), __anyAttribute() { }
        virtual ~tt__AudioDecoderConfiguration() { }
        /// Friend allocator used by soap_new_tt__AudioDecoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioDecoderConfiguration * SOAP_FMAC2 imageing_instantiate_tt__AudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:485 */
#ifndef SOAP_TYPE_tt__PTZConfiguration
#define SOAP_TYPE_tt__PTZConfiguration (150)
/* complex XML schema type 'tt:PTZConfiguration': */
class SOAP_CMAC tt__PTZConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:NodeToken' of XML schema type 'tt:ReferenceToken'
        std::string NodeToken;
        /// Optional element 'tt:DefaultAbsolutePantTiltPositionSpace' of XML schema type 'xsd:anyURI'
        std::string *DefaultAbsolutePantTiltPositionSpace;
        /// Optional element 'tt:DefaultAbsoluteZoomPositionSpace' of XML schema type 'xsd:anyURI'
        std::string *DefaultAbsoluteZoomPositionSpace;
        /// Optional element 'tt:DefaultRelativePanTiltTranslationSpace' of XML schema type 'xsd:anyURI'
        std::string *DefaultRelativePanTiltTranslationSpace;
        /// Optional element 'tt:DefaultRelativeZoomTranslationSpace' of XML schema type 'xsd:anyURI'
        std::string *DefaultRelativeZoomTranslationSpace;
        /// Optional element 'tt:DefaultContinuousPanTiltVelocitySpace' of XML schema type 'xsd:anyURI'
        std::string *DefaultContinuousPanTiltVelocitySpace;
        /// Optional element 'tt:DefaultContinuousZoomVelocitySpace' of XML schema type 'xsd:anyURI'
        std::string *DefaultContinuousZoomVelocitySpace;
        /// Optional element 'tt:DefaultPTZSpeed' of XML schema type 'tt:PTZSpeed'
        tt__PTZSpeed *DefaultPTZSpeed;
        /// Optional element 'tt:DefaultPTZTimeout' of XML schema type 'xsd:duration'
        std::string *DefaultPTZTimeout;
        /// Optional element 'tt:PanTiltLimits' of XML schema type 'tt:PanTiltLimits'
        tt__PanTiltLimits *PanTiltLimits;
        /// Optional element 'tt:ZoomLimits' of XML schema type 'tt:ZoomLimits'
        tt__ZoomLimits *ZoomLimits;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZConfigurationExtension'
        tt__PTZConfigurationExtension *Extension;
        /// Optional attribute 'MoveRamp' of XML schema type 'xsd:int'
        int *MoveRamp;
        /// Optional attribute 'PresetRamp' of XML schema type 'xsd:int'
        int *PresetRamp;
        /// Optional attribute 'PresetTourRamp' of XML schema type 'xsd:int'
        int *PresetTourRamp;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZConfiguration, default initialized and not managed by a soap context
        virtual tt__PTZConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZConfiguration); }
      public:
        /// Constructor with default initializations
        tt__PTZConfiguration() : NodeToken(), DefaultAbsolutePantTiltPositionSpace(), DefaultAbsoluteZoomPositionSpace(), DefaultRelativePanTiltTranslationSpace(), DefaultRelativeZoomTranslationSpace(), DefaultContinuousPanTiltVelocitySpace(), DefaultContinuousZoomVelocitySpace(), DefaultPTZSpeed(), DefaultPTZTimeout(), PanTiltLimits(), ZoomLimits(), Extension(), MoveRamp(), PresetRamp(), PresetTourRamp(), __anyAttribute() { }
        virtual ~tt__PTZConfiguration() { }
        /// Friend allocator used by soap_new_tt__PTZConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZConfiguration * SOAP_FMAC2 imageing_instantiate_tt__PTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:659 */
#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (237)
/* complex XML schema type 'wsnt:SubscribeCreationFailedFaultType': */
class SOAP_CMAC wsnt__SubscribeCreationFailedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__SubscribeCreationFailedFaultType, default initialized and not managed by a soap context
        virtual wsnt__SubscribeCreationFailedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__SubscribeCreationFailedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__SubscribeCreationFailedFaultType() { }
        virtual ~wsnt__SubscribeCreationFailedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__SubscribeCreationFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__SubscribeCreationFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:661 */
#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (238)
/* complex XML schema type 'wsnt:InvalidFilterFaultType': */
class SOAP_CMAC wsnt__InvalidFilterFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Required element 'wsnt:UnknownFilter' of XML schema type 'xsd:QName'
        std::vector<std::string> UnknownFilter;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidFilterFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidFilterFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidFilterFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidFilterFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidFilterFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__InvalidFilterFaultType() : UnknownFilter() { }
        virtual ~wsnt__InvalidFilterFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidFilterFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidFilterFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__InvalidFilterFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:663 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (239)
/* complex XML schema type 'wsnt:TopicExpressionDialectUnknownFaultType': */
class SOAP_CMAC wsnt__TopicExpressionDialectUnknownFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__TopicExpressionDialectUnknownFaultType, default initialized and not managed by a soap context
        virtual wsnt__TopicExpressionDialectUnknownFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__TopicExpressionDialectUnknownFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__TopicExpressionDialectUnknownFaultType() { }
        virtual ~wsnt__TopicExpressionDialectUnknownFaultType() { }
        /// Friend allocator used by soap_new_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:665 */
#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (240)
/* complex XML schema type 'wsnt:InvalidTopicExpressionFaultType': */
class SOAP_CMAC wsnt__InvalidTopicExpressionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidTopicExpressionFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidTopicExpressionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidTopicExpressionFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__InvalidTopicExpressionFaultType() { }
        virtual ~wsnt__InvalidTopicExpressionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidTopicExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__InvalidTopicExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:667 */
#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (241)
/* complex XML schema type 'wsnt:TopicNotSupportedFaultType': */
class SOAP_CMAC wsnt__TopicNotSupportedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__TopicNotSupportedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__TopicNotSupportedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__TopicNotSupportedFaultType, default initialized and not managed by a soap context
        virtual wsnt__TopicNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__TopicNotSupportedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__TopicNotSupportedFaultType() { }
        virtual ~wsnt__TopicNotSupportedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__TopicNotSupportedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__TopicNotSupportedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__TopicNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:669 */
#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (242)
/* complex XML schema type 'wsnt:MultipleTopicsSpecifiedFaultType': */
class SOAP_CMAC wsnt__MultipleTopicsSpecifiedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__MultipleTopicsSpecifiedFaultType, default initialized and not managed by a soap context
        virtual wsnt__MultipleTopicsSpecifiedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__MultipleTopicsSpecifiedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__MultipleTopicsSpecifiedFaultType() { }
        virtual ~wsnt__MultipleTopicsSpecifiedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:671 */
#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (243)
/* complex XML schema type 'wsnt:InvalidProducerPropertiesExpressionFaultType': */
class SOAP_CMAC wsnt__InvalidProducerPropertiesExpressionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidProducerPropertiesExpressionFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidProducerPropertiesExpressionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidProducerPropertiesExpressionFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__InvalidProducerPropertiesExpressionFaultType() { }
        virtual ~wsnt__InvalidProducerPropertiesExpressionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:673 */
#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (244)
/* complex XML schema type 'wsnt:InvalidMessageContentExpressionFaultType': */
class SOAP_CMAC wsnt__InvalidMessageContentExpressionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidMessageContentExpressionFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidMessageContentExpressionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidMessageContentExpressionFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__InvalidMessageContentExpressionFaultType() { }
        virtual ~wsnt__InvalidMessageContentExpressionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:675 */
#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (245)
/* complex XML schema type 'wsnt:UnrecognizedPolicyRequestFaultType': */
class SOAP_CMAC wsnt__UnrecognizedPolicyRequestFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Optional element 'wsnt:UnrecognizedPolicy' of XML schema type 'xsd:QName'
        std::vector<std::string> UnrecognizedPolicy;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnrecognizedPolicyRequestFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnrecognizedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnrecognizedPolicyRequestFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnrecognizedPolicyRequestFaultType() : UnrecognizedPolicy() { }
        virtual ~wsnt__UnrecognizedPolicyRequestFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:677 */
#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (246)
/* complex XML schema type 'wsnt:UnsupportedPolicyRequestFaultType': */
class SOAP_CMAC wsnt__UnsupportedPolicyRequestFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Optional element 'wsnt:UnsupportedPolicy' of XML schema type 'xsd:QName'
        std::vector<std::string> UnsupportedPolicy;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnsupportedPolicyRequestFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnsupportedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnsupportedPolicyRequestFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnsupportedPolicyRequestFaultType() : UnsupportedPolicy() { }
        virtual ~wsnt__UnsupportedPolicyRequestFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:679 */
#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (247)
/* complex XML schema type 'wsnt:NotifyMessageNotSupportedFaultType': */
class SOAP_CMAC wsnt__NotifyMessageNotSupportedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__NotifyMessageNotSupportedFaultType, default initialized and not managed by a soap context
        virtual wsnt__NotifyMessageNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__NotifyMessageNotSupportedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__NotifyMessageNotSupportedFaultType() { }
        virtual ~wsnt__NotifyMessageNotSupportedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:681 */
#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (248)
/* complex XML schema type 'wsnt:UnacceptableInitialTerminationTimeFaultType': */
class SOAP_CMAC wsnt__UnacceptableInitialTerminationTimeFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Required element 'wsnt:MinimumTime' of XML schema type 'xsd:dateTime'
        time_t MinimumTime;
        /// Optional element 'wsnt:MaximumTime' of XML schema type 'xsd:dateTime'
        time_t *MaximumTime;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnacceptableInitialTerminationTimeFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnacceptableInitialTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnacceptableInitialTerminationTimeFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnacceptableInitialTerminationTimeFaultType() : MinimumTime(), MaximumTime() { }
        virtual ~wsnt__UnacceptableInitialTerminationTimeFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:683 */
#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (249)
/* complex XML schema type 'wsnt:NoCurrentMessageOnTopicFaultType': */
class SOAP_CMAC wsnt__NoCurrentMessageOnTopicFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__NoCurrentMessageOnTopicFaultType, default initialized and not managed by a soap context
        virtual wsnt__NoCurrentMessageOnTopicFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__NoCurrentMessageOnTopicFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__NoCurrentMessageOnTopicFaultType() { }
        virtual ~wsnt__NoCurrentMessageOnTopicFaultType() { }
        /// Friend allocator used by soap_new_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:685 */
#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (250)
/* complex XML schema type 'wsnt:UnableToGetMessagesFaultType': */
class SOAP_CMAC wsnt__UnableToGetMessagesFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToGetMessagesFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToGetMessagesFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToGetMessagesFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToGetMessagesFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnableToGetMessagesFaultType() { }
        virtual ~wsnt__UnableToGetMessagesFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToGetMessagesFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnableToGetMessagesFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:687 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (251)
/* complex XML schema type 'wsnt:UnableToDestroyPullPointFaultType': */
class SOAP_CMAC wsnt__UnableToDestroyPullPointFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToDestroyPullPointFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToDestroyPullPointFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToDestroyPullPointFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnableToDestroyPullPointFaultType() { }
        virtual ~wsnt__UnableToDestroyPullPointFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToDestroyPullPointFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnableToDestroyPullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:689 */
#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (252)
/* complex XML schema type 'wsnt:UnableToCreatePullPointFaultType': */
class SOAP_CMAC wsnt__UnableToCreatePullPointFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToCreatePullPointFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToCreatePullPointFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToCreatePullPointFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnableToCreatePullPointFaultType() { }
        virtual ~wsnt__UnableToCreatePullPointFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToCreatePullPointFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnableToCreatePullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:691 */
#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (253)
/* complex XML schema type 'wsnt:UnacceptableTerminationTimeFaultType': */
class SOAP_CMAC wsnt__UnacceptableTerminationTimeFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Required element 'wsnt:MinimumTime' of XML schema type 'xsd:dateTime'
        time_t MinimumTime;
        /// Optional element 'wsnt:MaximumTime' of XML schema type 'xsd:dateTime'
        time_t *MaximumTime;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnacceptableTerminationTimeFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnacceptableTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnacceptableTerminationTimeFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnacceptableTerminationTimeFaultType() : MinimumTime(), MaximumTime() { }
        virtual ~wsnt__UnacceptableTerminationTimeFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:693 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (254)
/* complex XML schema type 'wsnt:UnableToDestroySubscriptionFaultType': */
class SOAP_CMAC wsnt__UnableToDestroySubscriptionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToDestroySubscriptionFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToDestroySubscriptionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToDestroySubscriptionFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnableToDestroySubscriptionFaultType() { }
        virtual ~wsnt__UnableToDestroySubscriptionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:695 */
#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (255)
/* complex XML schema type 'wsnt:PauseFailedFaultType': */
class SOAP_CMAC wsnt__PauseFailedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__PauseFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__PauseFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__PauseFailedFaultType, default initialized and not managed by a soap context
        virtual wsnt__PauseFailedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__PauseFailedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__PauseFailedFaultType() { }
        virtual ~wsnt__PauseFailedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__PauseFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__PauseFailedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__PauseFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:697 */
#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (256)
/* complex XML schema type 'wsnt:ResumeFailedFaultType': */
class SOAP_CMAC wsnt__ResumeFailedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__ResumeFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__ResumeFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__ResumeFailedFaultType, default initialized and not managed by a soap context
        virtual wsnt__ResumeFailedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__ResumeFailedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__ResumeFailedFaultType() { }
        virtual ~wsnt__ResumeFailedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__ResumeFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__ResumeFailedFaultType * SOAP_FMAC2 imageing_instantiate_wsnt__ResumeFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:10308 */
#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (494)
/* complex XML schema type 'wstop:TopicNamespaceType-Topic': */
class SOAP_CMAC _wstop__TopicNamespaceType_Topic {
      public:
        /// Optional element 'wstop:documentation' of XML schema type 'wstop:Documentation'
        wstop__Documentation *documentation;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Optional element 'wstop:MessagePattern' of XML schema type 'wstop:QueryExpressionType'
        wstop__QueryExpressionType *MessagePattern;
        /// Optional element 'wstop:Topic' of XML schema type 'wstop:TopicType'
        std::vector<wstop__TopicType *> Topic;
        std::vector<char *> __any;
        /// Required attribute 'name' of XML schema type 'xsd:NCName'
        std::string name;
        /// Optional attribute 'messageTypes' of XML schema type 'xsd:QName'
        std::string *messageTypes;
        /// Optional attribute 'final' of XML schema type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
        /// Optional attribute 'parent' of XML schema type 'wstop:ConcreteTopicExpression'
        std::string *parent;
      public:
        /// Return unique type id SOAP_TYPE__wstop__TopicNamespaceType_Topic
        virtual long soap_type(void) const { return SOAP_TYPE__wstop__TopicNamespaceType_Topic; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wstop__TopicNamespaceType_Topic, default initialized and not managed by a soap context
        virtual _wstop__TopicNamespaceType_Topic *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wstop__TopicNamespaceType_Topic); }
      public:
        /// Constructor with default initializations
        _wstop__TopicNamespaceType_Topic() : documentation(), __anyAttribute(), MessagePattern(), Topic(), __any(), name(), messageTypes(), final_((bool)0), parent() { }
        virtual ~_wstop__TopicNamespaceType_Topic() { }
        /// Friend allocator used by soap_new__wstop__TopicNamespaceType_Topic(struct soap*, int)
        friend SOAP_FMAC1 _wstop__TopicNamespaceType_Topic * SOAP_FMAC2 imageing_instantiate__wstop__TopicNamespaceType_Topic(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:751 */
#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (283)
/* complex XML schema type 'wstop:TopicNamespaceType': */
class SOAP_CMAC wstop__TopicNamespaceType : public wstop__ExtensibleDocumented {
      public:
        /// Optional element 'wstop:Topic' of XML schema type 'wstop:TopicNamespaceType-Topic'
        std::vector<_wstop__TopicNamespaceType_Topic> Topic;
        std::vector<char *> __any;
        /// Optional attribute 'name' of XML schema type 'xsd:NCName'
        std::string *name;
        /// Required attribute 'targetNamespace' of XML schema type 'xsd:anyURI'
        std::string targetNamespace;
        /// Optional attribute 'final' of XML schema type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_wstop__TopicNamespaceType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__TopicNamespaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__TopicNamespaceType, default initialized and not managed by a soap context
        virtual wstop__TopicNamespaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__TopicNamespaceType); }
      public:
        /// Constructor with default initializations
        wstop__TopicNamespaceType() : Topic(), __any(), name(), targetNamespace(), final_((bool)0) { }
        virtual ~wstop__TopicNamespaceType() { }
        /// Friend allocator used by soap_new_wstop__TopicNamespaceType(struct soap*, int)
        friend SOAP_FMAC1 wstop__TopicNamespaceType * SOAP_FMAC2 imageing_instantiate_wstop__TopicNamespaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:753 */
#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (284)
/* Type wstop__TopicType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wstop:TopicType': */
class SOAP_CMAC wstop__TopicType : public wstop__ExtensibleDocumented {
      public:
        /// Optional element 'wstop:MessagePattern' of XML schema type 'wstop:QueryExpressionType'
        wstop__QueryExpressionType *MessagePattern;
        /// Optional element 'wstop:Topic' of XML schema type 'wstop:TopicType'
        std::vector<wstop__TopicType *> Topic;
        std::vector<char *> __any;
        /// Required attribute 'name' of XML schema type 'xsd:NCName'
        std::string name;
        /// Optional attribute 'messageTypes' of XML schema type 'xsd:QName'
        std::string *messageTypes;
        /// Optional attribute 'final' of XML schema type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_wstop__TopicType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__TopicType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__TopicType, default initialized and not managed by a soap context
        virtual wstop__TopicType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__TopicType); }
      public:
        /// Constructor with default initializations
        wstop__TopicType() : MessagePattern(), Topic(), __any(), name(), messageTypes(), final_((bool)0) { }
        virtual ~wstop__TopicType() { }
        /// Friend allocator used by soap_new_wstop__TopicType(struct soap*, int)
        friend SOAP_FMAC1 wstop__TopicType * SOAP_FMAC2 imageing_instantiate_wstop__TopicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:755 */
#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (285)
/* complex XML schema type 'wstop:TopicSetType': */
class SOAP_CMAC wstop__TopicSetType : public wstop__ExtensibleDocumented {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_wstop__TopicSetType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__TopicSetType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__TopicSetType, default initialized and not managed by a soap context
        virtual wstop__TopicSetType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__TopicSetType); }
      public:
        /// Constructor with default initializations
        wstop__TopicSetType() : __any() { }
        virtual ~wstop__TopicSetType() { }
        /// Friend allocator used by soap_new_wstop__TopicSetType(struct soap*, int)
        friend SOAP_FMAC1 wstop__TopicSetType * SOAP_FMAC2 imageing_instantiate_wstop__TopicSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:10841 */
#ifndef SOAP_TYPE___timg__GetServiceCapabilities
#define SOAP_TYPE___timg__GetServiceCapabilities (505)
/* Wrapper: */
struct SOAP_CMAC __timg__GetServiceCapabilities {
      public:
        /** Optional element 'timg:GetServiceCapabilities' of XML schema type 'timg:GetServiceCapabilities' */
        _timg__GetServiceCapabilities *timg__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetServiceCapabilities */
        long soap_type() const { return SOAP_TYPE___timg__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __timg__GetServiceCapabilities() : timg__GetServiceCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetServiceCapabilities * SOAP_FMAC2 imageing_instantiate___timg__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:10909 */
#ifndef SOAP_TYPE___timg__GetImagingSettings
#define SOAP_TYPE___timg__GetImagingSettings (509)
/* Wrapper: */
struct SOAP_CMAC __timg__GetImagingSettings {
      public:
        /** Optional element 'timg:GetImagingSettings' of XML schema type 'timg:GetImagingSettings' */
        _timg__GetImagingSettings *timg__GetImagingSettings;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetImagingSettings */
        long soap_type() const { return SOAP_TYPE___timg__GetImagingSettings; }
        /** Constructor with member initializations */
        __timg__GetImagingSettings() : timg__GetImagingSettings() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetImagingSettings * SOAP_FMAC2 imageing_instantiate___timg__GetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:10977 */
#ifndef SOAP_TYPE___timg__SetImagingSettings
#define SOAP_TYPE___timg__SetImagingSettings (513)
/* Wrapper: */
struct SOAP_CMAC __timg__SetImagingSettings {
      public:
        /** Optional element 'timg:SetImagingSettings' of XML schema type 'timg:SetImagingSettings' */
        _timg__SetImagingSettings *timg__SetImagingSettings;
      public:
        /** Return unique type id SOAP_TYPE___timg__SetImagingSettings */
        long soap_type() const { return SOAP_TYPE___timg__SetImagingSettings; }
        /** Constructor with member initializations */
        __timg__SetImagingSettings() : timg__SetImagingSettings() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__SetImagingSettings * SOAP_FMAC2 imageing_instantiate___timg__SetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:11055 */
#ifndef SOAP_TYPE___timg__GetOptions
#define SOAP_TYPE___timg__GetOptions (517)
/* Wrapper: */
struct SOAP_CMAC __timg__GetOptions {
      public:
        /** Optional element 'timg:GetOptions' of XML schema type 'timg:GetOptions' */
        _timg__GetOptions *timg__GetOptions;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetOptions */
        long soap_type() const { return SOAP_TYPE___timg__GetOptions; }
        /** Constructor with member initializations */
        __timg__GetOptions() : timg__GetOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetOptions * SOAP_FMAC2 imageing_instantiate___timg__GetOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:11145 */
#ifndef SOAP_TYPE___timg__Move
#define SOAP_TYPE___timg__Move (521)
/* Wrapper: */
struct SOAP_CMAC __timg__Move {
      public:
        /** Optional element 'timg:Move' of XML schema type 'timg:Move' */
        _timg__Move *timg__Move;
      public:
        /** Return unique type id SOAP_TYPE___timg__Move */
        long soap_type() const { return SOAP_TYPE___timg__Move; }
        /** Constructor with member initializations */
        __timg__Move() : timg__Move() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__Move * SOAP_FMAC2 imageing_instantiate___timg__Move(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:11216 */
#ifndef SOAP_TYPE___timg__Stop
#define SOAP_TYPE___timg__Stop (525)
/* Wrapper: */
struct SOAP_CMAC __timg__Stop {
      public:
        /** Optional element 'timg:Stop' of XML schema type 'timg:Stop' */
        _timg__Stop *timg__Stop;
      public:
        /** Return unique type id SOAP_TYPE___timg__Stop */
        long soap_type() const { return SOAP_TYPE___timg__Stop; }
        /** Constructor with member initializations */
        __timg__Stop() : timg__Stop() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__Stop * SOAP_FMAC2 imageing_instantiate___timg__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:11286 */
#ifndef SOAP_TYPE___timg__GetStatus
#define SOAP_TYPE___timg__GetStatus (529)
/* Wrapper: */
struct SOAP_CMAC __timg__GetStatus {
      public:
        /** Optional element 'timg:GetStatus' of XML schema type 'timg:GetStatus' */
        _timg__GetStatus *timg__GetStatus;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetStatus */
        long soap_type() const { return SOAP_TYPE___timg__GetStatus; }
        /** Constructor with member initializations */
        __timg__GetStatus() : timg__GetStatus() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetStatus * SOAP_FMAC2 imageing_instantiate___timg__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:11354 */
#ifndef SOAP_TYPE___timg__GetMoveOptions
#define SOAP_TYPE___timg__GetMoveOptions (533)
/* Wrapper: */
struct SOAP_CMAC __timg__GetMoveOptions {
      public:
        /** Optional element 'timg:GetMoveOptions' of XML schema type 'timg:GetMoveOptions' */
        _timg__GetMoveOptions *timg__GetMoveOptions;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetMoveOptions */
        long soap_type() const { return SOAP_TYPE___timg__GetMoveOptions; }
        /** Constructor with member initializations */
        __timg__GetMoveOptions() : timg__GetMoveOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetMoveOptions * SOAP_FMAC2 imageing_instantiate___timg__GetMoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:11422 */
#ifndef SOAP_TYPE___timg__GetPresets
#define SOAP_TYPE___timg__GetPresets (537)
/* Wrapper: */
struct SOAP_CMAC __timg__GetPresets {
      public:
        /** Optional element 'timg:GetPresets' of XML schema type 'timg:GetPresets' */
        _timg__GetPresets *timg__GetPresets;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetPresets */
        long soap_type() const { return SOAP_TYPE___timg__GetPresets; }
        /** Constructor with member initializations */
        __timg__GetPresets() : timg__GetPresets() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetPresets * SOAP_FMAC2 imageing_instantiate___timg__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:11494 */
#ifndef SOAP_TYPE___timg__GetCurrentPreset
#define SOAP_TYPE___timg__GetCurrentPreset (541)
/* Wrapper: */
struct SOAP_CMAC __timg__GetCurrentPreset {
      public:
        /** Optional element 'timg:GetCurrentPreset' of XML schema type 'timg:GetCurrentPreset' */
        _timg__GetCurrentPreset *timg__GetCurrentPreset;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetCurrentPreset */
        long soap_type() const { return SOAP_TYPE___timg__GetCurrentPreset; }
        /** Constructor with member initializations */
        __timg__GetCurrentPreset() : timg__GetCurrentPreset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetCurrentPreset * SOAP_FMAC2 imageing_instantiate___timg__GetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* out/onvif_imaging.h:11570 */
#ifndef SOAP_TYPE___timg__SetCurrentPreset
#define SOAP_TYPE___timg__SetCurrentPreset (545)
/* Wrapper: */
struct SOAP_CMAC __timg__SetCurrentPreset {
      public:
        /** Optional element 'timg:SetCurrentPreset' of XML schema type 'timg:SetCurrentPreset' */
        _timg__SetCurrentPreset *timg__SetCurrentPreset;
      public:
        /** Return unique type id SOAP_TYPE___timg__SetCurrentPreset */
        long soap_type() const { return SOAP_TYPE___timg__SetCurrentPreset; }
        /** Constructor with member initializations */
        __timg__SetCurrentPreset() : timg__SetCurrentPreset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__SetCurrentPreset * SOAP_FMAC2 imageing_instantiate___timg__SetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* wsa5.h:89 */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (17)
typedef char *wsa5__RelationshipTypeOpenEnum;
#endif

/* wsa5.h:92 */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (18)
typedef char *wsa5__FaultCodesOpenEnumType;
#endif

/* wsa5.h:211 */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (25)
typedef struct wsa5__EndpointReferenceType _wsa5__EndpointReference;
#endif

/* wsa5.h:214 */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (26)
typedef struct wsa5__ReferenceParametersType _wsa5__ReferenceParameters;
#endif

/* wsa5.h:217 */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (27)
typedef struct wsa5__MetadataType _wsa5__Metadata;
#endif

/* wsa5.h:220 */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (28)
typedef char *_wsa5__MessageID;
#endif

/* wsa5.h:223 */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (29)
typedef struct wsa5__RelatesToType _wsa5__RelatesTo;
#endif

/* wsa5.h:226 */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (30)
typedef struct wsa5__EndpointReferenceType _wsa5__ReplyTo;
#endif

/* wsa5.h:229 */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (31)
typedef struct wsa5__EndpointReferenceType _wsa5__From;
#endif

/* wsa5.h:232 */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (32)
typedef struct wsa5__EndpointReferenceType _wsa5__FaultTo;
#endif

/* wsa5.h:235 */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (33)
typedef char *_wsa5__To;
#endif

/* wsa5.h:238 */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (34)
typedef char *_wsa5__Action;
#endif

/* wsa5.h:241 */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (36)
typedef ULONG64 _wsa5__RetryAfter;
#endif

/* wsa5.h:244 */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (37)
typedef _QName _wsa5__ProblemHeaderQName;
#endif

/* wsa5.h:247 */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (38)
typedef char *_wsa5__ProblemIRI;
#endif

/* wsa5.h:250 */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (39)
typedef struct wsa5__ProblemActionType _wsa5__ProblemAction;
#endif

/* out/onvif_imaging.h:232 */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (68)
typedef std::string xsd__NCName;
#endif

/* out/onvif_imaging.h:249 */
#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (71)
typedef std::string xsd__anySimpleType;
#endif

/* out/onvif_imaging.h:259 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (73)
typedef std::string xsd__anyURI;
#endif

/* out/onvif_imaging.h:297 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (82)
typedef std::string xsd__duration;
#endif

/* out/onvif_imaging.h:328 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (88)
typedef std::string xsd__integer;
#endif

/* out/onvif_imaging.h:338 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (90)
typedef std::string xsd__nonNegativeInteger;
#endif

/* out/onvif_imaging.h:355 */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (93)
typedef std::string xsd__token;
#endif

/* out/onvif_imaging.h:367 */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (95)
typedef std::string _xml__lang;
#endif

/* out/onvif_imaging.h:775 */
#ifndef SOAP_TYPE_tt__IntList
#define SOAP_TYPE_tt__IntList (286)
typedef std::string tt__IntList;
#endif

/* out/onvif_imaging.h:779 */
#ifndef SOAP_TYPE_tt__FloatList
#define SOAP_TYPE_tt__FloatList (287)
typedef std::string tt__FloatList;
#endif

/* out/onvif_imaging.h:783 */
#ifndef SOAP_TYPE_tt__StringAttrList
#define SOAP_TYPE_tt__StringAttrList (288)
typedef std::string tt__StringAttrList;
#endif

/* out/onvif_imaging.h:787 */
#ifndef SOAP_TYPE_tt__StringList
#define SOAP_TYPE_tt__StringList (289)
typedef std::string tt__StringList;
#endif

/* out/onvif_imaging.h:800 */
#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (290)
typedef std::string wsnt__AbsoluteOrRelativeTimeType;
#endif

/* out/onvif_imaging.h:835 */
#ifndef SOAP_TYPE_tt__Name
#define SOAP_TYPE_tt__Name (291)
typedef std::string tt__Name;
#endif

/* out/onvif_imaging.h:998 */
#ifndef SOAP_TYPE_tt__IPv4Address
#define SOAP_TYPE_tt__IPv4Address (305)
typedef xsd__token tt__IPv4Address;
#endif

/* out/onvif_imaging.h:1010 */
#ifndef SOAP_TYPE_tt__IPv6Address
#define SOAP_TYPE_tt__IPv6Address (307)
typedef xsd__token tt__IPv6Address;
#endif

/* out/onvif_imaging.h:1345 */
#ifndef SOAP_TYPE_tt__ReferenceToken
#define SOAP_TYPE_tt__ReferenceToken (333)
typedef std::string tt__ReferenceToken;
#endif

/* out/onvif_imaging.h:1409 */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (337)
typedef std::string wstop__ConcreteTopicExpression;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (85)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (81)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (10)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (9)
#endif

/* _wsa5__RetryAfter has binding name '_wsa5__RetryAfter' for type '' */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (36)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (35)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (79)
#endif

/* enum tt__MoveStatus has binding name 'tt__MoveStatus' for type 'tt:MoveStatus' */
#ifndef SOAP_TYPE_tt__MoveStatus
#define SOAP_TYPE_tt__MoveStatus (335)
#endif

/* enum tt__PropertyOperation has binding name 'tt__PropertyOperation' for type 'tt:PropertyOperation' */
#ifndef SOAP_TYPE_tt__PropertyOperation
#define SOAP_TYPE_tt__PropertyOperation (331)
#endif

/* enum tt__ImageStabilizationMode has binding name 'tt__ImageStabilizationMode' for type 'tt:ImageStabilizationMode' */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode
#define SOAP_TYPE_tt__ImageStabilizationMode (329)
#endif

/* enum tt__IrCutFilterMode has binding name 'tt__IrCutFilterMode' for type 'tt:IrCutFilterMode' */
#ifndef SOAP_TYPE_tt__IrCutFilterMode
#define SOAP_TYPE_tt__IrCutFilterMode (327)
#endif

/* enum tt__WhiteBalanceMode has binding name 'tt__WhiteBalanceMode' for type 'tt:WhiteBalanceMode' */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode
#define SOAP_TYPE_tt__WhiteBalanceMode (325)
#endif

/* enum tt__ExposureMode has binding name 'tt__ExposureMode' for type 'tt:ExposureMode' */
#ifndef SOAP_TYPE_tt__ExposureMode
#define SOAP_TYPE_tt__ExposureMode (323)
#endif

/* enum tt__ExposurePriority has binding name 'tt__ExposurePriority' for type 'tt:ExposurePriority' */
#ifndef SOAP_TYPE_tt__ExposurePriority
#define SOAP_TYPE_tt__ExposurePriority (321)
#endif

/* enum tt__BacklightCompensationMode has binding name 'tt__BacklightCompensationMode' for type 'tt:BacklightCompensationMode' */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode
#define SOAP_TYPE_tt__BacklightCompensationMode (319)
#endif

/* enum tt__WideDynamicMode has binding name 'tt__WideDynamicMode' for type 'tt:WideDynamicMode' */
#ifndef SOAP_TYPE_tt__WideDynamicMode
#define SOAP_TYPE_tt__WideDynamicMode (317)
#endif

/* enum tt__AutoFocusMode has binding name 'tt__AutoFocusMode' for type 'tt:AutoFocusMode' */
#ifndef SOAP_TYPE_tt__AutoFocusMode
#define SOAP_TYPE_tt__AutoFocusMode (315)
#endif

/* enum tt__ReverseMode has binding name 'tt__ReverseMode' for type 'tt:ReverseMode' */
#ifndef SOAP_TYPE_tt__ReverseMode
#define SOAP_TYPE_tt__ReverseMode (313)
#endif

/* enum tt__EFlipMode has binding name 'tt__EFlipMode' for type 'tt:EFlipMode' */
#ifndef SOAP_TYPE_tt__EFlipMode
#define SOAP_TYPE_tt__EFlipMode (311)
#endif

/* enum tt__IPType has binding name 'tt__IPType' for type 'tt:IPType' */
#ifndef SOAP_TYPE_tt__IPType
#define SOAP_TYPE_tt__IPType (309)
#endif

/* enum tt__AudioEncoding has binding name 'tt__AudioEncoding' for type 'tt:AudioEncoding' */
#ifndef SOAP_TYPE_tt__AudioEncoding
#define SOAP_TYPE_tt__AudioEncoding (303)
#endif

/* enum tt__H264Profile has binding name 'tt__H264Profile' for type 'tt:H264Profile' */
#ifndef SOAP_TYPE_tt__H264Profile
#define SOAP_TYPE_tt__H264Profile (301)
#endif

/* enum tt__Mpeg4Profile has binding name 'tt__Mpeg4Profile' for type 'tt:Mpeg4Profile' */
#ifndef SOAP_TYPE_tt__Mpeg4Profile
#define SOAP_TYPE_tt__Mpeg4Profile (299)
#endif

/* enum tt__VideoEncoding has binding name 'tt__VideoEncoding' for type 'tt:VideoEncoding' */
#ifndef SOAP_TYPE_tt__VideoEncoding
#define SOAP_TYPE_tt__VideoEncoding (297)
#endif

/* enum tt__SceneOrientationMode has binding name 'tt__SceneOrientationMode' for type 'tt:SceneOrientationMode' */
#ifndef SOAP_TYPE_tt__SceneOrientationMode
#define SOAP_TYPE_tt__SceneOrientationMode (295)
#endif

/* enum tt__RotateMode has binding name 'tt__RotateMode' for type 'tt:RotateMode' */
#ifndef SOAP_TYPE_tt__RotateMode
#define SOAP_TYPE_tt__RotateMode (293)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (77)
#endif

/* enum _wsa5__IsReferenceParameter has binding name '_wsa5__IsReferenceParameter' for type 'wsa5:IsReferenceParameter' */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (40)
#endif

/* enum wsa5__FaultCodesType has binding name 'wsa5__FaultCodesType' for type 'wsa5:FaultCodesType' */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (20)
#endif

/* enum wsa5__RelationshipType has binding name 'wsa5__RelationshipType' for type 'wsa5:RelationshipType' */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (19)
#endif

/* _wstop__TopicNamespaceType_Topic has binding name '_wstop__TopicNamespaceType_Topic' for type '' */
#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (494)
#endif

/* _wsrfbf__BaseFaultType_FaultCause has binding name '_wsrfbf__BaseFaultType_FaultCause' for type '' */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (474)
#endif

/* _wsrfbf__BaseFaultType_Description has binding name '_wsrfbf__BaseFaultType_Description' for type '' */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description (471)
#endif

/* _wsrfbf__BaseFaultType_ErrorCode has binding name '_wsrfbf__BaseFaultType_ErrorCode' for type '' */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (469)
#endif

/* _wsnt__Subscribe_SubscriptionPolicy has binding name '_wsnt__Subscribe_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (466)
#endif

/* _wsnt__NotificationMessageHolderType_Message has binding name '_wsnt__NotificationMessageHolderType_Message' for type '' */
#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (457)
#endif

/* _tt__ItemList_ElementItem has binding name '_tt__ItemList_ElementItem' for type '' */
#ifndef SOAP_TYPE__tt__ItemList_ElementItem
#define SOAP_TYPE__tt__ItemList_ElementItem (442)
#endif

/* _tt__ItemList_SimpleItem has binding name '_tt__ItemList_SimpleItem' for type '' */
#ifndef SOAP_TYPE__tt__ItemList_SimpleItem
#define SOAP_TYPE__tt__ItemList_SimpleItem (440)
#endif

/* _tt__EventSubscription_SubscriptionPolicy has binding name '_tt__EventSubscription_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (362)
#endif

/* wstop__ConcreteTopicExpression__ has binding name 'wstop__ConcreteTopicExpression__' for type 'wstop:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression__
#define SOAP_TYPE_wstop__ConcreteTopicExpression__ (338)
#endif

/* wstop__ConcreteTopicExpression has binding name 'wstop__ConcreteTopicExpression' for type 'wstop:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (337)
#endif

/* tt__MoveStatus_ has binding name 'tt__MoveStatus_' for type 'tt:MoveStatus' */
#ifndef SOAP_TYPE_tt__MoveStatus_
#define SOAP_TYPE_tt__MoveStatus_ (336)
#endif

/* tt__ReferenceToken__ has binding name 'tt__ReferenceToken__' for type 'tt:ReferenceToken' */
#ifndef SOAP_TYPE_tt__ReferenceToken__
#define SOAP_TYPE_tt__ReferenceToken__ (334)
#endif

/* tt__ReferenceToken has binding name 'tt__ReferenceToken' for type 'tt:ReferenceToken' */
#ifndef SOAP_TYPE_tt__ReferenceToken
#define SOAP_TYPE_tt__ReferenceToken (333)
#endif

/* tt__PropertyOperation_ has binding name 'tt__PropertyOperation_' for type 'tt:PropertyOperation' */
#ifndef SOAP_TYPE_tt__PropertyOperation_
#define SOAP_TYPE_tt__PropertyOperation_ (332)
#endif

/* tt__ImageStabilizationMode_ has binding name 'tt__ImageStabilizationMode_' for type 'tt:ImageStabilizationMode' */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode_
#define SOAP_TYPE_tt__ImageStabilizationMode_ (330)
#endif

/* tt__IrCutFilterMode_ has binding name 'tt__IrCutFilterMode_' for type 'tt:IrCutFilterMode' */
#ifndef SOAP_TYPE_tt__IrCutFilterMode_
#define SOAP_TYPE_tt__IrCutFilterMode_ (328)
#endif

/* tt__WhiteBalanceMode_ has binding name 'tt__WhiteBalanceMode_' for type 'tt:WhiteBalanceMode' */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode_
#define SOAP_TYPE_tt__WhiteBalanceMode_ (326)
#endif

/* tt__ExposureMode_ has binding name 'tt__ExposureMode_' for type 'tt:ExposureMode' */
#ifndef SOAP_TYPE_tt__ExposureMode_
#define SOAP_TYPE_tt__ExposureMode_ (324)
#endif

/* tt__ExposurePriority_ has binding name 'tt__ExposurePriority_' for type 'tt:ExposurePriority' */
#ifndef SOAP_TYPE_tt__ExposurePriority_
#define SOAP_TYPE_tt__ExposurePriority_ (322)
#endif

/* tt__BacklightCompensationMode_ has binding name 'tt__BacklightCompensationMode_' for type 'tt:BacklightCompensationMode' */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode_
#define SOAP_TYPE_tt__BacklightCompensationMode_ (320)
#endif

/* tt__WideDynamicMode_ has binding name 'tt__WideDynamicMode_' for type 'tt:WideDynamicMode' */
#ifndef SOAP_TYPE_tt__WideDynamicMode_
#define SOAP_TYPE_tt__WideDynamicMode_ (318)
#endif

/* tt__AutoFocusMode_ has binding name 'tt__AutoFocusMode_' for type 'tt:AutoFocusMode' */
#ifndef SOAP_TYPE_tt__AutoFocusMode_
#define SOAP_TYPE_tt__AutoFocusMode_ (316)
#endif

/* tt__ReverseMode_ has binding name 'tt__ReverseMode_' for type 'tt:ReverseMode' */
#ifndef SOAP_TYPE_tt__ReverseMode_
#define SOAP_TYPE_tt__ReverseMode_ (314)
#endif

/* tt__EFlipMode_ has binding name 'tt__EFlipMode_' for type 'tt:EFlipMode' */
#ifndef SOAP_TYPE_tt__EFlipMode_
#define SOAP_TYPE_tt__EFlipMode_ (312)
#endif

/* tt__IPType_ has binding name 'tt__IPType_' for type 'tt:IPType' */
#ifndef SOAP_TYPE_tt__IPType_
#define SOAP_TYPE_tt__IPType_ (310)
#endif

/* tt__IPv6Address__ has binding name 'tt__IPv6Address__' for type 'tt:IPv6Address' */
#ifndef SOAP_TYPE_tt__IPv6Address__
#define SOAP_TYPE_tt__IPv6Address__ (308)
#endif

/* tt__IPv6Address has binding name 'tt__IPv6Address' for type 'tt:IPv6Address' */
#ifndef SOAP_TYPE_tt__IPv6Address
#define SOAP_TYPE_tt__IPv6Address (307)
#endif

/* tt__IPv4Address__ has binding name 'tt__IPv4Address__' for type 'tt:IPv4Address' */
#ifndef SOAP_TYPE_tt__IPv4Address__
#define SOAP_TYPE_tt__IPv4Address__ (306)
#endif

/* tt__IPv4Address has binding name 'tt__IPv4Address' for type 'tt:IPv4Address' */
#ifndef SOAP_TYPE_tt__IPv4Address
#define SOAP_TYPE_tt__IPv4Address (305)
#endif

/* tt__AudioEncoding_ has binding name 'tt__AudioEncoding_' for type 'tt:AudioEncoding' */
#ifndef SOAP_TYPE_tt__AudioEncoding_
#define SOAP_TYPE_tt__AudioEncoding_ (304)
#endif

/* tt__H264Profile_ has binding name 'tt__H264Profile_' for type 'tt:H264Profile' */
#ifndef SOAP_TYPE_tt__H264Profile_
#define SOAP_TYPE_tt__H264Profile_ (302)
#endif

/* tt__Mpeg4Profile_ has binding name 'tt__Mpeg4Profile_' for type 'tt:Mpeg4Profile' */
#ifndef SOAP_TYPE_tt__Mpeg4Profile_
#define SOAP_TYPE_tt__Mpeg4Profile_ (300)
#endif

/* tt__VideoEncoding_ has binding name 'tt__VideoEncoding_' for type 'tt:VideoEncoding' */
#ifndef SOAP_TYPE_tt__VideoEncoding_
#define SOAP_TYPE_tt__VideoEncoding_ (298)
#endif

/* tt__SceneOrientationMode_ has binding name 'tt__SceneOrientationMode_' for type 'tt:SceneOrientationMode' */
#ifndef SOAP_TYPE_tt__SceneOrientationMode_
#define SOAP_TYPE_tt__SceneOrientationMode_ (296)
#endif

/* tt__RotateMode_ has binding name 'tt__RotateMode_' for type 'tt:RotateMode' */
#ifndef SOAP_TYPE_tt__RotateMode_
#define SOAP_TYPE_tt__RotateMode_ (294)
#endif

/* tt__Name__ has binding name 'tt__Name__' for type 'tt:Name' */
#ifndef SOAP_TYPE_tt__Name__
#define SOAP_TYPE_tt__Name__ (292)
#endif

/* tt__Name has binding name 'tt__Name' for type 'tt:Name' */
#ifndef SOAP_TYPE_tt__Name
#define SOAP_TYPE_tt__Name (291)
#endif

/* wsnt__AbsoluteOrRelativeTimeType has binding name 'wsnt__AbsoluteOrRelativeTimeType' for type 'wsnt:AbsoluteOrRelativeTimeType' */
#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (290)
#endif

/* tt__StringList has binding name 'tt__StringList' for type 'tt:StringList' */
#ifndef SOAP_TYPE_tt__StringList
#define SOAP_TYPE_tt__StringList (289)
#endif

/* tt__StringAttrList has binding name 'tt__StringAttrList' for type 'tt:StringAttrList' */
#ifndef SOAP_TYPE_tt__StringAttrList
#define SOAP_TYPE_tt__StringAttrList (288)
#endif

/* tt__FloatList has binding name 'tt__FloatList' for type 'tt:FloatList' */
#ifndef SOAP_TYPE_tt__FloatList
#define SOAP_TYPE_tt__FloatList (287)
#endif

/* tt__IntList has binding name 'tt__IntList' for type 'tt:IntList' */
#ifndef SOAP_TYPE_tt__IntList
#define SOAP_TYPE_tt__IntList (286)
#endif

/* wstop__TopicSetType has binding name 'wstop__TopicSetType' for type 'wstop:TopicSetType' */
#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (285)
#endif

/* wstop__TopicType has binding name 'wstop__TopicType' for type 'wstop:TopicType' */
#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (284)
#endif

/* wstop__TopicNamespaceType has binding name 'wstop__TopicNamespaceType' for type 'wstop:TopicNamespaceType' */
#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (283)
#endif

/* wstop__QueryExpressionType has binding name 'wstop__QueryExpressionType' for type 'wstop:QueryExpressionType' */
#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (282)
#endif

/* wstop__ExtensibleDocumented has binding name 'wstop__ExtensibleDocumented' for type 'wstop:ExtensibleDocumented' */
#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (281)
#endif

/* wstop__Documentation has binding name 'wstop__Documentation' for type 'wstop:Documentation' */
#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (280)
#endif

/* wsrfbf__BaseFaultType has binding name 'wsrfbf__BaseFaultType' for type 'wsrfbf:BaseFaultType' */
#ifndef SOAP_TYPE_wsrfbf__BaseFaultType
#define SOAP_TYPE_wsrfbf__BaseFaultType (279)
#endif

/* _wsnt__ResumeSubscriptionResponse has binding name '_wsnt__ResumeSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (278)
#endif

/* _wsnt__ResumeSubscription has binding name '_wsnt__ResumeSubscription' for type '' */
#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (277)
#endif

/* _wsnt__PauseSubscriptionResponse has binding name '_wsnt__PauseSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (276)
#endif

/* _wsnt__PauseSubscription has binding name '_wsnt__PauseSubscription' for type '' */
#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (275)
#endif

/* _wsnt__UnsubscribeResponse has binding name '_wsnt__UnsubscribeResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (274)
#endif

/* _wsnt__Unsubscribe has binding name '_wsnt__Unsubscribe' for type '' */
#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (273)
#endif

/* _wsnt__RenewResponse has binding name '_wsnt__RenewResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (272)
#endif

/* _wsnt__Renew has binding name '_wsnt__Renew' for type '' */
#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (271)
#endif

/* _wsnt__CreatePullPointResponse has binding name '_wsnt__CreatePullPointResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (270)
#endif

/* _wsnt__CreatePullPoint has binding name '_wsnt__CreatePullPoint' for type '' */
#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (269)
#endif

/* _wsnt__DestroyPullPointResponse has binding name '_wsnt__DestroyPullPointResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (268)
#endif

/* _wsnt__DestroyPullPoint has binding name '_wsnt__DestroyPullPoint' for type '' */
#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (267)
#endif

/* _wsnt__GetMessagesResponse has binding name '_wsnt__GetMessagesResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (266)
#endif

/* _wsnt__GetMessages has binding name '_wsnt__GetMessages' for type '' */
#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (265)
#endif

/* _wsnt__GetCurrentMessageResponse has binding name '_wsnt__GetCurrentMessageResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (264)
#endif

/* _wsnt__GetCurrentMessage has binding name '_wsnt__GetCurrentMessage' for type '' */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (263)
#endif

/* _wsnt__SubscribeResponse has binding name '_wsnt__SubscribeResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (262)
#endif

/* _wsnt__Subscribe has binding name '_wsnt__Subscribe' for type '' */
#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (261)
#endif

/* _wsnt__UseRaw has binding name '_wsnt__UseRaw' for type '' */
#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (260)
#endif

/* _wsnt__Notify has binding name '_wsnt__Notify' for type '' */
#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (259)
#endif

/* _wsnt__SubscriptionManagerRP has binding name '_wsnt__SubscriptionManagerRP' for type '' */
#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (258)
#endif

/* _wsnt__NotificationProducerRP has binding name '_wsnt__NotificationProducerRP' for type '' */
#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (257)
#endif

/* wsnt__ResumeFailedFaultType has binding name 'wsnt__ResumeFailedFaultType' for type 'wsnt:ResumeFailedFaultType' */
#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (256)
#endif

/* wsnt__PauseFailedFaultType has binding name 'wsnt__PauseFailedFaultType' for type 'wsnt:PauseFailedFaultType' */
#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (255)
#endif

/* wsnt__UnableToDestroySubscriptionFaultType has binding name 'wsnt__UnableToDestroySubscriptionFaultType' for type 'wsnt:UnableToDestroySubscriptionFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (254)
#endif

/* wsnt__UnacceptableTerminationTimeFaultType has binding name 'wsnt__UnacceptableTerminationTimeFaultType' for type 'wsnt:UnacceptableTerminationTimeFaultType' */
#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (253)
#endif

/* wsnt__UnableToCreatePullPointFaultType has binding name 'wsnt__UnableToCreatePullPointFaultType' for type 'wsnt:UnableToCreatePullPointFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (252)
#endif

/* wsnt__UnableToDestroyPullPointFaultType has binding name 'wsnt__UnableToDestroyPullPointFaultType' for type 'wsnt:UnableToDestroyPullPointFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (251)
#endif

/* wsnt__UnableToGetMessagesFaultType has binding name 'wsnt__UnableToGetMessagesFaultType' for type 'wsnt:UnableToGetMessagesFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (250)
#endif

/* wsnt__NoCurrentMessageOnTopicFaultType has binding name 'wsnt__NoCurrentMessageOnTopicFaultType' for type 'wsnt:NoCurrentMessageOnTopicFaultType' */
#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (249)
#endif

/* wsnt__UnacceptableInitialTerminationTimeFaultType has binding name 'wsnt__UnacceptableInitialTerminationTimeFaultType' for type 'wsnt:UnacceptableInitialTerminationTimeFaultType' */
#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (248)
#endif

/* wsnt__NotifyMessageNotSupportedFaultType has binding name 'wsnt__NotifyMessageNotSupportedFaultType' for type 'wsnt:NotifyMessageNotSupportedFaultType' */
#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (247)
#endif

/* wsnt__UnsupportedPolicyRequestFaultType has binding name 'wsnt__UnsupportedPolicyRequestFaultType' for type 'wsnt:UnsupportedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (246)
#endif

/* wsnt__UnrecognizedPolicyRequestFaultType has binding name 'wsnt__UnrecognizedPolicyRequestFaultType' for type 'wsnt:UnrecognizedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (245)
#endif

/* wsnt__InvalidMessageContentExpressionFaultType has binding name 'wsnt__InvalidMessageContentExpressionFaultType' for type 'wsnt:InvalidMessageContentExpressionFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (244)
#endif

/* wsnt__InvalidProducerPropertiesExpressionFaultType has binding name 'wsnt__InvalidProducerPropertiesExpressionFaultType' for type 'wsnt:InvalidProducerPropertiesExpressionFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (243)
#endif

/* wsnt__MultipleTopicsSpecifiedFaultType has binding name 'wsnt__MultipleTopicsSpecifiedFaultType' for type 'wsnt:MultipleTopicsSpecifiedFaultType' */
#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (242)
#endif

/* wsnt__TopicNotSupportedFaultType has binding name 'wsnt__TopicNotSupportedFaultType' for type 'wsnt:TopicNotSupportedFaultType' */
#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (241)
#endif

/* wsnt__InvalidTopicExpressionFaultType has binding name 'wsnt__InvalidTopicExpressionFaultType' for type 'wsnt:InvalidTopicExpressionFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (240)
#endif

/* wsnt__TopicExpressionDialectUnknownFaultType has binding name 'wsnt__TopicExpressionDialectUnknownFaultType' for type 'wsnt:TopicExpressionDialectUnknownFaultType' */
#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (239)
#endif

/* wsnt__InvalidFilterFaultType has binding name 'wsnt__InvalidFilterFaultType' for type 'wsnt:InvalidFilterFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (238)
#endif

/* wsnt__SubscribeCreationFailedFaultType has binding name 'wsnt__SubscribeCreationFailedFaultType' for type 'wsnt:SubscribeCreationFailedFaultType' */
#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (237)
#endif

/* wsnt__NotificationMessageHolderType has binding name 'wsnt__NotificationMessageHolderType' for type 'wsnt:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (236)
#endif

/* wsnt__SubscriptionPolicyType has binding name 'wsnt__SubscriptionPolicyType' for type 'wsnt:SubscriptionPolicyType' */
#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (235)
#endif

/* wsnt__FilterType has binding name 'wsnt__FilterType' for type 'wsnt:FilterType' */
#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (234)
#endif

/* wsnt__TopicExpressionType has binding name 'wsnt__TopicExpressionType' for type 'wsnt:TopicExpressionType' */
#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (233)
#endif

/* wsnt__QueryExpressionType has binding name 'wsnt__QueryExpressionType' for type 'wsnt:QueryExpressionType' */
#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (232)
#endif

/* _tt__Message has binding name '_tt__Message' for type '' */
#ifndef SOAP_TYPE__tt__Message
#define SOAP_TYPE__tt__Message (231)
#endif

/* _tt__StringItems has binding name '_tt__StringItems' for type '' */
#ifndef SOAP_TYPE__tt__StringItems
#define SOAP_TYPE__tt__StringItems (230)
#endif

/* tt__Polygon has binding name 'tt__Polygon' for type 'tt:Polygon' */
#ifndef SOAP_TYPE_tt__Polygon
#define SOAP_TYPE_tt__Polygon (229)
#endif

/* tt__Rectangle has binding name 'tt__Rectangle' for type 'tt:Rectangle' */
#ifndef SOAP_TYPE_tt__Rectangle
#define SOAP_TYPE_tt__Rectangle (228)
#endif

/* tt__Vector has binding name 'tt__Vector' for type 'tt:Vector' */
#ifndef SOAP_TYPE_tt__Vector
#define SOAP_TYPE_tt__Vector (227)
#endif

/* tt__Vector1D has binding name 'tt__Vector1D' for type 'tt:Vector1D' */
#ifndef SOAP_TYPE_tt__Vector1D
#define SOAP_TYPE_tt__Vector1D (226)
#endif

/* tt__Vector2D has binding name 'tt__Vector2D' for type 'tt:Vector2D' */
#ifndef SOAP_TYPE_tt__Vector2D
#define SOAP_TYPE_tt__Vector2D (225)
#endif

/* tt__IntRange has binding name 'tt__IntRange' for type 'tt:IntRange' */
#ifndef SOAP_TYPE_tt__IntRange
#define SOAP_TYPE_tt__IntRange (224)
#endif

/* tt__PolygonOptions has binding name 'tt__PolygonOptions' for type 'tt:PolygonOptions' */
#ifndef SOAP_TYPE_tt__PolygonOptions
#define SOAP_TYPE_tt__PolygonOptions (223)
#endif

/* tt__Config has binding name 'tt__Config' for type 'tt:Config' */
#ifndef SOAP_TYPE_tt__Config
#define SOAP_TYPE_tt__Config (222)
#endif

/* tt__RuleEngineConfigurationExtension has binding name 'tt__RuleEngineConfigurationExtension' for type 'tt:RuleEngineConfigurationExtension' */
#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension (221)
#endif

/* tt__RuleEngineConfiguration has binding name 'tt__RuleEngineConfiguration' for type 'tt:RuleEngineConfiguration' */
#ifndef SOAP_TYPE_tt__RuleEngineConfiguration
#define SOAP_TYPE_tt__RuleEngineConfiguration (220)
#endif

/* tt__AnalyticsEngineConfigurationExtension has binding name 'tt__AnalyticsEngineConfigurationExtension' for type 'tt:AnalyticsEngineConfigurationExtension' */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (219)
#endif

/* tt__AnalyticsEngineConfiguration has binding name 'tt__AnalyticsEngineConfiguration' for type 'tt:AnalyticsEngineConfiguration' */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration (218)
#endif

/* tt__Polyline has binding name 'tt__Polyline' for type 'tt:Polyline' */
#ifndef SOAP_TYPE_tt__Polyline
#define SOAP_TYPE_tt__Polyline (217)
#endif

/* tt__ItemListExtension has binding name 'tt__ItemListExtension' for type 'tt:ItemListExtension' */
#ifndef SOAP_TYPE_tt__ItemListExtension
#define SOAP_TYPE_tt__ItemListExtension (216)
#endif

/* tt__ItemList has binding name 'tt__ItemList' for type 'tt:ItemList' */
#ifndef SOAP_TYPE_tt__ItemList
#define SOAP_TYPE_tt__ItemList (215)
#endif

/* tt__MessageExtension has binding name 'tt__MessageExtension' for type 'tt:MessageExtension' */
#ifndef SOAP_TYPE_tt__MessageExtension
#define SOAP_TYPE_tt__MessageExtension (214)
#endif

/* tt__NoiseReductionOptions has binding name 'tt__NoiseReductionOptions' for type 'tt:NoiseReductionOptions' */
#ifndef SOAP_TYPE_tt__NoiseReductionOptions
#define SOAP_TYPE_tt__NoiseReductionOptions (213)
#endif

/* tt__DefoggingOptions has binding name 'tt__DefoggingOptions' for type 'tt:DefoggingOptions' */
#ifndef SOAP_TYPE_tt__DefoggingOptions
#define SOAP_TYPE_tt__DefoggingOptions (212)
#endif

/* tt__ToneCompensationOptions has binding name 'tt__ToneCompensationOptions' for type 'tt:ToneCompensationOptions' */
#ifndef SOAP_TYPE_tt__ToneCompensationOptions
#define SOAP_TYPE_tt__ToneCompensationOptions (211)
#endif

/* tt__FocusOptions20Extension has binding name 'tt__FocusOptions20Extension' for type 'tt:FocusOptions20Extension' */
#ifndef SOAP_TYPE_tt__FocusOptions20Extension
#define SOAP_TYPE_tt__FocusOptions20Extension (210)
#endif

/* tt__FocusOptions20 has binding name 'tt__FocusOptions20' for type 'tt:FocusOptions20' */
#ifndef SOAP_TYPE_tt__FocusOptions20
#define SOAP_TYPE_tt__FocusOptions20 (209)
#endif

/* tt__WhiteBalanceOptions20Extension has binding name 'tt__WhiteBalanceOptions20Extension' for type 'tt:WhiteBalanceOptions20Extension' */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension (208)
#endif

/* tt__WhiteBalanceOptions20 has binding name 'tt__WhiteBalanceOptions20' for type 'tt:WhiteBalanceOptions20' */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20
#define SOAP_TYPE_tt__WhiteBalanceOptions20 (207)
#endif

/* tt__FocusConfiguration20Extension has binding name 'tt__FocusConfiguration20Extension' for type 'tt:FocusConfiguration20Extension' */
#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension
#define SOAP_TYPE_tt__FocusConfiguration20Extension (206)
#endif

/* tt__FocusConfiguration20 has binding name 'tt__FocusConfiguration20' for type 'tt:FocusConfiguration20' */
#ifndef SOAP_TYPE_tt__FocusConfiguration20
#define SOAP_TYPE_tt__FocusConfiguration20 (205)
#endif

/* tt__WhiteBalance20Extension has binding name 'tt__WhiteBalance20Extension' for type 'tt:WhiteBalance20Extension' */
#ifndef SOAP_TYPE_tt__WhiteBalance20Extension
#define SOAP_TYPE_tt__WhiteBalance20Extension (204)
#endif

/* tt__WhiteBalance20 has binding name 'tt__WhiteBalance20' for type 'tt:WhiteBalance20' */
#ifndef SOAP_TYPE_tt__WhiteBalance20
#define SOAP_TYPE_tt__WhiteBalance20 (203)
#endif

/* tt__RelativeFocusOptions20 has binding name 'tt__RelativeFocusOptions20' for type 'tt:RelativeFocusOptions20' */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions20
#define SOAP_TYPE_tt__RelativeFocusOptions20 (202)
#endif

/* tt__MoveOptions20 has binding name 'tt__MoveOptions20' for type 'tt:MoveOptions20' */
#ifndef SOAP_TYPE_tt__MoveOptions20
#define SOAP_TYPE_tt__MoveOptions20 (201)
#endif

/* tt__ExposureOptions20 has binding name 'tt__ExposureOptions20' for type 'tt:ExposureOptions20' */
#ifndef SOAP_TYPE_tt__ExposureOptions20
#define SOAP_TYPE_tt__ExposureOptions20 (200)
#endif

/* tt__BacklightCompensationOptions20 has binding name 'tt__BacklightCompensationOptions20' for type 'tt:BacklightCompensationOptions20' */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20
#define SOAP_TYPE_tt__BacklightCompensationOptions20 (199)
#endif

/* tt__WideDynamicRangeOptions20 has binding name 'tt__WideDynamicRangeOptions20' for type 'tt:WideDynamicRangeOptions20' */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20
#define SOAP_TYPE_tt__WideDynamicRangeOptions20 (198)
#endif

/* tt__IrCutFilterAutoAdjustmentOptionsExtension has binding name 'tt__IrCutFilterAutoAdjustmentOptionsExtension' for type 'tt:IrCutFilterAutoAdjustmentOptionsExtension' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension (197)
#endif

/* tt__IrCutFilterAutoAdjustmentOptions has binding name 'tt__IrCutFilterAutoAdjustmentOptions' for type 'tt:IrCutFilterAutoAdjustmentOptions' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions (196)
#endif

/* tt__ImageStabilizationOptionsExtension has binding name 'tt__ImageStabilizationOptionsExtension' for type 'tt:ImageStabilizationOptionsExtension' */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptionsExtension
#define SOAP_TYPE_tt__ImageStabilizationOptionsExtension (195)
#endif

/* tt__ImageStabilizationOptions has binding name 'tt__ImageStabilizationOptions' for type 'tt:ImageStabilizationOptions' */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptions
#define SOAP_TYPE_tt__ImageStabilizationOptions (194)
#endif

/* tt__ImagingOptions20Extension4 has binding name 'tt__ImagingOptions20Extension4' for type 'tt:ImagingOptions20Extension4' */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension4
#define SOAP_TYPE_tt__ImagingOptions20Extension4 (193)
#endif

/* tt__ImagingOptions20Extension3 has binding name 'tt__ImagingOptions20Extension3' for type 'tt:ImagingOptions20Extension3' */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension3
#define SOAP_TYPE_tt__ImagingOptions20Extension3 (192)
#endif

/* tt__ImagingOptions20Extension2 has binding name 'tt__ImagingOptions20Extension2' for type 'tt:ImagingOptions20Extension2' */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension2
#define SOAP_TYPE_tt__ImagingOptions20Extension2 (191)
#endif

/* tt__ImagingOptions20Extension has binding name 'tt__ImagingOptions20Extension' for type 'tt:ImagingOptions20Extension' */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension
#define SOAP_TYPE_tt__ImagingOptions20Extension (190)
#endif

/* tt__ImagingOptions20 has binding name 'tt__ImagingOptions20' for type 'tt:ImagingOptions20' */
#ifndef SOAP_TYPE_tt__ImagingOptions20
#define SOAP_TYPE_tt__ImagingOptions20 (189)
#endif

/* tt__NoiseReduction has binding name 'tt__NoiseReduction' for type 'tt:NoiseReduction' */
#ifndef SOAP_TYPE_tt__NoiseReduction
#define SOAP_TYPE_tt__NoiseReduction (188)
#endif

/* tt__DefoggingExtension has binding name 'tt__DefoggingExtension' for type 'tt:DefoggingExtension' */
#ifndef SOAP_TYPE_tt__DefoggingExtension
#define SOAP_TYPE_tt__DefoggingExtension (187)
#endif

/* tt__Defogging has binding name 'tt__Defogging' for type 'tt:Defogging' */
#ifndef SOAP_TYPE_tt__Defogging
#define SOAP_TYPE_tt__Defogging (186)
#endif

/* tt__ToneCompensationExtension has binding name 'tt__ToneCompensationExtension' for type 'tt:ToneCompensationExtension' */
#ifndef SOAP_TYPE_tt__ToneCompensationExtension
#define SOAP_TYPE_tt__ToneCompensationExtension (185)
#endif

/* tt__ToneCompensation has binding name 'tt__ToneCompensation' for type 'tt:ToneCompensation' */
#ifndef SOAP_TYPE_tt__ToneCompensation
#define SOAP_TYPE_tt__ToneCompensation (184)
#endif

/* tt__Exposure20 has binding name 'tt__Exposure20' for type 'tt:Exposure20' */
#ifndef SOAP_TYPE_tt__Exposure20
#define SOAP_TYPE_tt__Exposure20 (183)
#endif

/* tt__BacklightCompensation20 has binding name 'tt__BacklightCompensation20' for type 'tt:BacklightCompensation20' */
#ifndef SOAP_TYPE_tt__BacklightCompensation20
#define SOAP_TYPE_tt__BacklightCompensation20 (182)
#endif

/* tt__WideDynamicRange20 has binding name 'tt__WideDynamicRange20' for type 'tt:WideDynamicRange20' */
#ifndef SOAP_TYPE_tt__WideDynamicRange20
#define SOAP_TYPE_tt__WideDynamicRange20 (181)
#endif

/* tt__IrCutFilterAutoAdjustmentExtension has binding name 'tt__IrCutFilterAutoAdjustmentExtension' for type 'tt:IrCutFilterAutoAdjustmentExtension' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension (180)
#endif

/* tt__IrCutFilterAutoAdjustment has binding name 'tt__IrCutFilterAutoAdjustment' for type 'tt:IrCutFilterAutoAdjustment' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustment
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustment (179)
#endif

/* tt__ImageStabilizationExtension has binding name 'tt__ImageStabilizationExtension' for type 'tt:ImageStabilizationExtension' */
#ifndef SOAP_TYPE_tt__ImageStabilizationExtension
#define SOAP_TYPE_tt__ImageStabilizationExtension (178)
#endif

/* tt__ImageStabilization has binding name 'tt__ImageStabilization' for type 'tt:ImageStabilization' */
#ifndef SOAP_TYPE_tt__ImageStabilization
#define SOAP_TYPE_tt__ImageStabilization (177)
#endif

/* tt__ImagingSettingsExtension204 has binding name 'tt__ImagingSettingsExtension204' for type 'tt:ImagingSettingsExtension204' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension204
#define SOAP_TYPE_tt__ImagingSettingsExtension204 (176)
#endif

/* tt__ImagingSettingsExtension203 has binding name 'tt__ImagingSettingsExtension203' for type 'tt:ImagingSettingsExtension203' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension203
#define SOAP_TYPE_tt__ImagingSettingsExtension203 (175)
#endif

/* tt__ImagingSettingsExtension202 has binding name 'tt__ImagingSettingsExtension202' for type 'tt:ImagingSettingsExtension202' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension202
#define SOAP_TYPE_tt__ImagingSettingsExtension202 (174)
#endif

/* tt__ImagingSettingsExtension20 has binding name 'tt__ImagingSettingsExtension20' for type 'tt:ImagingSettingsExtension20' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20
#define SOAP_TYPE_tt__ImagingSettingsExtension20 (173)
#endif

/* tt__ImagingSettings20 has binding name 'tt__ImagingSettings20' for type 'tt:ImagingSettings20' */
#ifndef SOAP_TYPE_tt__ImagingSettings20
#define SOAP_TYPE_tt__ImagingSettings20 (172)
#endif

/* tt__FocusStatus20Extension has binding name 'tt__FocusStatus20Extension' for type 'tt:FocusStatus20Extension' */
#ifndef SOAP_TYPE_tt__FocusStatus20Extension
#define SOAP_TYPE_tt__FocusStatus20Extension (171)
#endif

/* tt__FocusStatus20 has binding name 'tt__FocusStatus20' for type 'tt:FocusStatus20' */
#ifndef SOAP_TYPE_tt__FocusStatus20
#define SOAP_TYPE_tt__FocusStatus20 (170)
#endif

/* tt__ImagingStatus20Extension has binding name 'tt__ImagingStatus20Extension' for type 'tt:ImagingStatus20Extension' */
#ifndef SOAP_TYPE_tt__ImagingStatus20Extension
#define SOAP_TYPE_tt__ImagingStatus20Extension (169)
#endif

/* tt__ImagingStatus20 has binding name 'tt__ImagingStatus20' for type 'tt:ImagingStatus20' */
#ifndef SOAP_TYPE_tt__ImagingStatus20
#define SOAP_TYPE_tt__ImagingStatus20 (168)
#endif

/* tt__ContinuousFocusOptions has binding name 'tt__ContinuousFocusOptions' for type 'tt:ContinuousFocusOptions' */
#ifndef SOAP_TYPE_tt__ContinuousFocusOptions
#define SOAP_TYPE_tt__ContinuousFocusOptions (167)
#endif

/* tt__AbsoluteFocusOptions has binding name 'tt__AbsoluteFocusOptions' for type 'tt:AbsoluteFocusOptions' */
#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions
#define SOAP_TYPE_tt__AbsoluteFocusOptions (166)
#endif

/* tt__ContinuousFocus has binding name 'tt__ContinuousFocus' for type 'tt:ContinuousFocus' */
#ifndef SOAP_TYPE_tt__ContinuousFocus
#define SOAP_TYPE_tt__ContinuousFocus (165)
#endif

/* tt__RelativeFocus has binding name 'tt__RelativeFocus' for type 'tt:RelativeFocus' */
#ifndef SOAP_TYPE_tt__RelativeFocus
#define SOAP_TYPE_tt__RelativeFocus (164)
#endif

/* tt__AbsoluteFocus has binding name 'tt__AbsoluteFocus' for type 'tt:AbsoluteFocus' */
#ifndef SOAP_TYPE_tt__AbsoluteFocus
#define SOAP_TYPE_tt__AbsoluteFocus (163)
#endif

/* tt__FocusMove has binding name 'tt__FocusMove' for type 'tt:FocusMove' */
#ifndef SOAP_TYPE_tt__FocusMove
#define SOAP_TYPE_tt__FocusMove (162)
#endif

/* tt__PTZSpeed has binding name 'tt__PTZSpeed' for type 'tt:PTZSpeed' */
#ifndef SOAP_TYPE_tt__PTZSpeed
#define SOAP_TYPE_tt__PTZSpeed (161)
#endif

/* tt__Space1DDescription has binding name 'tt__Space1DDescription' for type 'tt:Space1DDescription' */
#ifndef SOAP_TYPE_tt__Space1DDescription
#define SOAP_TYPE_tt__Space1DDescription (160)
#endif

/* tt__Space2DDescription has binding name 'tt__Space2DDescription' for type 'tt:Space2DDescription' */
#ifndef SOAP_TYPE_tt__Space2DDescription
#define SOAP_TYPE_tt__Space2DDescription (159)
#endif

/* tt__ZoomLimits has binding name 'tt__ZoomLimits' for type 'tt:ZoomLimits' */
#ifndef SOAP_TYPE_tt__ZoomLimits
#define SOAP_TYPE_tt__ZoomLimits (158)
#endif

/* tt__PanTiltLimits has binding name 'tt__PanTiltLimits' for type 'tt:PanTiltLimits' */
#ifndef SOAP_TYPE_tt__PanTiltLimits
#define SOAP_TYPE_tt__PanTiltLimits (157)
#endif

/* tt__Reverse has binding name 'tt__Reverse' for type 'tt:Reverse' */
#ifndef SOAP_TYPE_tt__Reverse
#define SOAP_TYPE_tt__Reverse (156)
#endif

/* tt__EFlip has binding name 'tt__EFlip' for type 'tt:EFlip' */
#ifndef SOAP_TYPE_tt__EFlip
#define SOAP_TYPE_tt__EFlip (155)
#endif

/* tt__PTControlDirectionExtension has binding name 'tt__PTControlDirectionExtension' for type 'tt:PTControlDirectionExtension' */
#ifndef SOAP_TYPE_tt__PTControlDirectionExtension
#define SOAP_TYPE_tt__PTControlDirectionExtension (154)
#endif

/* tt__PTControlDirection has binding name 'tt__PTControlDirection' for type 'tt:PTControlDirection' */
#ifndef SOAP_TYPE_tt__PTControlDirection
#define SOAP_TYPE_tt__PTControlDirection (153)
#endif

/* tt__PTZConfigurationExtension2 has binding name 'tt__PTZConfigurationExtension2' for type 'tt:PTZConfigurationExtension2' */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension2
#define SOAP_TYPE_tt__PTZConfigurationExtension2 (152)
#endif

/* tt__PTZConfigurationExtension has binding name 'tt__PTZConfigurationExtension' for type 'tt:PTZConfigurationExtension' */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension
#define SOAP_TYPE_tt__PTZConfigurationExtension (151)
#endif

/* tt__PTZConfiguration has binding name 'tt__PTZConfiguration' for type 'tt:PTZConfiguration' */
#ifndef SOAP_TYPE_tt__PTZConfiguration
#define SOAP_TYPE_tt__PTZConfiguration (150)
#endif

/* tt__IPAddress has binding name 'tt__IPAddress' for type 'tt:IPAddress' */
#ifndef SOAP_TYPE_tt__IPAddress
#define SOAP_TYPE_tt__IPAddress (149)
#endif

/* tt__MulticastConfiguration has binding name 'tt__MulticastConfiguration' for type 'tt:MulticastConfiguration' */
#ifndef SOAP_TYPE_tt__MulticastConfiguration
#define SOAP_TYPE_tt__MulticastConfiguration (148)
#endif

/* tt__AudioDecoderConfiguration has binding name 'tt__AudioDecoderConfiguration' for type 'tt:AudioDecoderConfiguration' */
#ifndef SOAP_TYPE_tt__AudioDecoderConfiguration
#define SOAP_TYPE_tt__AudioDecoderConfiguration (147)
#endif

/* tt__AudioOutputConfiguration has binding name 'tt__AudioOutputConfiguration' for type 'tt:AudioOutputConfiguration' */
#ifndef SOAP_TYPE_tt__AudioOutputConfiguration
#define SOAP_TYPE_tt__AudioOutputConfiguration (146)
#endif

/* tt__EventSubscription has binding name 'tt__EventSubscription' for type 'tt:EventSubscription' */
#ifndef SOAP_TYPE_tt__EventSubscription
#define SOAP_TYPE_tt__EventSubscription (145)
#endif

/* tt__PTZFilter has binding name 'tt__PTZFilter' for type 'tt:PTZFilter' */
#ifndef SOAP_TYPE_tt__PTZFilter
#define SOAP_TYPE_tt__PTZFilter (144)
#endif

/* tt__MetadataConfigurationExtension has binding name 'tt__MetadataConfigurationExtension' for type 'tt:MetadataConfigurationExtension' */
#ifndef SOAP_TYPE_tt__MetadataConfigurationExtension
#define SOAP_TYPE_tt__MetadataConfigurationExtension (143)
#endif

/* tt__MetadataConfiguration has binding name 'tt__MetadataConfiguration' for type 'tt:MetadataConfiguration' */
#ifndef SOAP_TYPE_tt__MetadataConfiguration
#define SOAP_TYPE_tt__MetadataConfiguration (142)
#endif

/* tt__VideoAnalyticsConfiguration has binding name 'tt__VideoAnalyticsConfiguration' for type 'tt:VideoAnalyticsConfiguration' */
#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration (141)
#endif

/* tt__AudioEncoderConfiguration has binding name 'tt__AudioEncoderConfiguration' for type 'tt:AudioEncoderConfiguration' */
#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration
#define SOAP_TYPE_tt__AudioEncoderConfiguration (140)
#endif

/* tt__AudioSourceConfiguration has binding name 'tt__AudioSourceConfiguration' for type 'tt:AudioSourceConfiguration' */
#ifndef SOAP_TYPE_tt__AudioSourceConfiguration
#define SOAP_TYPE_tt__AudioSourceConfiguration (139)
#endif

/* tt__H264Configuration has binding name 'tt__H264Configuration' for type 'tt:H264Configuration' */
#ifndef SOAP_TYPE_tt__H264Configuration
#define SOAP_TYPE_tt__H264Configuration (138)
#endif

/* tt__Mpeg4Configuration has binding name 'tt__Mpeg4Configuration' for type 'tt:Mpeg4Configuration' */
#ifndef SOAP_TYPE_tt__Mpeg4Configuration
#define SOAP_TYPE_tt__Mpeg4Configuration (137)
#endif

/* tt__VideoRateControl has binding name 'tt__VideoRateControl' for type 'tt:VideoRateControl' */
#ifndef SOAP_TYPE_tt__VideoRateControl
#define SOAP_TYPE_tt__VideoRateControl (136)
#endif

/* tt__VideoResolution has binding name 'tt__VideoResolution' for type 'tt:VideoResolution' */
#ifndef SOAP_TYPE_tt__VideoResolution
#define SOAP_TYPE_tt__VideoResolution (135)
#endif

/* tt__VideoEncoderConfiguration has binding name 'tt__VideoEncoderConfiguration' for type 'tt:VideoEncoderConfiguration' */
#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration
#define SOAP_TYPE_tt__VideoEncoderConfiguration (134)
#endif

/* tt__SceneOrientation has binding name 'tt__SceneOrientation' for type 'tt:SceneOrientation' */
#ifndef SOAP_TYPE_tt__SceneOrientation
#define SOAP_TYPE_tt__SceneOrientation (133)
#endif

/* tt__LensDescription has binding name 'tt__LensDescription' for type 'tt:LensDescription' */
#ifndef SOAP_TYPE_tt__LensDescription
#define SOAP_TYPE_tt__LensDescription (132)
#endif

/* tt__LensOffset has binding name 'tt__LensOffset' for type 'tt:LensOffset' */
#ifndef SOAP_TYPE_tt__LensOffset
#define SOAP_TYPE_tt__LensOffset (131)
#endif

/* tt__LensProjection has binding name 'tt__LensProjection' for type 'tt:LensProjection' */
#ifndef SOAP_TYPE_tt__LensProjection
#define SOAP_TYPE_tt__LensProjection (130)
#endif

/* tt__RotateExtension has binding name 'tt__RotateExtension' for type 'tt:RotateExtension' */
#ifndef SOAP_TYPE_tt__RotateExtension
#define SOAP_TYPE_tt__RotateExtension (129)
#endif

/* tt__Rotate has binding name 'tt__Rotate' for type 'tt:Rotate' */
#ifndef SOAP_TYPE_tt__Rotate
#define SOAP_TYPE_tt__Rotate (128)
#endif

/* tt__VideoSourceConfigurationExtension2 has binding name 'tt__VideoSourceConfigurationExtension2' for type 'tt:VideoSourceConfigurationExtension2' */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (127)
#endif

/* tt__VideoSourceConfigurationExtension has binding name 'tt__VideoSourceConfigurationExtension' for type 'tt:VideoSourceConfigurationExtension' */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension (126)
#endif

/* tt__VideoSourceConfiguration has binding name 'tt__VideoSourceConfiguration' for type 'tt:VideoSourceConfiguration' */
#ifndef SOAP_TYPE_tt__VideoSourceConfiguration
#define SOAP_TYPE_tt__VideoSourceConfiguration (125)
#endif

/* tt__ConfigurationEntity has binding name 'tt__ConfigurationEntity' for type 'tt:ConfigurationEntity' */
#ifndef SOAP_TYPE_tt__ConfigurationEntity
#define SOAP_TYPE_tt__ConfigurationEntity (124)
#endif

/* tt__DurationRange has binding name 'tt__DurationRange' for type 'tt:DurationRange' */
#ifndef SOAP_TYPE_tt__DurationRange
#define SOAP_TYPE_tt__DurationRange (123)
#endif

/* tt__FloatRange has binding name 'tt__FloatRange' for type 'tt:FloatRange' */
#ifndef SOAP_TYPE_tt__FloatRange
#define SOAP_TYPE_tt__FloatRange (122)
#endif

/* tt__IntRectangleRange has binding name 'tt__IntRectangleRange' for type 'tt:IntRectangleRange' */
#ifndef SOAP_TYPE_tt__IntRectangleRange
#define SOAP_TYPE_tt__IntRectangleRange (121)
#endif

/* tt__IntRectangle has binding name 'tt__IntRectangle' for type 'tt:IntRectangle' */
#ifndef SOAP_TYPE_tt__IntRectangle
#define SOAP_TYPE_tt__IntRectangle (120)
#endif

/* _timg__SetCurrentPresetResponse has binding name '_timg__SetCurrentPresetResponse' for type '' */
#ifndef SOAP_TYPE__timg__SetCurrentPresetResponse
#define SOAP_TYPE__timg__SetCurrentPresetResponse (119)
#endif

/* _timg__SetCurrentPreset has binding name '_timg__SetCurrentPreset' for type '' */
#ifndef SOAP_TYPE__timg__SetCurrentPreset
#define SOAP_TYPE__timg__SetCurrentPreset (118)
#endif

/* _timg__GetCurrentPresetResponse has binding name '_timg__GetCurrentPresetResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetCurrentPresetResponse
#define SOAP_TYPE__timg__GetCurrentPresetResponse (117)
#endif

/* _timg__GetCurrentPreset has binding name '_timg__GetCurrentPreset' for type '' */
#ifndef SOAP_TYPE__timg__GetCurrentPreset
#define SOAP_TYPE__timg__GetCurrentPreset (116)
#endif

/* _timg__GetPresetsResponse has binding name '_timg__GetPresetsResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetPresetsResponse
#define SOAP_TYPE__timg__GetPresetsResponse (115)
#endif

/* _timg__GetPresets has binding name '_timg__GetPresets' for type '' */
#ifndef SOAP_TYPE__timg__GetPresets
#define SOAP_TYPE__timg__GetPresets (114)
#endif

/* _timg__GetStatusResponse has binding name '_timg__GetStatusResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetStatusResponse
#define SOAP_TYPE__timg__GetStatusResponse (113)
#endif

/* _timg__GetStatus has binding name '_timg__GetStatus' for type '' */
#ifndef SOAP_TYPE__timg__GetStatus
#define SOAP_TYPE__timg__GetStatus (112)
#endif

/* _timg__StopResponse has binding name '_timg__StopResponse' for type '' */
#ifndef SOAP_TYPE__timg__StopResponse
#define SOAP_TYPE__timg__StopResponse (111)
#endif

/* _timg__Stop has binding name '_timg__Stop' for type '' */
#ifndef SOAP_TYPE__timg__Stop
#define SOAP_TYPE__timg__Stop (110)
#endif

/* _timg__GetMoveOptionsResponse has binding name '_timg__GetMoveOptionsResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetMoveOptionsResponse
#define SOAP_TYPE__timg__GetMoveOptionsResponse (109)
#endif

/* _timg__GetMoveOptions has binding name '_timg__GetMoveOptions' for type '' */
#ifndef SOAP_TYPE__timg__GetMoveOptions
#define SOAP_TYPE__timg__GetMoveOptions (108)
#endif

/* _timg__MoveResponse has binding name '_timg__MoveResponse' for type '' */
#ifndef SOAP_TYPE__timg__MoveResponse
#define SOAP_TYPE__timg__MoveResponse (107)
#endif

/* _timg__Move has binding name '_timg__Move' for type '' */
#ifndef SOAP_TYPE__timg__Move
#define SOAP_TYPE__timg__Move (106)
#endif

/* _timg__GetOptionsResponse has binding name '_timg__GetOptionsResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetOptionsResponse
#define SOAP_TYPE__timg__GetOptionsResponse (105)
#endif

/* _timg__GetOptions has binding name '_timg__GetOptions' for type '' */
#ifndef SOAP_TYPE__timg__GetOptions
#define SOAP_TYPE__timg__GetOptions (104)
#endif

/* _timg__SetImagingSettingsResponse has binding name '_timg__SetImagingSettingsResponse' for type '' */
#ifndef SOAP_TYPE__timg__SetImagingSettingsResponse
#define SOAP_TYPE__timg__SetImagingSettingsResponse (103)
#endif

/* _timg__SetImagingSettings has binding name '_timg__SetImagingSettings' for type '' */
#ifndef SOAP_TYPE__timg__SetImagingSettings
#define SOAP_TYPE__timg__SetImagingSettings (102)
#endif

/* _timg__GetImagingSettingsResponse has binding name '_timg__GetImagingSettingsResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetImagingSettingsResponse
#define SOAP_TYPE__timg__GetImagingSettingsResponse (101)
#endif

/* _timg__GetImagingSettings has binding name '_timg__GetImagingSettings' for type '' */
#ifndef SOAP_TYPE__timg__GetImagingSettings
#define SOAP_TYPE__timg__GetImagingSettings (100)
#endif

/* _timg__GetServiceCapabilitiesResponse has binding name '_timg__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetServiceCapabilitiesResponse
#define SOAP_TYPE__timg__GetServiceCapabilitiesResponse (99)
#endif

/* _timg__GetServiceCapabilities has binding name '_timg__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__timg__GetServiceCapabilities
#define SOAP_TYPE__timg__GetServiceCapabilities (98)
#endif

/* timg__ImagingPreset has binding name 'timg__ImagingPreset' for type 'timg:ImagingPreset' */
#ifndef SOAP_TYPE_timg__ImagingPreset
#define SOAP_TYPE_timg__ImagingPreset (97)
#endif

/* timg__Capabilities has binding name 'timg__Capabilities' for type 'timg:Capabilities' */
#ifndef SOAP_TYPE_timg__Capabilities
#define SOAP_TYPE_timg__Capabilities (96)
#endif

/* _xml__lang has binding name '_xml__lang' for type '' */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (95)
#endif

/* xsd__token__ has binding name 'xsd__token__' for type 'xsd:token' */
#ifndef SOAP_TYPE_xsd__token__
#define SOAP_TYPE_xsd__token__ (94)
#endif

/* xsd__token has binding name 'xsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (93)
#endif

/* xsd__string_ has binding name 'xsd__string_' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string_
#define SOAP_TYPE_xsd__string_ (92)
#endif

/* xsd__nonNegativeInteger__ has binding name 'xsd__nonNegativeInteger__' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger__
#define SOAP_TYPE_xsd__nonNegativeInteger__ (91)
#endif

/* xsd__nonNegativeInteger has binding name 'xsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (90)
#endif

/* xsd__integer__ has binding name 'xsd__integer__' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer__
#define SOAP_TYPE_xsd__integer__ (89)
#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (88)
#endif

/* xsd__int_ has binding name 'xsd__int_' for type 'xsd:int' */
#ifndef SOAP_TYPE_xsd__int_
#define SOAP_TYPE_xsd__int_ (87)
#endif

/* xsd__hexBinary__ has binding name 'xsd__hexBinary__' for type 'xsd:hexBinary' */
#ifndef SOAP_TYPE_xsd__hexBinary__
#define SOAP_TYPE_xsd__hexBinary__ (86)
#endif

/* xsd__float_ has binding name 'xsd__float_' for type 'xsd:float' */
#ifndef SOAP_TYPE_xsd__float_
#define SOAP_TYPE_xsd__float_ (84)
#endif

/* xsd__duration__ has binding name 'xsd__duration__' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration__
#define SOAP_TYPE_xsd__duration__ (83)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (82)
#endif

/* xsd__double_ has binding name 'xsd__double_' for type 'xsd:double' */
#ifndef SOAP_TYPE_xsd__double_
#define SOAP_TYPE_xsd__double_ (80)
#endif

/* xsd__dateTime_ has binding name 'xsd__dateTime_' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime_
#define SOAP_TYPE_xsd__dateTime_ (78)
#endif

/* xsd__boolean_ has binding name 'xsd__boolean_' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean_
#define SOAP_TYPE_xsd__boolean_ (76)
#endif

/* xsd__base64Binary__ has binding name 'xsd__base64Binary__' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary__
#define SOAP_TYPE_xsd__base64Binary__ (75)
#endif

/* xsd__anyURI__ has binding name 'xsd__anyURI__' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI__
#define SOAP_TYPE_xsd__anyURI__ (74)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (73)
#endif

/* xsd__anySimpleType__ has binding name 'xsd__anySimpleType__' for type 'xsd:anySimpleType' */
#ifndef SOAP_TYPE_xsd__anySimpleType__
#define SOAP_TYPE_xsd__anySimpleType__ (72)
#endif

/* xsd__anySimpleType has binding name 'xsd__anySimpleType' for type 'xsd:anySimpleType' */
#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (71)
#endif

/* xsd__QName__ has binding name 'xsd__QName__' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName__
#define SOAP_TYPE_xsd__QName__ (70)
#endif

/* xsd__NCName__ has binding name 'xsd__NCName__' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_xsd__NCName__
#define SOAP_TYPE_xsd__NCName__ (69)
#endif

/* xsd__NCName has binding name 'xsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (68)
#endif

/* SOAP_ENV__Fault_ has binding name 'SOAP_ENV__Fault_' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault_
#define SOAP_TYPE_SOAP_ENV__Fault_ (67)
#endif

/* SOAP_ENV__Envelope_ has binding name 'SOAP_ENV__Envelope_' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope_
#define SOAP_TYPE_SOAP_ENV__Envelope_ (66)
#endif

/* wsa5__EndpointReferenceType__ has binding name 'wsa5__EndpointReferenceType__' for type 'wsa5:EndpointReferenceType' */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType__
#define SOAP_TYPE_wsa5__EndpointReferenceType__ (65)
#endif

/* xsd__hexBinary has binding name 'xsd__hexBinary' for type 'xsd:hexBinary' */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (64)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (63)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (62)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (61)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (57)
#endif

/* struct SOAP_ENV__Envelope has binding name 'SOAP_ENV__Envelope' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (59)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (56)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (52)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (50)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (48)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (42)
#endif

/* struct chan__ChannelInstanceType has binding name 'chan__ChannelInstanceType' for type 'chan:ChannelInstanceType' */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (41)
#endif

/* _wsa5__ProblemAction has binding name '_wsa5__ProblemAction' for type '' */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (39)
#endif

/* _wsa5__FaultTo has binding name '_wsa5__FaultTo' for type '' */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (32)
#endif

/* _wsa5__From has binding name '_wsa5__From' for type '' */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (31)
#endif

/* _wsa5__ReplyTo has binding name '_wsa5__ReplyTo' for type '' */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (30)
#endif

/* _wsa5__RelatesTo has binding name '_wsa5__RelatesTo' for type '' */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (29)
#endif

/* _wsa5__Metadata has binding name '_wsa5__Metadata' for type '' */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (27)
#endif

/* _wsa5__ReferenceParameters has binding name '_wsa5__ReferenceParameters' for type '' */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (26)
#endif

/* _wsa5__EndpointReference has binding name '_wsa5__EndpointReference' for type '' */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (25)
#endif

/* struct wsa5__ProblemActionType has binding name 'wsa5__ProblemActionType' for type 'wsa5:ProblemActionType' */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (16)
#endif

/* struct wsa5__RelatesToType has binding name 'wsa5__RelatesToType' for type 'wsa5:RelatesToType' */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (15)
#endif

/* struct wsa5__MetadataType has binding name 'wsa5__MetadataType' for type 'wsa5:MetadataType' */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (14)
#endif

/* struct wsa5__ReferenceParametersType has binding name 'wsa5__ReferenceParametersType' for type 'wsa5:ReferenceParametersType' */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (13)
#endif

/* struct wsa5__EndpointReferenceType has binding name 'wsa5__EndpointReferenceType' for type 'wsa5:EndpointReferenceType' */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (12)
#endif

/* struct _xop__Include has binding name '_xop__Include' for type '' */
#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (8)
#endif

/* _timg__SetCurrentPreset * has binding name 'PointerTo_timg__SetCurrentPreset' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__SetCurrentPreset
#define SOAP_TYPE_PointerTo_timg__SetCurrentPreset (542)
#endif

/* _timg__GetCurrentPreset * has binding name 'PointerTo_timg__GetCurrentPreset' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetCurrentPreset
#define SOAP_TYPE_PointerTo_timg__GetCurrentPreset (538)
#endif

/* _timg__GetPresets * has binding name 'PointerTo_timg__GetPresets' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetPresets
#define SOAP_TYPE_PointerTo_timg__GetPresets (534)
#endif

/* _timg__GetMoveOptions * has binding name 'PointerTo_timg__GetMoveOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetMoveOptions
#define SOAP_TYPE_PointerTo_timg__GetMoveOptions (530)
#endif

/* _timg__GetStatus * has binding name 'PointerTo_timg__GetStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetStatus
#define SOAP_TYPE_PointerTo_timg__GetStatus (526)
#endif

/* _timg__Stop * has binding name 'PointerTo_timg__Stop' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__Stop
#define SOAP_TYPE_PointerTo_timg__Stop (522)
#endif

/* _timg__Move * has binding name 'PointerTo_timg__Move' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__Move
#define SOAP_TYPE_PointerTo_timg__Move (518)
#endif

/* _timg__GetOptions * has binding name 'PointerTo_timg__GetOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetOptions
#define SOAP_TYPE_PointerTo_timg__GetOptions (514)
#endif

/* _timg__SetImagingSettings * has binding name 'PointerTo_timg__SetImagingSettings' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__SetImagingSettings
#define SOAP_TYPE_PointerTo_timg__SetImagingSettings (510)
#endif

/* _timg__GetImagingSettings * has binding name 'PointerTo_timg__GetImagingSettings' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetImagingSettings
#define SOAP_TYPE_PointerTo_timg__GetImagingSettings (506)
#endif

/* _timg__GetServiceCapabilities * has binding name 'PointerTo_timg__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_timg__GetServiceCapabilities (502)
#endif

/* std::string * has binding name 'PointerToxsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_PointerToxsd__NCName
#define SOAP_TYPE_PointerToxsd__NCName (501)
#endif

/* std::string * has binding name 'PointerTowstop__ConcreteTopicExpression' for type 'wstop:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_PointerTowstop__ConcreteTopicExpression
#define SOAP_TYPE_PointerTowstop__ConcreteTopicExpression (499)
#endif

/* std::string * has binding name 'PointerToxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_PointerToxsd__QName
#define SOAP_TYPE_PointerToxsd__QName (498)
#endif

/* wstop__TopicType * has binding name 'PointerTowstop__TopicType' for type 'wstop:TopicType' */
#ifndef SOAP_TYPE_PointerTowstop__TopicType
#define SOAP_TYPE_PointerTowstop__TopicType (496)
#endif

/* wstop__QueryExpressionType * has binding name 'PointerTowstop__QueryExpressionType' for type 'wstop:QueryExpressionType' */
#ifndef SOAP_TYPE_PointerTowstop__QueryExpressionType
#define SOAP_TYPE_PointerTowstop__QueryExpressionType (495)
#endif

/* tt__PTZConfigurationExtension * has binding name 'PointerTott__PTZConfigurationExtension' for type 'tt:PTZConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZConfigurationExtension
#define SOAP_TYPE_PointerTott__PTZConfigurationExtension (492)
#endif

/* tt__ZoomLimits * has binding name 'PointerTott__ZoomLimits' for type 'tt:ZoomLimits' */
#ifndef SOAP_TYPE_PointerTott__ZoomLimits
#define SOAP_TYPE_PointerTott__ZoomLimits (491)
#endif

/* tt__PanTiltLimits * has binding name 'PointerTott__PanTiltLimits' for type 'tt:PanTiltLimits' */
#ifndef SOAP_TYPE_PointerTott__PanTiltLimits
#define SOAP_TYPE_PointerTott__PanTiltLimits (490)
#endif

/* tt__PTZSpeed * has binding name 'PointerTott__PTZSpeed' for type 'tt:PTZSpeed' */
#ifndef SOAP_TYPE_PointerTott__PTZSpeed
#define SOAP_TYPE_PointerTott__PTZSpeed (489)
#endif

/* tt__MetadataConfigurationExtension * has binding name 'PointerTott__MetadataConfigurationExtension' for type 'tt:MetadataConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__MetadataConfigurationExtension
#define SOAP_TYPE_PointerTott__MetadataConfigurationExtension (488)
#endif

/* tt__EventSubscription * has binding name 'PointerTott__EventSubscription' for type 'tt:EventSubscription' */
#ifndef SOAP_TYPE_PointerTott__EventSubscription
#define SOAP_TYPE_PointerTott__EventSubscription (487)
#endif

/* tt__PTZFilter * has binding name 'PointerTott__PTZFilter' for type 'tt:PTZFilter' */
#ifndef SOAP_TYPE_PointerTott__PTZFilter
#define SOAP_TYPE_PointerTott__PTZFilter (486)
#endif

/* tt__RuleEngineConfiguration * has binding name 'PointerTott__RuleEngineConfiguration' for type 'tt:RuleEngineConfiguration' */
#ifndef SOAP_TYPE_PointerTott__RuleEngineConfiguration
#define SOAP_TYPE_PointerTott__RuleEngineConfiguration (485)
#endif

/* tt__AnalyticsEngineConfiguration * has binding name 'PointerTott__AnalyticsEngineConfiguration' for type 'tt:AnalyticsEngineConfiguration' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration
#define SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration (484)
#endif

/* tt__MulticastConfiguration * has binding name 'PointerTott__MulticastConfiguration' for type 'tt:MulticastConfiguration' */
#ifndef SOAP_TYPE_PointerTott__MulticastConfiguration
#define SOAP_TYPE_PointerTott__MulticastConfiguration (483)
#endif

/* tt__H264Configuration * has binding name 'PointerTott__H264Configuration' for type 'tt:H264Configuration' */
#ifndef SOAP_TYPE_PointerTott__H264Configuration
#define SOAP_TYPE_PointerTott__H264Configuration (482)
#endif

/* tt__Mpeg4Configuration * has binding name 'PointerTott__Mpeg4Configuration' for type 'tt:Mpeg4Configuration' */
#ifndef SOAP_TYPE_PointerTott__Mpeg4Configuration
#define SOAP_TYPE_PointerTott__Mpeg4Configuration (481)
#endif

/* tt__VideoRateControl * has binding name 'PointerTott__VideoRateControl' for type 'tt:VideoRateControl' */
#ifndef SOAP_TYPE_PointerTott__VideoRateControl
#define SOAP_TYPE_PointerTott__VideoRateControl (480)
#endif

/* tt__VideoResolution * has binding name 'PointerTott__VideoResolution' for type 'tt:VideoResolution' */
#ifndef SOAP_TYPE_PointerTott__VideoResolution
#define SOAP_TYPE_PointerTott__VideoResolution (479)
#endif

/* tt__VideoSourceConfigurationExtension * has binding name 'PointerTott__VideoSourceConfigurationExtension' for type 'tt:VideoSourceConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension
#define SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension (478)
#endif

/* tt__IntRectangle * has binding name 'PointerTott__IntRectangle' for type 'tt:IntRectangle' */
#ifndef SOAP_TYPE_PointerTott__IntRectangle
#define SOAP_TYPE_PointerTott__IntRectangle (477)
#endif

/* wstop__Documentation * has binding name 'PointerTowstop__Documentation' for type 'wstop:Documentation' */
#ifndef SOAP_TYPE_PointerTowstop__Documentation
#define SOAP_TYPE_PointerTowstop__Documentation (476)
#endif

/* _wsrfbf__BaseFaultType_FaultCause * has binding name 'PointerTo_wsrfbf__BaseFaultType_FaultCause' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause (475)
#endif

/* std::string * has binding name 'PointerTo_xml__lang' for type '' */
#ifndef SOAP_TYPE_PointerTo_xml__lang
#define SOAP_TYPE_PointerTo_xml__lang (472)
#endif

/* _wsrfbf__BaseFaultType_ErrorCode * has binding name 'PointerTo_wsrfbf__BaseFaultType_ErrorCode' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode (470)
#endif

/* std::string * has binding name 'PointerToxsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_PointerToxsd__nonNegativeInteger
#define SOAP_TYPE_PointerToxsd__nonNegativeInteger (468)
#endif

/* _wsnt__Subscribe_SubscriptionPolicy * has binding name 'PointerTo_wsnt__Subscribe_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy (467)
#endif

/* std::string * has binding name 'PointerTowsnt__AbsoluteOrRelativeTimeType' for type 'wsnt:AbsoluteOrRelativeTimeType' */
#ifndef SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType (465)
#endif

/* wsnt__NotificationMessageHolderType * has binding name 'PointerTowsnt__NotificationMessageHolderType' for type 'wsnt:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType
#define SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType (463)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (462)
#endif

/* wsnt__SubscriptionPolicyType * has binding name 'PointerTowsnt__SubscriptionPolicyType' for type 'wsnt:SubscriptionPolicyType' */
#ifndef SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType
#define SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType (461)
#endif

/* wstop__TopicSetType * has binding name 'PointerTowstop__TopicSetType' for type 'wstop:TopicSetType' */
#ifndef SOAP_TYPE_PointerTowstop__TopicSetType
#define SOAP_TYPE_PointerTowstop__TopicSetType (460)
#endif

/* wsnt__TopicExpressionType * has binding name 'PointerTowsnt__TopicExpressionType' for type 'wsnt:TopicExpressionType' */
#ifndef SOAP_TYPE_PointerTowsnt__TopicExpressionType
#define SOAP_TYPE_PointerTowsnt__TopicExpressionType (456)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTowsa5__EndpointReferenceType' for type 'wsa5:EndpointReferenceType' */
#ifndef SOAP_TYPE_PointerTowsa5__EndpointReferenceType
#define SOAP_TYPE_PointerTowsa5__EndpointReferenceType (455)
#endif

/* enum tt__PropertyOperation * has binding name 'PointerTott__PropertyOperation' for type 'tt:PropertyOperation' */
#ifndef SOAP_TYPE_PointerTott__PropertyOperation
#define SOAP_TYPE_PointerTott__PropertyOperation (454)
#endif

/* tt__MessageExtension * has binding name 'PointerTott__MessageExtension' for type 'tt:MessageExtension' */
#ifndef SOAP_TYPE_PointerTott__MessageExtension
#define SOAP_TYPE_PointerTott__MessageExtension (453)
#endif

/* std::string * has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_PointerToxsd__anyURI
#define SOAP_TYPE_PointerToxsd__anyURI (452)
#endif

/* tt__ItemList * has binding name 'PointerTott__ItemList' for type 'tt:ItemList' */
#ifndef SOAP_TYPE_PointerTott__ItemList
#define SOAP_TYPE_PointerTott__ItemList (451)
#endif

/* tt__RuleEngineConfigurationExtension * has binding name 'PointerTott__RuleEngineConfigurationExtension' for type 'tt:RuleEngineConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension
#define SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension (450)
#endif

/* tt__AnalyticsEngineConfigurationExtension * has binding name 'PointerTott__AnalyticsEngineConfigurationExtension' for type 'tt:AnalyticsEngineConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension (449)
#endif

/* tt__Config * has binding name 'PointerTott__Config' for type 'tt:Config' */
#ifndef SOAP_TYPE_PointerTott__Config
#define SOAP_TYPE_PointerTott__Config (447)
#endif

/* tt__Vector * has binding name 'PointerTott__Vector' for type 'tt:Vector' */
#ifndef SOAP_TYPE_PointerTott__Vector
#define SOAP_TYPE_PointerTott__Vector (445)
#endif

/* tt__ItemListExtension * has binding name 'PointerTott__ItemListExtension' for type 'tt:ItemListExtension' */
#ifndef SOAP_TYPE_PointerTott__ItemListExtension
#define SOAP_TYPE_PointerTott__ItemListExtension (444)
#endif

/* tt__FocusOptions20Extension * has binding name 'PointerTott__FocusOptions20Extension' for type 'tt:FocusOptions20Extension' */
#ifndef SOAP_TYPE_PointerTott__FocusOptions20Extension
#define SOAP_TYPE_PointerTott__FocusOptions20Extension (439)
#endif

/* tt__WhiteBalanceOptions20Extension * has binding name 'PointerTott__WhiteBalanceOptions20Extension' for type 'tt:WhiteBalanceOptions20Extension' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension
#define SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension (437)
#endif

/* std::string * has binding name 'PointerTott__StringAttrList' for type 'tt:StringAttrList' */
#ifndef SOAP_TYPE_PointerTott__StringAttrList
#define SOAP_TYPE_PointerTott__StringAttrList (435)
#endif

/* tt__FocusConfiguration20Extension * has binding name 'PointerTott__FocusConfiguration20Extension' for type 'tt:FocusConfiguration20Extension' */
#ifndef SOAP_TYPE_PointerTott__FocusConfiguration20Extension
#define SOAP_TYPE_PointerTott__FocusConfiguration20Extension (434)
#endif

/* tt__WhiteBalance20Extension * has binding name 'PointerTott__WhiteBalance20Extension' for type 'tt:WhiteBalance20Extension' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalance20Extension
#define SOAP_TYPE_PointerTott__WhiteBalance20Extension (433)
#endif

/* tt__ContinuousFocusOptions * has binding name 'PointerTott__ContinuousFocusOptions' for type 'tt:ContinuousFocusOptions' */
#ifndef SOAP_TYPE_PointerTott__ContinuousFocusOptions
#define SOAP_TYPE_PointerTott__ContinuousFocusOptions (432)
#endif

/* tt__RelativeFocusOptions20 * has binding name 'PointerTott__RelativeFocusOptions20' for type 'tt:RelativeFocusOptions20' */
#ifndef SOAP_TYPE_PointerTott__RelativeFocusOptions20
#define SOAP_TYPE_PointerTott__RelativeFocusOptions20 (431)
#endif

/* tt__AbsoluteFocusOptions * has binding name 'PointerTott__AbsoluteFocusOptions' for type 'tt:AbsoluteFocusOptions' */
#ifndef SOAP_TYPE_PointerTott__AbsoluteFocusOptions
#define SOAP_TYPE_PointerTott__AbsoluteFocusOptions (430)
#endif

/* tt__IrCutFilterAutoAdjustmentOptionsExtension * has binding name 'PointerTott__IrCutFilterAutoAdjustmentOptionsExtension' for type 'tt:IrCutFilterAutoAdjustmentOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension (425)
#endif

/* tt__DurationRange * has binding name 'PointerTott__DurationRange' for type 'tt:DurationRange' */
#ifndef SOAP_TYPE_PointerTott__DurationRange
#define SOAP_TYPE_PointerTott__DurationRange (424)
#endif

/* tt__ImageStabilizationOptionsExtension * has binding name 'PointerTott__ImageStabilizationOptionsExtension' for type 'tt:ImageStabilizationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__ImageStabilizationOptionsExtension
#define SOAP_TYPE_PointerTott__ImageStabilizationOptionsExtension (422)
#endif

/* tt__ImagingOptions20Extension4 * has binding name 'PointerTott__ImagingOptions20Extension4' for type 'tt:ImagingOptions20Extension4' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension4
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension4 (420)
#endif

/* tt__NoiseReductionOptions * has binding name 'PointerTott__NoiseReductionOptions' for type 'tt:NoiseReductionOptions' */
#ifndef SOAP_TYPE_PointerTott__NoiseReductionOptions
#define SOAP_TYPE_PointerTott__NoiseReductionOptions (419)
#endif

/* tt__DefoggingOptions * has binding name 'PointerTott__DefoggingOptions' for type 'tt:DefoggingOptions' */
#ifndef SOAP_TYPE_PointerTott__DefoggingOptions
#define SOAP_TYPE_PointerTott__DefoggingOptions (418)
#endif

/* tt__ToneCompensationOptions * has binding name 'PointerTott__ToneCompensationOptions' for type 'tt:ToneCompensationOptions' */
#ifndef SOAP_TYPE_PointerTott__ToneCompensationOptions
#define SOAP_TYPE_PointerTott__ToneCompensationOptions (417)
#endif

/* tt__ImagingOptions20Extension3 * has binding name 'PointerTott__ImagingOptions20Extension3' for type 'tt:ImagingOptions20Extension3' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension3
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension3 (416)
#endif

/* tt__IrCutFilterAutoAdjustmentOptions * has binding name 'PointerTott__IrCutFilterAutoAdjustmentOptions' for type 'tt:IrCutFilterAutoAdjustmentOptions' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptions (415)
#endif

/* tt__ImagingOptions20Extension2 * has binding name 'PointerTott__ImagingOptions20Extension2' for type 'tt:ImagingOptions20Extension2' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension2
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension2 (414)
#endif

/* tt__ImageStabilizationOptions * has binding name 'PointerTott__ImageStabilizationOptions' for type 'tt:ImageStabilizationOptions' */
#ifndef SOAP_TYPE_PointerTott__ImageStabilizationOptions
#define SOAP_TYPE_PointerTott__ImageStabilizationOptions (413)
#endif

/* tt__ImagingOptions20Extension * has binding name 'PointerTott__ImagingOptions20Extension' for type 'tt:ImagingOptions20Extension' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension (412)
#endif

/* tt__WhiteBalanceOptions20 * has binding name 'PointerTott__WhiteBalanceOptions20' for type 'tt:WhiteBalanceOptions20' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalanceOptions20
#define SOAP_TYPE_PointerTott__WhiteBalanceOptions20 (411)
#endif

/* tt__WideDynamicRangeOptions20 * has binding name 'PointerTott__WideDynamicRangeOptions20' for type 'tt:WideDynamicRangeOptions20' */
#ifndef SOAP_TYPE_PointerTott__WideDynamicRangeOptions20
#define SOAP_TYPE_PointerTott__WideDynamicRangeOptions20 (410)
#endif

/* tt__FocusOptions20 * has binding name 'PointerTott__FocusOptions20' for type 'tt:FocusOptions20' */
#ifndef SOAP_TYPE_PointerTott__FocusOptions20
#define SOAP_TYPE_PointerTott__FocusOptions20 (408)
#endif

/* tt__ExposureOptions20 * has binding name 'PointerTott__ExposureOptions20' for type 'tt:ExposureOptions20' */
#ifndef SOAP_TYPE_PointerTott__ExposureOptions20
#define SOAP_TYPE_PointerTott__ExposureOptions20 (407)
#endif

/* tt__BacklightCompensationOptions20 * has binding name 'PointerTott__BacklightCompensationOptions20' for type 'tt:BacklightCompensationOptions20' */
#ifndef SOAP_TYPE_PointerTott__BacklightCompensationOptions20
#define SOAP_TYPE_PointerTott__BacklightCompensationOptions20 (406)
#endif

/* tt__DefoggingExtension * has binding name 'PointerTott__DefoggingExtension' for type 'tt:DefoggingExtension' */
#ifndef SOAP_TYPE_PointerTott__DefoggingExtension
#define SOAP_TYPE_PointerTott__DefoggingExtension (405)
#endif

/* tt__ToneCompensationExtension * has binding name 'PointerTott__ToneCompensationExtension' for type 'tt:ToneCompensationExtension' */
#ifndef SOAP_TYPE_PointerTott__ToneCompensationExtension
#define SOAP_TYPE_PointerTott__ToneCompensationExtension (404)
#endif

/* tt__Rectangle * has binding name 'PointerTott__Rectangle' for type 'tt:Rectangle' */
#ifndef SOAP_TYPE_PointerTott__Rectangle
#define SOAP_TYPE_PointerTott__Rectangle (403)
#endif

/* enum tt__ExposurePriority * has binding name 'PointerTott__ExposurePriority' for type 'tt:ExposurePriority' */
#ifndef SOAP_TYPE_PointerTott__ExposurePriority
#define SOAP_TYPE_PointerTott__ExposurePriority (402)
#endif

/* tt__IrCutFilterAutoAdjustmentExtension * has binding name 'PointerTott__IrCutFilterAutoAdjustmentExtension' for type 'tt:IrCutFilterAutoAdjustmentExtension' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentExtension (401)
#endif

/* std::string * has binding name 'PointerToxsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_PointerToxsd__duration
#define SOAP_TYPE_PointerToxsd__duration (400)
#endif

/* tt__ImageStabilizationExtension * has binding name 'PointerTott__ImageStabilizationExtension' for type 'tt:ImageStabilizationExtension' */
#ifndef SOAP_TYPE_PointerTott__ImageStabilizationExtension
#define SOAP_TYPE_PointerTott__ImageStabilizationExtension (399)
#endif

/* tt__ImagingSettingsExtension204 * has binding name 'PointerTott__ImagingSettingsExtension204' for type 'tt:ImagingSettingsExtension204' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension204
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension204 (398)
#endif

/* tt__NoiseReduction * has binding name 'PointerTott__NoiseReduction' for type 'tt:NoiseReduction' */
#ifndef SOAP_TYPE_PointerTott__NoiseReduction
#define SOAP_TYPE_PointerTott__NoiseReduction (397)
#endif

/* tt__Defogging * has binding name 'PointerTott__Defogging' for type 'tt:Defogging' */
#ifndef SOAP_TYPE_PointerTott__Defogging
#define SOAP_TYPE_PointerTott__Defogging (396)
#endif

/* tt__ToneCompensation * has binding name 'PointerTott__ToneCompensation' for type 'tt:ToneCompensation' */
#ifndef SOAP_TYPE_PointerTott__ToneCompensation
#define SOAP_TYPE_PointerTott__ToneCompensation (395)
#endif

/* tt__ImagingSettingsExtension203 * has binding name 'PointerTott__ImagingSettingsExtension203' for type 'tt:ImagingSettingsExtension203' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension203
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension203 (394)
#endif

/* tt__IrCutFilterAutoAdjustment * has binding name 'PointerTott__IrCutFilterAutoAdjustment' for type 'tt:IrCutFilterAutoAdjustment' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustment
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustment (392)
#endif

/* tt__ImagingSettingsExtension202 * has binding name 'PointerTott__ImagingSettingsExtension202' for type 'tt:ImagingSettingsExtension202' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension202
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension202 (391)
#endif

/* tt__ImageStabilization * has binding name 'PointerTott__ImageStabilization' for type 'tt:ImageStabilization' */
#ifndef SOAP_TYPE_PointerTott__ImageStabilization
#define SOAP_TYPE_PointerTott__ImageStabilization (390)
#endif

/* tt__ImagingSettingsExtension20 * has binding name 'PointerTott__ImagingSettingsExtension20' for type 'tt:ImagingSettingsExtension20' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension20
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension20 (389)
#endif

/* tt__WhiteBalance20 * has binding name 'PointerTott__WhiteBalance20' for type 'tt:WhiteBalance20' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalance20
#define SOAP_TYPE_PointerTott__WhiteBalance20 (388)
#endif

/* tt__WideDynamicRange20 * has binding name 'PointerTott__WideDynamicRange20' for type 'tt:WideDynamicRange20' */
#ifndef SOAP_TYPE_PointerTott__WideDynamicRange20
#define SOAP_TYPE_PointerTott__WideDynamicRange20 (387)
#endif

/* enum tt__IrCutFilterMode * has binding name 'PointerTott__IrCutFilterMode' for type 'tt:IrCutFilterMode' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterMode
#define SOAP_TYPE_PointerTott__IrCutFilterMode (386)
#endif

/* tt__FocusConfiguration20 * has binding name 'PointerTott__FocusConfiguration20' for type 'tt:FocusConfiguration20' */
#ifndef SOAP_TYPE_PointerTott__FocusConfiguration20
#define SOAP_TYPE_PointerTott__FocusConfiguration20 (385)
#endif

/* tt__Exposure20 * has binding name 'PointerTott__Exposure20' for type 'tt:Exposure20' */
#ifndef SOAP_TYPE_PointerTott__Exposure20
#define SOAP_TYPE_PointerTott__Exposure20 (384)
#endif

/* tt__BacklightCompensation20 * has binding name 'PointerTott__BacklightCompensation20' for type 'tt:BacklightCompensation20' */
#ifndef SOAP_TYPE_PointerTott__BacklightCompensation20
#define SOAP_TYPE_PointerTott__BacklightCompensation20 (383)
#endif

/* tt__FocusStatus20Extension * has binding name 'PointerTott__FocusStatus20Extension' for type 'tt:FocusStatus20Extension' */
#ifndef SOAP_TYPE_PointerTott__FocusStatus20Extension
#define SOAP_TYPE_PointerTott__FocusStatus20Extension (382)
#endif

/* tt__ImagingStatus20Extension * has binding name 'PointerTott__ImagingStatus20Extension' for type 'tt:ImagingStatus20Extension' */
#ifndef SOAP_TYPE_PointerTott__ImagingStatus20Extension
#define SOAP_TYPE_PointerTott__ImagingStatus20Extension (381)
#endif

/* tt__FocusStatus20 * has binding name 'PointerTott__FocusStatus20' for type 'tt:FocusStatus20' */
#ifndef SOAP_TYPE_PointerTott__FocusStatus20
#define SOAP_TYPE_PointerTott__FocusStatus20 (380)
#endif

/* tt__ContinuousFocus * has binding name 'PointerTott__ContinuousFocus' for type 'tt:ContinuousFocus' */
#ifndef SOAP_TYPE_PointerTott__ContinuousFocus
#define SOAP_TYPE_PointerTott__ContinuousFocus (379)
#endif

/* tt__RelativeFocus * has binding name 'PointerTott__RelativeFocus' for type 'tt:RelativeFocus' */
#ifndef SOAP_TYPE_PointerTott__RelativeFocus
#define SOAP_TYPE_PointerTott__RelativeFocus (378)
#endif

/* tt__AbsoluteFocus * has binding name 'PointerTott__AbsoluteFocus' for type 'tt:AbsoluteFocus' */
#ifndef SOAP_TYPE_PointerTott__AbsoluteFocus
#define SOAP_TYPE_PointerTott__AbsoluteFocus (377)
#endif

/* tt__Vector1D * has binding name 'PointerTott__Vector1D' for type 'tt:Vector1D' */
#ifndef SOAP_TYPE_PointerTott__Vector1D
#define SOAP_TYPE_PointerTott__Vector1D (376)
#endif

/* tt__Vector2D * has binding name 'PointerTott__Vector2D' for type 'tt:Vector2D' */
#ifndef SOAP_TYPE_PointerTott__Vector2D
#define SOAP_TYPE_PointerTott__Vector2D (375)
#endif

/* tt__FloatRange * has binding name 'PointerTott__FloatRange' for type 'tt:FloatRange' */
#ifndef SOAP_TYPE_PointerTott__FloatRange
#define SOAP_TYPE_PointerTott__FloatRange (374)
#endif

/* tt__Space1DDescription * has binding name 'PointerTott__Space1DDescription' for type 'tt:Space1DDescription' */
#ifndef SOAP_TYPE_PointerTott__Space1DDescription
#define SOAP_TYPE_PointerTott__Space1DDescription (373)
#endif

/* tt__Space2DDescription * has binding name 'PointerTott__Space2DDescription' for type 'tt:Space2DDescription' */
#ifndef SOAP_TYPE_PointerTott__Space2DDescription
#define SOAP_TYPE_PointerTott__Space2DDescription (372)
#endif

/* tt__PTControlDirectionExtension * has binding name 'PointerTott__PTControlDirectionExtension' for type 'tt:PTControlDirectionExtension' */
#ifndef SOAP_TYPE_PointerTott__PTControlDirectionExtension
#define SOAP_TYPE_PointerTott__PTControlDirectionExtension (371)
#endif

/* tt__Reverse * has binding name 'PointerTott__Reverse' for type 'tt:Reverse' */
#ifndef SOAP_TYPE_PointerTott__Reverse
#define SOAP_TYPE_PointerTott__Reverse (370)
#endif

/* tt__EFlip * has binding name 'PointerTott__EFlip' for type 'tt:EFlip' */
#ifndef SOAP_TYPE_PointerTott__EFlip
#define SOAP_TYPE_PointerTott__EFlip (369)
#endif

/* tt__PTZConfigurationExtension2 * has binding name 'PointerTott__PTZConfigurationExtension2' for type 'tt:PTZConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTott__PTZConfigurationExtension2
#define SOAP_TYPE_PointerTott__PTZConfigurationExtension2 (368)
#endif

/* tt__PTControlDirection * has binding name 'PointerTott__PTControlDirection' for type 'tt:PTControlDirection' */
#ifndef SOAP_TYPE_PointerTott__PTControlDirection
#define SOAP_TYPE_PointerTott__PTControlDirection (367)
#endif

/* std::string * has binding name 'PointerTott__IPv6Address' for type 'tt:IPv6Address' */
#ifndef SOAP_TYPE_PointerTott__IPv6Address
#define SOAP_TYPE_PointerTott__IPv6Address (366)
#endif

/* std::string * has binding name 'PointerTott__IPv4Address' for type 'tt:IPv4Address' */
#ifndef SOAP_TYPE_PointerTott__IPv4Address
#define SOAP_TYPE_PointerTott__IPv4Address (365)
#endif

/* tt__IPAddress * has binding name 'PointerTott__IPAddress' for type 'tt:IPAddress' */
#ifndef SOAP_TYPE_PointerTott__IPAddress
#define SOAP_TYPE_PointerTott__IPAddress (364)
#endif

/* _tt__EventSubscription_SubscriptionPolicy * has binding name 'PointerTo_tt__EventSubscription_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy (363)
#endif

/* wsnt__FilterType * has binding name 'PointerTowsnt__FilterType' for type 'wsnt:FilterType' */
#ifndef SOAP_TYPE_PointerTowsnt__FilterType
#define SOAP_TYPE_PointerTowsnt__FilterType (361)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (360)
#endif

/* tt__LensProjection * has binding name 'PointerTott__LensProjection' for type 'tt:LensProjection' */
#ifndef SOAP_TYPE_PointerTott__LensProjection
#define SOAP_TYPE_PointerTott__LensProjection (358)
#endif

/* tt__LensOffset * has binding name 'PointerTott__LensOffset' for type 'tt:LensOffset' */
#ifndef SOAP_TYPE_PointerTott__LensOffset
#define SOAP_TYPE_PointerTott__LensOffset (357)
#endif

/* float * has binding name 'PointerTofloat' for type 'xsd:float' */
#ifndef SOAP_TYPE_PointerTofloat
#define SOAP_TYPE_PointerTofloat (356)
#endif

/* tt__RotateExtension * has binding name 'PointerTott__RotateExtension' for type 'tt:RotateExtension' */
#ifndef SOAP_TYPE_PointerTott__RotateExtension
#define SOAP_TYPE_PointerTott__RotateExtension (355)
#endif

/* tt__SceneOrientation * has binding name 'PointerTott__SceneOrientation' for type 'tt:SceneOrientation' */
#ifndef SOAP_TYPE_PointerTott__SceneOrientation
#define SOAP_TYPE_PointerTott__SceneOrientation (354)
#endif

/* tt__LensDescription * has binding name 'PointerTott__LensDescription' for type 'tt:LensDescription' */
#ifndef SOAP_TYPE_PointerTott__LensDescription
#define SOAP_TYPE_PointerTott__LensDescription (352)
#endif

/* tt__VideoSourceConfigurationExtension2 * has binding name 'PointerTott__VideoSourceConfigurationExtension2' for type 'tt:VideoSourceConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension2
#define SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension2 (351)
#endif

/* tt__Rotate * has binding name 'PointerTott__Rotate' for type 'tt:Rotate' */
#ifndef SOAP_TYPE_PointerTott__Rotate
#define SOAP_TYPE_PointerTott__Rotate (350)
#endif

/* tt__IntRange * has binding name 'PointerTott__IntRange' for type 'tt:IntRange' */
#ifndef SOAP_TYPE_PointerTott__IntRange
#define SOAP_TYPE_PointerTott__IntRange (349)
#endif

/* timg__ImagingPreset * has binding name 'PointerTotimg__ImagingPreset' for type 'timg:ImagingPreset' */
#ifndef SOAP_TYPE_PointerTotimg__ImagingPreset
#define SOAP_TYPE_PointerTotimg__ImagingPreset (347)
#endif

/* tt__ImagingStatus20 * has binding name 'PointerTott__ImagingStatus20' for type 'tt:ImagingStatus20' */
#ifndef SOAP_TYPE_PointerTott__ImagingStatus20
#define SOAP_TYPE_PointerTott__ImagingStatus20 (346)
#endif

/* tt__MoveOptions20 * has binding name 'PointerTott__MoveOptions20' for type 'tt:MoveOptions20' */
#ifndef SOAP_TYPE_PointerTott__MoveOptions20
#define SOAP_TYPE_PointerTott__MoveOptions20 (345)
#endif

/* tt__FocusMove * has binding name 'PointerTott__FocusMove' for type 'tt:FocusMove' */
#ifndef SOAP_TYPE_PointerTott__FocusMove
#define SOAP_TYPE_PointerTott__FocusMove (344)
#endif

/* tt__ImagingOptions20 * has binding name 'PointerTott__ImagingOptions20' for type 'tt:ImagingOptions20' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20
#define SOAP_TYPE_PointerTott__ImagingOptions20 (343)
#endif

/* tt__ImagingSettings20 * has binding name 'PointerTott__ImagingSettings20' for type 'tt:ImagingSettings20' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettings20
#define SOAP_TYPE_PointerTott__ImagingSettings20 (342)
#endif

/* timg__Capabilities * has binding name 'PointerTotimg__Capabilities' for type 'timg:Capabilities' */
#ifndef SOAP_TYPE_PointerTotimg__Capabilities
#define SOAP_TYPE_PointerTotimg__Capabilities (341)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (340)
#endif

/* struct SOAP_ENV__Header * has binding name 'PointerToSOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Header
#define SOAP_TYPE_PointerToSOAP_ENV__Header (60)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (53)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (51)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (49)
#endif

/* struct chan__ChannelInstanceType * has binding name 'PointerTochan__ChannelInstanceType' for type 'chan:ChannelInstanceType' */
#ifndef SOAP_TYPE_PointerTochan__ChannelInstanceType
#define SOAP_TYPE_PointerTochan__ChannelInstanceType (47)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__FaultTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__FaultTo
#define SOAP_TYPE_PointerTo_wsa5__FaultTo (46)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__ReplyTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__ReplyTo
#define SOAP_TYPE_PointerTo_wsa5__ReplyTo (45)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__From' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__From
#define SOAP_TYPE_PointerTo_wsa5__From (44)
#endif

/* struct wsa5__RelatesToType * has binding name 'PointerTo_wsa5__RelatesTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__RelatesTo
#define SOAP_TYPE_PointerTo_wsa5__RelatesTo (43)
#endif

/* _wsa5__ProblemIRI has binding name '_wsa5__ProblemIRI' for type '' */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (38)
#endif

/* _wsa5__ProblemHeaderQName has binding name '_wsa5__ProblemHeaderQName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (37)
#endif

/* _wsa5__Action has binding name '_wsa5__Action' for type '' */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (34)
#endif

/* _wsa5__To has binding name '_wsa5__To' for type '' */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (33)
#endif

/* _wsa5__MessageID has binding name '_wsa5__MessageID' for type '' */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (28)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (24)
#endif

/* char ** has binding name 'PointerTo_XML' for type '' */
#ifndef SOAP_TYPE_PointerTo_XML
#define SOAP_TYPE_PointerTo_XML (23)
#endif

/* struct wsa5__MetadataType * has binding name 'PointerTowsa5__MetadataType' for type 'wsa5:MetadataType' */
#ifndef SOAP_TYPE_PointerTowsa5__MetadataType
#define SOAP_TYPE_PointerTowsa5__MetadataType (22)
#endif

/* struct wsa5__ReferenceParametersType * has binding name 'PointerTowsa5__ReferenceParametersType' for type 'wsa5:ReferenceParametersType' */
#ifndef SOAP_TYPE_PointerTowsa5__ReferenceParametersType
#define SOAP_TYPE_PointerTowsa5__ReferenceParametersType (21)
#endif

/* wsa5__FaultCodesOpenEnumType has binding name 'wsa5__FaultCodesOpenEnumType' for type 'wsa5:FaultCodesOpenEnumType' */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (18)
#endif

/* wsa5__RelationshipTypeOpenEnum has binding name 'wsa5__RelationshipTypeOpenEnum' for type 'wsa5:RelationshipTypeOpenEnum' */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (17)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (11)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<_wstop__TopicNamespaceType_Topic>  has binding name 'std__vectorTemplateOf_wstop__TopicNamespaceType_Topic' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic
#define SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic (500)
#endif

/* std::vector<wstop__TopicType *>  has binding name 'std__vectorTemplateOfPointerTowstop__TopicType' for type 'wstop:TopicType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType (497)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__QName
#define SOAP_TYPE_std__vectorTemplateOfxsd__QName (493)
#endif

/* std::vector<_wsrfbf__BaseFaultType_Description>  has binding name 'std__vectorTemplateOf_wsrfbf__BaseFaultType_Description' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description
#define SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description (473)
#endif

/* std::vector<wsnt__NotificationMessageHolderType *>  has binding name 'std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType' for type 'wsnt:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType (464)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__anyURI
#define SOAP_TYPE_std__vectorTemplateOfxsd__anyURI (459)
#endif

/* std::vector<wsnt__TopicExpressionType *>  has binding name 'std__vectorTemplateOfPointerTowsnt__TopicExpressionType' for type 'wsnt:TopicExpressionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType (458)
#endif

/* std::vector<tt__Config *>  has binding name 'std__vectorTemplateOfPointerTott__Config' for type 'tt:Config' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Config
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Config (448)
#endif

/* std::vector<tt__Vector *>  has binding name 'std__vectorTemplateOfPointerTott__Vector' for type 'tt:Vector' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector (446)
#endif

/* std::vector<_tt__ItemList_ElementItem>  has binding name 'std__vectorTemplateOf_tt__ItemList_ElementItem' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem
#define SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem (443)
#endif

/* std::vector<_tt__ItemList_SimpleItem>  has binding name 'std__vectorTemplateOf_tt__ItemList_SimpleItem' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem
#define SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem (441)
#endif

/* std::vector<enum tt__AutoFocusMode>  has binding name 'std__vectorTemplateOftt__AutoFocusMode' for type 'tt:AutoFocusMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode
#define SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode (438)
#endif

/* std::vector<enum tt__WhiteBalanceMode>  has binding name 'std__vectorTemplateOftt__WhiteBalanceMode' for type 'tt:WhiteBalanceMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode
#define SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode (436)
#endif

/* std::vector<enum tt__ExposurePriority>  has binding name 'std__vectorTemplateOftt__ExposurePriority' for type 'tt:ExposurePriority' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority
#define SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority (429)
#endif

/* std::vector<enum tt__ExposureMode>  has binding name 'std__vectorTemplateOftt__ExposureMode' for type 'tt:ExposureMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__ExposureMode
#define SOAP_TYPE_std__vectorTemplateOftt__ExposureMode (428)
#endif

/* std::vector<enum tt__BacklightCompensationMode>  has binding name 'std__vectorTemplateOftt__BacklightCompensationMode' for type 'tt:BacklightCompensationMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode
#define SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode (427)
#endif

/* std::vector<enum tt__WideDynamicMode>  has binding name 'std__vectorTemplateOftt__WideDynamicMode' for type 'tt:WideDynamicMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode
#define SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode (426)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (423)
#endif

/* std::vector<enum tt__ImageStabilizationMode>  has binding name 'std__vectorTemplateOftt__ImageStabilizationMode' for type 'tt:ImageStabilizationMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode
#define SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode (421)
#endif

/* std::vector<enum tt__IrCutFilterMode>  has binding name 'std__vectorTemplateOftt__IrCutFilterMode' for type 'tt:IrCutFilterMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode
#define SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode (409)
#endif

/* std::vector<tt__IrCutFilterAutoAdjustment *>  has binding name 'std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment' for type 'tt:IrCutFilterAutoAdjustment' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment (393)
#endif

/* std::vector<tt__LensProjection *>  has binding name 'std__vectorTemplateOfPointerTott__LensProjection' for type 'tt:LensProjection' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection (359)
#endif

/* std::vector<tt__LensDescription *>  has binding name 'std__vectorTemplateOfPointerTott__LensDescription' for type 'tt:LensDescription' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription (353)
#endif

/* std::vector<timg__ImagingPreset *>  has binding name 'std__vectorTemplateOfPointerTotimg__ImagingPreset' for type 'timg:ImagingPreset' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset
#define SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset (348)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_XML
#define SOAP_TYPE_std__vectorTemplateOf_XML (339)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stub Functions                                            *
 *                                                                            *
\******************************************************************************/

    /** Web service one-way asynchronous operation 'soap_send_SOAP_ENV__Fault' */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send_SOAP_ENV__Fault(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *faultcode, char *faultstring, char *faultactor, struct SOAP_ENV__Detail *detail, struct SOAP_ENV__Code *SOAP_ENV__Code, struct SOAP_ENV__Reason *SOAP_ENV__Reason, char *SOAP_ENV__Node, char *SOAP_ENV__Role, struct SOAP_ENV__Detail *SOAP_ENV__Detail);
    /** Web service one-way asynchronous operation 'soap_recv_SOAP_ENV__Fault' */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *_param_1);
    
    /** Web service synchronous operation 'soap_call___timg__GetServiceCapabilities' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetServiceCapabilities *timg__GetServiceCapabilities, _timg__GetServiceCapabilitiesResponse &timg__GetServiceCapabilitiesResponse);
    /** Web service asynchronous operation 'soap_send___timg__GetServiceCapabilities' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___timg__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetServiceCapabilities *timg__GetServiceCapabilities);
    /** Web service asynchronous operation 'soap_recv___timg__GetServiceCapabilities' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilitiesResponse &timg__GetServiceCapabilitiesResponse);
    
    /** Web service synchronous operation 'soap_call___timg__GetImagingSettings' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetImagingSettings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetImagingSettings *timg__GetImagingSettings, _timg__GetImagingSettingsResponse &timg__GetImagingSettingsResponse);
    /** Web service asynchronous operation 'soap_send___timg__GetImagingSettings' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___timg__GetImagingSettings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetImagingSettings *timg__GetImagingSettings);
    /** Web service asynchronous operation 'soap_recv___timg__GetImagingSettings' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettingsResponse &timg__GetImagingSettingsResponse);
    
    /** Web service synchronous operation 'soap_call___timg__SetImagingSettings' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__SetImagingSettings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__SetImagingSettings *timg__SetImagingSettings, _timg__SetImagingSettingsResponse &timg__SetImagingSettingsResponse);
    /** Web service asynchronous operation 'soap_send___timg__SetImagingSettings' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___timg__SetImagingSettings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__SetImagingSettings *timg__SetImagingSettings);
    /** Web service asynchronous operation 'soap_recv___timg__SetImagingSettings' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettingsResponse &timg__SetImagingSettingsResponse);
    
    /** Web service synchronous operation 'soap_call___timg__GetOptions' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetOptions *timg__GetOptions, _timg__GetOptionsResponse &timg__GetOptionsResponse);
    /** Web service asynchronous operation 'soap_send___timg__GetOptions' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___timg__GetOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetOptions *timg__GetOptions);
    /** Web service asynchronous operation 'soap_recv___timg__GetOptions' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___timg__GetOptions(struct soap *soap, _timg__GetOptionsResponse &timg__GetOptionsResponse);
    
    /** Web service synchronous operation 'soap_call___timg__Move' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__Move(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__Move *timg__Move, _timg__MoveResponse &timg__MoveResponse);
    /** Web service asynchronous operation 'soap_send___timg__Move' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___timg__Move(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__Move *timg__Move);
    /** Web service asynchronous operation 'soap_recv___timg__Move' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___timg__Move(struct soap *soap, _timg__MoveResponse &timg__MoveResponse);
    
    /** Web service synchronous operation 'soap_call___timg__Stop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__Stop(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__Stop *timg__Stop, _timg__StopResponse &timg__StopResponse);
    /** Web service asynchronous operation 'soap_send___timg__Stop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___timg__Stop(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__Stop *timg__Stop);
    /** Web service asynchronous operation 'soap_recv___timg__Stop' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___timg__Stop(struct soap *soap, _timg__StopResponse &timg__StopResponse);
    
    /** Web service synchronous operation 'soap_call___timg__GetStatus' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetStatus *timg__GetStatus, _timg__GetStatusResponse &timg__GetStatusResponse);
    /** Web service asynchronous operation 'soap_send___timg__GetStatus' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___timg__GetStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetStatus *timg__GetStatus);
    /** Web service asynchronous operation 'soap_recv___timg__GetStatus' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___timg__GetStatus(struct soap *soap, _timg__GetStatusResponse &timg__GetStatusResponse);
    
    /** Web service synchronous operation 'soap_call___timg__GetMoveOptions' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetMoveOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetMoveOptions *timg__GetMoveOptions, _timg__GetMoveOptionsResponse &timg__GetMoveOptionsResponse);
    /** Web service asynchronous operation 'soap_send___timg__GetMoveOptions' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___timg__GetMoveOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetMoveOptions *timg__GetMoveOptions);
    /** Web service asynchronous operation 'soap_recv___timg__GetMoveOptions' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptionsResponse &timg__GetMoveOptionsResponse);
    
    /** Web service synchronous operation 'soap_call___timg__GetPresets' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetPresets(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetPresets *timg__GetPresets, _timg__GetPresetsResponse &timg__GetPresetsResponse);
    /** Web service asynchronous operation 'soap_send___timg__GetPresets' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___timg__GetPresets(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetPresets *timg__GetPresets);
    /** Web service asynchronous operation 'soap_recv___timg__GetPresets' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___timg__GetPresets(struct soap *soap, _timg__GetPresetsResponse &timg__GetPresetsResponse);
    
    /** Web service synchronous operation 'soap_call___timg__GetCurrentPreset' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetCurrentPreset(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetCurrentPreset *timg__GetCurrentPreset, _timg__GetCurrentPresetResponse &timg__GetCurrentPresetResponse);
    /** Web service asynchronous operation 'soap_send___timg__GetCurrentPreset' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___timg__GetCurrentPreset(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetCurrentPreset *timg__GetCurrentPreset);
    /** Web service asynchronous operation 'soap_recv___timg__GetCurrentPreset' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___timg__GetCurrentPreset(struct soap *soap, _timg__GetCurrentPresetResponse &timg__GetCurrentPresetResponse);
    
    /** Web service synchronous operation 'soap_call___timg__SetCurrentPreset' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__SetCurrentPreset(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__SetCurrentPreset *timg__SetCurrentPreset, _timg__SetCurrentPresetResponse &timg__SetCurrentPresetResponse);
    /** Web service asynchronous operation 'soap_send___timg__SetCurrentPreset' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___timg__SetCurrentPreset(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__SetCurrentPreset *timg__SetCurrentPreset);
    /** Web service asynchronous operation 'soap_recv___timg__SetCurrentPreset' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___timg__SetCurrentPreset(struct soap *soap, _timg__SetCurrentPresetResponse &timg__SetCurrentPresetResponse);

/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/

    /** Web service one-way operation 'SOAP_ENV__Fault' implementation, should return value of soap_send_empty_response() to send HTTP Accept acknowledgment, or return an error code, or return SOAP_OK to immediately return without sending an HTTP response message */
    SOAP_FMAC5 int SOAP_FMAC6 SOAP_ENV__Fault(struct soap*, char *faultcode, char *faultstring, char *faultactor, struct SOAP_ENV__Detail *detail, struct SOAP_ENV__Code *SOAP_ENV__Code, struct SOAP_ENV__Reason *SOAP_ENV__Reason, char *SOAP_ENV__Node, char *SOAP_ENV__Role, struct SOAP_ENV__Detail *SOAP_ENV__Detail);
    /** Web service operation '__timg__GetServiceCapabilities' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __timg__GetServiceCapabilities(struct soap*, _timg__GetServiceCapabilities *timg__GetServiceCapabilities, _timg__GetServiceCapabilitiesResponse &timg__GetServiceCapabilitiesResponse);
    /** Web service operation '__timg__GetImagingSettings' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __timg__GetImagingSettings(struct soap*, _timg__GetImagingSettings *timg__GetImagingSettings, _timg__GetImagingSettingsResponse &timg__GetImagingSettingsResponse);
    /** Web service operation '__timg__SetImagingSettings' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __timg__SetImagingSettings(struct soap*, _timg__SetImagingSettings *timg__SetImagingSettings, _timg__SetImagingSettingsResponse &timg__SetImagingSettingsResponse);
    /** Web service operation '__timg__GetOptions' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __timg__GetOptions(struct soap*, _timg__GetOptions *timg__GetOptions, _timg__GetOptionsResponse &timg__GetOptionsResponse);
    /** Web service operation '__timg__Move' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __timg__Move(struct soap*, _timg__Move *timg__Move, _timg__MoveResponse &timg__MoveResponse);
    /** Web service operation '__timg__Stop' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __timg__Stop(struct soap*, _timg__Stop *timg__Stop, _timg__StopResponse &timg__StopResponse);
    /** Web service operation '__timg__GetStatus' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __timg__GetStatus(struct soap*, _timg__GetStatus *timg__GetStatus, _timg__GetStatusResponse &timg__GetStatusResponse);
    /** Web service operation '__timg__GetMoveOptions' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __timg__GetMoveOptions(struct soap*, _timg__GetMoveOptions *timg__GetMoveOptions, _timg__GetMoveOptionsResponse &timg__GetMoveOptionsResponse);
    /** Web service operation '__timg__GetPresets' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __timg__GetPresets(struct soap*, _timg__GetPresets *timg__GetPresets, _timg__GetPresetsResponse &timg__GetPresetsResponse);
    /** Web service operation '__timg__GetCurrentPreset' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __timg__GetCurrentPreset(struct soap*, _timg__GetCurrentPreset *timg__GetCurrentPreset, _timg__GetCurrentPresetResponse &timg__GetCurrentPresetResponse);
    /** Web service operation '__timg__SetCurrentPreset' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __timg__SetCurrentPreset(struct soap*, _timg__SetCurrentPreset *timg__SetCurrentPreset, _timg__SetCurrentPresetResponse &timg__SetCurrentPresetResponse);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_SOAP_ENV__Fault(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetImagingSettings(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__SetImagingSettings(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__Move(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__Stop(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetMoveOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetPresets(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetCurrentPreset(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__SetCurrentPreset(struct soap*);

#endif

/* End of imageingStub.h */
